using MathNet.Numerics;
using MathNet.Numerics.Statistics;
using Nessos.LinqOptimizer.CSharp;
using OoplesFinance.StockIndicators.Models;
using static OoplesFinance.StockIndicators.Enums.SignalsClass;
using static OoplesFinance.StockIndicators.Helpers.SignalHelper;
using static OoplesFinance.StockIndicators.Helpers.MathHelper;

namespace OoplesFinance.StockIndicators
{
    public class CalculationsCopy
    {
        public static List<decimal> GetMovingAverageList(string maType, List<decimal>? customValuesList, StockData stockDataClass, int days)
        {
            List<decimal> movingAvgList = new();

            try
            {
                if (customValuesList != null)
                {
                    stockDataClass.InputValues = customValuesList;
                }

                switch (maType)
                {
                    case "1LCLeastSquaresMovingAverage":
                        movingAvgList = Calculate1LCLeastSquaresMovingAverage(stockDataClass, "SimpleMovingAverage", days).Item1;
                        break;
                    case "3HMA":
                        movingAvgList = Calculate3HMA(stockDataClass, "WeightedMovingAverage", days).Item2;
                        break;
                    case "AdaptiveAutonomousRecursiveMovingAverage":
                        movingAvgList = CalculateAdaptiveAutonomousRecursiveMovingAverage(stockDataClass, days).Item5;
                        break;
                    case "AdaptiveExponentialMovingAverage":
                        movingAvgList = CalculateAdaptiveExponentialMovingAverage(stockDataClass, days).Item3;
                        break;
                    case "AdaptiveLeastSquares":
                        movingAvgList = CalculateAdaptiveLeastSquares(stockDataClass, days).Item17;
                        break;
                    case "AdaptiveMovingAverage":
                        movingAvgList = CalculateAdaptiveMovingAverage(stockDataClass, days).Item3;
                        break;
                    case "AhrensMovingAverage":
                        movingAvgList = CalculateAhrensMovingAverage(stockDataClass, days).Item1;
                        break;
                    case "AlphaDecreasingExponentialMovingAverage":
                        movingAvgList = CalculateAlphaDecreasingExponentialMovingAverage(stockDataClass).Item1;
                        break;
                    case "ArnaudLegouxMovingAverage":
                        movingAvgList = CalculateArnaudLegouxMovingAverage(stockDataClass, days).Item3;
                        break;
                    case "AtrFilteredExponentialMovingAverage":
                        movingAvgList = CalculateAtrFilteredExponentialMovingAverage(stockDataClass, "SimpleMovingAverage", days).Item15;
                        break;
                    case "AutoFilter":
                        movingAvgList = CalculateAutoFilter(stockDataClass, "SimpleMovingAverage", days).Item6;
                        break;
                    case "AutonomousRecursiveMovingAverage":
                        movingAvgList = CalculateAutonomousRecursiveMovingAverage(stockDataClass, days).Item5;
                        break;
                    case "BryantAdaptiveMovingAverage":
                        movingAvgList = CalculateBryantAdaptiveMovingAverage(stockDataClass, days).Item4;
                        break;
                    case "ChuckBangerMovingAverage":
                        movingAvgList = CalculateChuckBangerMovingAverage(stockDataClass, "ExponentialMovingAverage", days).Item4;
                        break;
                    case "CompoundRatioMovingAverage":
                        movingAvgList = CalculateCompoundRatioMovingAverage(stockDataClass, "WeightedMovingAverage", days).Item4;
                        break;
                    case "CorrectedMovingAverage":
                        movingAvgList = CalculateCorrectedMovingAverage(stockDataClass, "SimpleMovingAverage", days).Item4;
                        break;
                    case "CubedWeightedMovingAverage":
                        movingAvgList = CalculateCubedWeightedMovingAverage(stockDataClass, days).Item3;
                        break;
                    case "DampedSineWaveWeightedFilter":
                        movingAvgList = CalculateDampedSineWaveWeightedFilter(stockDataClass, days).Item5;
                        break;
                    case "DistanceWeightedMovingAverage":
                        movingAvgList = CalculateDistanceWeightedMovingAverage(stockDataClass, days).Item3;
                        break;
                    case "decimalExponentialMovingAverage":
                        movingAvgList = CalculateDoubleExponentialMovingAverage(stockDataClass, "ExponentialMovingAverage", days).Item1;
                        break;
                    case "decimalExponentialSmoothing":
                        movingAvgList = CalculateDoubleExponentialSmoothing(stockDataClass).Item2;
                        break;
                    case "DynamicallyAdjustableFilter":
                        movingAvgList = CalculateDynamicallyAdjustableFilter(stockDataClass, days).Item8;
                        break;
                    case "DynamicallyAdjustableMovingAverage":
                        movingAvgList = CalculateDynamicallyAdjustableMovingAverage(stockDataClass, days).Item3;
                        break;
                    case "EdgePreservingFilter":
                        movingAvgList = CalculateEdgePreservingFilter(stockDataClass, "SimpleMovingAverage", days).Item8;
                        break;
                    case "Ehlers2PoleButterworthFilter":
                        movingAvgList = CalculateEhlers2PoleButterworthFilter(stockDataClass, days).Item1;
                        break;
                    case "Ehlers2PoleButterworthFilterV2":
                        movingAvgList = CalculateEhlers2PoleButterworthFilterV2(stockDataClass, days).Item1;
                        break;
                    case "Ehlers3PoleButterworthFilter":
                        movingAvgList = CalculateEhlers3PoleButterworthFilter(stockDataClass, days).Item1;
                        break;
                    case "Ehlers3PoleButterworthFilterV2":
                        movingAvgList = CalculateEhlers3PoleButterworthFilterV2(stockDataClass, days).Item1;
                        break;
                    case "Ehlers2PoleSuperSmootherFilter":
                        movingAvgList = CalculateEhlers2PoleSuperSmootherFilter(stockDataClass, days).Item1;
                        break;
                    case "Ehlers2PoleSuperSmootherFilterV2":
                        movingAvgList = CalculateEhlers2PoleSuperSmootherFilterV2(stockDataClass, days).Item1;
                        break;
                    case "Ehlers3PoleSuperSmootherFilter":
                        movingAvgList = CalculateEhlers3PoleSuperSmootherFilter(stockDataClass, days).Item1;
                        break;
                    case "EhlersAdaptiveLaguerreFilter":
                        movingAvgList = CalculateEhlersAdaptiveLaguerreFilter(stockDataClass, days).Item8;
                        break;
                    case "EhlersAllpassPhaseShifter":
                        movingAvgList = CalculateEhlersAllpassPhaseShifter(stockDataClass, days).Item1;
                        break;
                    case "EhlersAverageErrorFilter":
                        movingAvgList = CalculateEhlersAverageErrorFilter(stockDataClass, days).Item2;
                        break;
                    case "EhlersBetterExponentialMovingAverage":
                        movingAvgList = CalculateEhlersBetterExponentialMovingAverage(stockDataClass, days).Item2;
                        break;
                    case "EhlersChebyshevLowPassFilter":
                        movingAvgList = CalculateEhlersChebyshevLowPassFilter(stockDataClass).Item2;
                        break;
                    case "EhlersDeviationScaledMovingAverage":
                        movingAvgList = CalculateEhlersDeviationScaledMovingAverage(stockDataClass, "Ehlers2PoleSuperSmootherFilter", days).Item7;
                        break;
                    case "EhlersDeviationScaledSuperSmoother":
                        movingAvgList = CalculateEhlersDeviationScaledSuperSmoother(stockDataClass, days).Item7;
                        break;
                    case "EhlersDistanceCoefficientFilter":
                        movingAvgList = CalculateEhlersDistanceCoefficientFilter(stockDataClass, days).Item3;
                        break;
                    case "EhlersFilter":
                        movingAvgList = CalculateEhlersFilter(stockDataClass, days).Item3;
                        break;
                    case "EhlersFiniteImpulseResponseFilter":
                        movingAvgList = CalculateEhlersFiniteImpulseResponseFilter(stockDataClass).Item1;
                        break;
                    case "EhlersGaussianFilter":
                        movingAvgList = CalculateEhlersGaussianFilter(stockDataClass, days).Item4;
                        break;
                    case "EhlersInfiniteImpulseResponseFilter":
                        movingAvgList = CalculateEhlersInfiniteImpulseResponseFilter(stockDataClass, days).Item1;
                        break;
                    case "EhlersKaufmanAdaptiveMovingAverage":
                        movingAvgList = CalculateEhlersKaufmanAdaptiveMovingAverage(stockDataClass, days).Item2;
                        break;
                    case "EhlersLaguerreFilter":
                        movingAvgList = CalculateEhlersLaguerreFilter(stockDataClass).Item5;
                        break;
                    case "EhlersLeadingIndicator":
                        movingAvgList = CalculateEhlersLeadingIndicator(stockDataClass).Item2;
                        break;
                    case "EhlersModifiedOptimumEllipticFilter":
                        movingAvgList = CalculateEhlersModifiedOptimumEllipticFilter(stockDataClass).Item1;
                        break;
                    case "EhlersOptimumEllipticFilter":
                        movingAvgList = CalculateEhlersOptimumEllipticFilter(stockDataClass).Item1;
                        break;
                    case "EhlersRecursiveMedianFilter":
                        movingAvgList = CalculateEhlersRecursiveMedianFilter(stockDataClass, days).Item1;
                        break;
                    case "EhlersSimpleDecycler":
                        movingAvgList = CalculateEhlersSimpleDecycler(stockDataClass, days).Item1;
                        break;
                    case "EhlersSuperSmootherFilter":
                        movingAvgList = CalculateEhlersSuperSmootherFilter(null, stockDataClass, days).Item1;
                        break;
                    case "EhlersVariableIndexDynamicAverage":
                        movingAvgList = CalculateEhlersVariableIndexDynamicAverage(stockDataClass, "WeightedMovingAverage", days).Item8;
                        break;
                    case "EhlersZeroLagExponentialMovingAverage":
                        movingAvgList = CalculateEhlersZeroLagExponentialMovingAverage(stockDataClass, days).Item2;
                        break;
                    case "ElasticVolumeWeightedMovingAverage":
                        movingAvgList = CalculateElasticVolumeWeightedMovingAverage(stockDataClass, "SimpleMovingAverage", days).Item2;
                        break;
                    case "ElasticVolumeWeightedMovingAverageV2":
                        movingAvgList = CalculateElasticVolumeWeightedMovingAverageV2(stockDataClass, days).Item2;
                        break;
                    case "EndPointWeightedMovingAverage":
                        movingAvgList = CalculateEndPointMovingAverage(stockDataClass, days).Item3;
                        break;
                    case "EquityMovingAverage":
                        movingAvgList = CalculateEquityMovingAverage(stockDataClass, "SimpleMovingAverage", days).Item4;
                        break;
                    case "ExponentialMovingAverage":
                        movingAvgList = CalculateExponentialMovingAverage(stockDataClass, days).Item1;
                        break;
                    case "FallingRisingFilter":
                        movingAvgList = CalculateFallingRisingFilter(stockDataClass, days).Item2;
                        break;
                    case "FareySequenceWeightedMovingAverage":
                        movingAvgList = CalculateFareySequenceWeightedMovingAverage(stockDataClass, days).Item3;
                        break;
                    case "FibonacciWeightedMovingAverage":
                        movingAvgList = CalculateFibonacciWeightedMovingAverage(stockDataClass, days).Item3;
                        break;
                    case "FisherLeastSquaresMovingAverage":
                        movingAvgList = CalculateFisherLeastSquaresMovingAverage(stockDataClass, "SimpleMovingAverage", days).Item7;
                        break;
                    case "FollowingAdaptiveMovingAverage":
                        movingAvgList = CalculateEhlersMotherOfAdaptiveMovingAverages(stockDataClass).Item15;
                        break;
                    case "FractalAdaptiveMovingAverage":
                        movingAvgList = CalculateFractalAdaptiveMovingAverage(stockDataClass, days).Item5;
                        break;
                    case "GeneralFilterEstimator":
                        movingAvgList = CalculateGeneralFilterEstimator(stockDataClass, days).Item26;
                        break;
                    case "GeneralizeddecimalExponentialMovingAverage":
                        movingAvgList = CalculateGeneralizeddecimalExponentialMovingAverage(stockDataClass, "ExponentialMovingAverage", days).Item1;
                        break;
                    case "HampelFilter":
                        movingAvgList = CalculateHampelFilter(stockDataClass, days).Item4;
                        break;
                    case "HendersonWeightedMovingAverage":
                        movingAvgList = CalculateHendersonWeightedMovingAverage(stockDataClass, days).Item3;
                        break;
                    case "HoltExponentialMovingAverage":
                        movingAvgList = CalculateHoltExponentialMovingAverage(stockDataClass, days).Item2;
                        break;
                    case "HullEstimate":
                        movingAvgList = CalculateHullEstimate(stockDataClass, days).Item1;
                        break;
                    case "HullMovingAverage":
                        movingAvgList = CalculateHullMovingAverage(stockDataClass, "WeightedMovingAverage", days).Item2;
                        break;
                    case "HybridConvolutionFilter":
                        movingAvgList = CalculateHybridConvolutionFilter(stockDataClass, days).Item1;
                        break;
                    case "IIRLeastSquaresEstimate":
                        movingAvgList = CalculateIIRLeastSquaresEstimate(stockDataClass, days).Item2;
                        break;
                    case "InverseDistanceWeightedMovingAverage":
                        movingAvgList = CalculateInverseDistanceWeightedMovingAverage(stockDataClass, days).Item3;
                        break;
                    case "JsaMovingAverage":
                        movingAvgList = CalculateJsaMovingAverage(stockDataClass, days).Item1;
                        break;
                    case "JurikMovingAverage":
                        movingAvgList = CalculateJurikMovingAverage(stockDataClass, days).Item4;
                        break;
                    case "KalmanSmoother":
                        movingAvgList = CalculateKalmanSmoother(stockDataClass, days).Item4;
                        break;
                    case "KaufmanAdaptiveLeastSquaresMovingAverage":
                        movingAvgList = CalculateKaufmanAdaptiveLeastSquaresMovingAverage(stockDataClass, "KaufmanAdaptiveMovingAverage", days).Item3;
                        break;
                    case "KaufmanAdaptiveMovingAverage":
                        movingAvgList = CalculateKaufmanAdaptiveMovingAverage(stockDataClass, days).Item5;
                        break;
                    case "LeastSquaresMovingAverage":
                        movingAvgList = CalculateLeastSquaresMovingAverage(stockDataClass, days).Item1;
                        break;
                    case "LeoMovingAverage":
                        movingAvgList = CalculateLeoMovingAverage(stockDataClass, days).Item1;
                        break;
                    case "LightLeastSquaresMovingAverage":
                        movingAvgList = CalculateLightLeastSquaresMovingAverage(stockDataClass, "SimpleMovingAverage", days).Item3;
                        break;
                    case "LinearWeightedMovingAverage":
                        movingAvgList = CalculateLinearWeightedMovingAverage(stockDataClass, days).Item3;
                        break;
                    case "McGinleyDynamicIndicator":
                        movingAvgList = CalculateMcGinleyDynamicIndicator(stockDataClass, days).Item3;
                        break;
                    case "McNichollMovingAverage":
                        movingAvgList = CalculateMcNichollMovingAverage(stockDataClass, "ExponentialMovingAverage", days).Item1;
                        break;
                    case "MedianAverageAdaptiveFilter":
                        movingAvgList = CalculateMedianAverageAdaptiveFilter(stockDataClass, days).Item3;
                        break;
                    case "MesaAdaptiveMovingAverage":
                        movingAvgList = CalculateEhlersMotherOfAdaptiveMovingAverages(stockDataClass).Item16;
                        break;
                    case "MiddleHighLowMovingAverage":
                        movingAvgList = CalculateMiddleHighLowMovingAverage(stockDataClass, "ExponentialMovingAverage", days).Item1;
                        break;
                    case "ModularFilter":
                        movingAvgList = CalculateModularFilter(stockDataClass, days).Item13;
                        break;
                    case "MovingAverageAdaptiveQ":
                        movingAvgList = CalculateMovingAverageAdaptiveQ(stockDataClass, days).Item2;
                        break;
                    case "MovingAverageV3":
                        movingAvgList = CalculateMovingAverageV3(stockDataClass, "ExponentialMovingAverage", days).Item1;
                        break;
                    case "MultiDepthZeroLagExponentialMovingAverage":
                        movingAvgList = CalculateMultiDepthZeroLagExponentialMovingAverage(stockDataClass, days).Item11;
                        break;
                    case "NaturalMovingAverage":
                        movingAvgList = CalculateNaturalMovingAverage(stockDataClass, days).Item4;
                        break;
                    case "OptimalWeightedMovingAverage":
                        movingAvgList = CalculateOptimalWeightedMovingAverage(stockDataClass, days).Item4;
                        break;
                    case "OvershootReductionMovingAverage":
                        movingAvgList = CalculateOvershootReductionMovingAverage(stockDataClass, "SimpleMovingAverage", days).Item7;
                        break;
                    case "ParabolicWeightedMovingAverage":
                        movingAvgList = CalculateParabolicWeightedMovingAverage(stockDataClass, days).Item3;
                        break;
                    case "ParametricCorrectiveLinearMovingAverage":
                        movingAvgList = CalculateParametricCorrectiveLinearMovingAverage(stockDataClass, days).Item6;
                        break;
                    case "ParametricKalmanFilter":
                        movingAvgList = CalculateParametricKalmanFilter(stockDataClass, days).Item4;
                        break;
                    case "PentupleExponentialMovingAverage":
                        movingAvgList = CalculatePentupleExponentialMovingAverage(stockDataClass, "ExponentialMovingAverage", days).Item1;
                        break;
                    case "PolynomialLeastSquaresMovingAverage":
                        movingAvgList = CalculatePolynomialLeastSquaresMovingAverage(stockDataClass, days).Item12;
                        break;
                    case "PoweredKaufmanAdaptiveMovingAverage":
                        movingAvgList = CalculatePoweredKaufmanAdaptiveMovingAverage(stockDataClass, days).Item3;
                        break;
                    case "QuadraticLeastSquaresMovingAverage":
                        movingAvgList = CalculateQuadraticLeastSquaresMovingAverage(stockDataClass, days).Item20;
                        break;
                    case "QuadraticMovingAverage":
                        movingAvgList = CalculateQuadraticMovingAverage(stockDataClass, days).Item1;
                        break;
                    case "QuadraticRegression":
                        movingAvgList = CalculateQuadraticRegression(stockDataClass, "SimpleMovingAverage", days).Item20;
                        break;
                    case "QuadrupleExponentialMovingAverage":
                        movingAvgList = CalculateQuadrupleExponentialMovingAverage(stockDataClass, "ExponentialMovingAverage", days).Item1;
                        break;
                    case "QuickMovingAverage":
                        movingAvgList = CalculateQuickMovingAverage(stockDataClass, days).Item3;
                        break;
                    case "R2AdaptiveRegression":
                        movingAvgList = CalculateR2AdaptiveRegression(stockDataClass, days).Item13;
                        break;
                    case "RatioOCHLAverager":
                        movingAvgList = CalculateRatioOCHLAverager(stockDataClass).Item3;
                        break;
                    case "RegularizedExponentialMovingAverage":
                        movingAvgList = CalculateRegularizedExponentialMovingAverage(stockDataClass, days).Item1;
                        break;
                    case "RepulsionMovingAverage":
                        movingAvgList = CalculateRepulsionMovingAverage(stockDataClass, "SimpleMovingAverage", days).Item1;
                        break;
                    case "RetentionAccelerationFilter":
                        movingAvgList = CalculateRetentionAccelerationFilter(stockDataClass, days).Item10;
                        break;
                    case "ReverseEngineeringRelativeStrengthIndex":
                        movingAvgList = CalculateReverseEngineeringRelativeStrengthIndex(stockDataClass, days).Item4;
                        break;
                    case "RightSidedRickerMovingAverage":
                        movingAvgList = CalculateRightSidedRickerMovingAverage(stockDataClass, days).Item5;
                        break;
                    case "SelfWeightedMovingAverage":
                        movingAvgList = CalculateSelfWeightedMovingAverage(stockDataClass, days).Item3;
                        break;
                    case "SequentiallyFilteredMovingAverage":
                        movingAvgList = CalculateSequentiallyFilteredMovingAverage(stockDataClass, days).Item3;
                        break;
                    case "SettingLessTrendStepFiltering":
                        movingAvgList = CalculateSettingLessTrendStepFiltering(stockDataClass).Item5;
                        break;
                    case "ShapeshiftingMovingAverage":
                        movingAvgList = CalculateShapeshiftingMovingAverage(stockDataClass, days).Item5;
                        break;
                    case "SharpModifiedMovingAverage":
                        movingAvgList = CalculateSharpModifiedMovingAverage(stockDataClass, days).Item3;
                        break;
                    case "SimpleMovingAverage":
                        movingAvgList = CalculateSimpleMovingAverage(stockDataClass, days).Item1;
                        break;
                    case "SimplifiedLeastSquaresMovingAverage":
                        movingAvgList = CalculateSimplifiedLeastSquaresMovingAverage(stockDataClass, days).Item1;
                        break;
                    case "SimplifiedWeightedMovingAverage":
                        movingAvgList = CalculateSimplifiedWeightedMovingAverage(stockDataClass, days).Item3;
                        break;
                    case "SineWeightedMovingAverage":
                        movingAvgList = CalculateSineWeightedMovingAverage(stockDataClass, days).Item3;
                        break;
                    case "SlowSmoothedMovingAverage":
                        movingAvgList = CalculateSlowSmoothedMovingAverage(stockDataClass, "WeightedMovingAverage", days).Item3;
                        break;
                    case "Spencer15PointMovingAverage":
                        movingAvgList = CalculateSpencer15PointMovingAverage(stockDataClass).Item3;
                        break;
                    case "Spencer21PointMovingAverage":
                        movingAvgList = CalculateSpencer21PointMovingAverage(stockDataClass).Item3;
                        break;
                    case "SquareRootWeightedMovingAverage":
                        movingAvgList = CalculateSquareRootWeightedMovingAverage(stockDataClass, days).Item3;
                        break;
                    case "Svama":
                        movingAvgList = CalculateSvama(stockDataClass, days).Item6;
                        break;
                    case "TriangularMovingAverage":
                        movingAvgList = CalculateTriangularMovingAverage(stockDataClass, "SimpleMovingAverage", days).Item1;
                        break;
                    case "Trimean":
                        movingAvgList = CalculateTrimean(stockDataClass, days).Item4;
                        break;
                    case "TripleExponentialMovingAverage":
                        movingAvgList = CalculateTripleExponentialMovingAverage(stockDataClass, "ExponentialMovingAverage", days).Item1;
                        break;
                    case "TStepLeastSquaresMovingAverage":
                        movingAvgList = CalculateTStepLeastSquaresMovingAverage(stockDataClass, days).Item11;
                        break;
                    case "UltimateMovingAverage":
                        movingAvgList = CalculateUltimateMovingAverage(stockDataClass, "SimpleMovingAverage", days).Item10;
                        break;
                    case "VariableAdaptiveMovingAverage":
                        movingAvgList = CalculateVariableAdaptiveMovingAverage(stockDataClass, "SimpleMovingAverage", days).Item2;
                        break;
                    case "VariableIndexDynamicAverage":
                        movingAvgList = CalculateVariableIndexDynamicAverage(stockDataClass, "WeightedMovingAverage", days).Item1;
                        break;
                    case "VariableLengthMovingAverage":
                        movingAvgList = CalculateVariableLengthMovingAverage(stockDataClass, "SimpleMovingAverage", days).Item7;
                        break;
                    case "VariableMovingAverage":
                        movingAvgList = CalculateVariableMovingAverage(stockDataClass, days).Item16;
                        break;
                    case "VerticalHorizontalMovingAverage":
                        movingAvgList = CalculateVerticalHorizontalMovingAverage(stockDataClass, days).Item1;
                        break;
                    case "VolatilityMovingAverage":
                        movingAvgList = CalculateVolatilityMovingAverage(stockDataClass, "SimpleMovingAverage", days).Item9;
                        break;
                    case "VolatilityWaveMovingAverage":
                        movingAvgList = CalculateVolatilityWaveMovingAverage(stockDataClass, "WeightedMovingAverage", days).Item8;
                        break;
                    case "VolumeAdjustedMovingAverage":
                        movingAvgList = CalculateVolumeAdjustedMovingAverage(stockDataClass, "SimpleMovingAverage", days).Item6;
                        break;
                    case "VolumeWeightedAveragePrice":
                        movingAvgList = CalculateVolumeWeightedAveragePrice(stockDataClass, days).Item4;
                        break;
                    case "VolumeWeightedMovingAverage":
                        movingAvgList = CalculateVolumeWeightedMovingAverage(stockDataClass, "SimpleMovingAverage", days).Item3;
                        break;
                    case "WeightedMovingAverage":
                        movingAvgList = CalculateWeightedMovingAverage(stockDataClass, days).Item3;
                        break;
                    case "WellRoundedMovingAverage":
                        movingAvgList = CalculateWellRoundedMovingAverage(stockDataClass, days).Item4;
                        break;
                    case "WildersSmoothingMethod":
                        movingAvgList = CalculateWellesWilderMovingAverage(stockDataClass, days).Item1;
                        break;
                    case "WildersSummationMethod":
                        movingAvgList = CalculateWellesWilderSummation(stockDataClass, days).Item1;
                        break;
                    case "WindowedVolumeWeightedMovingAverage":
                        movingAvgList = CalculateWindowedVolumeWeightedMovingAverage(stockDataClass, days).Item6;
                        break;
                    case "ZeroLagExponentialMovingAverage":
                        movingAvgList = CalculateZeroLagExponentialMovingAverage(stockDataClass, "ExponentialMovingAverage", days).Item2;
                        break;
                    case "ZeroLagTripleExponentialMovingAverage":
                        movingAvgList = CalculateZeroLagTripleExponentialMovingAverage(stockDataClass, "ExponentialMovingAverage", days).Item2;
                        break;
                    case "ZeroLowLagMovingAverage":
                        movingAvgList = CalculateZeroLowLagMovingAverage(stockDataClass, days).Item3;
                        break;
                    default:
                        Console.WriteLine("Moving Avg Name: " + maType + " not supported!");
                        break;
                }

                // reset the input values list
                stockDataClass = LoadCalculations.GetInputValuesList(stockDataClass.InputName, stockDataClass);
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return movingAvgList;
        }

        public static (List<decimal>, List<Signal>) CalculateMovingAverageV3(StockData stockDataClass, string maType, int days = 3)
        {
            //@version=3
            // Copyright (c) 2018-present, Alex Orekhov (everget)
            // Moving Average 3.0 (3rd Generation) script may be freely distributed under the MIT license.
            //study("Moving Average 3.0 (3rd Generation)", shorttitle = "NMA", overlay = true)

            //length1 = input(title = "1st Length", type = integer, minval = 1, defval = 14)
            //length2 = input(title = "2nd Length", type = integer, minval = 1, defval = 3)
            //maInput = input(title = "MA Type", defval = "EMA", options =["EMA", "SMA", "VWMA", "WMA"])
            //src = input(title = "Source", type = source, defval = close)

            //getMA(src, length) =>
            //    ma = 0.0

            //    if maInput == "EMA"
            //        ma:= ema(src, length)

            //    if maInput == "SMA"
            //        ma:= sma(src, length)

            //    if maInput == "VWMA"
            //        ma:= vwma(src, length)

            //    if maInput == "WMA"
            //        ma:= wma(src, length)
            //    ma

            //getNMA(src, length1, length2) =>
            //    lambda = length1 / length2
            //    alpha = lambda * (length1 - 1) / (length1 - lambda)
            //    ma1 = getMA(src, length1)
            //    ma2 = getMA(ma1, length2)
            //    nma = (1 + alpha) * ma1 - alpha * ma2

            //nma = getNMA(src, length1, length2)

            //NOTE: A ratio of 1st Length and 2nd Length must be greater than or equal to 2. 
            //plot(nma, title = "NMA", linewidth = 2, color =#6d1e7f, transp=0)
            List<decimal> nmaList = new();
            List<Signal> signalsList = new();

            try
            {
                int length1 = (int)Math.Ceiling(days / 0.2143);
                int length2 = days;
                decimal lamdaRatio = (decimal)length1 / length2;
                decimal alpha = length1 - lamdaRatio != 0 ? lamdaRatio * (length1 - 1) / (length1 - lamdaRatio) : 0;

                List<decimal> ma1List = GetMovingAverageList(maType, null, stockDataClass, length1);
                List<decimal> ma2List = GetMovingAverageList(maType, ma1List, stockDataClass, length2);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal ma1 = ma1List.ElementAtOrDefault(i);
                    decimal ma2 = ma2List.ElementAtOrDefault(i);
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal prevNma = nmaList.LastOrDefault();
                    decimal nma = ((1 + alpha) * ma1) - (alpha * ma2);
                    nmaList.Add(nma);

                    var signal = GetCompareSignal(currentValue - nma, prevValue - prevNma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (nmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateSelfAdjustingRelativeStrengthIndex(
            StockData stockDataClass, string maType, int days = 14)
        {
            //@version=3
            // Copyright (c) 2019-present, Alex Orekhov (everget)
            //study("Self-Adjusting RSI", shorttitle = "SARSI")

            //rsiLength = input(title = "RSI Length", type = integer, defval = 14, minval = 1)
            //adjusting = input(title = "Method of Adjusting OB/OS Levels", defval = "Standard Deviation", options =["Standard Deviation", "SMA"])
            //mult = input(title = "Adjustment Multiplier", type = float, defval = 2, step = 0.1)
            //smoothingType = input(title = "Smoothing Type", defval = "SMA", options =["EMA", "SMA"])
            //smoothingLength = input(title = "Smoothing Length", type = integer, defval = 21, minval = 1)
            //highlightMovements = input(title = "Highlight Smoothing ?", type = bool, defval = false)
            //src = input(title = "Source", type = source, defval = close)

            //rsi = rsi(src, rsiLength)

            //adjusting() =>
            //   adjusting == "Standard Deviation" ? mult * stdev(rsi, rsiLength) :
            //    adjusting == "SMA" ? mult * sma(abs(rsi - sma(rsi, rsiLength)), rsiLength) :
            //    na

            //adjust = _adjusting()
            //obLevel = 50 + adjust
            //osLevel = 50 - adjust

            //hline(50, title = "Middle Level", linestyle = dotted)
            //transparent = color(white, 100)

            //rsiColor = rsi > obLevel ? #0ebb23 : rsi < osLevel ? red : #f4b77d
            //rsiPlot = plot(rsi, title = "SARSI", linewidth = 1, color = rsiColor, transp = 0)

            //smooth = smoothingType == "EMA" ? ema(rsi, smoothingLength) : sma(rsi, smoothingLength)
            //smoothColor = highlightMovements ? (smooth > smooth[1] ? #0ebb23 : red) : #6d1e7f
            //plot(smooth, title = "Smooth", linewidth = 1, color = smoothColor, transp = 0)

            //obosColor = #f1bc05 //#7b1fa2
            //obLevelPlot = plot(obLevel, title = "OB", color = obosColor, transp = 100)
            //osLevelPlot = plot(osLevel, title = "OS", color = obosColor, transp = 100)
            //fill(obLevelPlot, osLevelPlot, title = "OB/OS Filling", color =#f1bc05, transp=80)

            //obFillColor = rsi > obLevel ? green : transparent
            //fill(rsiPlot, obLevelPlot, title = "SARSI/OB Filling", color = obFillColor, transp = 85)

            //osFillColor = rsi < osLevel ? red : transparent
            //fill(rsiPlot, osLevelPlot, title = "SARSI/OS Filling", color = osFillColor, transp = 85)

            //co = crossover(rsi, obLevel)
            //cu = crossunder(rsi, osLevel)

            //alertcondition(co, title = "Alert on SARSI Overbought", message = "SARSI Overbought!")
            //alertcondition(cu, title = "Alert on SARSI Oversold", message = "SARSI Oversold!")
            List<decimal> obSmaList = new();
            List<decimal> osSmaList = new();
            List<decimal> obStdDevList = new();
            List<decimal> osStdDevList = new();
            List<decimal> adjustingStdDevList = new();
            List<decimal> adjustingSmaList = new();
            List<decimal> absDiffList = new();
            List<Signal> signalsList = new();
            decimal mult = 2;

            try
            {
                int smoothingLength = (int)Math.Ceiling(days / 0.6667);

                var rsiList = CalculateRelativeStrengthIndex(null, stockDataClass, maType, days).Item4;
                var rsiStdDevList = CalculateStandardDeviationVolatility(rsiList, stockDataClass, days).Item4;
                var rsiSmaList = GetMovingAverageList(maType, rsiList, stockDataClass, days);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal rsiStdDev = rsiStdDevList.ElementAtOrDefault(i);
                    decimal rsiSma = rsiSmaList.ElementAtOrDefault(i);
                    decimal rsi = rsiList.ElementAtOrDefault(i);
                    decimal prevRsi = i >= 1 ? rsiList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevRsiSma = i >= 1 ? rsiSmaList.ElementAtOrDefault(i - 1) : 0;

                    decimal absDiff = Math.Abs(rsi - rsiSma);
                    absDiffList.Add(absDiff);

                    decimal adjustingSma = mult * absDiffList.TakeLast(days).Average();
                    adjustingSmaList.Add(adjustingSma);

                    decimal adjustingStdDev = mult * rsiStdDev;
                    adjustingStdDevList.Add(adjustingStdDev);

                    decimal obSma = 50 + adjustingSma;
                    obSmaList.Add(obSma);

                    decimal osSma = 50 - adjustingSma;
                    osSmaList.Add(osSma);

                    decimal obStdDev = 50 + adjustingStdDev;
                    obStdDevList.Add(obStdDev);

                    decimal osStdDev = 50 - adjustingStdDev;
                    osStdDevList.Add(osStdDev);

                    var signal = GetRsiSignal(rsi - rsiSma, prevRsi - prevRsiSma, rsi, prevRsi, obStdDev, osStdDev);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (absDiffList, adjustingSmaList, adjustingStdDevList, obSmaList, osSmaList, obStdDevList, osStdDevList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateJurikMovingAverage(StockData stockDataClass, int days = 2)
        {
            //@version=3
            // Copyright (c) 2007-present Jurik Research and Consulting. All rights reserved.
            // Copyright (c) 2018-present, Alex Orekhov (everget)
            // Jurik Moving Average script may be freely distributed under the MIT license.
            //study("Jurik Moving Average", shorttitle = "JMA", overlay = true)

            //length = input(title = "Length", type = integer, defval = 7)
            //phase = input(title = "Phase", type = integer, defval = 50)
            //power = input(title = "Power", type = integer, defval = 2)
            //src = input(title = "Source", type = source, defval = close)
            //highlightMovements = input(title = "Highlight Movements ?", type = bool, defval = true)

            //phaseRatio = phase < -100 ? 0.5 : phase > 100 ? 2.5 : phase / 100 + 1.5

            //beta = 0.45 * (length - 1) / (0.45 * (length - 1) + 2)
            //alpha = pow(beta, power)

            //jma = 0.0

            //e0 = 0.0
            //e0:= (1 - alpha) * src + alpha * nz(e0[1])

            //e1 = 0.0
            //e1:= (src - e0) * (1 - beta) + beta * nz(e1[1])

            //e2 = 0.0
            //e2:= (e0 + phaseRatio * e1 - nz(jma[1])) * pow(1 - alpha, 2) + pow(alpha, 2) * nz(e2[1])

            //jma:= e2 + nz(jma[1])

            //jmaColor = highlightMovements ? (jma > jma[1] ? green : red) : #6d1e7f
            //plot(jma, title = "JMA", linewidth = 2, color = jmaColor, transp = 0)
            List<decimal> e0List = new();
            List<decimal> e1List = new();
            List<decimal> e2List = new();
            List<decimal> jmaList = new();
            List<Signal> signalsList = new();

            try
            {
                int power = days;
                int length = (int)Math.Ceiling(days / 0.2858);
                int phase = (int)Math.Ceiling(length / 0.14);
                decimal phaseRatio = phase < -100 ? 0.5m : phase > 100 ? 2.5m : ((decimal)phase / 100) + 1.5m;
                decimal ratio = 0.45m * (length - 1);
                decimal beta = ratio / (ratio + 2);
                decimal alpha = Pow(beta, power);

                for (int i = 0; i < stockDataClass.InputValues?.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevJma = jmaList.LastOrDefault();

                    decimal prevE0 = e0List.LastOrDefault();
                    decimal e0 = ((1 - alpha) * currentValue) + (alpha * prevE0);
                    e0List.Add(e0);

                    decimal prevE1 = e1List.LastOrDefault();
                    decimal e1 = ((currentValue - e0) * (1 - beta)) + (beta * prevE1);
                    e1List.Add(e1);

                    decimal prevE2 = e2List.LastOrDefault();
                    decimal e2 = ((e0 + (phaseRatio * e1) - prevJma) * Pow(1 - alpha, 2)) + (Pow(alpha, 2) * prevE2);
                    e2List.Add(e2);

                    decimal jma = e2 + prevJma;
                    jmaList.Add(jma);

                    var signal = GetCompareSignal(currentValue - jma, prevValue - prevJma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (e0List, e1List, e2List, jmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateSequentiallyFilteredMovingAverage(StockData stockDataClass, int days = 50)
        {
            // This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
            // © alexgrover

            //@version=4
            //study("Sequentially Filtered Moving Average", "SFMA", true)
            //length = input(50),src = input(close)
            //----
            //sum = 0.
            //filt = 0.
            //----
            //ma = sma(src, length)
            //a = sign(change(ma))
            //for i = 0 to length - 1
            //    sum := sum + a[i]
            //alpha = abs(sum) == length ? 1 : 0
            //filt := alpha * ma + (1 - alpha) * nz(filt[1], ma)
            //----
            //css = filt > filt[1] ? #2157f3 : filt < filt[1] ? #ff1100 : na
            //plot(filt, "Plot", fixnan(css), 3, transp = 0)
            List<decimal> sumList = new();
            List<decimal> sfmaList = new();
            List<decimal> signList = new();
            List<Signal> signalsList = new();

            try
            {
                var smaList = CalculateSimpleMovingAverage(stockDataClass, days).Item1;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal sma = smaList.ElementAtOrDefault(i);
                    decimal prevSma = i >= 1 ? smaList.ElementAtOrDefault(i - 1) : 0;

                    decimal a = Math.Sign(sma - prevSma);
                    signList.Add(a);

                    decimal sum = signList.TakeLast(days).Sum();
                    sumList.Add(sum);

                    decimal alpha = Math.Abs(sum) == days ? 1 : 0;
                    decimal prevSfma = i >= 1 ? sfmaList.ElementAtOrDefault(i - 1) : sma;
                    decimal sfma = (alpha * sma) + ((1 - alpha) * prevSfma);
                    sfmaList.Add(sfma);

                    var signal = GetCompareSignal(currentValue - sfma, prevValue - prevSfma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (signList, sumList, sfmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateRightSidedRickerMovingAverage(StockData stockDataClass, int days = 50)
        {
            // This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
            // © alexgrover

            //@version=4
            //study("Right Sided Ricker Moving Average", "RSRMA", true)
            //length = input(50),pw = input(60, "Percent Width", minval = 0, maxval = 100),src = input(close)
            //----
            //sum = 0.,sumw = 0.
            //width = pw / 100 * length
            //for i = 0 to length - 1
            //    w = (1 - pow(i / width, 2)) * exp(-(i * i / (2 * pow(width, 2))))
            //    sumw := sumw + w
            //    sum := sum + src[i] * w
            //filt = sum / sumw
            //----
            //plot(filt, "Plot",#ff1100,2,transp=0)
            List<decimal> wList = new();
            List<decimal> vwList = new();
            List<decimal> sumList = new();
            List<decimal> sumWList = new();
            List<decimal> rrmaList = new();
            List<Signal> signalsList = new();
            decimal pctWidth = (decimal)60 / 100 * days;

            try
            {
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal w = (1 - Pow(i / pctWidth, 2)) * Exp(-(i * i / (2 * Pow(pctWidth, 2))));
                    wList.Add(w);

                    decimal vw = currentValue * w;
                    vwList.Add(vw);

                    decimal wSum = wList.TakeLast(days).Sum();
                    sumWList.Add(wSum);

                    decimal sum = vwList.TakeLast(days).Sum();
                    sumList.Add(sum);

                    decimal prevRrma = rrmaList.LastOrDefault();
                    decimal rrma = wSum != 0 ? sum / wSum : 0;
                    rrmaList.Add(rrma);

                    var signal = GetCompareSignal(currentValue - rrma, prevValue - prevRrma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (wList, vwList, sumWList, sumList, rrmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateGChannels(StockData stockDataClass, int days = 100)
        {
            //@version=4
            //study("G-Channels", overlay = true)
            //length = input(100),src = input(close)
            //----
            //a = 0.,b = 0.
            //a := max(src, nz(a[1])) - nz(a[1] - b[1]) / length
            //b:= min(src, nz(b[1])) + nz(a[1] - b[1]) / length
            //avg = avg(a, b)
            //----
            //plot(a, "Upper", color = color.blue, linewidth = 2, transp = 0)
            //plot(avg, "Average", color = color.orange, linewidth = 2, transp = 0)
            //plot(b, "Lower", color = color.blue, linewidth = 2, transp = 0)
            List<decimal> aList = new();
            List<decimal> bList = new();
            List<decimal> midList = new();
            List<decimal> factorList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevA = aList.LastOrDefault();
                    decimal prevB = bList.LastOrDefault();

                    decimal factor = (prevA - prevB) / days;
                    factorList.Add(factor);

                    decimal a = Math.Max(currentValue, prevA) - factor;
                    aList.Add(a);

                    decimal b = Math.Min(currentValue, prevB) + factor;
                    bList.Add(b);

                    decimal prevMid = midList.LastOrDefault();
                    decimal mid = (a + b) / 2;
                    midList.Add(mid);

                    var signal = GetCompareSignal(currentValue - mid, prevValue - prevMid);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (factorList, aList, bList, midList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculatePriceCurveChannel(
            StockData stockDataClass, string maType, int days = 100)
        {
            //@version=4
            //study("Price-Curve Channel", overlay = true)
            //length = input(100),mult = input(1.),src = input(close)
            //----
            //a = 0.,b = 0.,size = 0.
            //    size := change(a[1]) > 0 or change(b[1]) < 0 ? atr(length) : nz(size[1], tr)
            //a:= max(src, nz(a[1], src)) - size / pow(length, 2) * (nz(barssince(a[1] > a[2]) + 1, 1) * mult)
            //b:= min(src, nz(b[1], src)) + size / pow(length, 2) * (nz(barssince(b[1] < b[2]) + 1, 1) * mult)
            //----
            //plot(a, "Upper", color =#0cb51a,linewidth=2,transp=0)
            //plot(b, "Lower", color =#ff1100,linewidth=2,transp=0)
            List<decimal> aList = new();
            List<decimal> bList = new();
            List<decimal> sizeList = new();
            List<decimal> aChgList = new();
            List<decimal> bChgList = new();
            List<decimal> barsSinceAList = new();
            List<decimal> barsSinceBList = new();
            List<decimal> midList = new();
            List<Signal> signalsList = new();

            try
            {
                var atrList = CalculateAverageTrueRange(stockDataClass, maType, days).Item1;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal atr = atrList.ElementAtOrDefault(i);
                    decimal prevA1 = i >= 1 ? aList.ElementAtOrDefault(i - 1) : currentValue;
                    decimal prevB1 = i >= 1 ? bList.ElementAtOrDefault(i - 1) : currentValue;
                    decimal prevA2 = i >= 2 ? aList.ElementAtOrDefault(i - 2) : 0;
                    decimal prevB2 = i >= 2 ? bList.ElementAtOrDefault(i - 2) : 0;
                    decimal prevSize = i >= 1 ? sizeList.ElementAtOrDefault(i - 1) : atr / days;

                    decimal size = prevA1 - prevA2 > 0 || prevB1 - prevB2 < 0 ? atr : prevSize;
                    sizeList.Add(size);

                    decimal aChg = prevA1 > prevA2 ? 1 : 0;
                    aChgList.Add(aChg);

                    decimal bChg = prevB1 < prevB2 ? 1 : 0;
                    bChgList.Add(bChg);

                    int maxIndexA = aChgList.LastIndexOf(1);
                    int maxIndexB = bChgList.LastIndexOf(1);

                    int barsSinceA = aChgList.Count - 1 - maxIndexA;
                    barsSinceAList.Add(barsSinceA);

                    int barsSinceB = bChgList.Count - 1 - maxIndexB;
                    barsSinceBList.Add(barsSinceB);

                    decimal a = Math.Max(currentValue, prevA1) - (size / Pow(days, 2) * (barsSinceA + 1));
                    aList.Add(a);

                    decimal b = Math.Min(currentValue, prevB1) + (size / Pow(days, 2) * (barsSinceB + 1));
                    bList.Add(b);

                    decimal prevMid = midList.LastOrDefault();
                    decimal mid = (a + b) / 2;
                    midList.Add(mid);

                    var signal = GetCompareSignal(currentValue - mid, prevValue - prevMid);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (sizeList, aChgList, bChgList, barsSinceAList, barsSinceBList, aList, bList, midList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculatePriceLineChannel(StockData stockDataClass, string maType, int days = 100)
        {
            //@version=4
            //study("Price-Line Channel", overlay = true)
            //length = input(50),src = input(close),r = input(false, "Readjustement")
            //----
            //a = 0.,b = 0.,sizeA = 0.,sizeB = 0.,sizeC = 0.
            //sizeA := change(a[1]) > 0 ? atr(length) : nz(sizeA[1], tr)
            //sizeB:= change(b[1]) < 0 ? atr(length) : nz(sizeB[1], tr)
            //sizeC:= change(a[1]) > 0 or change(b[1]) < 0 ? atr(length) : nz(sizeC[1], tr)
            //----
            //a:= max(src, nz(a[1], src)) - iff(r, sizeC, sizeA) / length
            //b:= min(src, nz(b[1], src)) + iff(r, sizeC, sizeB) / length
            //----
            //plot(a, "Upper", color = color.blue, linewidth = 2, transp = 0)
            //plot(b, "Lower", color =#ff1100,linewidth=2,transp=0)
            List<decimal> aList = new();
            List<decimal> bList = new();
            List<decimal> sizeAList = new();
            List<decimal> sizeBList = new();
            List<decimal> sizeCList = new();
            List<decimal> midList = new();
            List<Signal> signalsList = new();

            try
            {
                var atrList = CalculateAverageTrueRange(stockDataClass, maType, days).Item1;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal atr = atrList.ElementAtOrDefault(i);
                    decimal prevA1 = i >= 1 ? aList.ElementAtOrDefault(i - 1) : currentValue;
                    decimal prevB1 = i >= 1 ? bList.ElementAtOrDefault(i - 1) : currentValue;
                    decimal prevA2 = i >= 2 ? aList.ElementAtOrDefault(i - 2) : 0;
                    decimal prevB2 = i >= 2 ? bList.ElementAtOrDefault(i - 2) : 0;
                    decimal prevSizeA = i >= 1 ? sizeAList.ElementAtOrDefault(i - 1) : atr / days;
                    decimal prevSizeB = i >= 1 ? sizeBList.ElementAtOrDefault(i - 1) : atr / days;
                    decimal prevSizeC = i >= 1 ? sizeCList.ElementAtOrDefault(i - 1) : atr / days;

                    decimal sizeA = prevA1 - prevA2 > 0 ? atr : prevSizeA;
                    sizeAList.Add(sizeA);

                    decimal sizeB = prevB1 - prevB2 < 0 ? atr : prevSizeB;
                    sizeBList.Add(sizeB);

                    decimal sizeC = prevA1 - prevA2 > 0 || prevB1 - prevB2 < 0 ? atr : prevSizeC;
                    sizeCList.Add(sizeC);

                    decimal a = Math.Max(currentValue, prevA1) - (sizeA / days);
                    aList.Add(a);

                    decimal b = Math.Min(currentValue, prevB1) + (sizeB / days);
                    bList.Add(b);

                    decimal prevMid = midList.LastOrDefault();
                    decimal mid = (a + b) / 2;
                    midList.Add(mid);

                    var signal = GetCompareSignal(currentValue - mid, prevValue - prevMid);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (sizeAList, sizeBList, sizeCList, aList, bList, midList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>)
            CalculateParametricCorrectiveLinearMovingAverage(StockData stockDataClass, int days = 50)
        {
            // This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
            // © alexgrover

            //@version=4
            //study("Parametric Corrective Linear Moving Averages", "PCLMA's", true)
            //length = input(50),src = input(close),per = input(35., "Percentage Of Negative Weights", minval = 0, maxval = 50)
            //alpha = input(1., "Corrective Factor", minval = 0, maxval = 1, step = 0.1)
            //----
            //filter(per)=>
            //    sum = 0.,sumw = 0.
            //    for i = 1 to length
            //        p = i - per / 100 * length
            //        w = p >= 0 ? p : iff(per > 50, 1 / alpha, alpha) * p
            //        sumw := sumw + w
            //        sum := sum + src[length - i] * w
            //    sum / sumw
            //----
            //trigger = filter(per)
            //signal = filter(100 - per)
            //----
            //plot(trigger, "trigger",#2196f3,2,transp=0)
            //plot(signal, "signal",#ff1100,2,transp=0)
            List<decimal> w1List = new();
            List<decimal> w2List = new();
            List<decimal> p1List = new();
            List<decimal> p2List = new();
            List<decimal> vw1List = new();
            List<decimal> vw2List = new();
            List<decimal> sum1List = new();
            List<decimal> sumW1List = new();
            List<decimal> rrma1List = new();
            List<decimal> sum2List = new();
            List<decimal> sumW2List = new();
            List<decimal> rrma2List = new();
            List<Signal> signalsList = new();

            try
            {
                decimal alpha = 1, per = 35;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal prevValue = i >= days ? stockDataClass.InputValues.ElementAtOrDefault(i - days) : 0;

                    decimal p1 = i + 1 - (per / 100 * days);
                    p1List.Add(p1);

                    decimal p2 = i + 1 - ((100 - per) / 100 * days);
                    p2List.Add(p2);

                    decimal w1 = p1 >= 0 ? p1 : alpha * p1;
                    w1List.Add(w1);

                    decimal w2 = p2 >= 0 ? p2 : alpha * p2;
                    w2List.Add(w2);

                    decimal vw1 = prevValue * w1;
                    vw1List.Add(vw1);

                    decimal vw2 = prevValue * w2;
                    vw2List.Add(vw2);

                    decimal wSum1 = w1List.TakeLast(days).Sum();
                    sumW1List.Add(wSum1);

                    decimal wSum2 = w2List.TakeLast(days).Sum();
                    sumW2List.Add(wSum2);

                    decimal sum1 = vw1List.TakeLast(days).Sum();
                    sum1List.Add(sum1);

                    decimal sum2 = vw2List.TakeLast(days).Sum();
                    sum2List.Add(sum2);

                    decimal prevRrma1 = rrma1List.LastOrDefault();
                    decimal rrma1 = wSum1 != 0 ? sum1 / wSum1 : 0;
                    rrma1List.Add(rrma1);

                    decimal prevRrma2 = rrma2List.LastOrDefault();
                    decimal rrma2 = wSum2 != 0 ? sum2 / wSum2 : 0;
                    rrma2List.Add(rrma2);

                    var signal = GetCompareSignal(rrma1 - rrma2, prevRrma1 - prevRrma2);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (p1List, w1List, vw1List, sumW1List, sum1List, rrma1List, p2List, w2List, vw2List, sumW2List, sum2List, rrma2List, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>)
            CalculateGrandTrendForecasting(StockData stockDataClass, int days = 100)
        {
            // This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License https://creativecommons.org/licenses/by-sa/4.0/
            // © alexgrover

            //@version=4
            //study("Grand Trend Forecasting", "GTF", true)
            //src = input(close),length = input(100),forecast = input(200),corrective = input(false)
            //source = input("Noisy", options =["Noisy", "Smooth"]),mult = input(2, "Interval Width")
            //sh = input(false, "Show Historal Forecasts")
            //----
            //t = 0.
            //c = 0.
            //t := 0.9 * nz(t[length], src) + 0.1 * src + change(0.9 * nz(t[length], src), length) * iff(corrective, 0.9, 1)
            //trend = sma(t, length)
            //srcf = iff(source == "Smooth", sma(t, length), t)
            //fcast = srcf + change(srcf, forecast) * iff(corrective, 0.9, 1)
            //----
            //dev = sma(abs(src - fcast[forecast]), forecast) * mult
            //upper = fcast + dev
            //lower = fcast - dev
            //----
            //plot(t, "Grand Trend Plot",#285DF3,2,transp=0)
            //plot(trend, "Smooth",#ff1100,2,transp=0)
            //----
            //h = sh ? 0 : forecast
            //plot(fcast, "fcast",#0cb51a,2,transp=0,offset=forecast,show_last=h)
            //a = plot(upper, "", na, offset = forecast, editable = false, show_last = h)
            //b = plot(lower, "", na, offset = forecast, editable = false, show_last = h)
            //fill(a, b,#787b86,80,show_last=1)
            List<decimal> devList = new();
            List<decimal> upperList = new();
            List<decimal> lowerList = new();
            List<decimal> tList = new();
            List<decimal> trendList = new();
            List<decimal> chgList = new();
            List<decimal> fcastList = new();
            List<decimal> diffList = new();
            List<decimal> diffSmaList = new();
            List<decimal> bullSlopeList = new();
            List<decimal> bearSlopeList = new();
            List<Signal> signalsList = new();

            try
            {
                int forecastLength = MinOrMax(days * 2);
                decimal mult = 2;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevT = i >= days ? tList.ElementAtOrDefault(i - days) : currentValue;
                    decimal priorT = i >= forecastLength ? tList.ElementAtOrDefault(i - forecastLength) : 0;
                    decimal prevFcast = i >= forecastLength ? fcastList.ElementAtOrDefault(i - forecastLength) : 0;
                    decimal prevChg = i >= days ? chgList.ElementAtOrDefault(i - days) : currentValue;

                    decimal chg = 0.9m * prevT;
                    chgList.Add(chg);

                    decimal t = (0.9m * prevT) + (0.1m * currentValue) + (chg - prevChg);
                    tList.Add(t);

                    decimal trend = tList.TakeLast(days).Average();
                    trendList.Add(trend);

                    decimal fcast = t + (t - priorT);
                    fcastList.Add(fcast);

                    decimal diff = Math.Abs(currentValue - prevFcast);
                    diffList.Add(diff);

                    decimal diffSma = diffList.TakeLast(forecastLength).Average();
                    diffSmaList.Add(diffSma);

                    decimal dev = diffSma * mult;
                    devList.Add(dev);

                    decimal upper = fcast + dev;
                    upperList.Add(upper);

                    decimal lower = fcast - dev;
                    lowerList.Add(lower);

                    decimal prevBullSlope = bullSlopeList.LastOrDefault();
                    decimal bullSlope = currentValue - Math.Max(fcast, Math.Max(t, trend));
                    bullSlopeList.Add(bullSlope);

                    decimal prevBearSlope = bearSlopeList.LastOrDefault();
                    decimal bearSlope = currentValue - Math.Min(fcast, Math.Min(t, trend));
                    bearSlopeList.Add(bearSlope);

                    var signal = GetBullishBearishSignal(bullSlope, prevBullSlope, bearSlope, prevBearSlope);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (chgList, tList, trendList, fcastList, diffList, diffSmaList, devList, upperList, lowerList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateGroverLlorensCycleOscillator(StockData stockDataClass, string maType, int days = 20)
        {
            // This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License https://creativecommons.org/licenses/by-sa/4.0/
            // © alexgrover & Lucía Llorens

            //@version=4
            //study("Grover Llorens Cycle Oscillator [alexgrover & Lucía Llorens]", "GLCO")
            //length = input(100),mult = input(10),src = input(close)
            //smooth = input(true),rsi = input(20, "Rsi Period/Smoothing Amount")
            //----
            //ts = 0.
            //diff = src - nz(ts[1], src[1])
            //atr = atr(length)
            //----
            //up = crossover(diff, 0)
            //dn = crossunder(diff, 0)
            //val = valuewhen(up or dn, atr / length, 0)
            //bars = barssince(up or dn)
            //ts:= up ? nz(ts[1], src) - atr * mult : dn ? nz(ts[1], src) + atr * mult : nz(ts[1], src) + sign(diff) * val * bars
            //----
            //osc = src - ts
            //smo = smooth ? ema(osc, rsi) : osc
            //norm = rsi(smo, rsi)
            //----
            //plot(norm, "Osc",#2196f3,2,transp=0)
            //hline(80, color =#009688,linewidth=2)
            //hline(20, color =#e65100,linewidth=2)
            List<decimal> tsList = new();
            List<decimal> oscList = new();
            List<decimal> smoList = new();
            List<decimal> diffList = new();
            List<decimal> rsiList = new();
            List<Signal> signalsList = new();
            decimal mult = 10;

            try
            {
                int length = MinOrMax(days * 5);

                var atrList = CalculateAverageTrueRange(stockDataClass, maType, length).Item1;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal atr = atrList.ElementAtOrDefault(i);
                    decimal prevTs = i >= 1 ? tsList.ElementAtOrDefault(i - 1) : currentValue;

                    decimal diff = currentValue - prevTs;
                    diffList.Add(diff);

                    decimal ts = diff > 0 ? prevTs - (atr * mult) : diff < 0 ? prevTs + (atr * mult) : prevTs;
                    tsList.Add(ts);

                    decimal osc = currentValue - ts;
                    oscList.Add(osc);
                }

                smoList = GetMovingAverageList(maType, oscList, stockDataClass, days);
                rsiList = CalculateRelativeStrengthIndex(smoList, stockDataClass, maType, days).Item4;
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal rsi = rsiList.ElementAtOrDefault(j);
                    decimal prevRsi1 = j >= 1 ? rsiList.ElementAtOrDefault(j - 1) : 0;
                    decimal prevRsi2 = j >= 2 ? rsiList.ElementAtOrDefault(j - 2) : 0;

                    var signal = GetRsiSignal(rsi - prevRsi1, prevRsi1 - prevRsi2, rsi, prevRsi1, 80, 20);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (diffList, tsList, oscList, smoList, rsiList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateGroverLlorensActivator(StockData stockDataClass, string maType, int days = 480)
        {
            // This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License https://creativecommons.org/licenses/by-sa/4.0/
            // © alexgrover & Lucía Llorens

            //@version=4
            //strategy("Grover Llorens Activator")
            //length = input(480),mult = input(14),src = input(close)
            //----
            //ts = 0.
            //diff = src - nz(ts[1], src[1])
            //atr = atr(length)
            //----
            //up = crossover(diff, 0)
            //dn = crossunder(diff, 0)
            //val = valuewhen(up or dn, atr / length, 0)
            //bars = barssince(up or dn)
            //ts:= up ? nz(ts[1], src) - atr * mult : dn ? nz(ts[1], src) + atr * mult : nz(ts[1], src) + sign(diff) * val * bars
            //----
            //if up
            //    strategy.entry("Buy", strategy.long)
            //if dn
            //    strategy.entry("Sell", strategy.short)
            //----
            //cap = strategy.initial_capital
            //eq = strategy.equity
            //rmax = 0.
            //rmax := max(eq, nz(rmax[1]))
            //----
            //css = eq > cap ? #0cb51a : #e65100
            //a = plot(eq, "Equity",#2196f3,2,transp=0)
            //b = plot(rmax, "Maximum", css, 2, transp = 0)
            //fill(a, b, css, 80)
            List<decimal> tsList = new();
            List<decimal> diffList = new();
            List<Signal> signalsList = new();
            decimal mult = 14;

            try
            {
                var atrList = CalculateAverageTrueRange(stockDataClass, maType, days).Item1;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal atr = atrList.ElementAtOrDefault(i);
                    decimal prevTs = i >= 1 ? tsList.ElementAtOrDefault(i - 1) : currentValue;
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    prevTs = prevTs == 0 ? prevValue : prevTs;

                    decimal prevDiff = diffList.LastOrDefault();
                    decimal diff = currentValue - prevTs;
                    diffList.Add(diff);

                    decimal ts = diff > 0 ? prevTs - (atr * mult) : diff < 0 ? prevTs + (atr * mult) : prevTs;
                    tsList.Add(ts);

                    var signal = GetCompareSignal(diff, prevDiff);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (diffList, tsList, signalsList);
        }

        public static (List<decimal>, List<Signal>) CalculateLeoMovingAverage(StockData stockDataClass, int days = 14)
        {
            //@version=3
            // Copyright (c) 2018-present, Alex Orekhov (everget)
            // Leo Moving Average script may be freely distributed under the MIT license.
            //study("Leo Moving Average", shorttitle = "LMA", overlay = true)

            //length = input(title = "Length", type = integer, minval = 1, defval = 14)
            //highlightMovements = input(title = "Highlight Movements ?", type = bool, defval = true)
            //src = input(title = "Source", type = source, defval = close)

            //lma = 2 * wma(src, length) - sma(src, length)

            //lmaColor = highlightMovements ? (lma > lma[1] ? green : red) : #6d1e7f
            //plot(lma, title = "LMA", linewidth = 2, color = lmaColor, transp = 0)
            List<decimal> lmaList = new();
            List<Signal> signalsList = new();

            try
            {
                var wmaList = CalculateWeightedMovingAverage(stockDataClass, days).Item3;
                var smaList = CalculateSimpleMovingAverage(stockDataClass, days).Item1;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal currentWma = wmaList.ElementAtOrDefault(i);
                    decimal currentSma = smaList.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal prevLma = lmaList.LastOrDefault();
                    decimal lma = (2 * currentWma) - currentSma;
                    lmaList.Add(lma);

                    var signal = GetCompareSignal(currentValue - lma, prevValue - prevLma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (lmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>)
            CalculateEfficientTrendStepChannel(StockData stockDataClass, int days = 50)
        {
            // This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
            // © alexgrover

            //@version=4
            //study("Efficient Trend Step Channel", overlay = true)
            //length = input(100),fast = input(50),slow = input(200),src = input(close)
            //----
            //er = abs(change(src, length)) / sum(abs(change(src)), length)
            //dev = er * stdev(src * 2, fast) + (1 - er) * stdev(src * 2, slow)
            //----
            //a = 0.,a:= src > nz(a[1], src) + dev ? src : src < nz(a[1], src) - dev ? src : nz(a[1], src)
            //upper = valuewhen(change(a), a + dev, 0)
            //lower = valuewhen(change(a), a - dev, 0)
            //----
            //css = fixnan(a > a[1] ? #2E9AFE : a < a[1] ? #e65100 : na)
            //plot(upper, color = css, transp = 0, linewidth = 3)
            //plot(a, color = css, transp = 0, linewidth = 3)
            //plot(lower, color = css, transp = 0, linewidth = 3)
            List<decimal> val2List = new();
            List<decimal> devList = new();
            List<decimal> upperList = new();
            List<decimal> lowerList = new();
            List<decimal> aList = new();
            List<decimal> stdDevFastList = new();
            List<decimal> stdDevSlowList = new();
            List<Signal> signalsList = new();

            try
            {
                int slow = MinOrMax(days * 4);
                int length = MinOrMax(days * 2);

                List<decimal> erList = CalculateKaufmanAdaptiveMovingAverage(stockDataClass, length).Item3;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);

                    decimal val2 = currentValue * 2;
                    val2List.Add(val2);
                }

                stdDevFastList = CalculateStandardDeviationVolatility(val2List, stockDataClass, days).Item4;
                stdDevSlowList = CalculateStandardDeviationVolatility(val2List, stockDataClass, slow).Item4;
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(j);
                    decimal er = erList.ElementAtOrDefault(j);
                    decimal fastStdDev = stdDevFastList.ElementAtOrDefault(j);
                    decimal slowStdDev = stdDevSlowList.ElementAtOrDefault(j);
                    decimal prevA = j >= 1 ? aList.ElementAtOrDefault(j - 1) : currentValue;
                    decimal prevValue = j >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(j - 1) : 0;

                    decimal dev = (er * fastStdDev) + ((1 - er) * slowStdDev);
                    devList.Add(dev);

                    decimal a = currentValue > prevA + dev ? currentValue : currentValue < prevA - dev ? currentValue : prevA;
                    aList.Add(a);

                    decimal prevUpper = upperList.LastOrDefault();
                    decimal upper = a + dev;
                    upperList.Add(upper);

                    decimal prevLower = lowerList.LastOrDefault();
                    decimal lower = a - dev;
                    lowerList.Add(lower);

                    var signal = GetBollingerBandsSignal(currentValue - a, prevValue - prevA, currentValue, prevValue, upper, prevUpper, lower, prevLower);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (val2List, stdDevFastList, stdDevSlowList, devList, aList, upperList, lowerList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateRunningEquity(StockData stockDataClass, string maType, int days = 100)
        {
            //@version=4
            //study("Running Equity")
            //length = input(100)
            //----
            //src = close
            //X = sign(src - sma(src, length))
            //Req = sum(change(src) * X[1], length)
            //----
            //css = Req > 0 ? #0cb51a : #FF0000
            //plot(Req, color = css, style = plot.style_area, transp = 20)
            List<decimal> chgXList = new();
            List<decimal> reqList = new();
            List<decimal> xList = new();
            List<Signal> signalsList = new();

            try
            {
                var smaList = GetMovingAverageList(maType, null, stockDataClass, days);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal sma = smaList.ElementAtOrDefault(i);

                    decimal prevX = xList.LastOrDefault();
                    decimal x = Math.Sign(currentValue - sma);
                    xList.Add(x);

                    decimal chgX = (currentValue - prevValue) * prevX;
                    chgXList.Add(chgX);

                    decimal prevReq = reqList.LastOrDefault();
                    decimal req = chgXList.TakeLast(days).Sum();
                    reqList.Add(req);

                    var signal = GetCompareSignal(req, prevReq);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (chgXList, reqList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateEquityMovingAverage(StockData stockDataClass, string maType, int days = 14)
        {
            //@version=4
            //study("EQma", overlay = true)
            //length = input(14),lag = input(false, title = "Lag Reduction"),effi = input(false, title = "Efficient"),coloring = input(false)
            //----
            //ma = 0.
            //src = close
            //X = sign(src - iff(effi, nz(ma[1]), sma(src, length)))
            //Req = sum(change(src) * X[1], length)
            //OPTeq = cum(change(src) * X)
            //----
            //alpha = pow(max(Req / OPTeq, 0), iff(lag, .5, 1))
            //ma:= alpha * src + (1 - alpha) * nz(ma[1], src)
            //----
            //css = coloring ? fixnan(ma > ma[2] ?#0cb51a:ma<ma[2]?#FF0000:na) : #FF0000
            //plot(ma, color = css, linewidth = 2, transp = 0)
            List<decimal> chgXList = new();
            List<decimal> chgXCumList = new();
            List<decimal> opteqList = new();
            List<decimal> alphaList = new();
            List<decimal> xList = new();
            List<decimal> eqmaList = new();
            List<Signal> signalsList = new();

            try
            {
                var smaList = GetMovingAverageList(maType, null, stockDataClass, days);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal sma = smaList.ElementAtOrDefault(i);
                    decimal prevEqma = i >= 1 ? eqmaList.ElementAtOrDefault(i - 1) : currentValue;

                    decimal prevX = xList.LastOrDefault();
                    decimal x = Math.Sign(currentValue - sma);
                    xList.Add(x);

                    decimal chgX = (currentValue - prevValue) * prevX;
                    chgXList.Add(chgX);

                    decimal req = chgXList.TakeLast(days).Sum();

                    decimal chgXCum = (currentValue - prevValue) * x;
                    chgXCumList.Add(chgXCum);

                    decimal opteq = chgXCumList.Sum();
                    opteqList.Add(opteq);

                    decimal alpha = opteq != 0 ? MinOrMax(req / opteq, 0.99m, 0.01m) : 0.99m;
                    alphaList.Add(alpha);

                    decimal eqma = (alpha * currentValue) + ((1 - alpha) * prevEqma);
                    eqmaList.Add(eqma);

                    var signal = GetCompareSignal(currentValue - eqma, prevValue - prevEqma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (chgXCumList, opteqList, alphaList, eqmaList, signalsList);
        }

        public static (List<decimal>, List<Signal>) CalculateHullEstimate(StockData stockDataClass, int days = 50)
        {
            // This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
            // © alexgrover
            //@version=4
            //study("Hull Estimate", "HEMA", true)
            //length = input(50)
            //----
            //a = 3 * wma(close, length / 2) - 2 * ema(close, length / 2)
            //plot(a, "HEMA",#e91e63,2,transp=0)
            List<decimal> hemaList = new();
            List<Signal> signalsList = new();

            try
            {
                int maLength = MinOrMax((int)Math.Ceiling((double)days / 2));

                var wmaList = CalculateWeightedMovingAverage(stockDataClass, maLength).Item3;
                var emaList = CalculateExponentialMovingAverage(stockDataClass, maLength).Item1;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal currentWma = wmaList.ElementAtOrDefault(i);
                    decimal currentEma = emaList.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal prevHema = hemaList.LastOrDefault();
                    decimal hema = (3 * currentWma) - (2 * currentEma);
                    hemaList.Add(hema);

                    var signal = GetCompareSignal(currentValue - hema, prevValue - prevHema);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (hemaList, signalsList);
        }

        public static (List<decimal>, List<Signal>) CalculateLeastSquaresMovingAverage(StockData stockDataClass, int days = 25)
        {
            // This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
            // © alexgrover

            //@version=4
            //study("LSMA", overlay = true)
            //length = input(25),src = input(close)
            //----
            //a = 3 * wma(src, length) - 2 * sma(src, length)
            //plot(a, "LSMA",#ff9800,2,transp=0)
            List<decimal> lsmaList = new();
            List<Signal> signalsList = new();

            try
            {
                var wmaList = CalculateWeightedMovingAverage(stockDataClass, days).Item3;
                var smaList = CalculateSimpleMovingAverage(stockDataClass, days).Item1;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal currentWma = wmaList.ElementAtOrDefault(i);
                    decimal currentSma = smaList.ElementAtOrDefault(i);

                    decimal prevLsma = lsmaList.LastOrDefault();
                    decimal lsma = (3 * currentWma) - (2 * currentSma);
                    lsmaList.Add(lsma);

                    var signal = GetCompareSignal(currentValue - lsma, prevValue - prevLsma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (lsmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateSimplifiedWeightedMovingAverage(StockData stockDataClass, int days = 14)
        {
            // This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License https://creativecommons.org/licenses/by-sa/4.0/
            // © alexgrover

            //@version=4
            //study("WMA/LSMA", overlay = true)
            //length = input(14),src = input(close)
            //----
            //cml = cum(src)
            //sum = change(cum(cml), length)
            //wma = (length * cml - sum[1]) / (length * (length + 1) / 2)
            //lsma = 3 * wma - 2 * change(cml, length) / length
            //----
            //plot(lsma, "LSMA",#2157f3,2)
            //plot(wma, "WMA",#ff1100,2)
            List<decimal> wmaList = new();
            List<decimal> cmlList = new();
            List<decimal> cmlSumList = new();
            List<decimal> tempList = new();
            List<decimal> sumList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal prevValue = tempList.LastOrDefault();
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    tempList.Add(currentValue);

                    decimal cml = tempList.Sum();
                    cmlList.Add(cml);

                    decimal prevCmlSum = i >= days ? cmlSumList.ElementAtOrDefault(i - days) : 0;
                    decimal cmlSum = cmlList.Sum();
                    cmlSumList.Add(cmlSum);

                    decimal prevSum = sumList.LastOrDefault();
                    decimal sum = cmlSum - prevCmlSum;
                    sumList.Add(sum);

                    decimal prevWma = wmaList.LastOrDefault();
                    decimal wma = ((days * cml) - prevSum) / (days * (days + 1) / 2);
                    wmaList.Add(wma);

                    var signal = GetCompareSignal(currentValue - wma, prevValue - prevWma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (cmlList, cmlSumList, sumList, wmaList, signalsList);
        }

        public static (List<decimal>, List<Signal>) CalculateSimplifiedLeastSquaresMovingAverage(StockData stockDataClass, int days = 14)
        {
            // This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License https://creativecommons.org/licenses/by-sa/4.0/
            // © alexgrover

            //@version=4
            //study("WMA/LSMA", overlay = true)
            //length = input(14),src = input(close)
            //----
            //cml = cum(src)
            //sum = change(cum(cml), length)
            //wma = (length * cml - sum[1]) / (length * (length + 1) / 2)
            //lsma = 3 * wma - 2 * change(cml, length) / length
            //----
            //plot(lsma, "LSMA",#2157f3,2)
            //plot(wma, "WMA",#ff1100,2)
            List<decimal> lsmaList = new();
            List<Signal> signalsList = new();

            try
            {
                var swmaList = CalculateSimplifiedWeightedMovingAverage(stockDataClass, days);
                var cmlList = swmaList.Item1;
                var wmaList = swmaList.Item4;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal currentWma = wmaList.ElementAtOrDefault(i);
                    decimal currentCml = cmlList.ElementAtOrDefault(i);
                    decimal prevCml = i >= days ? cmlList.ElementAtOrDefault(i - days) : 0;

                    decimal prevLsma = lsmaList.LastOrDefault();
                    decimal lsma = (3 * currentWma) - (2 * (currentCml - prevCml) / days);
                    lsmaList.Add(lsma);

                    var signal = GetCompareSignal(currentValue - lsma, prevValue - prevLsma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (lsmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<Signal>) CalculateTStepLeastSquaresMovingAverage(StockData stockDataClass, int days = 100)
        {
            //@version=4
            //study("T-Step LSMA", overlay = true)
            //length = input(100),sc = input(.5),ns = input(false, "No Smoothing")
            //----
            //b = 0.,ls = 0.
            //src = sc * close + (1 - sc) * nz(ls[1], close)
            //----
            //er = 1 - abs(change(src, length)) / sum(abs(change(src)), length)
            //n = cum(1) - 1
            //a = cum(abs(src - nz(b[1], src))) / n * (1 + er)
            //b:= src > nz(b[1], src) + a ? src : src < nz(b[1], src) - a ? src : nz(b[1], src)
            //----
            //alpha = fixnan(correlation(src, b, length) * (stdev(src, length) / stdev(b, length)))
            //beta = sma(src, length) - alpha * sma(b, length)
            //ls:= alpha * b + beta
            //----
            //osc = 0
            //osc:= b > b[1] ? 1 : b < b[1] ? 0 : osc[1]
            //css = osc == 1 ? color.blue :#e65100
            //plot(ns ? b : fixnan(ls), color = css, linewidth = 3, transp = 0)
            //alertcondition(change(osc) > 0, title = "Up", message = "Up-trending Market Estimated")
            //alertcondition(change(osc) < 0, title = "Dn", message = "Down-trending Market Estimated")
            List<decimal> tslsmaList = new();
            List<decimal> lsList = new();
            List<decimal> erList = new();
            List<decimal> bList = new();
            List<decimal> chgList = new();
            List<decimal> aList = new();
            List<decimal> alphaList = new();
            List<decimal> betaList = new();
            List<decimal> tempList = new();
            List<decimal> corrList = new();
            List<decimal> bStdDevList = new();
            List<decimal> bSmaList = new();
            List<Signal> signalsList = new();
            decimal sc = 0.5m;

            try
            {
                var efRatioList = CalculateKaufmanAdaptiveMovingAverage(stockDataClass, days).Item3;
                var stdDevList = CalculateStandardDeviationVolatility(null, stockDataClass, days).Item4;
                var smaList = CalculateSimpleMovingAverage(stockDataClass, days).Item1;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    tempList.Add(currentValue);

                    decimal efRatio = efRatioList.ElementAtOrDefault(i);
                    decimal prevB = i >= 1 ? bList.ElementAtOrDefault(i - 1) : currentValue;

                    decimal er = 1 - efRatio;
                    erList.Add(er);

                    decimal chg = Math.Abs(currentValue - prevB);
                    chgList.Add(chg);

                    decimal a = chgList.Average() * (1 + er);
                    aList.Add(a);

                    decimal b = currentValue > prevB + a ? currentValue : currentValue < prevB - a ? currentValue : prevB;
                    bList.Add(b);

                    decimal bSma = bList.TakeLast(days).Average();
                    bSmaList.Add(bSma);

                    var corr = GoodnessOfFit.R(bList.TakeLast(days).Select(x => (double)x), tempList.TakeLast(days).Select(x => (double)x));
                    corr = IsValueNullOrInfinity(corr) ? 0 : corr;
                    corrList.Add((decimal)corr);
                }

                bStdDevList = CalculateStandardDeviationVolatility(bList, stockDataClass, days).Item4;
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal corr = corrList.ElementAtOrDefault(j);
                    decimal stdDev = stdDevList.ElementAtOrDefault(j);
                    decimal bStdDev = bStdDevList.ElementAtOrDefault(j);
                    decimal bSma = bSmaList.ElementAtOrDefault(j);
                    decimal sma = smaList.ElementAtOrDefault(j);
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(j);
                    decimal prevLs = j >= 1 ? lsList.ElementAtOrDefault(j - 1) : currentValue;
                    decimal b = bList.ElementAtOrDefault(j);
                    decimal prevValue = j >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(j - 1) : 0;

                    decimal tslsma = (sc * currentValue) + ((1 - sc) * prevLs);
                    tslsmaList.Add(tslsma);

                    decimal alpha = bStdDev != 0 ? corr * stdDev / bStdDev : 0;
                    alphaList.Add(alpha);

                    decimal beta = sma - (alpha * bSma);
                    betaList.Add(beta);

                    decimal ls = (alpha * b) + beta;
                    lsList.Add(ls);

                    var signal = GetCompareSignal(currentValue - ls, prevValue - prevLs);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (erList, chgList, aList, bList, bSmaList, corrList, bStdDevList, tslsmaList, alphaList, betaList, lsList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateSettingLessTrendStepFiltering(StockData stockDataClass)
        {
            //@version=4
            //study("Setting-Less Trend-Step Filtering", overlay = true)
            //input = input(close),robust = input(true)
            //----
            //b = 0.,sc = 0.,a = 0.
            //    sc := robust ? abs(input - nz(b[1])) / (abs(input - nz(b[1])) + nz(a[1])) : 1
            //src = sc * input + (1 - sc) * nz(b[1], input)
            //----
            //n = cum(1) - 1
            //a:= cum(abs(src - nz(b[1], src))) / n * (iff(robust, 1, 0) + sc)
            //b:= src > nz(b[1], src) + a ? src : src < nz(b[1], src) - a ? src : nz(b[1], src)
            //----
            //plot(b, color =#ff1100,linewidth=3,transp=0)
            List<decimal> chgList = new();
            List<decimal> aList = new();
            List<decimal> bList = new();
            List<decimal> scList = new();
            List<decimal> sltsfList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevB = i >= 1 ? bList.ElementAtOrDefault(i - 1) : currentValue;
                    decimal prevA = aList.LastOrDefault();

                    decimal sc = Math.Abs(currentValue - prevB) + prevA != 0 ? Math.Abs(currentValue - prevB) / (Math.Abs(currentValue - prevB) + prevA) : 0;
                    scList.Add(sc);

                    decimal sltsf = (sc * currentValue) + ((1 - sc) * prevB);
                    sltsfList.Add(sltsf);

                    decimal chg = Math.Abs(currentValue - prevB);
                    chgList.Add(chg);

                    decimal a = chgList.Average() * (1 + sc);
                    aList.Add(a);

                    decimal b = currentValue > prevB + a ? currentValue : currentValue < prevB - a ? currentValue : prevB;
                    bList.Add(b);

                    var signal = GetCompareSignal(currentValue - b, prevValue - prevB);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (scList, sltsfList, chgList, aList, bList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateGOscillator(StockData stockDataClass, int days = 14)
        {
            //@version=4
            //study("%G Oscillator")
            //length = input(14),src = input(close)
            //----
            //b = 0
            //for i = 1 to length
            //    a = src > src[i] ? 100 : 0
            //    b := b + a / length
            //----
            //plot(b, color =#e65100,transp=0)
            //hline(80), hline(20)
            List<decimal> bList = new();
            List<decimal> bSumList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevBSum1 = i >= 1 ? bSumList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevBSum2 = i >= 2 ? bSumList.ElementAtOrDefault(i - 2) : 0;

                    decimal b = currentValue > prevValue ? (decimal)100 / days : 0;
                    bList.Add(b);

                    decimal bSum = bList.TakeLast(days).Sum();
                    bSumList.Add(bSum);

                    var signal = GetRsiSignal(bSum - prevBSum1, prevBSum1 - prevBSum2, bSum, prevBSum1, 80, 20);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (bList, bSumList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>)
            CalculateQuadraticLeastSquaresMovingAverage(StockData stockDataClass, int days = 50)
        {
            //@version=4
            //study("Quadratic Least Squares Moving Average", "Qlsma", overlay = true)
            //length = input(50),src = input(close),forecast = input(14),showpast = input(false, "Show Past Predicted Values")
            //----
            //Cov(x, y) => sma(x * y, length) - sma(x, length) * sma(y, length)
            //Var(x) => variance(x, length)
            //n = bar_index
            //----
            //norm = Var(n * n) * Var(n) - pow(Cov(n, n * n), 2)
            //a = (Cov(n * n, src) * Var(n) - Cov(n, src) * Cov(n, n * n)) / norm
            //b = (Cov(n, src) * Var(n * n) - Cov(n * n, src) * Cov(n, n * n)) / norm
            //c = sma(src, length) - a * sma(n * n, length) - b * sma(n, length)
            //----
            //qlsma = a * (n * n) + b * n + c
            //fcast = a * pow(n + forecast, 2) + b * (n + forecast) + c
            //----
            //plot(qlsma, "Qlsma",#ff1100,2,transp=0)
            //plot(fcast, "Forecast",#ff9800,2,transp=0,offset=forecast,show_last=iff(showpast,0,forecast))
            List<decimal> nList = new();
            List<decimal> nSmaList = new();
            List<decimal> n2List = new();
            List<decimal> n2SmaList = new();
            List<decimal> nn2List = new();
            List<decimal> nn2SmaList = new();
            List<decimal> nn2CovList = new();
            List<decimal> n2vList = new();
            List<decimal> n2vSmaList = new();
            List<decimal> n2vCovList = new();
            List<decimal> nvList = new();
            List<decimal> nvCovList = new();
            List<decimal> nvSmaList = new();
            List<decimal> nVarianceList = new();
            List<decimal> n2VarianceList = new();
            List<decimal> normList = new();
            List<decimal> aList = new();
            List<decimal> bList = new();
            List<decimal> cList = new();
            List<decimal> qlsmaList = new();
            List<decimal> fcastList = new();
            List<Signal> signalsList = new();
            decimal forecast = 14;

            try
            {
                var smaList = CalculateSimpleMovingAverage(stockDataClass, days).Item1;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal sma = smaList.ElementAtOrDefault(i);

                    decimal n = i;
                    nList.Add(n);

                    decimal n2 = Pow(n, 2);
                    n2List.Add(n2);

                    decimal nn2 = n * n2;
                    nn2List.Add(nn2);

                    decimal n2v = n2 * currentValue;
                    n2vList.Add(n2v);

                    decimal nv = n * currentValue;
                    nvList.Add(nv);

                    decimal nSma = nList.TakeLast(days).Average();
                    nSmaList.Add(nSma);

                    decimal n2Sma = n2List.TakeLast(days).Average();
                    n2SmaList.Add(n2Sma);

                    decimal n2vSma = n2vList.TakeLast(days).Average();
                    n2vSmaList.Add(n2vSma);

                    decimal nvSma = nvList.TakeLast(days).Average();
                    nvSmaList.Add(nvSma);

                    decimal nn2Sma = nn2List.TakeLast(days).Average();
                    nn2SmaList.Add(nn2Sma);

                    decimal nn2Cov = nn2Sma - (nSma * n2Sma);
                    nn2CovList.Add(nn2Cov);

                    decimal n2vCov = n2vSma - (n2Sma * sma);
                    n2vCovList.Add(n2vCov);

                    decimal nvCov = nvSma - (nSma * sma);
                    nvCovList.Add(nvCov);
                }

                nVarianceList = CalculateStandardDeviationVolatility(nList, stockDataClass, days).Item3;
                n2VarianceList = CalculateStandardDeviationVolatility(n2List, stockDataClass, days).Item3;
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(j);
                    decimal prevValue = j >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(j - 1) : 0;
                    decimal n2Variance = n2VarianceList.ElementAtOrDefault(j);
                    decimal nVariance = nVarianceList.ElementAtOrDefault(j);
                    decimal nn2Cov = nn2CovList.ElementAtOrDefault(j);
                    decimal n2vCov = n2vCovList.ElementAtOrDefault(j);
                    decimal nvCov = nvCovList.ElementAtOrDefault(j);
                    decimal sma = smaList.ElementAtOrDefault(j);
                    decimal n2Sma = n2SmaList.ElementAtOrDefault(j);
                    decimal nSma = nSmaList.ElementAtOrDefault(j);
                    decimal n2 = n2List.ElementAtOrDefault(j);

                    decimal norm = (n2Variance * nVariance) - Pow(nn2Cov, 2);
                    normList.Add(norm);

                    decimal a = norm != 0 ? ((n2vCov * nVariance) - (nvCov * nn2Cov)) / norm : 0;
                    aList.Add(a);

                    decimal b = norm != 0 ? ((nvCov * n2Variance) - (n2vCov * nn2Cov)) / norm : 0;
                    bList.Add(b);

                    decimal c = sma - (a * n2Sma) - (b * nSma);
                    cList.Add(c);

                    decimal prevQlsma = qlsmaList.LastOrDefault();
                    decimal qlsma = (a * n2) + (b * j) + c;
                    qlsmaList.Add(qlsma);

                    decimal fcast = (a * Pow(j + forecast, 2)) + (b * (j + forecast)) + c;
                    fcastList.Add(fcast);

                    var signal = GetCompareSignal(currentValue - qlsma, prevValue - prevQlsma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (nList, n2List, nn2List, n2vList, nvList, nSmaList, n2SmaList, n2vSmaList, nvSmaList, nn2SmaList, nn2CovList, n2vCovList, nvCovList, nVarianceList,
                n2VarianceList, normList, aList, bList, cList, qlsmaList, fcastList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<decimal>, List<decimal>, List<Signal>)
            CalculateFastSlowDegreeOscillator(StockData stockDataClass, int days = 2)
        {
            //@version=4
            //study("Fast/Slow Degree Oscillator", "FSDO", overlay = false)
            //length = input(100),fast = input(3),slow = input(2),len = input(14, "Signal Length"),src = input(close)
            //----
            //f(x, d) => 
            //    sum = 0.,pi = atan(1) * 4
            //    for i = 1 to d
            //        b = 1 / i * sin(x * i * pi)
            //        sum := sum + b
            //    pol = x * x + iff(d == 0, 0, sum)
            //----
            //filt(x, p, d) =>
            //    sum = 0.
            //    for i = 1 to p
            //        w = f(i / p, d) - f((i - 1) / p, d)
            //        sum := sum + x[i - 1] * w
            //    sum
            //----
            //a = filt(src, length, fast)
            //b = filt(src, length, slow)
            //os = a - b
            //signal = ema(os, len)
            //hist = os - signal
            //----
            //plot(hist, "Histogram",#64b5f6,2,plot.style_histogram,transp=50)
            //plot(os, "Oscillator",#0cb51a,2,transp=0)
            //plot(signal, "Signal",#e65100,2,transp=0)
            List<decimal> fastF1bList = new();
            List<decimal> fastF1bSumList = new();
            List<decimal> fastF2bList = new();
            List<decimal> fastF2bSumList = new();
            List<decimal> fastF1xList = new();
            List<decimal> fastF2xList = new();
            List<decimal> fastF1polList = new();
            List<decimal> fastF2polList = new();
            List<decimal> fastVWList = new();
            List<decimal> fastWList = new();
            List<decimal> fastVWSumList = new();
            List<decimal> slowF1bList = new();
            List<decimal> slowF1bSumList = new();
            List<decimal> slowF2bList = new();
            List<decimal> slowF2bSumList = new();
            List<decimal> slowF1xList = new();
            List<decimal> slowF2xList = new();
            List<decimal> slowF1polList = new();
            List<decimal> slowF2polList = new();
            List<decimal> slowVWList = new();
            List<decimal> slowWList = new();
            List<decimal> slowVWSumList = new();
            List<decimal> osList = new();
            List<decimal> osSignalList = new();
            List<decimal> histList = new();
            List<Signal> signalsList = new();

            try
            {
                int length = MinOrMax(days * 50);
                int fast = (int)Math.Ceiling(days / 0.6667);
                int signalLength = MinOrMax(days * 7);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal fastF1x = (decimal)(i + 1) / length;
                    fastF1xList.Add(fastF1x);

                    decimal fastF1b = 1 / (i + 1) * (decimal)Sin((double)fastF1x * (i + 1) * Math.PI);
                    fastF1bList.Add(fastF1b);

                    decimal fastF1bSum = fastF1bList.TakeLast(fast).Sum();
                    fastF1bSumList.Add(fastF1bSum);

                    decimal fastF1pol = (fastF1x * fastF1x) + fastF1bSum;
                    fastF1polList.Add(fastF1pol);

                    decimal fastF2x = (decimal)i / length;
                    fastF2xList.Add(fastF2x);

                    decimal fastF2b = 1 / (i + 1) * (decimal)Sin((double)fastF2x * (i + 1) * Math.PI);
                    fastF2bList.Add(fastF2b);

                    decimal fastF2bSum = fastF2bList.TakeLast(fast).Sum();
                    fastF2bSumList.Add(fastF2bSum);

                    decimal fastF2pol = (fastF2x * fastF2x) + fastF2bSum;
                    fastF2polList.Add(fastF2pol);

                    decimal fastW = fastF1pol - fastF2pol;
                    fastWList.Add(fastW);

                    decimal fastVW = prevValue * fastW;
                    fastVWList.Add(fastVW);

                    decimal fastVWSum = fastVWList.TakeLast(length).Sum();
                    fastVWSumList.Add(fastVWSum);

                    decimal slowF1x = (decimal)(i + 1) / length;
                    slowF1xList.Add(slowF1x);

                    decimal slowF1b = 1 / (i + 1) * (decimal)Sin((double)slowF1x * (i + 1) * Math.PI);
                    slowF1bList.Add(slowF1b);

                    decimal slowF1bSum = slowF1bList.TakeLast(days).Sum();
                    slowF1bSumList.Add(slowF1bSum);

                    decimal slowF1pol = (slowF1x * slowF1x) + slowF1bSum;
                    slowF1polList.Add(slowF1pol);

                    decimal slowF2x = (decimal)i / length;
                    slowF2xList.Add(slowF2x);

                    decimal slowF2b = 1 / (i + 1) * (decimal)Sin((double)slowF2x * (i + 1) * Math.PI);
                    slowF2bList.Add(slowF2b);

                    decimal slowF2bSum = slowF2bList.TakeLast(days).Sum();
                    slowF2bSumList.Add(slowF2bSum);

                    decimal slowF2pol = (slowF2x * slowF2x) + slowF2bSum;
                    slowF2polList.Add(slowF2pol);

                    decimal slowW = slowF1pol - slowF2pol;
                    slowWList.Add(slowW);

                    decimal slowVW = prevValue * slowW;
                    slowVWList.Add(slowVW);

                    decimal slowVWSum = slowVWList.TakeLast(length).Sum();
                    slowVWSumList.Add(slowVWSum);

                    decimal os = fastVWSum - slowVWSum;
                    osList.Add(os);

                    decimal osSignal = CalculateExponentialMovingAverage(os, osSignalList.LastOrDefault(), signalLength);
                    osSignalList.Add(osSignal);

                    decimal prevHist = histList.LastOrDefault();
                    decimal hist = os - osSignal;
                    histList.Add(hist);

                    var signal = GetCompareSignal(hist, prevHist);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (fastF1xList, fastF1bList, fastF1bSumList, fastF1polList, fastF2xList, fastF2bList, fastF2bSumList, fastF2polList, fastWList, fastVWList, fastVWSumList,
                slowF1xList, slowF1bList, slowF1bSumList, slowF1polList, slowF2xList, slowF2bList, slowF2bSumList, slowF2polList, slowWList, slowVWList, slowVWSumList,
                osList, osSignalList, histList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateRSMKIndicator(StockData stockDataClass, StockData marketDataClass, int days = 3)
        {
            //RSMK Indicator
            //RSMK (Relative Strength) Indicator
            //Copyright Markos Katsanos 2020
            //_SECTION_BEGIN("RSMK TASC");
            //RSBARS = Param("RS BARS", 90, 10, 500, 10);
            //SK = Param("SMOOTHING CONSTANT", 3, 1, 5, 1);
            //CS = ParamStr("Comparison Symbol", "SPY");
            //SEC2 = Foreign(CS, "C");
            //RSMK
            //RSMK = EMA(log(C / (SEC2)) - log(Ref(C / (SEC2), -
            //RSBARS)), 3) * 100;
            //dynamic_color = IIf(RSmk > 0, colorGreen, colorred);
            //Plot(RSmk, "RSMK", dynamic_color, styleHistogram);
            //Plot(0, "", colorBlue);
            //_SECTION_END();
            List<decimal> rsmkList = new();
            List<decimal> logRatioList = new();
            List<decimal> logDiffList = new();
            List<decimal> logDiffEmaList = new();
            List<Signal> signalsList = new();

            try
            {
                int lookBackPeriod = MinOrMax(days * 30);

                if (stockDataClass.InputValues.Count == marketDataClass.InputValues.Count)
                {
                    for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                    {
                        decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                        decimal spValue = marketDataClass.InputValues.ElementAtOrDefault(i);
                        decimal prevLogRatio = i >= lookBackPeriod ? logRatioList.ElementAtOrDefault(i - lookBackPeriod) : 0;

                        decimal logRatio = spValue != 0 ? currentValue / spValue : 0;
                        logRatioList.Add(logRatio);

                        decimal logDiff = logRatio - prevLogRatio;
                        logDiffList.Add(logDiff);

                        decimal logDiffEma = CalculateExponentialMovingAverage(logDiff, logDiffEmaList.LastOrDefault(), days);
                        logDiffEmaList.Add(logDiffEma);

                        decimal prevRsmk = rsmkList.LastOrDefault();
                        decimal rsmk = logDiffEma * 100;
                        rsmkList.Add(rsmk);

                        var signal = GetCompareSignal(rsmk, prevRsmk);
                        signalsList.Add(signal);
                    }
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (logRatioList, logDiffList, logDiffEmaList, rsmkList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>)
            CalculateRelativeNormalizedVolatility(StockData stockDataClass, StockData marketDataClass, string maType, int days = 14)
        {
            // This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License https://creativecommons.org/licenses/by-sa/4.0/
            // © alexgrover

            //@version=4
            //study("Relative Normalized Volatility", "RNV")
            //ticker = input("TVC:SPX", "Relative Security", type = input.symbol)
            //length = input(14),src = input(close),log = input(false)
            //----
            //d = change(src)
            //sym = change(security(ticker, timeframe.period, close[1], lookahead = true))
            //zsrc = d / stdev(d, length)
            //zsym = sym / stdev(sym, length)
            //r = sma(abs(zsrc), length) / sma(abs(zsym), length)
            //----
            //hline(log ? 0 : 1)
            //plot(log ? log(r) : r, "Plot",#009688)
            List<decimal> zsrcList = new();
            List<decimal> zspList = new();
            List<decimal> absZsrcList = new();
            List<decimal> absZspList = new();
            List<decimal> absZsrcSmaList = new();
            List<decimal> absZspSmaList = new();
            List<decimal> rList = new();
            List<decimal> rLogList = new();
            List<Signal> signalsList = new();

            try
            {
                if (stockDataClass.InputValues.Count == marketDataClass.InputValues.Count)
                {
                    var emaList = CalculateExponentialMovingAverage(stockDataClass, days).Item1;
                    var stdDevList = CalculateStandardDeviationVolatility(null, stockDataClass, days).Item4;
                    var spStdDevList = CalculateStandardDeviationVolatility(null, marketDataClass, days).Item4;

                    for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                    {
                        decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                        decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                        decimal spValue = marketDataClass.InputValues.ElementAtOrDefault(i);
                        decimal prevSpValue = i >= 1 ? marketDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                        decimal stdDev = stdDevList.ElementAtOrDefault(i);
                        decimal spStdDev = spStdDevList.ElementAtOrDefault(i);
                        decimal d = currentValue - prevValue;
                        decimal sp = spValue - prevSpValue;

                        decimal zsrc = stdDev != 0 ? d / stdDev : 0;
                        zsrcList.Add(zsrc);

                        decimal zsp = spStdDev != 0 ? sp / spStdDev : 0;
                        zspList.Add(zsp);

                        decimal absZsrc = Math.Abs(zsrc);
                        absZsrcList.Add(absZsrc);

                        decimal absZsp = Math.Abs(zsp);
                        absZspList.Add(absZsp);
                    }

                    absZsrcSmaList = GetMovingAverageList(maType, absZsrcList, stockDataClass, days);
                    absZspSmaList = GetMovingAverageList(maType, absZspList, stockDataClass, days);
                    for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                    {
                        decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(j);
                        decimal currentEma = emaList.ElementAtOrDefault(j);
                        decimal absZsrcSma = absZsrcSmaList.ElementAtOrDefault(j);
                        decimal absZspSma = absZspSmaList.ElementAtOrDefault(j);
                        decimal prevValue = j >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(j - 1) : 0;
                        decimal prevEma = j >= 1 ? emaList.ElementAtOrDefault(j - 1) : 0;

                        decimal r = absZspSma != 0 ? absZsrcSma / absZspSma : 0;
                        rList.Add(r);

                        decimal rLog = r > 0 ? (decimal)Log((double)r) : 0;
                        rLogList.Add(rLog);

                        var signal = GetVolatilitySignal(currentValue - currentEma, prevValue - prevEma, r, 1);
                        signalsList.Add(signal);
                    }
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (zsrcList, zspList, absZsrcList, absZspList, absZsrcSmaList, absZspSmaList, rList, rLogList, signalsList);
        }

        public static (List<decimal>, List<Signal>) CalculateAlphaDecreasingExponentialMovingAverage(StockData stockDataClass)
        {
            //@version=4
            // Copyright (c) 2019-present, Alex Orekhov (everget)
            // Alpha-Decreasing Exponential Moving Average script may be freely distributed under the terms of the GPL-3.0 license.
            //study("Alpha-Decreasing Exponential Moving Average", shorttitle = "ADEMA", overlay = true)

            //alpha = 2 / (int(bar_index) + 1)

            //ema = close
            //ema:= alpha * ema + (1 - alpha) * nz(ema[1], ema)

            //plot(ema, title = "ADEMA", linewidth = 2, color = color.orange)
            List<decimal> emaList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal alpha = (decimal)2 / (i + 1);
                    decimal prevEma = i >= 1 ? emaList.ElementAtOrDefault(i - 1) : currentValue;

                    decimal ema = (alpha * currentValue) + ((1 - alpha) * prevEma);
                    emaList.Add(ema);

                    var signal = GetCompareSignal(currentValue - ema, prevValue - prevEma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (emaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateHoltExponentialMovingAverage(StockData stockDataClass, int days = 20)
        {
            //@version=3
            // Copyright (c) 2018-present, Alex Orekhov (everget)
            // Holt Exponential Moving Average script may be freely distributed under the MIT license.
            //study("Holt Exponential Moving Average", shorttitle = "HEMA", overlay = true)

            //alphaLength = input(title = "Alpha Length", type = integer, defval = 20, minval = 1)
            //gammaLength = input(title = "Gamma Length", type = integer, defval = 20, minval = 1)
            //highlightMovements = input(title = "Highlight Movements ?", type = bool, defval = true)
            //src = input(title = "Source", type = source, defval = close)

            //alpha = 2 / (alphaLength + 1)
            //gamma = 2 / (gammaLength + 1)

            //b = 0.0
            //hema = 0.0

            //hema:= (1 - alpha) * (nz(hema[1]) + nz(b[1], src)) + alpha * src
            //b:= (1 - gamma) * nz(b[1]) + gamma * (hema - nz(hema[1]))

            //hemaColor = highlightMovements ? (hema > hema[1] ? green : red) : #6d1e7f
            //plot(hema, title = "HEMA", linewidth = 2, color = hemaColor, transp = 0)
            List<decimal> hemaList = new();
            List<decimal> bList = new();
            List<Signal> signalsList = new();

            try
            {
                decimal alpha = (decimal)2 / (days + 1);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevB = i >= 1 ? bList.ElementAtOrDefault(i - 1) : currentValue;
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal prevHema = hemaList.LastOrDefault();
                    decimal hema = ((1 - alpha) * (prevHema + prevB)) + (alpha * currentValue);
                    hemaList.Add(hema);

                    decimal b = ((1 - alpha) * prevB) + (alpha * (hema - prevHema));
                    bList.Add(b);

                    var signal = GetCompareSignal(currentValue - hema, prevValue - prevHema);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (bList, hemaList, signalsList);
        }

        public static (List<decimal>, List<Signal>) CalculateAhrensMovingAverage(StockData stockDataClass, int days = 9)
        {
            //@version=3
            // Copyright (c) 2018-present, Alex Orekhov (everget)
            // Ahrens Moving Average script may be freely distributed under the MIT license.
            //study("Ahrens Moving Average", shorttitle = "AHMA", overlay = true)

            //length = input(title = "Length", type = integer, defval = 9)
            //highlightMovements = input(title = "Highlight Movements ?", type = bool, defval = true)
            //src = input(title = "Source", type = source, defval = close)

            //ahma = 0.0
            //ahma:= nz(ahma[1]) + (src - (nz(ahma[1]) + nz(ahma[length])) / 2) / length

            //ahmaColor = highlightMovements ? (ahma > ahma[1] ? green : red) : #6d1e7f
            //plot(ahma, title = "AHMA", linewidth = 2, color = ahmaColor, transp = 0)
            List<decimal> ahmaList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal priorAhma = i >= days ? ahmaList.ElementAtOrDefault(i - days) : currentValue;

                    decimal prevAhma = ahmaList.LastOrDefault();
                    decimal ahma = prevAhma + ((currentValue - ((prevAhma + priorAhma) / 2)) / days);
                    ahmaList.Add(ahma);

                    var signal = GetCompareSignal(currentValue - ahma, prevValue - prevAhma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (ahmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateHendersonWeightedMovingAverage(StockData stockDataClass, int days = 7)
        {
            //@version=3
            // Copyright (c) 2018-present, Alex Orekhov (everget)
            // Henderson Weighted Moving Average script may be freely distributed under the MIT license.
            //study("Henderson Weighted Moving Average", shorttitle = "HWMA", overlay = true)

            //termsNumber = input(title = "Terms Number", type = integer, minval = 1, defval = 7)
            //highlightMovements = input(title = "Highlight Movements ?", type = bool, defval = true)
            //src = input(title = "Source", type = source, defval = close)

            // The general form of the weights of the (2m + 1)-term Henderson Weighted Moving Average
            //getWeight(m, j) =>
            //numerator = 315 * (pow(m + 1, 2) - pow(j, 2)) * (pow(m + 2, 2) - pow(j, 2)) * (pow(m + 3, 2) - pow(j, 2)) * (3 * pow(m + 2, 2) - 11 * pow(j, 2) - 16)
            //denominator = 8 * (m + 2) * (pow(m + 2, 2) - 1) * (4 * pow(m + 2, 2) - 1) * (4 * pow(m + 2, 2) - 9) * (4 * pow(m + 2, 2) - 25)

            //denominator != 0
            //? numerator / denominator
            //: 0

            //_hwma(src, termsNumber) =>
            //sum = 0.0
            //weightSum = 0.0

            //termMult = floor((termsNumber - 1) / 2)

            //for i = 0 to termsNumber - 1
            //weight = getWeight(termMult, i - termMult)
            //sum := sum + nz(src[i]) * weight
            //weightSum := weightSum + weight

            //sum / weightSum

            //hwma = _hwma(src, termsNumber)
            //hwmaColor = highlightMovements ? (hwma > hwma[1] ? green : red) : #6d1e7f
            //plot(hwma, title = "HWMA", linewidth = 2, color = hwmaColor, transp = 0)
            List<decimal> sumList = new();
            List<decimal> weightedSumList = new();
            List<decimal> hwmaList = new();
            List<Signal> signalsList = new();

            try
            {
                int termMult = MinOrMax((int)Math.Floor((decimal)(days - 1) / 2));

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevVal = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal sum = 0, weightedSum = 0;
                    for (int j = 0; j <= days - 1; j++)
                    {
                        int m = termMult;
                        int n = j - termMult;
                        decimal numerator = 315 * (Pow(m + 1, 2) - Pow(n, 2)) * (Pow(m + 2, 2) - Pow(n, 2)) * (Pow(m + 3, 2) -
                            Pow(n, 2)) * ((3 * Pow(m + 2, 2)) - (11 * Pow(n, 2)) - 16);
                        decimal denominator = 8 * (m + 2) * (Pow(m + 2, 2) - 1) * ((4 * Pow(m + 2, 2)) - 1) * ((4 * Pow(m + 2, 2)) - 9) *
                            ((4 * Pow(m + 2, 2)) - 25);
                        decimal weight = denominator != 0 ? numerator / denominator : 0;
                        decimal prevValue = i >= j ? stockDataClass.InputValues.ElementAtOrDefault(i - j) : 0;

                        sum += prevValue * weight;
                        weightedSum += weight;
                    }
                    sumList.Add(sum);
                    weightedSumList.Add(weightedSum);

                    decimal prevHwma = hwmaList.LastOrDefault();
                    decimal hwma = weightedSum != 0 ? sum / weightedSum : 0;
                    hwmaList.Add(hwma);

                    var signal = GetCompareSignal(currentValue - hwma, prevVal - prevHwma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (sumList, weightedSumList, hwmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateSpencer21PointMovingAverage(StockData stockDataClass)
        {
            //@version=3
            // Copyright (c) 2018-present, Alex Orekhov (everget)
            // Spencer 21-Point Moving Average script may be freely distributed under the MIT license.
            //study("Spencer 21-Point Moving Average", shorttitle = "SpMA 21", overlay = true)

            //highlightMovements = input(title = "Highlight Movements ?", type = bool, defval = true)
            //src = input(title = "Source", type = source, defval = close)

            //getWeight(i) =>
            //    weight = 0.0

            //    if i == 0
            //        weight:= -1
            //    if i == 1
            //        weight:= -3
            //    if i == 2
            //        weight:= -5
            //    if i == 3
            //        weight:= -5
            //    if i == 4
            //        weight:= -2
            //    if i == 5
            //        weight:= 6
            //    if i == 6
            //        weight:= 18
            //    if i == 7
            //        weight:= 33
            //    if i == 8
            //        weight:= 47
            //    if i == 9
            //        weight:= 57
            //    if i == 10
            //        weight:= 60
            //    if i == 11
            //        weight:= 57
            //    if i == 12
            //        weight:= 47
            //    if i == 13
            //        weight:= 33
            //    if i == 14
            //        weight:= 18
            //    if i == 15
            //        weight:= 6
            //    if i == 16
            //        weight:= -2
            //    if i == 17
            //        weight:= -5
            //    if i == 18
            //        weight:= -5
            //    if i == 19
            //        weight:= -3
            //    if i == 20
            //        weight:= -1

            //    weight

            //_spma21(src) =>
            //    sum = 0.0
            //    weightSum = 0.0

            //    for i = 0 to 20
            //        weight = getWeight(i)
            //        sum := sum + nz(src[i]) * weight
            //        weightSum := weightSum + weight

            //    sum / weightSum

            //spma21 = _spma21(src)

            //spma21Color = highlightMovements ? (spma21 > spma21[1] ? green : red) : #6d1e7f
            //plot(spma21, title = "SpMA 21", linewidth = 2, color = spma21Color, transp = 0)
            List<decimal> sumList = new();
            List<decimal> weightedSumList = new();
            List<decimal> spmaList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevVal = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal sum = 0, weightedSum = 0;
                    for (int j = 0; j <= 20; j++)
                    {
                        var weight = j switch
                        {
                            0 => -1,
                            1 => -3,
                            2 => -5,
                            3 => -5,
                            4 => -2,
                            5 => 6,
                            6 => 18,
                            7 => 33,
                            8 => 47,
                            9 => 57,
                            10 => 60,
                            11 => 57,
                            12 => 47,
                            13 => 33,
                            14 => 18,
                            15 => 6,
                            16 => -2,
                            17 => -5,
                            18 => -5,
                            19 => -3,
                            20 => -1,
                            _ => 0,
                        };
                        decimal prevValue = i >= j ? stockDataClass.InputValues.ElementAtOrDefault(i - j) : 0;

                        sum += prevValue * weight;
                        weightedSum += weight;
                    }
                    sumList.Add(sum);
                    weightedSumList.Add(weightedSum);

                    decimal prevSpma = spmaList.LastOrDefault();
                    decimal spma = weightedSum != 0 ? sum / weightedSum : 0;
                    spmaList.Add(spma);

                    var signal = GetCompareSignal(currentValue - spma, prevVal - prevSpma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (sumList, weightedSumList, spmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateSpencer15PointMovingAverage(StockData stockDataClass)
        {
            //@version=3
            // Copyright (c) 2018-present, Alex Orekhov (everget)
            // Spencer 15-Point Moving Average script may be freely distributed under the MIT license.
            //study("Spencer 15-Point Moving Average", shorttitle = "SpMA 15", overlay = true)

            //highlightMovements = input(title = "Highlight Movements ?", type = bool, defval = true)
            //src = input(title = "Source", type = source, defval = close)

            //getWeight(i) =>
            //    weight = 0.0

            //    if i == 0
            //        weight:= -3
            //    if i == 1
            //        weight:= -6
            //    if i == 2
            //        weight:= -5
            //    if i == 3
            //        weight:= 3
            //    if i == 4
            //        weight:= 21
            //    if i == 5
            //        weight:= 46
            //    if i == 6
            //        weight:= 67
            //    if i == 7
            //        weight:= 74
            //    if i == 8
            //        weight:= 67
            //    if i == 9
            //        weight:= 46
            //    if i == 10
            //        weight:= 21
            //    if i == 11
            //        weight:= 3
            //    if i == 12
            //        weight:= -5
            //    if i == 13
            //        weight:= -6
            //    if i == 14
            //        weight:= -3

            //    weight

            //_spma15(src) =>
            //    sum = 0.0
            //    weightSum = 0.0

            //    for i = 0 to 14
            //        weight = getWeight(i)
            //        sum := sum + nz(src[i]) * weight
            //        weightSum := weightSum + weight

            //    sum / weightSum

            //spma15 = _spma15(src)

            //spma15Color = highlightMovements ? (spma15 > spma15[1] ? green : red) : #6d1e7f
            //plot(spma15, title = "SpMA 15", linewidth = 2, color = spma15Color, transp = 0)
            List<decimal> sumList = new();
            List<decimal> weightedSumList = new();
            List<decimal> spmaList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevVal = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal sum = 0, weightedSum = 0;
                    for (int j = 0; j <= 14; j++)
                    {
                        var weight = j switch
                        {
                            0 => -3,
                            1 => -6,
                            2 => -5,
                            3 => 3,
                            4 => 21,
                            5 => 46,
                            6 => 67,
                            7 => 74,
                            8 => 67,
                            9 => 46,
                            10 => 21,
                            11 => 3,
                            12 => -5,
                            13 => -6,
                            14 => -3,
                            _ => 0,
                        };
                        decimal prevValue = i >= j ? stockDataClass.InputValues.ElementAtOrDefault(i - j) : 0;

                        sum += prevValue * weight;
                        weightedSum += weight;
                    }
                    sumList.Add(sum);
                    weightedSumList.Add(weightedSum);

                    decimal prevSpma = spmaList.LastOrDefault();
                    decimal spma = weightedSum != 0 ? sum / weightedSum : 0;
                    spmaList.Add(spma);

                    var signal = GetCompareSignal(currentValue - spma, prevVal - prevSpma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (sumList, weightedSumList, spmaList, signalsList);
        }

        public static (List<decimal>, List<Signal>) CalculateMcNichollMovingAverage(StockData stockDataClass, string maType, int days = 20)
        {
            //@version=3
            // Copyright (c) 1998-present, Dennis McNicholl
            // Copyright (c) 2019-present, Alex Orekhov (everget)
            // McNicholl Moving Average script may be freely distributed under the MIT license.
            //study("McNicholl Moving Average", shorttitle = "MNMA", overlay = true)

            //length = input(title = "Length", type = integer, defval = 20)
            //highlightMovements = input(title = "Highlight Movements ?", type = bool, defval = true)
            //src = input(title = "Source", type = source, defval = close)

            //alpha = 2 / (length + 1)

            //ema1 = ema(src, length)
            //ema2 = ema(ema1, length)

            //mnma = ((2 - alpha) * ema1 - ema2) / (1 - alpha)

            //mnmaColor = highlightMovements ? (mnma > mnma[1] ? green : red) : #6d1e7f
            //plot(mnma, title = "MNMA", linewidth = 2, color = mnmaColor, transp = 0)
            List<decimal> mnmaList = new();
            List<Signal> signalsList = new();

            try
            {
                decimal alpha = (decimal)2 / (days + 1);

                List<decimal> ema1List = GetMovingAverageList(maType, null, stockDataClass, days);
                List<decimal> ema2List = GetMovingAverageList(maType, ema1List, stockDataClass, days);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal ema1 = ema1List.ElementAtOrDefault(i);
                    decimal ema2 = ema2List.ElementAtOrDefault(i);

                    decimal prevMnma = mnmaList.LastOrDefault();
                    decimal mnma = 1 - alpha != 0 ? (((2 - alpha) * ema1) - ema2) / (1 - alpha) : 0;
                    mnmaList.Add(mnma);

                    var signal = GetCompareSignal(currentValue - mnma, prevValue - prevMnma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (mnmaList, signalsList);
        }

        public static (List<decimal>, List<Signal>) CalculateSimpleMovingAverage(StockData stockDataClass, int days = 14)
        {
            // starting date is the day that we are calculating the value for so look in the past
            // SMA = ( Sum of close ) / n
            List<decimal> smaList = new();
            List<decimal> tempList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal prevValue = tempList.LastOrDefault();
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    tempList.Add(currentValue);

                    decimal prevSma = smaList.LastOrDefault();
                    decimal sma = tempList.TakeLast(days).Average();
                    smaList.Add(sma);

                    var signal = GetCompareSignal(currentValue - sma, prevValue - prevSma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (smaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateParabolicWeightedMovingAverage(StockData stockDataClass, int days = 14)
        {
            //@version=3
            // Copyright (c) 2019-present, Alex Orekhov (everget)
            // Parabolic Weighted Moving Average script may be freely distributed under the MIT license.
            //study("Parabolic Weighted Moving Average", shorttitle = "PWMA", overlay = true)

            //length = input(title = "Length", type = integer, defval = 14)
            //power = input(title = "Power", type = integer, minval = 0, defval = 2)
            //highlightMovements = input(title = "Highlight Movements ?", type = bool, defval = true)
            //src = input(title = "Source", type = source, defval = close)

            //sum = 0.0
            //weightSum = 0.0

            //for i = 0 to length - 1
            //    weight = pow(length - i, power)
            //    sum := sum + nz(src[i]) * weight
            //    weightSum := weightSum + weight

            //pwma = sum / weightSum

            //pwmaColor = highlightMovements ? (pwma > pwma[1] ? green : red) : #6d1e7f
            //plot(pwma, title = "PWMA", linewidth = 2, color = pwmaColor, transp = 0)
            List<decimal> sumList = new();
            List<decimal> weightedSumList = new();
            List<decimal> pwmaList = new();
            List<Signal> signalsList = new();
            int power = 2;

            try
            {
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevVal = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal sum = 0, weightedSum = 0;
                    for (int j = 0; j <= days - 1; j++)
                    {
                        decimal weight = Pow(days - j, power);
                        decimal prevValue = i >= j ? stockDataClass.InputValues.ElementAtOrDefault(i - j) : 0;

                        sum += prevValue * weight;
                        weightedSum += weight;
                    }
                    sumList.Add(sum);
                    weightedSumList.Add(weightedSum);

                    decimal prevPwma = pwmaList.LastOrDefault();
                    decimal pwma = weightedSum != 0 ? sum / weightedSum : 0;
                    pwmaList.Add(pwma);

                    var signal = GetCompareSignal(currentValue - pwma, prevVal - prevPwma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (sumList, weightedSumList, pwmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateSquareRootWeightedMovingAverage(StockData stockDataClass, int days = 14)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Square Root Weighted Moving Average script may be freely distributed under the MIT license.
            //study("Square Root Weighted Moving Average", shorttitle = "SRWMA", overlay = true)

            //length = input(title = "Length", type = input.integer, defval = 14)
            //src = input(title = "Source", type = input.source, defval = close)

            //sum = 0.0, weightSum = 0.0
            //for i = 0 to length - 1
            //    weight = pow(length - i, 0.5)
            //    sum := sum + (src[i] * weight)
            //    weightSum := weightSum + weight
            //srwma = sum / weightSum

            //srwmaColor = src > srwma ? color.green : src < srwma ? color.red : color.black
            //plot(srwma, title = "SRWMA", linewidth = 2, color = srwmaColor)
            List<decimal> sumList = new();
            List<decimal> weightedSumList = new();
            List<decimal> srwmaList = new();
            List<Signal> signalsList = new();
            var power = 0.5;

            try
            {
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevVal = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal sum = 0, weightedSum = 0;
                    for (int j = 0; j <= days - 1; j++)
                    {
                        decimal weight = Pow(days - j, power);
                        decimal prevValue = i >= j ? stockDataClass.InputValues.ElementAtOrDefault(i - j) : 0;

                        sum += prevValue * weight;
                        weightedSum += weight;
                    }
                    sumList.Add(sum);
                    weightedSumList.Add(weightedSum);

                    decimal prevSrwma = srwmaList.LastOrDefault();
                    decimal srwma = weightedSum != 0 ? sum / weightedSum : 0;
                    srwmaList.Add(srwma);

                    var signal = GetCompareSignal(currentValue - srwma, prevVal - prevSrwma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (sumList, weightedSumList, srwmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateOptimalWeightedMovingAverage(StockData stockDataClass, int days = 14)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Optimal Weighted Moving Average script may be freely distributed under the MIT license.
            //study("Optimal Weighted Moving Average", shorttitle = "OWMA", overlay = true)

            //length = input(title = "Length", type = input.integer, defval = 14)
            //src = input(title = "Source", type = input.source, defval = close)

            //sum = 0.0, weightSum = 0.0, owma = 0.0
            //for i = 0 to length - 1
            //    corr = correlation(src, owma, length)
            //    weight = pow(length - i, corr)
            //    sum := sum + (src[i] * weight)
            //    weightSum := weightSum + weight
            //owma := sum / weightSum

            //owmaColor = src > owma ? color.green : src < owma ? color.red : color.black
            //plot(owma, title = "OWMA", linewidth = 2, color = owmaColor)
            List<decimal> tempList = new();
            List<decimal> corrList = new();
            List<decimal> sumList = new();
            List<decimal> weightedSumList = new();
            List<decimal> owmaList = new();
            List<decimal> prevOwmaList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal prevVal = tempList.LastOrDefault();
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    tempList.Add(currentValue);

                    decimal prevOwma = i >= 1 ? owmaList.ElementAtOrDefault(i - 1) : 0;
                    prevOwmaList.Add(prevOwma);

                    var corr = GoodnessOfFit.R(tempList.TakeLast(days).Select(x => (double)x), prevOwmaList.TakeLast(days).Select(x => (double)x));
                    corr = IsValueNullOrInfinity((double)corr) ? 0 : corr;
                    corrList.Add((decimal)corr);

                    decimal sum = 0, weightedSum = 0;
                    for (int j = 0; j <= days - 1; j++)
                    {
                        decimal weight = Pow(days - j, corr);
                        decimal prevValue = i >= j ? stockDataClass.InputValues.ElementAtOrDefault(i - j) : 0;

                        sum += prevValue * weight;
                        weightedSum += weight;
                    }
                    sumList.Add(sum);
                    weightedSumList.Add(weightedSum);

                    decimal owma = weightedSum != 0 ? sum / weightedSum : 0;
                    owmaList.Add(owma);

                    var signal = GetCompareSignal(currentValue - owma, prevVal - prevOwma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (corrList, sumList, weightedSumList, owmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateCubedWeightedMovingAverage(StockData stockDataClass, int days = 14)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Cubed Weighted Moving Average script may be freely distributed under the MIT license.
            //study("Cubed Weighted Moving Average", shorttitle = "CWMA", overlay = true)

            //length = input(title = "Length", type = input.integer, defval = 14)
            //src = input(title = "Source", type = input.source, defval = close)

            //sum = 0.0, weightSum = 0.0
            //for i = 0 to length - 1
            //    weight = pow(length - i, 3)
            //    sum := sum + (src[i] * weight)
            //    weightSum := weightSum + weight
            //cwma = sum / weightSum

            //cwmaColor = src > cwma ? color.green : src < cwma ? color.red : color.black
            //plot(cwma, title = "CWMA", linewidth = 2, color = cwmaColor)
            List<decimal> sumList = new();
            List<decimal> weightedSumList = new();
            List<decimal> cwmaList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevVal = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal sum = 0, weightedSum = 0;
                    for (int j = 0; j <= days - 1; j++)
                    {
                        decimal weight = Pow(days - j, 3);
                        decimal prevValue = i >= j ? stockDataClass.InputValues.ElementAtOrDefault(i - j) : 0;

                        sum += prevValue * weight;
                        weightedSum += weight;
                    }
                    sumList.Add(sum);
                    weightedSumList.Add(weightedSum);

                    decimal prevCwma = cwmaList.LastOrDefault();
                    decimal cwma = weightedSum != 0 ? sum / weightedSum : 0;
                    cwmaList.Add(cwma);

                    var signal = GetCompareSignal(currentValue - cwma, prevVal - prevCwma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (sumList, weightedSumList, cwmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>)
            CalculateVolatilityWaveMovingAverage(StockData stockDataClass, string maType, int days = 20)
        {
            // This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
            // © RedKTrader

            //@version=4
            //study("V_Wave", overlay = true)

            //main PWMA function
            //pwma(x, length, p) =>
            //numerator = 0.0, denom = 0.0
            //for i = 0 to length - 1
            //weight = pow((length - i), p)
            //numerator := numerator + x[i] * weight
            //denom := denom + weight
            //numerator / denom
            //inputs
            //data = input(close, "Source")
            //length = input(20, "length")
            //kf = input(2.5, "Accelerator", step = 0.25, minval = 1.0, maxval = 7.0)

            //Calculations
            //s = int(sqrt(length)), sdpct = stdev(data, length) / data * 100, p = max(1, sqrt(sdpct) * kf)

            //PMA = pwma(data, length, p)
            //Extra Smoothing of the PWMA
            //wmap = wma(PMA, s), zlmap = 2 * wmap - wma(wmap, s)
            //plot(zlmap, title = "V_Wave", color = color.yellow, linewidth = 3)
            List<decimal> zlmapList = new();
            List<decimal> wmap1List = new();
            List<decimal> wmap2List = new();
            List<decimal> sumList = new();
            List<decimal> weightedSumList = new();
            List<decimal> pmaList = new();
            List<decimal> sdpctList = new();
            List<decimal> pList = new();
            List<Signal> signalsList = new();
            decimal kf = 2.5m;

            try
            {
                int s = MinOrMax((int)Math.Ceiling(Sqrt((double)days)));

                var stdDevList = CalculateStandardDeviationVolatility(null, stockDataClass, days).Item4;

                for (int h = 0; h < stockDataClass.InputValues.Count; h++)
                {
                    decimal stdDev = stdDevList.ElementAtOrDefault(h);
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(h);

                    decimal sdPct = currentValue != 0 ? stdDev / currentValue * 100 : 0;
                    sdpctList.Add(sdPct);

                    decimal p = sdPct >= 0 ? MinOrMax((decimal)Sqrt((double)sdPct) * kf, 4, 1) : 1;
                    pList.Add(p);
                }

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal p = pList.ElementAtOrDefault(i);

                    decimal sum = 0, weightedSum = 0;
                    for (int j = 0; j <= days - 1; j++)
                    {
                        decimal weight = Pow(days - j, (double)p);
                        decimal prevValue = i >= j ? stockDataClass.InputValues.ElementAtOrDefault(i - j) : 0;

                        sum += prevValue * weight;
                        weightedSum += weight;
                    }
                    sumList.Add(sum);
                    weightedSumList.Add(weightedSum);

                    decimal pma = weightedSum != 0 ? sum / weightedSum : 0;
                    pmaList.Add(pma);
                }

                wmap1List = GetMovingAverageList(maType, pmaList, stockDataClass, s);
                wmap2List = GetMovingAverageList(maType, wmap1List, stockDataClass, s);
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(j);
                    decimal prevValue = j >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(j - 1) : 0;
                    decimal wmap1 = wmap1List.ElementAtOrDefault(j);
                    decimal wmap2 = wmap2List.ElementAtOrDefault(j);

                    decimal prevZlmap = zlmapList.LastOrDefault();
                    decimal zlmap = (2 * wmap1) - wmap2;
                    zlmapList.Add(zlmap);

                    var signal = GetCompareSignal(currentValue - zlmap, prevValue - prevZlmap);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (sdpctList, pList, sumList, weightedSumList, pmaList, wmap1List, wmap2List, zlmapList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateDistanceWeightedMovingAverage(StockData stockDataClass, int days = 14)
        {
            //@version=3
            // Copyright (c) 2019-present, Alex Orekhov (everget)
            // Distance Weighted Moving Average script may be freely distributed under the MIT license.
            //study("Distance Weighted Moving Average", shorttitle = "DWMA", overlay = true)

            //length = input(title = "Length", type = integer, defval = 14)
            //highlightMovements = input(title = "Highlight Movements ?", type = bool, defval = true)
            //src = input(title = "Source", type = source, defval = close)

            //sum = 0.0
            //weightSum = 0.0

            //calcWeight(src, length, i) =>
            //    distanceSum = 0.0
            //    for j = 0 to length - 1
            //        distanceSum := distanceSum + abs(nz(src[i]) - nz(src[j]))
            //    1 / distanceSum

            //for i = 0 to length - 1
            //    weight = calcWeight(src, length, i)
            //    sum := sum + nz(src[i]) * weight
            //    weightSum := weightSum + weight
            //dwma = sum / weightSum

            //dwmaColor = highlightMovements ? (dwma > dwma[1] ? green : red) : #6d1e7f
            //plot(dwma, title = "DWMA", linewidth = 2, color = dwmaColor, transp = 0)
            List<decimal> sumList = new();
            List<decimal> weightedSumList = new();
            List<decimal> dwmaList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevVal = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal sum = 0, weightedSum = 0;
                    for (int j = 0; j <= days - 1; j++)
                    {
                        decimal prevValue = i >= j ? stockDataClass.InputValues.ElementAtOrDefault(i - j) : 0;

                        decimal distanceSum = 0;
                        for (int k = 0; k <= days - 1; k++)
                        {
                            decimal prevValue2 = i >= k ? stockDataClass.InputValues.ElementAtOrDefault(i - k) : 0;

                            distanceSum += Math.Abs(prevValue - prevValue2);
                        }

                        decimal weight = distanceSum != 0 ? 1 / distanceSum : 0;

                        sum += prevValue * weight;
                        weightedSum += weight;
                    }
                    sumList.Add(sum);
                    weightedSumList.Add(weightedSum);

                    decimal prevDwma = dwmaList.LastOrDefault();
                    decimal dwma = weightedSum != 0 ? sum / weightedSum : 0;
                    dwmaList.Add(dwma);

                    var signal = GetCompareSignal(currentValue - dwma, prevVal - prevDwma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (sumList, weightedSumList, dwmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateInverseDistanceWeightedMovingAverage(StockData stockDataClass, int days = 14)
        {
            //@version=3
            // Copyright (c) 2019-present, Alex Orekhov (everget)
            // Inverse Distance Weighted Moving Average script may be freely distributed under the MIT license.
            //study("Inverse Distance Weighted Moving Average", shorttitle = "IDWMA", overlay = true)

            //length = input(title = "Length", type = integer, defval = 14)
            //highlightMovements = input(title = "Highlight Movements ?", type = bool, defval = true)
            //src = input(title = "Source", type = source, defval = close)

            //sum = 0.0
            //weightSum = 0.0

            //calcWeight(src, length, i) =>
            //    distanceSum = 0.0
            //    for j = 0 to length - 1
            //        distanceSum := distanceSum + abs(nz(src[i]) - nz(src[j]))
            //    distanceSum

            //for i = 0 to length - 1
            //    weight = calcWeight(src, length, i)
            //    sum := sum + nz(src[i]) * weight
            //    weightSum := weightSum + weight
            //idwma = sum / weightSum

            //idwmaColor = highlightMovements ? (idwma > idwma[1] ? green : red) : #6d1e7f
            //plot(idwma, title = "IDWMA", linewidth = 2, color = idwmaColor, transp = 0)
            List<decimal> sumList = new();
            List<decimal> weightedSumList = new();
            List<decimal> idwmaList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevVal = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal sum = 0, weightedSum = 0;
                    for (int j = 0; j <= days - 1; j++)
                    {
                        decimal prevValue = i >= j ? stockDataClass.InputValues.ElementAtOrDefault(i - j) : 0;

                        decimal distanceSum = 0;
                        for (int k = 0; k <= days - 1; k++)
                        {
                            decimal prevValue2 = i >= k ? stockDataClass.InputValues.ElementAtOrDefault(i - k) : 0;

                            distanceSum += Math.Abs(prevValue - prevValue2);
                        }
                        decimal weight = distanceSum;

                        sum += prevValue * weight;
                        weightedSum += weight;
                    }
                    sumList.Add(sum);
                    weightedSumList.Add(weightedSum);

                    decimal prevIdwma = idwmaList.LastOrDefault();
                    decimal idwma = weightedSum != 0 ? sum / weightedSum : 0;
                    idwmaList.Add(idwma);

                    var signal = GetCompareSignal(currentValue - idwma, prevVal - prevIdwma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (sumList, weightedSumList, idwmaList, signalsList);
        }

        public static (List<decimal>, List<Signal>) CalculateMiddleHighLowMovingAverage(StockData stockDataClass, string maType, int days = 10)
        {
            //@version=3
            // Copyright (c) 2018-present, Alex Orekhov (everget)
            // Middle-High-Low Moving Average script may be freely distributed under the MIT license.
            //study("Middle-High-Low Moving Average", shorttitle = "MHLMA", overlay = true)

            //length = input(title = "Length", type = integer, minval = 1, defval = 14)
            //mhlRange = input(title = "High-Low Range", type = integer, defval = 10)
            //maType = input(title = "MA Type", defval = "EMA", options =["EMA", "SMA"])
            //highlightMovements = input(title = "Highlight Movements ?", type = bool, defval = true)

            //mhl = avg(highest(mhlRange), lowest(mhlRange))
            //mhlma = maType == "EMA" ? ema(mhl, length) : sma(mhl, length)

            //mhlmaColor = highlightMovements ? (mhlma > mhlma[1] ? green : red) : #6d1e7f
            //plot(mhlma, title = "MHLMA", linewidth = 2, color = mhlmaColor, transp = 0)
            List<decimal> mhlMaList = new();
            List<Signal> signalsList = new();

            try
            {
                int length = (int)Math.Ceiling(days / 0.7143);
                int mhlRange = days;

                List<decimal> mhlList = CalculateMidpoint(stockDataClass, mhlRange).Item2;
                mhlMaList = GetMovingAverageList(maType, mhlList, stockDataClass, length);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal currentMhlMa = mhlMaList.ElementAtOrDefault(i);
                    decimal prevMhlma = i >= 1 ? mhlMaList.ElementAtOrDefault(i - 1) : 0;

                    var signal = GetCompareSignal(currentValue - currentMhlMa, prevValue - prevMhlma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (mhlMaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateFareySequenceWeightedMovingAverage(StockData stockDataClass, int days = 5)
        {
            //@version=4
            // Copyright (c) 2019-present, Alex Orekhov (everget)
            // Farey Sequence Weighted Moving Average script may be freely distributed under the terms of the GPL-3.0 license.
            //study("Farey Sequence Weighted Moving Average", shorttitle = "FSWMA", overlay = true)

            //order = input(title = "Order", defval = "5",
            //options =["2","3","4","5","6","7","8","9","10","11","12","13","14"])
            //src = input(title = "Source", type = input.source, defval = close)
            //highlightMovements = input(title = "Highlight Movements ?", type = input.bool, defval = true)

            // Generated by script, not manually
            //fswma =
            //order == "2" ? (src + 0.5 * src1) / 1.5 :
            //order == "3" ? (src + 0.667 * src1 + 0.5 * src2 + 0.333 * src3) / 2.5 :
            //order == "4" ? (src + 0.75 * src1 + 0.667 * src2 + 0.5 * src3 + 0.333 * src4 + 0.25 * src5) / 3.5 :
            //order == "5" ? (src + 0.8 * src1 + 0.75 * src2 + 0.667 * src3 + 0.6 * src4 + 0.5 * src5 + 0.4 * src6 + 0.333 * src7 + 0.25 * src8 + 0.2 * src9) / 5.5 :
            //order == "6" ? (src + 0.833 * src1 + 0.8 * src2 + 0.75 * src3 + 0.667 * src4 + 0.6 * src5 + 0.5 * src6 + 0.4 * src7 + 0.333 * src8 + 0.25 * src9 + 0.2 * src10 + 0.167 * src11) / 6.5 :
            //order == "7" ? (src + 0.857 * src1 + 0.833 * src2 + 0.8 * src3 + 0.75 * src4 + 0.714 * src5 + 0.667 * src6 + 0.6 * src7 + 0.571 * src8 + 0.5 * src9 + 0.429 * src10 + 0.4 * src11 + 0.333 * src12 + 0.286 * src13 + 0.25 * src14 + 0.2 * src15 + 0.167 * src16 + 0.143 * src17) / 9.5 :
            //order == "8" ? (src + 0.875 * src1 + 0.857 * src2 + 0.833 * src3 + 0.8 * src4 + 0.75 * src5 + 0.714 * src6 + 0.667 * src7 + 0.625 * src8 + 0.6 * src9 + 0.571 * src10 + 0.5 * src11 + 0.429 * src12 + 0.4 * src13 + 0.375 * src14 + 0.333 * src15 + 0.286 * src16 + 0.25 * src17 + 0.2 * src18 + 0.167 * src19 + 0.143 * src20 + 0.125 * src21) / 11.5 :
            //order == "9" ? (src + 0.889 * src1 + 0.875 * src2 + 0.857 * src3 + 0.833 * src4 + 0.8 * src5 + 0.778 * src6 + 0.75 * src7 + 0.714 * src8 + 0.667 * src9 + 0.625 * src10 + 0.6 * src11 + 0.571 * src12 + 0.556 * src13 + 0.5 * src14 + 0.444 * src15 + 0.429 * src16 + 0.4 * src17 + 0.375 * src18 + 0.333 * src19 + 0.286 * src20 + 0.25 * src21 + 0.222 * src22 + 0.2 * src23 + 0.167 * src24 + 0.143 * src25 + 0.125 * src26 + 0.111 * src27) / 14.5 :
            //order == "10" ? (src + 0.9 * src1 + 0.889 * src2 + 0.875 * src3 + 0.857 * src4 + 0.833 * src5 + 0.8 * src6 + 0.778 * src7 + 0.75 * src8 + 0.714 * src9 + 0.7 * src10 + 0.667 * src11 + 0.625 * src12 + 0.6 * src13 + 0.571 * src14 + 0.556 * src15 + 0.5 * src16 + 0.444 * src17 + 0.429 * src18 + 0.4 * src19 + 0.375 * src20 + 0.333 * src21 + 0.3 * src22 + 0.286 * src23 + 0.25 * src24 + 0.222 * src25 + 0.2 * src26 + 0.167 * src27 + 0.143 * src28 + 0.125 * src29 + 0.111 * src30 + 0.1 * src31) / 16.5 :
            //order == "11" ? (src + 0.909 * src1 + 0.9 * src2 + 0.889 * src3 + 0.875 * src4 + 0.857 * src5 + 0.833 * src6 + 0.818 * src7 + 0.8 * src8 + 0.778 * src9 + 0.75 * src10 + 0.727 * src11 + 0.714 * src12 + 0.7 * src13 + 0.667 * src14 + 0.636 * src15 + 0.625 * src16 + 0.6 * src17 + 0.571 * src18 + 0.556 * src19 + 0.545 * src20 + 0.5 * src21 + 0.455 * src22 + 0.444 * src23 + 0.429 * src24 + 0.4 * src25 + 0.375 * src26 + 0.364 * src27 + 0.333 * src28 + 0.3 * src29 + 0.286 * src30 + 0.273 * src31 + 0.25 * src32 + 0.222 * src33 + 0.2 * src34 + 0.182 * src35 + 0.167 * src36 + 0.143 * src37 + 0.125 * src38 + 0.111 * src39 + 0.1 * src40 + 0.091 * src41) / 21.5 :
            //order == "12" ? (src + 0.917 * src1 + 0.909 * src2 + 0.9 * src3 + 0.889 * src4 + 0.875 * src5 + 0.857 * src6 + 0.833 * src7 + 0.818 * src8 + 0.8 * src9 + 0.778 * src10 + 0.75 * src11 + 0.727 * src12 + 0.714 * src13 + 0.7 * src14 + 0.667 * src15 + 0.636 * src16 + 0.625 * src17 + 0.6 * src18 + 0.583 * src19 + 0.571 * src20 + 0.556 * src21 + 0.545 * src22 + 0.5 * src23 + 0.455 * src24 + 0.444 * src25 + 0.429 * src26 + 0.417 * src27 + 0.4 * src28 + 0.375 * src29 + 0.364 * src30 + 0.333 * src31 + 0.3 * src32 + 0.286 * src33 + 0.273 * src34 + 0.25 * src35 + 0.222 * src36 + 0.2 * src37 + 0.182 * src38 + 0.167 * src39 + 0.143 * src40 + 0.125 * src41 + 0.111 * src42 + 0.1 * src43 + 0.091 * src44 + 0.083 * src45) / 23.5 :
            //order == "13" ? (src + 0.923 * src1 + 0.917 * src2 + 0.909 * src3 + 0.9 * src4 + 0.889 * src5 + 0.875 * src6 + 0.857 * src7 + 0.846 * src8 + 0.833 * src9 + 0.818 * src10 + 0.8 * src11 + 0.778 * src12 + 0.769 * src13 + 0.75 * src14 + 0.727 * src15 + 0.714 * src16 + 0.7 * src17 + 0.692 * src18 + 0.667 * src19 + 0.636 * src20 + 0.625 * src21 + 0.615 * src22 + 0.6 * src23 + 0.583 * src24 + 0.571 * src25 + 0.556 * src26 + 0.545 * src27 + 0.538 * src28 + 0.5 * src29 + 0.462 * src30 + 0.455 * src31 + 0.444 * src32 + 0.429 * src33 + 0.417 * src34 + 0.4 * src35 + 0.385 * src36 + 0.375 * src37 + 0.364 * src38 + 0.333 * src39 + 0.308 * src40 + 0.3 * src41 + 0.286 * src42 + 0.273 * src43 + 0.25 * src44 + 0.231 * src45 + 0.222 * src46 + 0.2 * src47 + 0.182 * src48 + 0.167 * src49 + 0.154 * src50 + 0.143 * src51 + 0.125 * src52 + 0.111 * src53 + 0.1 * src54 + 0.091 * src55 + 0.083 * src56 + 0.077 * src57) / 29.5 :
            //order == "14" ? (src + 0.929 * src1 + 0.923 * src2 + 0.917 * src3 + 0.909 * src4 + 0.9 * src5 + 0.889 * src6 + 0.875 * src7 + 0.857 * src8 + 0.846 * src9 + 0.833 * src10 + 0.818 * src11 + 0.8 * src12 + 0.786 * src13 + 0.778 * src14 + 0.769 * src15 + 0.75 * src16 + 0.727 * src17 + 0.714 * src18 + 0.7 * src19 + 0.692 * src20 + 0.667 * src21 + 0.643 * src22 + 0.636 * src23 + 0.625 * src24 + 0.615 * src25 + 0.6 * src26 + 0.583 * src27 + 0.571 * src28 + 0.556 * src29 + 0.545 * src30 + 0.538 * src31 + 0.5 * src32 + 0.462 * src33 + 0.455 * src34 + 0.444 * src35 + 0.429 * src36 + 0.417 * src37 + 0.4 * src38 + 0.385 * src39 + 0.375 * src40 + 0.364 * src41 + 0.357 * src42 + 0.333 * src43 + 0.308 * src44 + 0.3 * src45 + 0.286 * src46 + 0.273 * src47 + 0.25 * src48 + 0.231 * src49 + 0.222 * src50 + 0.214 * src51 + 0.2 * src52 + 0.182 * src53 + 0.167 * src54 + 0.154 * src55 + 0.143 * src56 + 0.125 * src57 + 0.111 * src58 + 0.1 * src59 + 0.091 * src60 + 0.083 * src61 + 0.077 * src62 + 0.071 * src63) / 32.5 :
            //na

            /*
                    function farey(order)
                    {
                        let[a, b, c, d] = [0, 1, 1, order];
                        const res = [a / b];
                        while (c <= order)
                        {
                            let k = Math.floor((order + b) / d);

                            [a, b, c, d] = [c, d, k * c - a, k * d - b];
		                    res.push(+(a / b).toFixed(3));
	                    }
	                    return res;
                    }
            */

            //fswmaColor = highlightMovements ? (fswma > fswma[1] ? color.green : color.red) : #6d1e7f
            //plot(fswma, title = "FSWMA", linewidth = 2, color = fswmaColor, transp = 0)
            List<decimal> fswmaList = new();
            List<decimal> fswmaSumList = new();
            List<decimal> fswmaWeightedSumList = new();
            List<Signal> signalsList = new();

            try
            {
                decimal[] array = new decimal[4] { 0, 1, 1, days };
                List<decimal> resList = new();

                while (array[2] <= days)
                {
                    decimal a = array[0];
                    decimal b = array[1];
                    decimal c = array[2];
                    decimal d = array[3];
                    decimal k = Math.Floor((days + b) / array[3]);

                    array[0] = c;
                    array[1] = d;
                    array[2] = (k * c) - a;
                    array[3] = (k * d) - b;

                    decimal res = array[1] != 0 ? Math.Round(array[0] / array[1], 3) : 0;
                    resList.Insert(0, res);
                }

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevVal = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal sum = 0, weightedSum = 0;
                    for (int k = 0; k < resList.Count; k++)
                    {
                        decimal prevValue = i >= k ? stockDataClass.InputValues.ElementAtOrDefault(i - k) : 0;
                        decimal weight = resList.ElementAtOrDefault(k);

                        sum += prevValue * weight;
                        weightedSum += weight;
                    }
                    fswmaSumList.Add(sum);
                    fswmaWeightedSumList.Add(weightedSum);

                    decimal prevFswma = fswmaList.LastOrDefault();
                    decimal fswma = weightedSum != 0 ? sum / weightedSum : 0;
                    fswmaList.Add(fswma);

                    var signal = GetCompareSignal(currentValue - fswma, prevVal - prevFswma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (fswmaSumList, fswmaWeightedSumList, fswmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateWeightedMovingAverage(StockData stockDataClass, int days = 14)
        {
            //@version=3
            // Copyright (c) 2019-present, Alex Orekhov (everget)
            // Parabolic Weighted Moving Average script may be freely distributed under the MIT license.
            //study("Parabolic Weighted Moving Average", shorttitle = "PWMA", overlay = true)

            //length = input(title = "Length", type = integer, defval = 14)
            //power = input(title = "Power", type = integer, minval = 0, defval = 2)
            //highlightMovements = input(title = "Highlight Movements ?", type = bool, defval = true)
            //src = input(title = "Source", type = source, defval = close)

            //sum = 0.0
            //weightSum = 0.0

            //for i = 0 to length - 1
            //    weight = pow(length - i, power)
            //    sum := sum + nz(src[i]) * weight
            //    weightSum := weightSum + weight

            //pwma = sum / weightSum

            //pwmaColor = highlightMovements ? (pwma > pwma[1] ? green : red) : #6d1e7f
            //plot(pwma, title = "PWMA", linewidth = 2, color = pwmaColor, transp = 0)
            List<decimal> sumList = new();
            List<decimal> weightedSumList = new();
            List<decimal> weightedMovingAverageList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevVal = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal sum = 0, weightedSum = 0;
                    for (int j = 0; j < days; j++)
                    {
                        decimal weight = days - j;
                        decimal prevValue = i >= j ? stockDataClass.InputValues.ElementAtOrDefault(i - j) : 0;

                        sum += prevValue * weight;
                        weightedSum += weight;
                    }
                    sumList.Add(sum);
                    weightedSumList.Add(weightedSum);

                    decimal prevWma = weightedMovingAverageList.LastOrDefault();
                    decimal wma = weightedSum != 0 ? sum / weightedSum : 0;
                    weightedMovingAverageList.Add(wma);

                    var signal = GetCompareSignal(currentValue - wma, prevVal - prevWma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (sumList, weightedSumList, weightedMovingAverageList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateEndPointMovingAverage(StockData stockDataClass, int days = 4)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // End Point Moving Average script may be freely distributed under the MIT license.
            //study("End Point Moving Average", shorttitle = "EPMA", overlay = true)

            //length = input(title = "Length", type = input.integer, defval = 11)
            //offset = input(title = "Offset", type = input.integer, defval = 4)
            //src = input(title = "Source", type = input.source, defval = close)

            //sum = 0.0, weightSum = 0.0
            //for i = 0 to length - 1
            //    weight = length - i - offset
            //    sum := sum + (src[i] * weight)
            //    weightSum := weightSum + weight
            //epma = 1 / weightSum * sum

            //epmaColor = src > epma ? color.green : src < epma ? color.red : color.black
            //plot(epma, title = "EPMA", linewidth = 2, color = epmaColor)
            List<decimal> sumList = new();
            List<decimal> weightedSumList = new();
            List<decimal> epmaList = new();
            List<Signal> signalsList = new();

            try
            {
                int length = (int)Math.Ceiling(days / 0.3637);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevVal = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal sum = 0, weightedSum = 0;
                    for (int j = 0; j <= days - 1; j++)
                    {
                        decimal weight = length - j - days;
                        decimal prevValue = i >= j ? stockDataClass.InputValues.ElementAtOrDefault(i - j) : 0;

                        sum += prevValue * weight;
                        weightedSum += weight;
                    }
                    sumList.Add(sum);
                    weightedSumList.Add(weightedSum);

                    decimal prevEpma = epmaList.LastOrDefault();
                    decimal epma = weightedSum != 0 ? 1 / weightedSum * sum : 0;
                    epmaList.Add(epma);

                    var signal = GetCompareSignal(currentValue - epma, prevVal - prevEpma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (sumList, weightedSumList, epmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateShapeshiftingMovingAverage(StockData stockDataClass, int days = 50)
        {
            // This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
            // © alexgrover

            //@version=4
            //study("Shapeshifting Moving Average", overlay = true)
            //length = input(50),src = input(close),pow = input(4., 'power'),smooth = input(false)
            //----
            //sum = 0.,sumw = 0.
            //alpha = smooth ? 2 : 1
            //power = smooth ? pow - pow % 2 : pow
            //----
            //for i = 0 to length - 1
            //    x = i / (length - 1)
            //    n = smooth ? -1 + x * 2 : x
            //    w = 1 - 2 * pow(n, alpha) / (pow(n, power) + 1)
            //    sumw := sumw + w
            //    sum := sum + src[i] * w
            //filt = sum / sumw
            //----
            //plot(filt, "Plot",#ff1100,2,transp=0)
            List<decimal> sumXList = new();
            List<decimal> weightedSumXList = new();
            List<decimal> sumNList = new();
            List<decimal> weightedSumNList = new();
            List<decimal> filtXList = new();
            List<decimal> filtNList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevVal = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal sumX = 0, weightedSumX = 0, sumN = 0, weightedSumN = 0;
                    for (int j = 0; j <= days - 1; j++)
                    {
                        decimal x = (decimal)j / (days - 1);
                        decimal n = -1 + (x * 2);
                        decimal wx = 1 - (2 * x / (Pow(x, 4) + 1));
                        decimal wn = 1 - (2 * Pow(n, 2) / (Pow(n, 4 - (4 % 2)) + 1));
                        decimal prevValue = i >= j ? stockDataClass.InputValues.ElementAtOrDefault(i - j) : 0;

                        sumX += prevValue * wx;
                        weightedSumX += wx;
                        sumN += prevValue * wn;
                        weightedSumN += wn;
                    }
                    sumXList.Add(sumX);
                    weightedSumXList.Add(weightedSumX);
                    sumNList.Add(sumN);
                    weightedSumNList.Add(weightedSumN);

                    decimal prevFiltX = filtXList.LastOrDefault();
                    decimal filtX = weightedSumX != 0 ? sumX / weightedSumX : 0;
                    filtXList.Add(filtX);

                    decimal filtN = weightedSumN != 0 ? sumN / weightedSumN : 0;
                    filtNList.Add(filtN);

                    var signal = GetCompareSignal(currentValue - filtX, prevVal - prevFiltX);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (sumXList, weightedSumXList, sumNList, weightedSumNList, filtXList, filtNList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateCorrectedMovingAverage(StockData stockDataClass, string maType, int days = 35)
        {
            //@version=4
            // Copyright (c) 2020-present, Alex Orekhov (everget)
            // Corrected Moving Average script may be freely distributed under the terms of the GPL-3.0 license.
            //study("Corrected Moving Average", shorttitle = "CMA", overlay = true)

            //length = input(title = "Length", type = input.integer, defval = 35)
            //src = input(title = "Source", type = input.source, defval = close)
            //highlight = input(title = "Highlight CMA ?", type = input.bool, defval = false)
            //applyFilling = input(title = "Apply Ribbon Filling ?", type = input.bool, defval = true)

            //sma = sma(src, length)
            //cma = sma

            //v1 = variance(src, length)
            //v2 = pow(nz(cma[1], cma) - sma, 2)
            //v3 = v1 == 0 or v2 == 0 ? 1 : v2 / (v1 + v2)

            //var tolerance = pow(10, -5)
            //float err = 1

            // Gain Factor
            //float kPrev = 1
            //float k = 1

            //for i = 0 to 5000
            //    if err > tolerance
            //        k:= v3 * kPrev * (2 - kPrev)
            //       err:= kPrev - k
            //        kPrev:= k

            //cma:= nz(cma[1], src) + k * (sma - nz(cma[1], src))

            //cmaColor = highlight ? (cma > cma[1] ? color.green : color.red) : color.orange
            //cmaPlot = plot(cma, title = "CMA", linewidth = 2, color = cmaColor)
            //smaPlot = plot(sma, title = "SMA", linewidth = 2, color = color.blue)

            //fillColor = applyFilling ? (sma > cma ? #0ebb23 : #cc0000) : color.new(color.white, 100) 
            //fill(smaPlot, cmaPlot, color = fillColor, transp = 80)

            //long = crossover(sma, cma)
            //short = crossunder(sma, cma)

            //alertcondition(long, title = "Long", message = "Long")
            //alertcondition(short, title = "Short", message = "Short")
            List<decimal> cmaList = new();
            List<decimal> v2List = new();
            List<decimal> v3List = new();
            List<decimal> kList = new();
            List<Signal> signalsList = new();

            try
            {
                var smaList = GetMovingAverageList(maType, null, stockDataClass, days);
                var v1List = CalculateStandardDeviationVolatility(null, stockDataClass, days).Item3;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal sma = smaList.ElementAtOrDefault(i);
                    decimal prevCma = i >= 1 ? cmaList.ElementAtOrDefault(i - 1) : sma;
                    decimal v1 = v1List.ElementAtOrDefault(i);

                    decimal v2 = Pow(prevCma - sma, 2);
                    v2List.Add(v2);

                    decimal v3 = v1 == 0 || v2 == 0 ? 1 : v2 / (v1 + v2);
                    v3List.Add(v3);

                    decimal tolerance = Pow(10, -5), err = 1, kPrev = 1, k = 1;
                    for (int j = 0; j <= 5000; j++)
                    {
                        if (err > tolerance)
                        {
                            k = v3 * kPrev * (2 - kPrev);
                            err = kPrev - k;
                            kPrev = k;
                        }
                    }
                    kList.Add(k);

                    decimal cma = prevCma + (k * (sma - prevCma));
                    cmaList.Add(cma);

                    var signal = GetCompareSignal(currentValue - cma, prevValue - prevCma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (v2List, v3List, kList, cmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateArnaudLegouxMovingAverage(StockData stockDataClass, int days = 6)
        {
            // parameters
            // Window = 9
            // Sigma = 6
            // Offset = 0.85

            //Price = Close

            //m = (Offset * (Window - 1))
            //s = Window / Sigma

            //WtdSum = 0
            //CumWt = 0

            //for k = 0 to Window - 1 do
            // Wtd = Exp(-((k - m) * (k - m)) / (2 * s * s))
            // WtdSum = WtdSum + Wtd * Price[Window - 1 - k]
            // CumWt = CumWt + Wtd
            //next

            //ALAverage = WtdSum / CumWt

            //RETURN ALAverage
            List<decimal> sumList = new();
            List<decimal> weightedSumList = new();
            List<decimal> almaList = new();
            List<Signal> signalsList = new();
            decimal offset = 0.85m;

            try
            {
                int sigma = days;
                int window = (int)Math.Ceiling(sigma / 0.6667);

                decimal m = (offset * (window - 1));
                decimal s = (decimal)window / sigma;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevVal = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal sum = 0, weightedSum = 0;
                    for (int j = 0; j <= days - 1; j++)
                    {
                        decimal weight = s != 0 ? Exp(-((j - m) * (j - m)) / (2 * s * s)) : 0;
                        decimal prevValue = i >= window - 1 - j ? stockDataClass.InputValues.ElementAtOrDefault(window - 1 - j) : 0;

                        sum += prevValue * weight;
                        weightedSum += weight;
                    }
                    sumList.Add(sum);
                    weightedSumList.Add(weightedSum);

                    decimal prevAlma = almaList.LastOrDefault();
                    decimal alma = weightedSum != 0 ? sum / weightedSum : 0;
                    almaList.Add(alma);

                    var signal = GetCompareSignal(currentValue - alma, prevVal - prevAlma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (sumList, weightedSumList, almaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateLinearWeightedMovingAverage(StockData stockDataClass, int days = 14)
        {
            // LWMA
            //    lwma(src, length) =>
            //    weightSum = 0.0
            //    sum = 0.0
            //    for i = 0 to length - 1
            //        weight = length - i
            //        weightSum := weightSum + weight
            //        sum := sum + nz(src[i]) * weight
            //    sum / weightSum
            List<decimal> sumList = new();
            List<decimal> weightedSumList = new();
            List<decimal> weightedMovingAverageList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevVal = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal sum = 0, weightedSum = 0;
                    for (int j = 0; j <= days - 1; j++)
                    {
                        decimal weight = days - j;
                        decimal prevValue = i >= j ? stockDataClass.InputValues.ElementAtOrDefault(i - j) : 0;

                        sum += prevValue * weight;
                        weightedSum += weight;
                    }
                    sumList.Add(sum);
                    weightedSumList.Add(weightedSum);

                    decimal prevWma = weightedMovingAverageList.LastOrDefault();
                    decimal wma = weightedSum != 0 ? sum / weightedSum : 0;
                    weightedMovingAverageList.Add(wma);

                    var signal = GetCompareSignal(currentValue - wma, prevVal - prevWma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (sumList, weightedSumList, weightedMovingAverageList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateSelfWeightedMovingAverage(StockData stockDataClass, int days = 14)
        {
            //@version=3
            // Copyright (c) 2019-present, Alex Orekhov (everget)
            // Self-Weighted Moving Average script may be freely distributed under the MIT license.
            //study("Self-Weighted Moving Average", shorttitle = "SEWMA", overlay = true)

            //length = input(title = "Length", type = integer, minval = 1, defval = 14)
            //highlightMovements = input(title = "Highlight Movements ?", type = bool, defval = false)
            //src = input(title = "Source", type = source, defval = close)

            //sum = 0.0
            //weightSum = 0.0

            //for i = 0 to length - 1
            //    weight = src[length + i]
            //    weightSum := weightSum + weight
            //    sum := sum + weight * src[i]

            //sewma = sum / weightSum

            //sewmaColor = highlightMovements ? (sewma > sewma[1] ? green : red) : #6d1e7f
            //plot(sewma, title = "SEWMA", linewidth = 2, color = sewmaColor, transp = 0)
            List<decimal> sumList = new();
            List<decimal> weightedSumList = new();
            List<decimal> wmaList = new();
            List<decimal> weightList = new();
            List<decimal> weightVList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal priorValue = i >= days + 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - (days + 1)) : 0;

                    decimal weight = priorValue;
                    weightList.Add(weight);

                    decimal weightValue = weight < 0 && prevValue < 0 ? weight * Math.Abs(prevValue) : weight * prevValue;
                    weightVList.Add(weightValue);

                    decimal sum = weightVList.TakeLast(days).Sum();
                    sumList.Add(sum);

                    decimal weightedSum = weightList.TakeLast(days).Sum();
                    weightedSumList.Add(weightedSum);

                    decimal prevWma = wmaList.LastOrDefault();
                    decimal wma = weightedSum != 0 ? sum / Math.Max(weightedSum, 1) : 0;
                    wmaList.Add(wma);

                    var signal = GetCompareSignal(currentValue - wma, prevValue - prevWma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (sumList, weightedSumList, wmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateQuickMovingAverage(StockData stockDataClass, int days = 14)
        {
            //@version=3
            // Copyright (c) 2008-present, John McCormick
            // Copyright (c) 2019-present, Alex Orekhov (everget)
            //study("Quick Moving Average", shorttitle = "QMA", overlay = true)

            //length = input(title = "Length", type = integer, minval = 1, defval = 14)
            //src = input(title = "Source", type = source, defval = close)
            //highlightMovements = input(title = "Highlight Movements ?", type = bool, defval = false)

            //peak = length / 3
            //num = 0.0
            //denom = 0.0

            //for i = 1 to length + 1
            //    mult = 0.0

            //    if i <= peak
            //        mult:= i / peak
            //    else
            //        mult:= (length + 1 - i) / (length + 1 - peak)

            //    num:= num + src[i - 1] * mult
            //    denom:= denom + mult

            //qma = denom != 0.0 ? num / denom : src

            //qmaColor = highlightMovements ? (qma > qma[1] ? green : red) : #6d1e7f
            //plot(qma, title = "QMA", linewidth = 2, color = qmaColor, transp = 0)
            List<decimal> numList = new();
            List<decimal> denomList = new();
            List<decimal> qmaList = new();
            List<Signal> signalsList = new();

            try
            {
                int peak = MinOrMax((int)Math.Ceiling((decimal)days / 3));

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevVal = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal num = 0, denom = 0;
                    for (int j = 1; j <= days + 1; j++)
                    {
                        decimal mult = j <= peak ? (decimal)j / peak : (decimal)(days + 1 - j) / (days + 1 - peak);
                        decimal prevValue = i >= j - 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - (j - 1)) : 0;

                        num += prevValue * mult;
                        denom += mult;
                    }
                    numList.Add(num);
                    denomList.Add(denom);

                    decimal prevQma = qmaList.LastOrDefault();
                    decimal qma = denom != 0 ? num / denom : 0;
                    qmaList.Add(qma);

                    var signal = GetCompareSignal(currentValue - qma, prevVal - prevQma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (numList, denomList, qmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateSineWeightedMovingAverage(StockData stockDataClass, int days = 14)
        {
            //@version=3
            // Copyright (c) 2018-present, Alex Orekhov (everget)
            // Sine Weighted Moving Average script may be freely distributed under the MIT license.
            //study("Sine Weighted Moving Average", shorttitle = "SWMA", overlay = true)

            //length = input(title = "Length", type = integer, defval = 14)
            //highlightMovements = input(title = "Highlight Movements ?", type = bool, defval = true)
            //src = input(title = "Source", type = source, defval = close)

            //PI = 2 * asin(1)
            //sum = 0.0
            //weightSum = 0.0

            //for i = 0 to length - 1
            //    weight = sin((i + 1) * PI / (length + 1))
            //    sum := sum + nz(src[i]) * weight
            //    weightSum := weightSum + weight

            //swma = sum / weightSum

            //swmaColor = highlightMovements ? (swma > swma[1] ? green : red) : #6d1e7f
            //plot(swma, title = "SWMA", linewidth = 2, color = swmaColor, transp = 0)
            List<decimal> sumList = new();
            List<decimal> weightedSumList = new();
            List<decimal> swmaList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevVal = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal sum = 0, weightedSum = 0;
                    for (int j = 0; j <= days - 1; j++)
                    {
                        decimal weight = (decimal)Sin((double)(j + 1) * Math.PI / (days + 1));
                        decimal prevValue = i >= j ? stockDataClass.InputValues.ElementAtOrDefault(i - j) : 0;

                        sum += prevValue * weight;
                        weightedSum += weight;
                    }
                    sumList.Add(sum);
                    weightedSumList.Add(weightedSum);

                    decimal prevSwma = swmaList.LastOrDefault();
                    decimal swma = weightedSum != 0 ? sum / weightedSum : 0;
                    swmaList.Add(swma);

                    var signal = GetCompareSignal(currentValue - swma, prevVal - prevSwma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (sumList, weightedSumList, swmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateFibonacciWeightedMovingAverage(StockData stockDataClass, int days = 14)
        {
            //@version=3
            // Copyright (c) 2018-present, Alex Orekhov (everget)
            // Fibonacci Weighted Moving Average script may be freely distributed under the MIT license.
            //study("Fibonacci Weighted Moving Average", shorttitle = "FWMA", overlay = true)

            //length = input(title = "Length", type = integer, defval = 14)
            //src = input(title = "Source", type = source, defval = close)

            //phi = (1 + sqrt(5)) / 2

            //fiboWeight(i) =>
            //    pow = pow(phi, i)
            //    (pow - pow(-1, i) / pow) / sqrt(5)

            //fwma(src, length) =>
            //    sum = 0.0
            //    weightSum = 0.0

            //    for i = 0 to length - 1
            //        weight = fiboWeight(length - i)
            //        sum := sum + nz(src[i]) * weight
            //        weightSum := weightSum + weight

            //    sum / weightSum

            //plot(fwma(src, length), title = "FWMA", linewidth = 2, color =#741b47, transp=0)
            List<decimal> sumList = new();
            List<decimal> weightedSumList = new();
            List<decimal> fibonacciWmaList = new();
            List<Signal> signalsList = new();

            try
            {
                decimal phi = (1 + (decimal)Sqrt((double)5)) / 2;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevVal = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal sum = 0, weightedSum = 0;
                    for (int j = 0; j <= days - 1; j++)
                    {
                        decimal pow = Pow(phi, days - j);
                        decimal weight = (pow - (Pow(-1, j) / pow)) / (decimal)Sqrt((double)5);
                        decimal prevValue = i >= j ? stockDataClass.InputValues.ElementAtOrDefault(i - j) : 0;

                        sum += prevValue * weight;
                        weightedSum += weight;
                    }
                    sumList.Add(sum);
                    weightedSumList.Add(weightedSum);

                    decimal prevFwma = fibonacciWmaList.LastOrDefault();
                    decimal fwma = weightedSum != 0 ? sum / weightedSum : 0;
                    fibonacciWmaList.Add(fwma);

                    var signal = GetCompareSignal(currentValue - fwma, prevVal - prevFwma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (sumList, weightedSumList, fibonacciWmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateHighLowMovingAverage(StockData stockDataClass, string maType, int days = 14)
        {
            //method = moving average (ma), user defined, default is WMA
            //highPeriod = user defined, default is 14
            //highMAPeriod = user defined, default is 14
            //highShift = user defined, default is 0
            //lowPeriod = user defined, default is 14
            //lowMAPeriod = user defined, default is 14
            //lowShift = user defined, default is 0
            //index = current bar number

            //high_line = ma( Highest(highPeriod), highMAPeriod ) 
            //low_line = ma( Lowest(lowPeriod), lowMAPeriod )
            //highest = highest(index, highPeriod, HIGH);
            //Plot1: TOP = calcMAAt(index, method, HIGHEST, highMAPeriod, highShift);
            //lowest = lowest(index, lowPeriod, LOW);
            //Plot2: BOTTOM = calcMAAt(index, method, LOWEST, lowMAPeriod, lowShift);
            // Calculate the midpoint
            //Plot3: MIDDLE = (top + bottom) / 2;
            List<decimal> upperBandList = new();
            List<decimal> lowerBandList = new();
            List<decimal> middleBandList = new();
            List<Signal> signalsList = new();

            try
            {
                var minMaxList = VolumeInputCheck(stockDataClass, days, true);
                var highestList = minMaxList.Item1;
                var lowestList = minMaxList.Item2;
                upperBandList = GetMovingAverageList(maType, highestList, stockDataClass, days);
                lowerBandList = GetMovingAverageList(maType, lowestList, stockDataClass, days);

                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(j);
                    decimal prevValue = j >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(j - 1) : 0;
                    decimal upperBand = upperBandList.ElementAtOrDefault(j);
                    decimal lowerBand = lowerBandList.ElementAtOrDefault(j);

                    decimal prevMiddleBand = middleBandList.LastOrDefault();
                    decimal middleBand = (upperBand + lowerBand) / 2;
                    middleBandList.Add(middleBand);

                    var signal = GetCompareSignal(currentValue - middleBand, prevValue - prevMiddleBand);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (upperBandList, lowerBandList, middleBandList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateHullMovingAverage(StockData stockDataClass, string maType, int days = 20)
        {
            //@version=3
            // Copyright (c) 2018-present, Alex Orekhov (everget)
            // Multiple Hull Moving Average script may be freely distributed under the MIT license.
            //study("Multiple Hull Moving Average", shorttitle = "HMA", overlay = true)

            //len1 = input(title = "1st Length", type = integer, defval = 20)
            //src1 = input(title = "1st Source", type = source, defval = close)
            //hma1 = wma(2 * wma(src1, len1 / 2) - wma(src1, len1), round(sqrt(len1)))
            //plot(hma1, title = "1", linewidth = 2, color =#85200c, transp=0)

            //len2 = input(title = "2nd Length", type = integer, defval = 50)
            //src2 = input(title = "2nd Source", type = source, defval = close)
            //hma2 = wma(2 * wma(src2, len2 / 2) - wma(src2, len2), round(sqrt(len2)))
            //plot(hma2, title = "2", linewidth = 2, color =#1155cc, transp=0)

            //len3 = input(title = "3rd Length", type = integer, defval = 100)
            //src3 = input(title = "3rd Source", type = source, defval = close)
            //hma3 = wma(2 * wma(src3, len3 / 2) - wma(src3, len3), round(sqrt(len3)))
            //plot(hma3, title = "3", linewidth = 2, color =#f1c232, transp=0)
            List<decimal> totalWeightedMAList = new();
            List<decimal> hullMAList = new();
            List<Signal> signalsList = new();

            try
            {
                int firstPeriod = days;
                int secondPeriod = days * 2;
                int sqrtPeriod = MinOrMax((int)Math.Ceiling(Sqrt((double)secondPeriod)));

                var weightedSMAList = GetMovingAverageList(maType, null, stockDataClass, secondPeriod);
                var firstWeightedMAList = GetMovingAverageList(maType, null, stockDataClass, firstPeriod);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal currentWMA1 = weightedSMAList.ElementAtOrDefault(i);
                    decimal currentWMA2 = firstWeightedMAList.ElementAtOrDefault(i);

                    decimal totalWeightedMA = (2 * currentWMA2) - currentWMA1;
                    totalWeightedMAList.Add(totalWeightedMA);
                }

                hullMAList = GetMovingAverageList(maType, totalWeightedMAList, stockDataClass, sqrtPeriod);
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(j);
                    decimal prevValue = j >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(j - 1) : 0;
                    decimal hullMa = hullMAList.ElementAtOrDefault(j);
                    decimal prevHullMa = j >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(j - 1) : 0;

                    var signal = GetCompareSignal(currentValue - hullMa, prevValue - prevHullMa);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (totalWeightedMAList, hullMAList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateChuckBangerMovingAverage(StockData stockDataClass, string maType, int days = 14)
        {
            // This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
            // © ChuckBanger

            // I was experimenting with the zero lag moving average from John Ehlers and the Hull moving average and noticed that they seemed to respond in 
            // complementary to each other. They blend together to make a moving average which responds with almost no lag at all. 

            //@version=4
            //study("CB Moving Average [ChuckBanger]", shorttitle = "CBMA CB", overlay = true)
            //src = input(title = "Source", type = input.source, defval = close)
            //length = input(title = "Length", type = input.integer, defval = 14)
            //emaLen = input(title = "EMA Length", type = input.integer, defval = 17)
            //emaGL = input(title = "EMA Gain Limit", type = input.integer, defval = 50)
            //highlight = input(title = "Highlight On/Off", type = input.bool, defval = true)
            //drawHMA = input(title = "HMA On/Off", type = input.bool, defval = false)
            //hmaLen = input(title = "HMA Length", type = input.integer, defval = 50)
            //drawZelma = input(title = "ZELMA On/Off", type = input.bool, defval = false)
            //zelmaLen = input(title = "ZELMA Length", type = input.integer, defval = 34)

            //calc_zlema(src, length) =>
            //    lag = floor((length - 1) / 2)
            //    zlema = ema(src + (src - src[lag]), length)
            //    zlema

            //calc_hma(src, length) =>
            //    hullma = wma(2 * wma(src, length / 2) - wma(src, length), round(sqrt(length)))
            //    hullma

            //calc_cbma(price, length, emaLength, emaGainLimit) =>
            //    alpha = 2 / (emaLength + 1)
            //    ema = ema(price, emaLength)
            //    int leastError = 1000000

            //float ec = 0
            //float bestGain = 0

            //for i = emaGainLimit to emaGainLimit
            //    gain = i / 10
            //    ec := alpha * (ema + gain * (price - nz(ec[1]))) + (1 - alpha) * nz(ec[1])
            //    error = price - ec
            //    if (abs(error) < leastError)
            //    leastError = abs(error)
            //    bestGain = gain

            //ec:= alpha * (ema + bestGain * (price - nz(ec[1]))) + (1 - alpha) * nz(ec[1])
            //hull = calc_hma(price, length)

            //cbma = (ec + hull) / 2
            //cbma

            //cbma = calc_cbma(src, length, emaLen, emaGL) // calc_dma(src, 7, 20, 50)
            //cbmaColor = fixnan(highlight ? cbma > high ? color.purple : cbma < low ? color.aqua : na : color.lime)
            //plot(cbma, color = cbmaColor)

            //zlema = calc_zlema(src, zelmaLen)
            //zelmaColor = fixnan(highlight ? zlema > high ? color.red : zlema < low ? color.olive : na : color.red)
            //plot(drawZelma ? zlema : na, color = zelmaColor)

            //hma = calc_hma(src, hmaLen)
            //hmaColor = fixnan(highlight ? hma > high ? color.orange : hma < low ? color.teal : na : color.orange)
            //plot(drawHMA ? hma : na, color = hmaColor)
            List<decimal> cbmaList = new();
            List<decimal> ecList = new();
            List<decimal> errorList = new();
            List<decimal> bestGainList = new();
            List<Signal> signalsList = new();

            try
            {
                int emaLength = (int)Math.Ceiling(days / 0.8236);
                int emaGainLimit = (int)Math.Ceiling(days / 0.28);
                int zlemaLength = emaLength * 2;
                decimal alpha = (decimal)2 / (emaLength + 1);

                var hullMaList = CalculateHullMovingAverage(stockDataClass, "WeightedMovingAverage", days).Item2;
                var zlemaList = CalculateEhlersZeroLagExponentialMovingAverage(stockDataClass, zlemaLength).Item2;
                var emaList = GetMovingAverageList(maType, null, stockDataClass, emaLength);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal hullMa = hullMaList.ElementAtOrDefault(i);
                    decimal zlema = zlemaList.ElementAtOrDefault(i);
                    decimal ema = emaList.ElementAtOrDefault(i);
                    decimal prevEc = ecList.LastOrDefault();

                    decimal leastError = 1000000, ec = 0, bestGain = 0, error = 0;
                    for (int j = 0; j <= emaGainLimit; j++)
                    {
                        decimal gain = (decimal)j / 10;
                        ec = (alpha * (ema + (gain * (currentValue - prevEc)))) + ((1 - alpha) * prevEc);
                        error = currentValue - ec;
                        if (Math.Abs(error) < leastError)
                        {
                            leastError = Math.Abs(error);
                            bestGain = gain;
                        }
                    }
                    errorList.Add(error);
                    bestGainList.Add(bestGain);

                    ec = (alpha * (ema + (bestGain * (currentValue - prevEc)))) + ((1 - alpha) * prevEc);
                    ecList.Add(ec);

                    decimal prevCbma = cbmaList.LastOrDefault();
                    decimal cbma = (ec + hullMa) / 2;
                    cbmaList.Add(cbma);

                    var signal = GetCompareSignal(currentValue - cbma, prevValue - prevCbma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (errorList, bestGainList, ecList, cbmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateIchimokuCloud(StockData stockDataClass, int days = 9)
        {
            //period1 = user defined, default is 9
            //period2 = user defined, default is 26
            //period3 = user defined, default is 52

            //highest = highest(index, period1, HIGH);
            //lowest = lowest(index, period1, LOW);
            //TS = (highest + lowest) / 2);
            //Kijun-Sen
            //highest = highest(index, period2, HIGH);
            //lowest = lowest(index, period2, LOW);
            //KS = (highest + lowest) / 2;
            // Chikou Span
            //CS = getClose(index + period2)); //shift backward by period2
            //Senkou Span B
            //highest = highest(index, period3, HIGH);
            //lowest = lowest(index, period3, LOW);
            //SSB[index + period2] = (highest + lowest) / 2); //shift Forward by period2
            //Senkou Span A
            //SSA[index + period2] = (TS + KS) / 2; //shift forward by period2
            //Signals
            //buy = crossedAbove(TS, KS);
            //sell = crossedBelow(TS, KS);
            List<decimal> tenkanSenList = new();
            List<decimal> kijunSenList = new();
            List<decimal> senkouSpanAList = new();
            List<decimal> senkouSpanBList = new();
            List<Signal> signalsList = new();

            try
            {
                int period1 = days;
                int period2 = (int)Math.Ceiling(period1 / 0.346);
                int period3 = period2 * 2;

                var minMaxList1 = GetMaxAndMinValuesList(stockDataClass.HighPrices, stockDataClass.LowPrices, period1);
                var minMaxList2 = GetMaxAndMinValuesList(stockDataClass.HighPrices, stockDataClass.LowPrices, period2);
                var minMaxList3 = GetMaxAndMinValuesList(stockDataClass.HighPrices, stockDataClass.LowPrices, period3);

                for (int i = 0; i < stockDataClass.HighPrices.Count; i++)
                {
                    decimal currentHigh = stockDataClass.HighPrices.ElementAtOrDefault(i);
                    decimal currentLow = stockDataClass.LowPrices.ElementAtOrDefault(i);
                    decimal highest1 = minMaxList1.Item1.ElementAtOrDefault(i);
                    decimal lowest1 = minMaxList1.Item2.ElementAtOrDefault(i);
                    decimal highest2 = minMaxList2.Item1.ElementAtOrDefault(i);
                    decimal lowest2 = minMaxList2.Item2.ElementAtOrDefault(i);
                    decimal highest3 = minMaxList3.Item1.ElementAtOrDefault(i);
                    decimal lowest3 = minMaxList3.Item2.ElementAtOrDefault(i);

                    decimal prevTenkanSen = tenkanSenList.LastOrDefault();
                    decimal tenkanSen = (highest1 + lowest1) / 2;
                    tenkanSenList.Add(tenkanSen);

                    decimal prevKijunSen = kijunSenList.LastOrDefault();
                    decimal kijunSen = (highest2 + lowest2) / 2;
                    kijunSenList.Add(kijunSen);

                    decimal senkouSpanA = (tenkanSen + kijunSen) / 2;
                    senkouSpanAList.Add(senkouSpanA);

                    decimal senkouSpanB = (highest3 + lowest3) / 2;
                    senkouSpanBList.Add(senkouSpanB);

                    var signal = GetCompareSignal(tenkanSen - kijunSen, prevTenkanSen - prevKijunSen);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (tenkanSenList, kijunSenList, senkouSpanAList, senkouSpanBList, signalsList);
        }

        public static (List<decimal>, List<Signal>) CalculateVixTradingSystem(StockData stockDataClass, string maType, int days = 50)
        {
            //input = price, default is closing
            //method = moving average, default is SMA
            //period = ma period, default is 50
            //maxCount = default is 11 
            //index = current bar number

            //minCount = maxCount * -1;
            //Plot: vixts = ma(method, index, period, price);
            //prevCount = count[index - 1];

            //if (price moreThan vixts AND prevCount moreOrEqual 0) count = prevCount + 1;
            //if (price lessOrEqual vixts AND prevCount lessOrEqual 0) count = prevCount - 1;
            //Check for signal events
            //sell = count == maxCount;
            //buy = count == minCount;
            List<decimal> countList = new();
            List<Signal> signalsList = new();

            try
            {
                decimal maxCount = 11;
                decimal minCount = maxCount * -1;

                var smaList = GetMovingAverageList(maType, null, stockDataClass, days);

                for (int i = 0; i < smaList.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal vixts = smaList.ElementAtOrDefault(i);

                    decimal prevCount = countList.LastOrDefault();
                    decimal count = currentValue > vixts && prevCount >= 0 ? prevCount + 1 : currentValue <= vixts && prevCount <= 0 ? prevCount - 1 : prevCount;
                    countList.Add(count);

                    var signal = GetBullishBearishSignal(count - maxCount - 1, prevCount - maxCount - 1, count - minCount + 1, prevCount - minCount + 1, true);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (countList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculatePriceZoneOscillator(StockData stockDataClass, string maType, int days = 20)
        {
            //
            // @author LazyBear
            //
            // If you use this code in its original/modified form, do drop me a note. 
            //
            //study("Price Zone Oscillator [LazyBear]", shorttitle = "VZO_LB")
            //length = input(20, title = "MA Length")

            //dvol = sign(close - close[1]) * close
            //dvma = ema(dvol, length)
            //vma = ema(close, length)
            //pzo = iff(vma != 0, 100 * dvma / vma, 0)

            //hline(60, color = red)
            //hline(40, color = gray)
            //hline(20, color = gray)
            //hline(0, color = gray)
            //hline(-20, color = gray)
            //hline(-40, color = gray)
            //hline(-60, color = green)

            //plot(vzo, color = maroon, linewidth = 2)
            List<decimal> pzoList = new();
            List<decimal> dvolList = new();
            List<decimal> dvmaList = new();
            List<Signal> signalsList = new();

            try
            {
                var emaList = GetMovingAverageList(maType, null, stockDataClass, days);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal dvol = Math.Sign(currentValue - prevValue) * currentValue;
                    dvolList.Add(dvol);
                }

                dvmaList = GetMovingAverageList(maType, dvolList, stockDataClass, days);
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal vma = emaList.ElementAtOrDefault(j);
                    decimal dvma = dvmaList.ElementAtOrDefault(j);
                    decimal prevPzo1 = j >= 1 ? pzoList.ElementAtOrDefault(j - 1) : 0;
                    decimal prevPzo2 = j >= 2 ? pzoList.ElementAtOrDefault(j - 2) : 0;

                    decimal pzo = vma != 0 ? MinOrMax(100 * dvma / vma, 100, -100) : 0;
                    pzoList.Add(pzo);

                    var signal = GetRsiSignal(pzo - prevPzo1, prevPzo1 - prevPzo2, pzo, prevPzo1, 40, -40);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (dvolList, dvmaList, pzoList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateAdaptivePriceZoneIndicator(StockData stockDataClass, string maType, int days = 20)
        {
            //@version=4
            ////////////////////////////////////////////////////////////
            //  Copyright by HPotter v1.0 13/01/2020
            //
            // The adaptive price zone (APZ) is a volatility-based technical indicator that helps investors 
            // identify possible market turning points, which can be especially useful in a sideways-moving 
            // market. It was created by technical analyst Lee Leibfarth in the article “Identify the 
            // Turning Point: Trading With An Adaptive Price Zone,” which appeared in the September 2006 issue 
            // of the journal Technical Analysis of Stocks and Commodities.
            // This indicator attempts to signal significant price movements by using a set of bands based on 
            // short-term, decimal-smoothed exponential moving averages that lag only slightly behind price changes. 
            // It can help short-term investors and day traders profit in volatile markets by signaling price 
            // reversal points, which can indicate potentially lucrative times to buy or sell. The APZ can be 
            // implemented as part of an automated trading system and can be applied to the charts of all tradeable assets.
            //
            ////////////////////////////////////////////////////////////

            //study(title = "Adaptive Price Zone Indicator", shorttitle = "APZ", overlay = true)
            //nPeriods = input(20, minval = 1)
            //nBandPct = input(2, minval = 0)
            //xHL = high - low
            //nP = ceil(sqrt(nPeriods))
            //xVal1 = ema(ema(close, nP), nP)
            //xVal2 = ema(ema(xHL, nP), nP)
            //UpBand = nBandPct * xVal2 + xVal1
            //DnBand = xVal1 - nBandPct * xVal2
            //plot(UpBand, color = color.red, linewidth = 2, title = "UpBand")
            //plot(DnBand, color = color.green, linewidth = 2, title = "DnBand")
            List<decimal> xHLList = new();
            List<decimal> xHLEma2List = new();
            List<decimal> innerUpBandList = new();
            List<decimal> innerDnBandList = new();
            List<decimal> outerUpBandList = new();
            List<decimal> outerDnBandList = new();
            List<decimal> middleBandList = new();
            List<Signal> signalsList = new();

            try
            {
                int nP = MinOrMax((int)Math.Ceiling(Sqrt((double)days)));
                int nBandPct = 2;

                List<decimal> ema1List = GetMovingAverageList(maType, null, stockDataClass, nP);
                List<decimal> ema2List = GetMovingAverageList(maType, ema1List, stockDataClass, nP);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentHigh = stockDataClass.HighPrices.ElementAtOrDefault(i);
                    decimal currentLow = stockDataClass.LowPrices.ElementAtOrDefault(i);

                    decimal xHL = currentHigh - currentLow;
                    xHLList.Add(xHL);
                }

                var xHLEma1List = GetMovingAverageList(maType, xHLList, stockDataClass, nP);
                xHLEma2List = GetMovingAverageList(maType, xHLEma1List, stockDataClass, nP);
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(j);
                    decimal prevValue = j >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(j - 1) : 0;
                    decimal xVal1 = ema2List.ElementAtOrDefault(j);
                    decimal xVal2 = xHLEma2List.ElementAtOrDefault(j);

                    decimal prevUpBand = outerUpBandList.LastOrDefault();
                    decimal outerUpBand = (nBandPct * xVal2) + xVal1;
                    outerUpBandList.Add(outerUpBand);

                    decimal innerUpBand = xVal2 + xVal1;
                    innerUpBandList.Add(innerUpBand);

                    decimal prevDnBand = outerDnBandList.LastOrDefault();
                    decimal outerDnBand = xVal1 - (nBandPct * xVal2);
                    outerDnBandList.Add(outerDnBand);

                    decimal innerDnBand = xVal1 - xVal2;
                    innerDnBandList.Add(innerDnBand);

                    decimal prevMiddleBand = middleBandList.LastOrDefault();
                    decimal middleBand = (outerUpBand + outerDnBand) / 2;
                    middleBandList.Add(middleBand);

                    var signal = GetBollingerBandsSignal(currentValue - middleBand, prevValue - prevMiddleBand, currentValue, prevValue, outerUpBand, prevUpBand, outerDnBand, prevDnBand);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (xHLEma2List, outerUpBandList, outerDnBandList, innerUpBandList, innerDnBandList, middleBandList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateWaveTrendOscillator(StockData stockDataClass, string maType, int days = 4)
        {
            //
            // @author LazyBear
            //
            // If you use this code in its original/modified form, do drop me a note. 
            //
            //study(title = "WaveTrend [LazyBear]", shorttitle = "WT_LB")
            //n1 = input(10, "Channel Length")
            //n2 = input(21, "Average Length")
            //obLevel1 = input(60, "Over Bought Level 1")
            //obLevel2 = input(53, "Over Bought Level 2")
            //osLevel1 = input(-60, "Over Sold Level 1")
            //osLevel2 = input(-53, "Over Sold Level 2")

            //ap = hlc3
            //esa = ema(ap, n1)
            //d = ema(abs(ap - esa), n1)
            //ci = (ap - esa) / (0.015 * d)
            //tci = ema(ci, n2)

            //wt1 = tci
            //wt2 = sma(wt1, 4)

            //plot(0, color = gray)
            //plot(obLevel1, color = red)
            //plot(osLevel1, color = green)
            //plot(obLevel2, color = red, style = 3)
            //plot(osLevel2, color = green, style = 3)

            //plot(wt1, color = green)
            //plot(wt2, color = red, style = 3)
            //plot(wt1 - wt2, color = blue, style = area, transp = 80)
            List<decimal> absApEsaList = new();
            List<decimal> ciList = new();
            List<decimal> tciList = new();
            List<decimal> wt2List = new();
            List<Signal> signalsList = new();

            try
            {
                int n1 = (int)Math.Ceiling(days / 0.4);
                int n2 = MinOrMax((int)Math.Ceiling(days / 0.1905));
                int wt1SmaLength = days;

                List<decimal> emaList = GetMovingAverageList(maType, null, stockDataClass, n1);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal ap = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal esa = emaList.ElementAtOrDefault(i);

                    decimal absApEsa = Math.Abs(ap - esa);
                    absApEsaList.Add(absApEsa);
                }

                var dList = GetMovingAverageList(maType, absApEsaList, stockDataClass, n1);
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal ap = stockDataClass.InputValues.ElementAtOrDefault(j);
                    decimal esa = emaList.ElementAtOrDefault(j);
                    decimal d = dList.ElementAtOrDefault(j);

                    decimal ci = d != 0 ? (ap - esa) / (0.015m * d) : 0;
                    ciList.Add(ci);
                }

                tciList = GetMovingAverageList(maType, ciList, stockDataClass, n2);
                wt2List = GetMovingAverageList(maType, tciList, stockDataClass, wt1SmaLength);
                for (int k = 0; k < stockDataClass.InputValues.Count; k++)
                {
                    decimal tci = tciList.ElementAtOrDefault(k);
                    decimal wt2 = wt2List.ElementAtOrDefault(k);
                    decimal prevTci = k >= 1 ? tciList.ElementAtOrDefault(k - 1) : 0;
                    decimal prevWt2 = k >= 1 ? wt2List.ElementAtOrDefault(k - 1) : 0;

                    var signal = GetRsiSignal(tci - wt2, prevTci - prevWt2, tci, prevTci, 53, -53);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (ciList, tciList, wt2List, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateKeltnerChannels(StockData stockDataClass, string maType, int days = 10)
        {
            //Middle Line: 20-day exponential moving average 
            //Upper Channel Line: 20 - day EMA + (2 x ATR(10))
            //Lower Channel Line: 20 - day EMA - (2 x ATR(10))
            List<decimal> upperChannelList = new();
            List<decimal> lowerChannelList = new();
            List<decimal> midChannelList = new();
            List<Signal> signalsList = new();
            decimal multiple = 2;

            try
            {
                int atrPeriod = days;
                int emaPeriod = MinOrMax(atrPeriod * 2);

                List<decimal> emaList = GetMovingAverageList(maType, null, stockDataClass, emaPeriod);
                var atrList = CalculateAverageTrueRange(stockDataClass, maType, atrPeriod).Item1;

                for (int i = 0; i < atrList.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal currentEma20Day = emaList.ElementAtOrDefault(i);
                    decimal currentAtr10Day = atrList.ElementAtOrDefault(i);

                    decimal upperChannel = currentEma20Day + (multiple * currentAtr10Day);
                    upperChannelList.Add(upperChannel);

                    decimal lowerChannel = currentEma20Day - (multiple * currentAtr10Day);
                    lowerChannelList.Add(lowerChannel);

                    decimal prevMidChannel = midChannelList.LastOrDefault();
                    decimal midChannel = (upperChannel + lowerChannel) / 2;
                    midChannelList.Add(midChannel);

                    var signal = GetCompareSignal(currentValue - midChannel, prevValue - prevMidChannel);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (upperChannelList, midChannelList, lowerChannelList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateMedianPrice(StockData stockDataClass)
        {
            // median price = high + low / 2
            List<decimal> medianPriceList = new();
            List<decimal> medianPricePlusList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.LowPrices.Count; i++)
                {
                    decimal currentLow = stockDataClass.LowPrices.ElementAtOrDefault(i);
                    decimal currentHigh = stockDataClass.HighPrices.ElementAtOrDefault(i);
                    decimal prevMedianPrice1 = i >= 1 ? medianPricePlusList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevMedianPrice2 = i >= 2 ? medianPricePlusList.ElementAtOrDefault(i - 2) : 0;

                    decimal medianPrice = (currentHigh - currentLow) / 2;
                    medianPriceList.Add(medianPrice);

                    decimal medianPricePlus = (currentHigh + currentLow) / 2;
                    medianPricePlusList.Add(medianPricePlus);

                    var signal = GetCompareSignal(medianPricePlus - prevMedianPrice1, prevMedianPrice1 - prevMedianPrice2);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (medianPriceList, medianPricePlusList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateMidprice(StockData stockDataClass, int days)
        {
            // MIDPRI = Average (Highest High - Lowest Low) within the look back period.
            List<decimal> midpriceList = new();
            List<decimal> midpricePlusList = new();
            List<Signal> signalsList = new();

            try
            {
                var minMaxList = VolumeInputCheck(stockDataClass, days, true);
                List<decimal> highestHighList = minMaxList.Item1;
                List<decimal> lowestLowList = minMaxList.Item2;

                for (int i = 0; i < lowestLowList.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal currentHigh = highestHighList.ElementAtOrDefault(i);
                    decimal currentLow = lowestLowList.ElementAtOrDefault(i);

                    decimal midPrice = (currentHigh - currentLow) / 2;
                    midpriceList.Add(midPrice);

                    decimal prevMidPricePlus = midpricePlusList.LastOrDefault();
                    decimal midPricePlus = (currentHigh + currentLow) / 2;
                    midpricePlusList.Add(midPricePlus);

                    var signal = GetCompareSignal(currentValue - midPricePlus, prevValue - prevMidPricePlus);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (midpriceList, midpricePlusList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateMidpoint(StockData stockDataClass, int days)
        {
            // Midpoint = Average (Highest Value - Lowest Value) within the look back period.
            List<decimal> midpointList = new();
            List<decimal> midpointPlusList = new();
            List<Signal> signalsList = new();

            try
            {
                var minMaxList = GetMaxAndMinValuesList(stockDataClass.InputValues, days);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal highest = minMaxList.Item1.ElementAtOrDefault(i);
                    decimal lowest = minMaxList.Item2.ElementAtOrDefault(i);

                    decimal midpoint = (highest - lowest) / 2;
                    midpointList.Add(midpoint);

                    decimal prevMidPointPlus = midpointPlusList.LastOrDefault();
                    decimal midpointPlus = (highest + lowest) / 2;
                    midpointPlusList.Add(midpointPlus);

                    var signal = GetCompareSignal(currentValue - midpointPlus, prevValue - prevMidPointPlus);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (midpointList, midpointPlusList, signalsList);
        }

        public static (List<decimal>, List<Signal>) CalculateAwesomeOscillator(StockData stockDataClass, string maType, int days = 5)
        {
            //@version=3
            // Copyright (c) 2018-present, Alex Orekhov (everget)
            // Awesome Oscillator script may be freely distributed under the MIT license.
            //study("Awesome Oscillator", shorttitle = "AO")

            //fastLength = input(title = "Fast Length", type = integer, defval = 5)
            //slowLength = input(title = "Slow Length", type = integer, defval = 34)

            //ao = sma(hl2, fastLength) - sma(hl2, slowLength)

            //aoColor = ao >= 0 ? (ao[1] < ao ? #26A69A : #B2DFDB) : (ao[1] < ao ? #FFCDD2 : #EF5350)
            //plot(ao, title = "AO", style = columns, color = aoColor, transp = 0)
            List<decimal> awesomeOscillatorList = new();
            List<Signal> signalsList = new();

            try
            {
                int fastPeriod = days;
                int slowPeriod = MinOrMax((int)Math.Ceiling(fastPeriod / 0.1471));

                List<decimal> fastSmaList = GetMovingAverageList(maType, null, stockDataClass, fastPeriod);
                List<decimal> slowSmaList = GetMovingAverageList(maType, null, stockDataClass, slowPeriod);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal fastSma = fastSmaList.ElementAtOrDefault(i);
                    decimal slowSma = slowSmaList.ElementAtOrDefault(i);

                    decimal prevAo = awesomeOscillatorList.LastOrDefault();
                    decimal ao = fastSma - slowSma;
                    awesomeOscillatorList.Add(ao);

                    var signal = GetCompareSignal(ao, prevAo);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (awesomeOscillatorList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateAcceleratorOscillator(StockData stockDataClass, string maType, int days = 5)
        {
            //@version=3
            // Copyright (c) 2018-present, Alex Orekhov (everget)
            // Accelerator Oscillator script may be freely distributed under the MIT license.
            //study("Accelerator Oscillator", shorttitle = "AC")

            //fastLength = input(title = "Fast Length", type = integer, defval = 5)
            //slowLength = input(title = "Slow Length", type = integer, defval = 34)
            //smoothLength = input(title = "Smoothing Length", type = integer, defval = 5)

            //ao = sma(hl2, fastLength) - sma(hl2, slowLength)

            //ac = ao - sma(ao, smoothLength)

            //acColor = ac >= 0 ? (ac[1] < ac ? #26A69A : #B2DFDB) : (ac[1] < ac ? #FFCDD2 : #EF5350)
            //plot(ac, title = "AC", style = columns, color = acColor, transp = 0)
            List<decimal> aoSmaList = new();
            List<decimal> acceleratorOscillatorList = new();
            List<Signal> signalsList = new();

            try
            {
                List<decimal> awesomeOscillatorList = CalculateAwesomeOscillator(stockDataClass, maType, days).Item1;
                aoSmaList = GetMovingAverageList(maType, awesomeOscillatorList, stockDataClass, days);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal ao = awesomeOscillatorList.ElementAtOrDefault(i);
                    decimal aoSma = aoSmaList.ElementAtOrDefault(i);

                    decimal prevAc = acceleratorOscillatorList.LastOrDefault();
                    decimal ac = ao - aoSma;
                    acceleratorOscillatorList.Add(ac);

                    var signal = GetCompareSignal(ac, prevAc);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (aoSmaList, acceleratorOscillatorList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateRapidRelativeStrengthIndex(StockData stockDataClass, string maType, int days = 14)
        {
            //@version=3
            // Copyright (c) 2018-present, Alex Orekhov (everget)
            // Rapid RSI script may be freely distributed under the MIT license.
            //study("Rapid RSI", shorttitle = "RRSI")

            //length = input(title = "Length", type = integer, minval = 1, defval = 14)
            //highlightBreakouts = input(title = "Highlight Overbought/Oversold Breakouts ?", type = bool, defval = true)
            //src = input(title = "Source", type = source, defval = close)

            //upSum = sum(max(change(src), 0), length)
            //downSum = sum(max(-change(src), 0), length)

            //rrsi = downSum == 0 ? 100 : upSum == 0 ? 0 : 100 - (100 / (1 + upSum / downSum))

            //obLevel = 70
            //osLevel = 30

            //rrsiColor = rrsi > obLevel ? #0ebb23 : rrsi < osLevel ? #ff0000 : #f4b77d
            //plot(rrsi, title = "RRSI", linewidth = 2, color = rrsiColor, transp = 0)

            //transparent = color(white, 100)

            //maxLevelPlot = hline(100, title = "Max Level", linestyle = dotted, color = transparent)
            //obLevelPlot = hline(obLevel, title = "Overbought Level", linestyle = dotted)
            //hline(50, title = "Middle Level", linestyle = dotted)
            //osLevelPlot = hline(osLevel, title = "Oversold Level", linestyle = dotted)
            //minLevelPlot = hline(0, title = "Min Level", linestyle = dotted, color = transparent)

            //fill(obLevelPlot, osLevelPlot, color = purple, transp = 95)

            //obFillColor = rrsi > obLevel and highlightBreakouts ? green: transparent
            //osFillColor = rrsi < osLevel and highlightBreakouts ? red: transparent

            //fill(maxLevelPlot, obLevelPlot, color = obFillColor, transp = 90)
            //fill(minLevelPlot, osLevelPlot, color = osFillColor, transp = 90)
            List<decimal> upChgList = new();
            List<decimal> downChgList = new();
            List<decimal> rapidRsiList = new();
            List<decimal> upChgSumList = new();
            List<decimal> downChgSumList = new();
            List<decimal> rsList = new();
            List<decimal> rrsiEmaList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal chg = currentValue - prevValue;

                    decimal upChg = chg > 0 ? chg : 0;
                    upChgList.Add(upChg);

                    decimal downChg = chg < 0 ? Math.Abs(chg) : 0;
                    downChgList.Add(downChg);

                    decimal upChgSum = upChgList.TakeLast(days).Sum();
                    upChgSumList.Add(upChgSum);

                    decimal downChgSum = downChgList.TakeLast(days).Sum();
                    downChgSumList.Add(downChgSum);

                    decimal rs = downChgSum != 0 ? upChgSum / downChgSum : 0;
                    rsList.Add(rs);

                    decimal rapidRsi = downChgSum == 0 ? 100 : upChgSum == 0 ? 0 : MinOrMax(100 - (100 / (1 + rs)), 100, 0);
                    rapidRsiList.Add(rapidRsi);
                }

                rrsiEmaList = GetMovingAverageList(maType, rapidRsiList, stockDataClass, days);
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal rapidRsi = rrsiEmaList.ElementAtOrDefault(j);
                    decimal prevRapidRsi1 = j >= 1 ? rrsiEmaList.ElementAtOrDefault(j - 1) : 0;
                    decimal prevRapidRsi2 = j >= 2 ? rrsiEmaList.ElementAtOrDefault(j - 2) : 0;

                    var signal = GetRsiSignal(rapidRsi - prevRapidRsi1, prevRapidRsi1 - prevRapidRsi2, rapidRsi, prevRapidRsi1, 70, 30);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (rsList, rapidRsiList, rrsiEmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>)
            CalculateAsymmetricalRelativeStrengthIndex(StockData stockDataClass, int days = 14)
        {
            //@version=3
            // Copyright (c) 2018-present, Alex Orekhov (everget)
            // Asymmetrical RSI script may be freely distributed under the MIT license.
            //study("Asymmetrical RSI", shorttitle = "ARSI")

            //length = input(title = "Length", type = integer, defval = 14)
            //obLevel = input(title = "Overbought Level", type = integer, defval = 70)
            //osLevel = input(title = "Oversold Level", type = integer, defval = 30)
            //src = input(title = "Source", type = source, defval = close)
            //highlightBreakouts = input(title = "Highlight Overbought/Oversold Breakouts ?", type = bool, defval = true)

            //roc = roc(src, 1)

            //upCount = sum(roc >= 0 ? 1 : 0, length)
            //upAlpha = 1 / upCount

            //upSum = 0.0
            //upSum:= upAlpha * (roc >= 0 ? roc : 0) + (1 - upAlpha) * nz(upSum[1])

            //downCount = length - upCount
            //downAlpha = 1 / downCount

            //downSum = 0.0
            //downSum:= downAlpha * (roc >= 0 ? 0 : abs(roc)) + (1 - downAlpha) * nz(downSum[1])

            //arsi = downSum == 0
            //     ? 100
            //     : upSum == 0
            //          ? 0
            //          : 100 - (100 / (1 + upSum / downSum))

            //arsiColor = arsi > obLevel ? #0ebb23 : arsi < osLevel ? #ff0000 : #f4b77d
            //plot(arsi, title = "ARSI", linewidth = 2, color = arsiColor, transp = 0)

            //transparent = color(white, 100)

            //maxLevelPlot = hline(100, title = "Max Level", linestyle = dotted, color = transparent)
            //obLevelPlot = hline(obLevel, title = "Overbought Level", linestyle = dotted)
            //hline(50, title = "Middle Level", linestyle = dotted)
            //osLevelPlot = hline(osLevel, title = "Oversold Level", linestyle = dotted)
            //minLevelPlot = hline(0, title = "Min Level", linestyle = dotted, color = transparent)

            //fill(obLevelPlot, osLevelPlot, color = purple, transp = 95)

            //obFillColor = arsi > obLevel and highlightBreakouts ? green: transparent
            //osFillColor = arsi < osLevel and highlightBreakouts ? red: transparent

            //fill(maxLevelPlot, obLevelPlot, color = obFillColor, transp = 90)
            //fill(minLevelPlot, osLevelPlot, color = osFillColor, transp = 90)
            List<decimal> tempList = new();
            List<decimal> upCountList = new();
            List<decimal> posRocList = new();
            List<decimal> negRocList = new();
            List<decimal> upSumList = new();
            List<decimal> downSumList = new();
            List<decimal> downCountList = new();
            List<decimal> upAlphaList = new();
            List<decimal> downAlphaList = new();
            List<decimal> arsList = new();
            List<decimal> arsiList = new();
            List<Signal> signalsList = new();

            try
            {
                List<decimal> rocList = CalculateRateOfChange(null, stockDataClass, 1).Item1;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal prevArsi1 = i >= 1 ? arsiList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevArsi2 = i >= 2 ? arsiList.ElementAtOrDefault(i - 2) : 0;

                    decimal roc = rocList.ElementAtOrDefault(i);
                    tempList.Add(roc);

                    decimal upCount = tempList.TakeLast(days).Where(x => x >= 0).Count();
                    upCountList.Add(upCount);

                    decimal upAlpha = upCount != 0 ? 1 / upCount : 0;
                    upAlphaList.Add(upAlpha);

                    decimal posRoc = roc > 0 ? roc : 0;
                    posRocList.Add(posRoc);

                    decimal negRoc = roc < 0 ? Math.Abs(roc) : 0;
                    negRocList.Add(negRoc);

                    decimal prevUpSum = upSumList.LastOrDefault();
                    decimal upSum = (upAlpha * posRoc) + ((1 - upAlpha) * prevUpSum);
                    upSumList.Add(upSum);

                    decimal downCount = days - upCount;
                    downCountList.Add(downCount);

                    decimal downAlpha = downCount != 0 ? 1 / downCount : 0;
                    downAlphaList.Add(downAlpha);

                    decimal prevDownSum = downSumList.LastOrDefault();
                    decimal downSum = (downAlpha * negRoc) + ((1 - downAlpha) * prevDownSum);
                    downSumList.Add(downSum);

                    decimal ars = downSum != 0 ? upSum / downSum : 0;
                    arsList.Add(ars);

                    decimal arsi = downSum == 0 ? 100 : upSum == 0 ? 0 : MinOrMax(100 - (100 / (1 + ars)), 100, 0);
                    arsiList.Add(arsi);

                    var signal = GetRsiSignal(arsi - prevArsi1, prevArsi1 - prevArsi2, arsi, prevArsi1, 70, 30);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (upAlphaList, posRocList, negRocList, upSumList, downCountList, downAlphaList, downSumList, arsList, arsiList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<Signal>) CalculateEhlersRocketRelativeStrengthIndex(StockData stockDataClass, string maType, int days = 8)
        {
            //@version=3
            // Copyright (c) 2018-present, Alex Orekhov (everget)
            // Rocket RSI script may be freely distributed under the MIT license.
            //study("Rocket RSI", shorttitle = "Rocket RSI")

            //rsiLength = input(title = "RSI Length", type = integer, defval = 10)
            //ssfPoles = input(title = "Super Smoother Filter Poles", type = integer, defval = 2, options =[2, 3])
            //ssfLength = input(title = "Super Smoother Filter Length", type = integer, defval = 8)
            //obosLevel = input(title = "Overbought / Oversold Level", type = float, defval = 2.0, minval = 0.0)
            //applyNormalization = input(title = "Apply Normalization to [-100, 100] values ?", type = bool, defval = false)
            //src = input(title = "Source", type = source, defval = close)

            //PI = 2 * asin(1)

            //get2PoleSSF(src, length) =>
            //    arg = sqrt(2) * PI / length
            //    a1 = exp(-arg)
            //    b1 = 2 * a1 * cos(arg)
            //    c2 = b1
            //    c3 = -pow(a1, 2)
            //    c1 = 1 - c2 - c3
            //    ssf = 0.0
            //    ssf:= c1 * src + c2 * nz(ssf[1]) + c3 * nz(ssf[2])

            //get3PoleSSF(src, length) =>
            //    arg = PI / length
            //    a1 = exp(-arg)
            //    b1 = 2 * a1 * cos(1.738 * arg)
            //    c1 = pow(a1, 2)
            //    coef2 = b1 + c1
            //    coef3 = -(c1 + b1 * c1)
            //    coef4 = pow(c1, 2)
            //    coef1 = 1 - coef2 - coef3 - coef4
            //    ssf = 0.0
            //    ssf:= coef1 * src + coef2 * nz(ssf[1]) + coef3 * nz(ssf[2]) + coef4 * nz(ssf[3])

            // Create half dominant cycle momentum
            //mom = change(src, rsiLength - 1)
            //arg = (mom + nz(mom[1])) / 2

            // Super Smoother Filter
            //            ssf = ssfPoles == 2
            //     ? get2PoleSSF(arg, ssfLength)
            //     : get3PoleSSF(arg, ssfLength)

            // Accumulate `Closes Up` and `Closes Down`
            //ssfMom = change(ssf)
            //upSum = sum(ssfMom > 0 ? ssfMom : 0, rsiLength)
            //downSum = sum(ssfMom > 0 ? 0 : abs(ssfMom), rsiLength)

            //tmp = 0.0
            //tmp:= upSum + downSum != 0
            //    ? (upSum - downSum) / (upSum + downSum)
            //    : nz(tmp[1])

            // Limit RocketRSI output to +/- 3 Standard Deviations
            //if tmp > 0.999
            //tmp:= 0.999
            //if tmp < -0.999
            //    tmp:= -0.999

            //normMult = (applyNormalization ? 25 : 1)
            // Apply Fisher Transform to establish Gaussian Probability Distribution
            //rocketRSI = 0.5 * fixnan(log((1 + tmp) / (1 - tmp)))
            //rocketRSI:= rocketRSI * normMult
            //obLevel = obosLevel * normMult
            //osLevel = -obosLevel * normMult
            //rocketRSIColor = rocketRSI > obLevel ? green : rocketRSI < osLevel ? red : #ff9370
            //plot(rocketRSI, title = "RRSI", linewidth = 2, color = rocketRSIColor, transp = 0)
            //plot(obLevel, title = "OB", style = circles, color =#3d85c6, transp=0)
            //hline(0, title = "Zero Level", linestyle = dotted)
            //plot(osLevel, title = "OS", style = circles, color =#3d85c6, transp=0)
            List<decimal> momList = new();
            List<decimal> argList = new();
            List<decimal> ssf2PoleRocketRsiList = new();
            List<decimal> argSsf2PoleList = new();
            List<decimal> ssf2PoleMomList = new();
            List<decimal> ssf2PoleUpChgList = new();
            List<decimal> ssf2PoleDownChgList = new();
            List<decimal> ssf2PoleUpChgSumList = new();
            List<decimal> ssf2PoleDownChgSumList = new();
            List<decimal> ssf2PoleTmpList = new();
            List<decimal> ssf2PoleTempLogList = new();
            List<decimal> ssf2PoleLogList = new();
            List<Signal> signalsList = new();
            decimal obosLevel = 2, normMult = 1;

            try
            {
                int ssfLength = days;
                int rsiLength = (int)Math.Ceiling(days / 0.8);

                decimal obLevel = obosLevel * normMult;
                decimal osLevel = -obosLevel * normMult;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= rsiLength - 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - (rsiLength - 1)) : 0;

                    decimal prevMom = momList.LastOrDefault();
                    decimal mom = currentValue - prevValue;
                    momList.Add(mom);

                    decimal arg = (mom + prevMom) / 2;
                    argList.Add(arg);
                }

                argSsf2PoleList = GetMovingAverageList(maType, argList, stockDataClass, ssfLength);
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal ssf2Pole = argSsf2PoleList.ElementAtOrDefault(j);
                    decimal prevSsf2Pole = j >= 1 ? argSsf2PoleList.ElementAtOrDefault(j - 1) : 0;
                    decimal prevRocketRsi1 = j >= 1 ? ssf2PoleRocketRsiList.ElementAtOrDefault(j - 1) : 0;
                    decimal prevRocketRsi2 = j >= 2 ? ssf2PoleRocketRsiList.ElementAtOrDefault(j - 2) : 0;

                    decimal ssf2PoleMom = ssf2Pole - prevSsf2Pole;
                    ssf2PoleMomList.Add(ssf2PoleMom);

                    decimal up2PoleChg = ssf2PoleMom > 0 ? ssf2PoleMom : 0;
                    ssf2PoleUpChgList.Add(up2PoleChg);

                    decimal down2PoleChg = ssf2PoleMom < 0 ? Math.Abs(ssf2PoleMom) : 0;
                    ssf2PoleDownChgList.Add(down2PoleChg);

                    decimal up2PoleChgSum = ssf2PoleUpChgList.TakeLast(rsiLength).Sum();
                    ssf2PoleUpChgSumList.Add(up2PoleChgSum);

                    decimal down2PoleChgSum = ssf2PoleDownChgList.TakeLast(rsiLength).Sum();
                    ssf2PoleDownChgSumList.Add(down2PoleChgSum);

                    decimal prevTmp2Pole = ssf2PoleTmpList.LastOrDefault();
                    decimal tmp2Pole = up2PoleChgSum + down2PoleChgSum != 0 ?
                        MinOrMax((up2PoleChgSum - down2PoleChgSum) / (up2PoleChgSum + down2PoleChgSum), 0.999m, -0.999m) : prevTmp2Pole;
                    ssf2PoleTmpList.Add(tmp2Pole);

                    decimal ssf2PoleTempLog = 1 - tmp2Pole != 0 ? (1 + tmp2Pole) / (1 - tmp2Pole) : 0;
                    ssf2PoleTempLogList.Add(ssf2PoleTempLog);

                    decimal ssf2PoleLog = ssf2PoleTempLog > 0 ? (decimal)Log((double)ssf2PoleTempLog) : 0;
                    ssf2PoleLogList.Add(ssf2PoleLog);

                    decimal ssf2PoleRocketRsi = 0.5m * ssf2PoleLog * normMult;
                    ssf2PoleRocketRsiList.Add(ssf2PoleRocketRsi);

                    var signal = GetRsiSignal(ssf2PoleRocketRsi - prevRocketRsi1, prevRocketRsi1 - prevRocketRsi2, ssf2PoleRocketRsi, prevRocketRsi1, obLevel, osLevel);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (argList, argSsf2PoleList, ssf2PoleMomList, ssf2PoleUpChgList, ssf2PoleDownChgList, ssf2PoleUpChgSumList, ssf2PoleDownChgSumList, ssf2PoleTmpList,
                ssf2PoleTempLogList, ssf2PoleLogList, ssf2PoleRocketRsiList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateEhlersCorrelationTrendIndicator(StockData stockDataClass, int days = 20)
        {
            //{
            //    Correlation Trend Indicator
            //    (c) 2013 - 2019 John F. Ehlers
            //}
            //Inputs:
            //Length(20);
            //Vars:
            //Sx(0),Sy(0),Sxx(0),Sxy(0),Syy(0),count(0),X(0),Y(0),Corr(0);Sx = 0;Sy = 0;Sxx = 0;Sxy = 0;Syy = 0;
            //For count = 0 to Length -1 Begin
            //X = Close[count];
            //Y = -count;
            //Sx = Sx + X;
            //Sy = Sy + Y;
            //Sxx = Sxx + X * X;
            //Sxy = Sxy + X * Y;
            //Syy = Syy + Y * Y;
            //End;
            //If(Length * Sxx - Sx * Sx > 0) and(Length * Syy - Sy * Sy > 0)
            //Then Corr = (Length * Sxy - Sx * Sy) / SquareRoot((Length * Sxx -
            //Sx * Sx) * (Length * Syy - Sy * Sy));
            //Plot1(Corr);
            //Plot2(0);
            List<decimal> sxList = new();
            List<decimal> syList = new();
            List<decimal> sxxList = new();
            List<decimal> sxyList = new();
            List<decimal> syyList = new();
            List<decimal> corrList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal prevCorr1 = i >= 1 ? corrList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevCorr2 = i >= 2 ? corrList.ElementAtOrDefault(i - 2) : 0;

                    decimal sx = 0, sy = 0, sxx = 0, sxy = 0, syy = 0;
                    for (int j = 0; j <= days - 1; j++)
                    {
                        decimal x = i >= j ? stockDataClass.InputValues.ElementAtOrDefault(i - j) : 0;
                        decimal y = -j;

                        sx += x;
                        sy += y;
                        sxx += x * x;
                        sxy += x * y;
                        syy += y * y;
                    }
                    sxList.Add(sx);
                    syList.Add(sy);
                    sxxList.Add(sxx);
                    sxyList.Add(sxy);
                    syyList.Add(syy);

                    decimal corr = (days * sxx) - (sx * sx) > 0 && (days * syy) - (sy * sy) > 0 ? ((days * sxy) - (sx * sy)) /
                        (decimal)Sqrt((double)(((days * sxx) - (sx * sx)) * ((days * syy) - (sy * sy)))) : 0;
                    corrList.Add(corr);

                    var signal = GetRsiSignal(corr - prevCorr1, prevCorr1 - prevCorr2, corr, prevCorr1, 0.5m, -0.5m);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (syList, sxxList, sxyList, syyList, corrList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<decimal>, List<decimal>, List<Signal>) CalculateKlingerVolumeOscillator(StockData stockDataClass, string maType, int days = 13)
        {
            //@version=3
            // Copyright (c) 2018-present, Alex Orekhov (everget)
            // Klinger Volume Oscillator script may be freely distributed under the MIT license.
            //study(title = "Klinger Volume Oscillator", shorttitle = "KVO", precision = 0)

            //fastLength = input(title = "Fast Length", type = integer, defval = 34)
            //slowLength = input(title = "Slow Length", type = integer, defval = 55)
            //showSignal = input(title = "Show Signal ?", type = bool, defval = true)
            //signalType = input(title = "Signal Smoothing Type", defval = "EMA", options =["EMA", "SMA"])
            //signalLength = input(title = "Signal Smoothing Length", type = integer, defval = 13)
            //showHistogram = input(title = "Show Histogram ?", type = bool, defval = false)
            //highlightCrossovers = input(title = "Highlight KVO/Signal Crossovers ?", type = bool, defval = true)
            //highlightZeroCrossovers = input(title = "Highlight Zero Line Crossovers ?", type = bool, defval = true)
            //applyFilling = input(title = "Apply Ribbon Filling ?", type = bool, defval = false)

            //mom = change(hlc3)

            //trend = 0.0
            //trend:= na(trend[1]) ? 0.0 : (mom > 0 ? 1 : mom < 0 ? -1 : trend[1])

            // Daily Measurement
            //dm = high - low

            // Cumulative Measurement
            //cm = 0.0
            //cm:= na(cm[1]) ? 0.0 : (trend == trend[1] ? cm[1] + dm : dm + dm[1])

            // Volume Force
            //vf = cm != 0 ? 100 * volume * trend * abs(2 * dm / cm - 1) : 0

            //kvo = ema(vf, fastLength) - ema(vf, slowLength)
            //signal = signalType == "EMA" ? ema(kvo, signalLength) : sma(kvo, signalLength)

            //hist = kvo - signal
            //histColor = hist >= 0 ? (hist[1] < hist ? #26A69A : #B2DFDB) : (hist[1] < hist ? #FFCDD2 : #EF5350)
            //plot(showHistogram ? hist : na, title = "Histogram", style = columns, color = histColor, transp = 0)
            //hline(0, title = "Zero Level", linestyle = dotted)

            //trendColor = kvo > signal ? #0ebb23 : red

            //kvoColor = applyFilling ? trendColor : (kvo > 0 ? #0ebb23 : red)
            //signalColor = applyFilling ? trendColor : #512da8

            //kvoPlot = plot(kvo, title = "KVO", linewidth = 2, color = kvoColor, transp = 0)
            //signalPlot = plot(showSignal ? signal : na, title = "Signal", color = signalColor, transp = 0)

            //transparent = color(white, 100)

            //fillColor = applyFilling ? trendColor : transparent
            //fill(kvoPlot, signalPlot, title = "Ribbon", color = fillColor, transp = 70)

            //zeroCrossBgColor = highlightZeroCrossovers ? (kvo > 0 ? green : red) : transparent
            //bgcolor(zeroCrossBgColor, title = "Background", transp = 85)

            //plotshape(crossover(kvo, signal) and highlightCrossovers ? signal : na, title = "Crossover", location = location.absolute, style = shape.circle, size = size.tiny, color = green, transp = 20)
            //plotshape(crossunder(kvo, signal) and highlightCrossovers ? signal : na, title = "Crossunder", location = location.absolute, style = shape.circle, size = size.tiny, color = red, transp = 20)
            List<decimal> klingerOscillatorList = new();
            List<decimal> trendList = new();
            List<decimal> tempList = new();
            List<decimal> dmList = new();
            List<decimal> cmList = new();
            List<decimal> vfList = new();
            List<decimal> ema34List = new();
            List<decimal> ema55List = new();
            List<decimal> klingerOscillatorSignalList = new();
            List<decimal> klingerOscillatorHistogramList = new();
            List<Signal> signalsList = new();

            try
            {
                int fastLength = (int)Math.Ceiling(days / 0.3824);
                int slowLength = (int)Math.Ceiling(days / 0.2364);
                int signalLength = days;

                for (int i = 0; i < stockDataClass.HighPrices.Count; i++)
                {
                    decimal currentHigh = stockDataClass.HighPrices.ElementAtOrDefault(i);
                    decimal currentLow = stockDataClass.LowPrices.ElementAtOrDefault(i);
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal currentVolume = stockDataClass.Volumes.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal mom = currentValue - prevValue;

                    decimal prevTrend = trendList.LastOrDefault();
                    decimal trend = mom > 0 ? 1 : mom < 0 ? -1 : prevTrend;
                    trendList.Add(trend);

                    decimal prevDm = dmList.LastOrDefault();
                    decimal dm = currentHigh - currentLow;
                    dmList.Add(dm);

                    decimal prevCm = cmList.LastOrDefault();
                    decimal cm = trend == prevTrend ? prevCm + dm : prevDm + dm;
                    cmList.Add(cm);

                    decimal temp = cm != 0 ? Math.Abs((2 * (dm / cm)) - 1) : -1;
                    tempList.Add(temp);

                    decimal vf = currentVolume * temp * trend * 100;
                    vfList.Add(vf);
                }

                ema34List = GetMovingAverageList(maType, vfList, stockDataClass, fastLength);
                ema55List = GetMovingAverageList(maType, vfList, stockDataClass, slowLength);
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal ema34 = ema34List.ElementAtOrDefault(j);
                    decimal ema55 = ema55List.ElementAtOrDefault(j);

                    decimal klingerOscillator = ema34 - ema55;
                    klingerOscillatorList.Add(klingerOscillator);
                }

                klingerOscillatorSignalList = GetMovingAverageList(maType, klingerOscillatorList, stockDataClass, signalLength);
                for (int k = 0; k < stockDataClass.InputValues.Count; k++)
                {
                    decimal klingerOscillator = klingerOscillatorList.ElementAtOrDefault(k);
                    decimal koSignalLine = klingerOscillatorSignalList.ElementAtOrDefault(k);

                    decimal prevKlingerOscillatorHistogram = klingerOscillatorHistogramList.LastOrDefault();
                    decimal klingerOscillatorHistogram = klingerOscillator - koSignalLine;
                    klingerOscillatorHistogramList.Add(klingerOscillatorHistogram);

                    var signal = GetCompareSignal(klingerOscillatorHistogram, prevKlingerOscillatorHistogram);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (dmList, trendList, cmList, tempList, vfList, ema34List, ema55List, klingerOscillatorList, klingerOscillatorSignalList, klingerOscillatorHistogramList,
                signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateMultiVoteOnBalanceVolume(StockData stockDataClass, int days = 14)
        {
            //prev = previous, index = current bar number

            //prevC = close[index - 1];
            //prevL = low[index - 1];
            //prevH = high[index - 1];
            //volume = getVolume(index) / 1000000; //volume in millions
            //highVote = 0;
            //lowVote = 0;
            //closeVote = 0;
            //if (high moreThan prevH) highVote = 1;
            //if (high lessThan prevH) highVote = -1;
            //if (low moreThan prevL) lowVote = 1;
            //if (low lessThan prevL) lowVote = -1;
            //if (close moreThan prevC) closeVote = 1;
            //if (close lessThan prevC) closeVote = -1;
            //totVote = highVote + lowVote + closeVote;
            //prevMvo = mvo[index, 1];
            //Plot: mvo = prevMvo + (volume * totVote);
            List<decimal> mvoList = new();
            List<decimal> highVoteList = new();
            List<decimal> lowVoteList = new();
            List<decimal> closeVoteList = new();
            List<decimal> totalVoteList = new();
            List<decimal> mvoEmaList = new();
            List<Signal> signalsList = new();

            try
            {
                var list = VolumeInputCheck(stockDataClass, days, false);
                var highList = list.Item1;
                var lowList = list.Item2;

                for (int i = 0; i < stockDataClass.HighPrices.Count; i++)
                {
                    decimal currentHigh = highList.ElementAtOrDefault(i);
                    decimal currentClose = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal currentLow = lowList.ElementAtOrDefault(i);
                    decimal currentVolume = stockDataClass.Volumes.ElementAtOrDefault(i) / 1000000;
                    decimal prevClose = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevHigh = i >= 1 ? highList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevLow = i >= 1 ? lowList.ElementAtOrDefault(i - 1) : 0;

                    decimal highVote = currentHigh > prevHigh ? 1 : currentHigh < prevHigh ? -1 : 0;
                    highVoteList.Add(highVote);

                    decimal lowVote = currentLow > prevLow ? 1 : currentLow < prevLow ? -1 : 0;
                    lowVoteList.Add(lowVote);

                    decimal closeVote = currentClose > prevClose ? 1 : currentClose < prevClose ? -1 : 0;
                    closeVoteList.Add(closeVote);

                    decimal totalVotes = highVote + lowVote + closeVote;
                    totalVoteList.Add(totalVotes);

                    decimal prevMvo = mvoList.LastOrDefault();
                    decimal mvo = prevMvo + (currentVolume * totalVotes);
                    mvoList.Add(mvo);

                    decimal prevMvoEma = mvoEmaList.LastOrDefault();
                    decimal mvoEma = CalculateExponentialMovingAverage(mvo, mvoEmaList.LastOrDefault(), days);
                    mvoEmaList.Add(mvoEma);

                    var signal = GetCompareSignal(mvo - mvoEma, prevMvo - prevMvoEma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (highVoteList, lowVoteList, closeVoteList, totalVoteList, mvoList, mvoEmaList, signalsList);
        }

        public static (List<decimal>, List<Signal>) CalculateDisparityIndex(StockData stockDataClass, string maType, int days = 14)
        {
            //@version=3
            // Copyright (c) 2018-present, Alex Orekhov (everget)
            // Disparity Index script may be freely distributed under the MIT license.
            //study("Disparity Index", shorttitle = "DI")

            //length = input(title = "Length", type = integer, minval = 1, defval = 14)
            //src = input(title = "Source", type = source, defval = close)

            //di = 100 * (src - sma(src, length)) / sma(src, length)

            //diColor = di >= 0 ? #0ebb23 : red
            //plot(di, title = "Disparity Index", linewidth = 2, color = diColor, transp = 0)

            //hline(0, title = "Zero Level", linestyle = dotted, color =#989898)
            List<decimal> disparityIndexList = new();
            List<Signal> signalsList = new();

            try
            {
                List<decimal> smaList = GetMovingAverageList(maType, null, stockDataClass, days);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal currentSma = smaList.ElementAtOrDefault(i);

                    decimal prevDisparityIndex = disparityIndexList.LastOrDefault();
                    decimal disparityIndex = currentSma != 0 ? (currentValue - currentSma) / currentSma * 100 : 0;
                    disparityIndexList.Add(disparityIndex);

                    var signal = GetCompareSignal(disparityIndex, prevDisparityIndex);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (disparityIndexList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateCMOaDisparityIndex(StockData stockDataClass, string maType, int days = 20)
        {
            ////////////////////////////////////////////////////////////
            //  Copyright by HPotter v1.0 30/06/2018
            // The related article is copyrighted materialfrom Stocks & Commodities Dec 2009
            // My strategy modification.
            //
            // WARNING:
            //  - This script to change bars colors.
            ////////////////////////////////////////////////////////////
            //study(title = "CMOaDisparity Index Strategy")
            //LengthFirst = input(200, minval = 1)
            //LengthSecond = input(50, minval = 1)
            //LengthThird = input(20, minval = 1)
            //ShowFirst = input(type = bool, defval = true)
            //ShowSecond = input(type = bool, defval = true)
            //ShowThird = input(type = bool, defval = true)
            //xEMAFirst = ema(close, LengthFirst)
            //xEMASecond = ema(close, LengthSecond)
            //xEMAThird = ema(close, LengthThird)
            //xResFirst = 100 * (close - xEMAFirst) / close
            //xResSecond = 100 * (close - xEMASecond) / close
            //xResThird = 100 * (close - xEMAThird) / close
            //pos = iff(xResThird > xResFirst, -1,
            //      iff(xResThird < xResSecond, 1, nz(pos[1], 0)))
            //barcolor(pos == -1 ? red : pos == 1 ? green : blue)
            //plot(ShowFirst ? xResFirst : na, color = red, title = "DIX 1")
            //plot(ShowSecond ? xResSecond : na, color = blue, title = "DIX 2")
            //plot(ShowThird ? xResThird : na, color = green, title = "DIX 3")
            List<decimal> firstDisparityIndexList = new();
            List<decimal> secondDisparityIndexList = new();
            List<decimal> thirdDisparityIndexList = new();
            List<decimal> avgDisparityIndexList = new();
            List<Signal> signalsList = new();

            try
            {
                int firstLength = MinOrMax(days * 10);
                int secondLength = MinOrMax((int)Math.Ceiling(days / 0.4));
                int thirdLength = days;

                List<decimal> firstEmaList = GetMovingAverageList(maType, null, stockDataClass, firstLength);
                List<decimal> secondEmaList = GetMovingAverageList(maType, null, stockDataClass, secondLength);
                List<decimal> thirdEmaList = GetMovingAverageList(maType, null, stockDataClass, thirdLength);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal firstEma = firstEmaList.ElementAtOrDefault(i);
                    decimal secondEma = secondEmaList.ElementAtOrDefault(i);
                    decimal thirdEma = thirdEmaList.ElementAtOrDefault(i);

                    decimal firstDisparityIndex = currentValue != 0 ? (currentValue - firstEma) / currentValue * 100 : 0;
                    firstDisparityIndexList.Add(firstDisparityIndex);

                    decimal secondDisparityIndex = currentValue != 0 ? (currentValue - secondEma) / currentValue * 100 : 0;
                    secondDisparityIndexList.Add(secondDisparityIndex);

                    decimal thirdDisparityIndex = currentValue != 0 ? (currentValue - thirdEma) / currentValue * 100 : 0;
                    thirdDisparityIndexList.Add(thirdDisparityIndex);

                    decimal prevAvgDisparityIndex = avgDisparityIndexList.LastOrDefault();
                    decimal avgDisparityIndex = (firstDisparityIndex + secondDisparityIndex + thirdDisparityIndex) / 3;
                    avgDisparityIndexList.Add(avgDisparityIndex);

                    var signal = GetCompareSignal(avgDisparityIndex, prevAvgDisparityIndex);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (firstDisparityIndexList, secondDisparityIndexList, thirdDisparityIndexList, avgDisparityIndexList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateBalanceOfPower(StockData stockDataClass, string maType, int days = 14)
        {
            //
            // @author LazyBear
            //
            // Balance Of Power - BOP
            //
            //study(title = "Balance of Power [LazyBear]", shorttitle = "BOP_LB")
            //PlotEMA = input(true, "Plot SMA?", type = bool)
            //PlotOuterLine = input(false, "Plot Outer line?", type = bool)
            //length = input(14, title = "MA length")
            //BOP = (close - open) / (high - low)
            //b_color = (BOP >= 0 ? (BOP >= BOP[1] ? green : orange) : (BOP >= BOP[1] ? orange : red))
            //hline(0)
            //plot(BOP, color = b_color, style = columns, linewidth = 3)
            //plot(PlotOuterLine ? BOP : na, color = gray, style = line, linewidth = 2)
            //plot(PlotEMA ? sma(BOP, length) : na, color = navy, linewidth = 2)
            List<decimal> balanceOfPowerList = new();
            List<decimal> balanceOfPowerEmaList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.ClosePrices.Count; i++)
                {
                    decimal currentClose = stockDataClass.ClosePrices.ElementAtOrDefault(i);
                    decimal currentOpen = stockDataClass.OpenPrices.ElementAtOrDefault(i);
                    decimal currentHigh = stockDataClass.HighPrices.ElementAtOrDefault(i);
                    decimal currentLow = stockDataClass.LowPrices.ElementAtOrDefault(i);

                    decimal balanceOfPower = currentHigh - currentLow != 0 ? (currentClose - currentOpen) / (currentHigh - currentLow) : 0;
                    balanceOfPowerList.Add(balanceOfPower);
                }

                balanceOfPowerEmaList = GetMovingAverageList(maType, balanceOfPowerList, stockDataClass, days);
                for (int j = 0; j < stockDataClass.ClosePrices.Count; j++)
                {
                    decimal bop = balanceOfPowerList.ElementAtOrDefault(j);
                    decimal bopMa = balanceOfPowerEmaList.ElementAtOrDefault(j);
                    decimal prevBop = j >= 1 ? balanceOfPowerList.ElementAtOrDefault(j - 1) : 0;
                    decimal prevBopMa = j >= 1 ? balanceOfPowerEmaList.ElementAtOrDefault(j - 1) : 0;

                    var signal = GetCompareSignal(bop - bopMa, prevBop - prevBopMa);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (balanceOfPowerList, balanceOfPowerEmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateRelativeVigorIndex(StockData stockDataClass, string maType, int days = 14)
        {
            // RVI Calculation
            //bar a = Close – Open
            //bar b = Close – Open one bar prior to a
            //bar c = Close – Open one bar prior to b
            //bar d = Close – Open one bar prior to c
            //numerator = [a + (2 * b) + (2 * c) + d] / 6

            //e = High – Low of bar a
            //f = High – Low of bar b
            //g = High – Low of bar c
            //h = High – Low of bar d
            //denominator = [e + (2 * f) + (2 * g) + h] / 6

            //RVI = SMA of numerator for period selected / SMA of denominator for period selected

            //Signal Line Calculation
            //i = RVI value one bar prior
            //j = RVI value one bar prior to i
            //k = RVI value one bar prior to j

            //Signal Line = [RVI + (2 * i) + (2 * j) + k] / 6
            List<decimal> aList = new();
            List<decimal> bList = new();
            List<decimal> cList = new();
            List<decimal> dList = new();
            List<decimal> eList = new();
            List<decimal> fList = new();
            List<decimal> gList = new();
            List<decimal> hList = new();
            List<decimal> mList = new();
            List<decimal> kList = new();
            List<decimal> lList = new();
            List<decimal> relativeVigorIndexList = new();
            List<decimal> numeratorList = new();
            List<decimal> denominatorList = new();
            List<decimal> numeratorAvgList = new();
            List<decimal> denominatorAvgList = new();
            List<decimal> signalLineList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.ClosePrices.Count; i++)
                {
                    decimal currentClose = stockDataClass.ClosePrices.ElementAtOrDefault(i);
                    decimal currentOpen = stockDataClass.OpenPrices.ElementAtOrDefault(i);
                    decimal currentHigh = stockDataClass.HighPrices.ElementAtOrDefault(i);
                    decimal currentLow = stockDataClass.LowPrices.ElementAtOrDefault(i);
                    decimal prevOpen1 = i >= 1 ? stockDataClass.OpenPrices.ElementAtOrDefault(i - 1) : 0;
                    decimal prevClose1 = i >= 1 ? stockDataClass.ClosePrices.ElementAtOrDefault(i - 1) : 0;
                    decimal prevHigh1 = i >= 1 ? stockDataClass.HighPrices.ElementAtOrDefault(i - 1) : 0;
                    decimal prevOpen2 = i >= 2 ? stockDataClass.OpenPrices.ElementAtOrDefault(i - 2) : 0;
                    decimal prevClose2 = i >= 2 ? stockDataClass.ClosePrices.ElementAtOrDefault(i - 2) : 0;
                    decimal prevHigh2 = i >= 2 ? stockDataClass.HighPrices.ElementAtOrDefault(i - 2) : 0;
                    decimal prevOpen3 = i >= 3 ? stockDataClass.OpenPrices.ElementAtOrDefault(i - 3) : 0;
                    decimal prevClose3 = i >= 3 ? stockDataClass.ClosePrices.ElementAtOrDefault(i - 3) : 0;
                    decimal prevHigh3 = i >= 3 ? stockDataClass.HighPrices.ElementAtOrDefault(i - 3) : 0;

                    var a = currentClose - currentOpen;
                    aList.Add(a);

                    var b = prevClose1 - prevOpen1;
                    bList.Add(b);

                    var c = prevClose2 - prevOpen2;
                    cList.Add(c);

                    var d = prevClose3 - prevOpen3;
                    dList.Add(d);

                    var e = currentHigh - currentLow;
                    eList.Add(e);

                    var f = prevHigh1 - prevOpen1;
                    fList.Add(f);

                    var g = prevHigh2 - prevOpen2;
                    gList.Add(g);

                    var h = prevHigh3 - prevOpen3;
                    hList.Add(h);

                    decimal numerator = (a + (2 * b) + (2 * c) + d) / 6;
                    numeratorList.Add(numerator);

                    decimal denominator = (e + (2 * f) + (2 * g) + h) / 6;
                    denominatorList.Add(denominator);
                }

                numeratorAvgList = GetMovingAverageList(maType, numeratorList, stockDataClass, days);
                denominatorAvgList = GetMovingAverageList(maType, denominatorList, stockDataClass, days);
                for (int j = 0; j < stockDataClass.ClosePrices.Count; j++)
                {
                    decimal numeratorAvg = numeratorAvgList.ElementAtOrDefault(j);
                    decimal denominatorAvg = denominatorAvgList.ElementAtOrDefault(j);
                    decimal prevRvi1 = j >= 1 ? relativeVigorIndexList.ElementAtOrDefault(j - 1) : 0;
                    decimal prevRvi2 = j >= 2 ? relativeVigorIndexList.ElementAtOrDefault(j - 2) : 0;
                    decimal prevRvi3 = j >= 3 ? relativeVigorIndexList.ElementAtOrDefault(j - 3) : 0;

                    decimal rvi = denominatorAvg != 0 ? numeratorAvg / denominatorAvg : 0;
                    relativeVigorIndexList.Add(rvi);

                    var k = prevRvi1;
                    kList.Add(k);

                    var l = prevRvi2;
                    lList.Add(l);

                    var m = prevRvi3;
                    mList.Add(m);

                    decimal prevSignalLine = signalLineList.LastOrDefault();
                    decimal signalLine = (rvi + (2 * k) + (2 * l) + m) / 6;
                    signalLineList.Add(signalLine);

                    var signal = GetCompareSignal(rvi - signalLine, prevRvi1 - prevSignalLine);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (aList, bList, cList, dList, eList, fList, gList, hList, numeratorList, denominatorList, numeratorAvgList, denominatorAvgList, relativeVigorIndexList,
                kList, lList, mList, signalLineList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>)
            CalculateNormalizedRelativeVigorIndex(StockData stockDataClass, string maType, int days = 10)
        {
            //@version=3
            // Copyright (c) 2018-present, Alex Orekhov (everget)
            //study("Normalized Relative Vigor Index", shorttitle = "N-RVGI")

            //length = input(title = "Length", type = integer, defval = 10, minval = 1)
            //applyFilling = input(title = "Apply Ribbon Filling ?", type = bool, defval = true)

            //rvgi = sum(swma(close - open), length) / sum(swma(high - low), length)
            //signal = swma(rvgi)

            //trendColor = rvgi > signal ? #0ebb23 : red

            //rvgiColor = applyFilling ? trendColor : #0094ff
            //signalColor = applyFilling ? trendColor : #ff6a00

            //rvgiPlot = plot(100 * rvgi, title = "N-RVGI", color = rvgiColor, transp = 0)
            //signalPlot = plot(100 * signal, title = "Signal", color = signalColor, transp = 0)
            //hline(0, title = "Zero Level", linestyle = dotted)

            //transparent = color(white, 100)

            //fillColor = applyFilling ? trendColor : transparent
            //fill(rvgiPlot, signalPlot, color = fillColor, transp = 70)
            List<decimal> closeOpenList = new();
            List<decimal> highLowList = new();
            List<decimal> swmaCloseOpenList = new();
            List<decimal> swmaHighLowList = new();
            List<decimal> tempCloseOpenList = new();
            List<decimal> tempHighLowList = new();
            List<decimal> swmaCloseOpenSumList = new();
            List<decimal> swmaHighLowSumList = new();
            List<decimal> rvgiList = new();
            List<decimal> nrvgiList = new();
            List<decimal> signalList = new();
            List<decimal> nSignalList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.ClosePrices.Count; i++)
                {
                    decimal currentClose = stockDataClass.ClosePrices.ElementAtOrDefault(i);
                    decimal currentOpen = stockDataClass.OpenPrices.ElementAtOrDefault(i);
                    decimal currentHigh = stockDataClass.HighPrices.ElementAtOrDefault(i);
                    decimal currentLow = stockDataClass.LowPrices.ElementAtOrDefault(i);

                    decimal closeOpen = currentClose - currentOpen;
                    closeOpenList.Add(closeOpen);

                    decimal highLow = currentHigh - currentLow;
                    highLowList.Add(highLow);
                }

                swmaCloseOpenList = GetMovingAverageList(maType, closeOpenList, stockDataClass, days);
                swmaHighLowList = GetMovingAverageList(maType, highLowList, stockDataClass, days);
                for (int j = 0; j < stockDataClass.ClosePrices.Count; j++)
                {
                    decimal swmaCloseOpen = swmaCloseOpenList.ElementAtOrDefault(j);
                    tempCloseOpenList.Add(swmaCloseOpen);

                    decimal closeOpenSum = tempCloseOpenList.TakeLast(days).Sum();
                    swmaCloseOpenSumList.Add(closeOpenSum);

                    decimal swmaHighLow = swmaHighLowList.ElementAtOrDefault(j);
                    tempHighLowList.Add(swmaHighLow);

                    decimal highLowSum = tempHighLowList.TakeLast(days).Sum();
                    swmaHighLowSumList.Add(highLowSum);

                    decimal rvgi = highLowSum != 0 ? closeOpenSum / highLowSum : 0;
                    rvgiList.Add(rvgi);
                }

                signalList = GetMovingAverageList(maType, rvgiList, stockDataClass, days);
                for (int k = 0; k < stockDataClass.ClosePrices.Count; k++)
                {
                    decimal rvgi = rvgiList.ElementAtOrDefault(k);
                    decimal sig = signalList.ElementAtOrDefault(k);

                    decimal prevNrvgi = nrvgiList.LastOrDefault();
                    decimal nRvgi = rvgi * 100;
                    nrvgiList.Add(nRvgi);

                    decimal prevNsignal = nSignalList.LastOrDefault();
                    decimal nSignal = sig * 100;
                    nSignalList.Add(nSignal);

                    var signal = GetCompareSignal(nRvgi - nSignal, prevNrvgi - prevNsignal);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (swmaCloseOpenList, swmaHighLowList, swmaCloseOpenSumList, swmaHighLowSumList, rvgiList, signalList, nrvgiList, nSignalList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateEhlersRelativeVigorIndex(StockData stockDataClass, string maType, int days = 4)
        {
            //Relative Vigor Index (1) = (Close-Open) / (High-Low)
            //In order to smooth the resulting value, one may use a Simple Moving Average(SMA) with a period of 10.Or,
            //Relative Vigor Index(10) = 10 - period SMA of Relative Vigor Index(1)
            List<decimal> rviList = new();
            List<decimal> rviSmaList = new();
            List<decimal> rviSignalList = new();
            List<Signal> signalsList = new();

            try
            {
                int smoothPeriod = (int)Math.Ceiling(days / 0.4);
                int signalPeriod = days;

                for (int i = 0; i < stockDataClass.HighPrices.Count; i++)
                {
                    decimal currentClose = stockDataClass.ClosePrices.ElementAtOrDefault(i);
                    decimal currentOpen = stockDataClass.OpenPrices.ElementAtOrDefault(i);
                    decimal currentHigh = stockDataClass.HighPrices.ElementAtOrDefault(i);
                    decimal currentLow = stockDataClass.LowPrices.ElementAtOrDefault(i);

                    decimal rvi = currentHigh - currentLow != 0 ? (currentClose - currentOpen) / (currentHigh - currentLow) : 0;
                    rviList.Add(rvi);
                }

                rviSmaList = GetMovingAverageList(maType, rviList, stockDataClass, smoothPeriod);
                rviSignalList = GetMovingAverageList(maType, rviSmaList, stockDataClass, signalPeriod);
                for (int j = 0; j < stockDataClass.HighPrices.Count; j++)
                {
                    decimal rviSma = rviSmaList.ElementAtOrDefault(j);
                    decimal prevRviSma = j >= 1 ? rviSmaList.ElementAtOrDefault(j - 1) : 0;
                    decimal rviSignal = rviSignalList.ElementAtOrDefault(j);
                    decimal prevRviSignal = j >= 1 ? rviSignalList.ElementAtOrDefault(j - 1) : 0;

                    var signal = GetCompareSignal(rviSma - rviSignal, prevRviSma - prevRviSignal);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (rviList, rviSmaList, rviSignalList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<Signal>) CalculateTimeAndMoneyChannel(StockData stockDataClass, string maType, int days = 41)
        {
            //
            // @author LazyBear
            //
            // If you use this code in its original/modified form, do drop me a note. 
            //
            //study("Time and Money Chart Channel [LazyBear]", shorttitle = "TAMC_LB", overlay = true)
            //length = input(41)
            //showPriceTracker = input(false, type = bool)
            //prev(s, x) =>
            //y = abs(round(x))
            //s[y]

            //halfLength = floor(length / 2)
            //basis = sma(close, length)
            //plot(basis, title = "Minor term avg", color = maroon, style = 3)
            //yom = 100 * (close - prev(basis, halfLength)) / prev(basis, halfLength)
            //avyom = sma(yom, 2 * length)
            //varyom = sma(yom * yom, 2 * length) - avyom * avyom
            //som = prev(sqrt(varyom), halfLength)
            //sigom = sma(som, length)

            //plot(basis * (1 + 0.01 * sigom), title = "Ch+1", color = red, trackprice = showPriceTracker)
            //plot(basis * (1 - 0.01 * sigom), title = "Ch-1", color = green, trackprice = showPriceTracker)
            //plot(basis * (1 + 0.02 * sigom), title = "Ch+2", color = red, trackprice = showPriceTracker)
            //plot(basis * (1 - 0.02 * sigom), title = "Ch-2", color = green, trackprice = showPriceTracker)
            //plot(basis * (1 + 0.03 * sigom), title = "Ch+3", color = red, trackprice = showPriceTracker)
            //plot(basis * (1 - 0.03 * sigom), title = "Ch-3", color = green, trackprice = showPriceTracker)
            List<decimal> yomList = new();
            List<decimal> avyomList = new();
            List<decimal> yomSquaredList = new();
            List<decimal> yomSquaredSmaList = new();
            List<decimal> varyomList = new();
            List<decimal> somList = new();
            List<decimal> sigomList = new();
            List<decimal> chPlus1List = new();
            List<decimal> chMinus1List = new();
            List<decimal> chPlus2List = new();
            List<decimal> chMinus2List = new();
            List<decimal> chPlus3List = new();
            List<decimal> chMinus3List = new();
            List<Signal> signalsList = new();

            try
            {
                int halfLength = MinOrMax((int)Math.Ceiling((decimal)days / 2));

                List<decimal> smaList = GetMovingAverageList(maType, null, stockDataClass, days);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevBasis = i >= halfLength ? smaList.ElementAtOrDefault(i - halfLength) : 0;

                    decimal yom = prevBasis != 0 ? 100 * (currentValue - prevBasis) / prevBasis : 0;
                    yomList.Add(yom);

                    decimal yomSquared = yom * yom;
                    yomSquaredList.Add(yomSquared);
                }

                avyomList = GetMovingAverageList(maType, yomList, stockDataClass, days * 2);
                yomSquaredSmaList = GetMovingAverageList(maType, yomSquaredList, stockDataClass, days * 2);
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal prevVaryom = j >= halfLength ? varyomList.ElementAtOrDefault(j - halfLength) : 0;
                    decimal avyom = avyomList.ElementAtOrDefault(j);
                    decimal yomSquaredSma = yomSquaredSmaList.ElementAtOrDefault(j);

                    decimal varyom = yomSquaredSma - (avyom * avyom);
                    varyomList.Add(varyom);

                    decimal som = prevVaryom >= 0 ? (decimal)Sqrt((double)prevVaryom) : 0;
                    somList.Add(som);
                }

                sigomList = GetMovingAverageList(maType, somList, stockDataClass, days);
                for (int k = 0; k < stockDataClass.InputValues.Count; k++)
                {
                    decimal som = somList.ElementAtOrDefault(k);
                    decimal prevSom = k >= 1 ? somList.ElementAtOrDefault(k - 1) : 0;
                    decimal sigom = sigomList.ElementAtOrDefault(k);
                    decimal prevSigom = k >= 1 ? sigomList.ElementAtOrDefault(k - 1) : 0;
                    decimal basis = smaList.ElementAtOrDefault(k);

                    decimal chPlus1 = basis * (1 + (0.01m * sigom));
                    chPlus1List.Add(chPlus1);

                    decimal chMinus1 = basis * (1 - (0.01m * sigom));
                    chMinus1List.Add(chMinus1);

                    decimal chPlus2 = basis * (1 + (0.02m * sigom));
                    chPlus2List.Add(chPlus2);

                    decimal chMinus2 = basis * (1 - (0.02m * sigom));
                    chMinus2List.Add(chMinus2);

                    decimal chPlus3 = basis * (1 + (0.03m * sigom));
                    chPlus3List.Add(chPlus3);

                    decimal chMinus3 = basis * (1 - (0.03m * sigom));
                    chMinus3List.Add(chMinus3);

                    var signal = GetCompareSignal(som - sigom, prevSom - prevSigom);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (yomList, avyomList, yomSquaredList, yomSquaredSmaList, varyomList, somList, sigomList, chPlus1List, chMinus1List, chPlus2List, chMinus2List, chPlus3List, chMinus3List, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateElderRayBearandBullPower(StockData stockDataClass,
            string maType, int days = 13)
        {
            // bull power = high - 13 day ema
            // bear power = low - 13 day ema
            List<decimal> bullPowerList = new();
            List<decimal> bearPowerList = new();
            List<Signal> signalsList = new();

            try
            {
                List<decimal> emaList = GetMovingAverageList(maType, null, stockDataClass, days);
                var minMaxList = VolumeInputCheck(stockDataClass, days, false);
                var highList = minMaxList.Item1;
                var lowList = minMaxList.Item2;

                for (int i = 0; i < stockDataClass.HighPrices.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal currentHigh = highList.ElementAtOrDefault(i);
                    decimal currentLow = lowList.ElementAtOrDefault(i);
                    decimal currentEma = emaList.ElementAtOrDefault(i);

                    decimal prevBullPower = bullPowerList.LastOrDefault();
                    decimal bullPower = currentHigh - currentEma;
                    bullPowerList.Add(bullPower);

                    decimal prevBearPower = bearPowerList.LastOrDefault();
                    decimal bearPower = currentLow - currentEma;
                    bearPowerList.Add(bearPower);

                    var signal = GetCompareSignal(bullPower - bearPower, prevBullPower - prevBearPower);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (bullPowerList, bearPowerList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateTopsAndBottomsFinder(StockData stockDataClass, string maType, int days = 50)
        {
            //@version=2
            //study("Tops & Bottoms Finder", overlay = true)
            //length = input(50)
            //----
            //a = ema(close, length)
            //b = stdev(a > a[1] ? a : 0, length)
            //c = stdev(a < a[1] ? a : 0, length)
            //up = a / (a + b)
            //dn = a / (a + c)
            //----
            //os = up[1] == 1 and up != 1 ? 1 : dn[1] == 1 and dn != 1 ? -1 : na
            //plotarrow(os, colorup =#2196f3,colordown=red,transp=0)
            List<decimal> bList = new();
            List<decimal> cList = new();
            List<decimal> bStdDevList = new();
            List<decimal> cStdDevList = new();
            List<decimal> upList = new();
            List<decimal> dnList = new();
            List<decimal> osList = new();
            List<Signal> signalsList = new();

            try
            {
                List<decimal> emaList = GetMovingAverageList(maType, null, stockDataClass, days);

                for (int i = 0; i < stockDataClass.HighPrices.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal a = emaList.ElementAtOrDefault(i);
                    decimal prevA = i >= 1 ? emaList.ElementAtOrDefault(i - 1) : 0;

                    decimal b = a > prevA ? a : 0;
                    bList.Add(b);

                    decimal c = a < prevA ? a : 0;
                    cList.Add(c);
                }

                bStdDevList = CalculateStandardDeviationVolatility(bList, stockDataClass, days).Item4;
                cStdDevList = CalculateStandardDeviationVolatility(cList, stockDataClass, days).Item4;
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal a = emaList.ElementAtOrDefault(j);
                    decimal b = bStdDevList.ElementAtOrDefault(j);
                    decimal c = cStdDevList.ElementAtOrDefault(j);

                    decimal prevUp = upList.LastOrDefault();
                    decimal up = a + b != 0 ? a / (a + b) : 0;
                    upList.Add(up);

                    decimal prevDn = dnList.LastOrDefault();
                    decimal dn = a + c != 0 ? a / (a + c) : 0;
                    dnList.Add(dn);

                    decimal os = prevUp == 1 && up != 1 ? 1 : prevDn == 1 && dn != 1 ? -1 : 0;
                    osList.Add(os);

                    var signal = GetConditionSignal(os > 0, os < 0);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (bList, cList, bStdDevList, cStdDevList, upList, dnList, osList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculatePeakValleyEstimation(StockData stockDataClass, string maType, int days = 100)
        {
            //@version=3
            //study("Peak/Valley Estimation", overlay = true)
            //length = input(500),smooth = input(100),mod = input(type = integer, defval = 1, options =[1, 2, 3])
            //
            //src = close
            //os = src - sma(src, length)
            //p = linreg(abs(os), smooth, 0)
            //h = p / highest(p, length)
            //
            //cnd = mod == 1 ? h == 1 and h[1] != 1 : mod == 2 ? crossunder(h, 0.8) : mod == 3 ? h[1] == 1 and h < h[1] : na
            // sign = cnd and os< 0 ? 1 : cnd and os > 0 ? -1 : 0
            //
            //plotarrow(sign)
            List<decimal> sign1List = new();
            List<decimal> sign2List = new();
            List<decimal> sign3List = new();
            List<decimal> mod1List = new();
            List<decimal> mod2List = new();
            List<decimal> mod3List = new();
            List<decimal> osList = new();
            List<decimal> absOsList = new();
            List<decimal> hList = new();
            List<Signal> signalsList = new();

            try
            {
                int length = days * 5;
                int smooth = days;

                var smaList = GetMovingAverageList(maType, null, stockDataClass, length);

                for (int h = 0; h < stockDataClass.InputValues.Count; h++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(h);
                    decimal sma = smaList.ElementAtOrDefault(h);

                    decimal os = currentValue - sma;
                    osList.Add(os);

                    decimal absOs = Math.Abs(os);
                    absOsList.Add(absOs);
                }

                var pList = CalculateLinearRegression(absOsList, stockDataClass, smooth).Item15;
                var highestList = GetMaxAndMinValuesList(pList, length).Item1;
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal os = osList.ElementAtOrDefault(i);
                    decimal p = pList.ElementAtOrDefault(i);
                    decimal highest = highestList.ElementAtOrDefault(i);

                    decimal prevH = i >= 1 ? hList.ElementAtOrDefault(i - 1) : 0;
                    decimal h = highest != 0 ? p / highest : 0;
                    hList.Add(h);

                    decimal mod1 = h == 1 && prevH != 1 ? 1 : 0;
                    mod1List.Add(mod1);

                    decimal mod2 = h < 0.8m ? 1 : 0;
                    mod2List.Add(mod2);

                    decimal mod3 = prevH == 1 && h < prevH ? 1 : 0;
                    mod3List.Add(mod3);

                    decimal sign1 = mod1 == 1 && os < 0 ? 1 : mod1 == 1 && os > 0 ? -1 : 0;
                    sign1List.Add(sign1);

                    decimal sign2 = mod2 == 1 && os < 0 ? 1 : mod2 == 1 && os > 0 ? -1 : 0;
                    sign2List.Add(sign2);

                    decimal sign3 = mod3 == 1 && os < 0 ? 1 : mod2 == 1 && os > 0 ? -1 : 0;
                    sign3List.Add(sign3);

                    var signal = GetConditionSignal(sign1 > 0, sign1 < 0);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (mod1List, mod2List, mod3List, sign1List, sign2List, sign3List, signalsList);
        }

        public static (List<decimal>, List<Signal>) CalculateRepulsionMovingAverage(StockData stockDataClass, string maType, int days = 100)
        {
            //@version=2
            //study("Repulsion Moving Average", overlay = true)
            //length = input(100)
            //
            //ma = sma(close, length * 3) + sma(close, length * 2) - sma(close, length)
            //plot(ma, color =#2ECCFA,transp=0)
            List<decimal> maList = new();
            List<Signal> signalsList = new();

            try
            {
                var sma1List = GetMovingAverageList(maType, null, stockDataClass, days);
                var sma2List = GetMovingAverageList(maType, null, stockDataClass, days * 2);
                var sma3List = GetMovingAverageList(maType, null, stockDataClass, days * 3);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal sma1 = sma1List.ElementAtOrDefault(i);
                    decimal sma2 = sma2List.ElementAtOrDefault(i);
                    decimal sma3 = sma3List.ElementAtOrDefault(i);

                    decimal prevMa = maList.LastOrDefault();
                    decimal ma = sma3 + sma2 - sma1;
                    maList.Add(ma);

                    var signal = GetCompareSignal(currentValue - ma, prevValue - prevMa);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (maList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateRepulse(StockData stockDataClass, string maType, int days = 5)
        {
            //@version=3
            // Copyright (c) 2018-present, Alex Orekhov (everget)
            // Repulse script may be freely distributed under the MIT license.
            //study("Repulse")

            //length = input(title = "Length", type = integer, minval = 1, defval = 5)

            //bullPower = 100 * (3 * close - 2 * lowest(length) - open[length - 1]) / close

            //bearPower = 100 * (open[length - 1] + 2 * highest(length) - 3 * close) / close

            //repulse = ema(bullPower, 5 * length) - ema(bearPower, 5 * length)

            //repulseColor = repulse >= repulse[1] ? #0ebb23 : red
            //plot(repulse, title = "Repulse", linewidth = 2, color = repulseColor, transp = 0)

            //hline(0, title = "Zero Level", linestyle = dotted)
            List<decimal> tempHighList = new();
            List<decimal> tempLowList = new();
            List<decimal> bullPowerList = new();
            List<decimal> bearPowerList = new();
            List<decimal> bullPowerEmaList = new();
            List<decimal> bearPowerEmaList = new();
            List<decimal> repulseList = new();
            List<decimal> repulseEmaList = new();
            List<Signal> signalsList = new();

            try
            {
                int length = days;
                int emaLength = MinOrMax(length * 5);

                for (int i = 0; i < stockDataClass.HighPrices.Count; i++)
                {
                    decimal currentHigh = stockDataClass.HighPrices.ElementAtOrDefault(i);
                    tempHighList.Add(currentHigh);

                    decimal currentLow = stockDataClass.LowPrices.ElementAtOrDefault(i);
                    tempLowList.Add(currentLow);

                    decimal currentClose = stockDataClass.ClosePrices.ElementAtOrDefault(i);
                    decimal lowestLow = tempLowList.TakeLast(length).Min();
                    decimal highestHigh = tempHighList.TakeLast(length).Max();
                    decimal prevOpen = i >= 1 ? stockDataClass.OpenPrices.ElementAtOrDefault(i - 1) : 0;

                    decimal bullPower = currentClose != 0 ? 100 * ((3 * currentClose) - (2 * lowestLow) - prevOpen) / currentClose : 0;
                    bullPowerList.Add(bullPower);

                    decimal bearPower = currentClose != 0 ? 100 * (prevOpen + (2 * highestHigh) - (3 * currentClose)) / currentClose : 0;
                    bearPowerList.Add(bearPower);
                }

                bullPowerEmaList = GetMovingAverageList(maType, bullPowerList, stockDataClass, emaLength);
                bearPowerEmaList = GetMovingAverageList(maType, bearPowerList, stockDataClass, emaLength);
                for (int j = 0; j < stockDataClass.HighPrices.Count; j++)
                {
                    decimal bullPowerEma = bullPowerEmaList.ElementAtOrDefault(j);
                    decimal bearPowerEma = bearPowerEmaList.ElementAtOrDefault(j);

                    decimal prevRepulse = repulseList.LastOrDefault();
                    decimal repulse = bullPowerEma - bearPowerEma;
                    repulseList.Add(repulse);

                    decimal prevRepulseEma = repulseEmaList.LastOrDefault();
                    decimal repulseEma = CalculateExponentialMovingAverage(repulse, repulseEmaList.LastOrDefault(), length);
                    repulseEmaList.Add(repulseEma);

                    var signal = GetCompareSignal(repulse - repulseEma, prevRepulse - prevRepulseEma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (bullPowerList, bullPowerEmaList, bearPowerList, bearPowerEmaList, repulseList, repulseEmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>)
            CalculateDemandOscillator(StockData stockDataClass, string maType, int days = 2)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Demand Oscillator script may be freely distributed under the MIT license.
            //study("Demand Oscillator", shorttitle = "DO", overlay = false)

            //length = input(title = "Length", type = input.integer, defval = 10, minval = 1)
            //src = input(title = "Source", type = input.source, defval = close)

            //range = highest(2) - lowest(2)
            //va = ema(range, length)
            //k = va != 0 ? (3 * src) / va : 0
            //pctChg = src[1] != 0 ? (src - src[1]) / abs(src[1]) * 100 : 0
            //bp = src > src[1] ? volume : volume / (pctChg * k)
            //sp = src > src[1] ? volume / (pctChg * k) : volume
            //do = sma(bp - sp, length * 2)
            //sig = ema(do, length)

            //hline(0)
            //doColor = (do > sig ? color.green : do < sig ? color.red : color.black)
            //plot(do, color = doColor, linewidth = 1)
            //plot(sig, color = color.black, linewidth = 1)
            List<decimal> kList = new();
            List<decimal> pctKList = new();
            List<decimal> volPctKList = new();
            List<decimal> bpList = new();
            List<decimal> spList = new();
            List<decimal> rangeList = new();
            List<decimal> vaList = new();
            List<decimal> doList = new();
            List<decimal> doSmaList = new();
            List<decimal> doSigList = new();
            List<Signal> signalsList = new();

            try
            {
                int length = days * 5;

                var list = VolumeInputCheck(stockDataClass, days, true);
                var highList = list.Item1;
                var lowList = list.Item2;

                for (int h = 0; h < stockDataClass.HighPrices.Count; h++)
                {
                    decimal highest = highList.ElementAtOrDefault(h);
                    decimal lowest = lowList.ElementAtOrDefault(h);

                    decimal range = highest - lowest;
                    rangeList.Add(range);
                }

                vaList = GetMovingAverageList(maType, rangeList, stockDataClass, length);
                for (int i = 0; i < stockDataClass.HighPrices.Count; i++)
                {
                    decimal va = vaList.ElementAtOrDefault(i);
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal pctChg = prevValue != 0 ? (currentValue - prevValue) / Math.Abs(prevValue) * 100 : 0;
                    decimal currentVolume = stockDataClass.Volumes.ElementAtOrDefault(i);

                    decimal k = va != 0 ? (3 * currentValue) / va : 0;
                    kList.Add(k);

                    decimal pctK = pctChg * k;
                    pctKList.Add(pctK);

                    decimal volPctK = pctK != 0 ? currentVolume / pctK : 0;
                    volPctKList.Add(volPctK);

                    decimal bp = currentValue > prevValue ? currentVolume : volPctK;
                    bpList.Add(bp);

                    decimal sp = currentValue > prevValue ? volPctK : currentVolume;
                    spList.Add(sp);

                    decimal dosc = bp - sp;
                    doList.Add(dosc);

                    decimal doSma = doList.TakeLast(length * 2).Average();
                    doSmaList.Add(doSma);
                }

                doSigList = GetMovingAverageList(maType, doSmaList, stockDataClass, length);
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal doSig = doSigList.ElementAtOrDefault(j);
                    decimal prevSig1 = j >= 1 ? doSigList.ElementAtOrDefault(j - 1) : 0;
                    decimal prevSig2 = j >= 2 ? doSigList.ElementAtOrDefault(j - 1) : 0;

                    var signal = GetCompareSignal(doSig - prevSig1, prevSig1 - prevSig2);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (vaList, kList, pctKList, volPctKList, bpList, spList, doList, doSmaList, doSigList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<Signal>) CalculateUberTrendIndicator(StockData stockDataClass, int days = 14)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Uber Trend Indicator script may be freely distributed under the MIT license.
            //study("Uber Trend Indicator", shorttitle = "UTI", overlay = false)

            //length = input(title = "Length", type = input.integer, defval = 14, minval = 1)
            //src = input(title = "Source", type = input.source, defval = close)

            //advSum = sum(src > src[1] ? src - src[1] : 0, length)
            //decSum = sum(src < src[1] ? src[1] - src : 0, length)
            //advVolSum = sum(src > src[1] and advSum != 0 ? volume / advSum : 0, length)
            //decVolSum = sum(src < src[1] and decSum != 0 ? volume / decSum : 0, length)
            //top = decSum != 0 ? advSum / decSum : 0
            //bot = decVolSum != 0 ? advVolSum / decVolSum : 0
            //ut = bot != 0 ? top / bot : 0
            //uti = ut + 1 != 0 ? (ut - 1) / (ut + 1) : 0

            //hline(0)
            //utiColor = uti > 0 ? color.green : uti < 0 ? color.red : color.black
            //plot(uti, color = utiColor, linewidth = 2)
            List<decimal> advSumList = new();
            List<decimal> decSumList = new();
            List<decimal> advList = new();
            List<decimal> decList = new();
            List<decimal> advVolSumList = new();
            List<decimal> decVolSumList = new();
            List<decimal> advVolList = new();
            List<decimal> decVolList = new();
            List<decimal> topList = new();
            List<decimal> botList = new();
            List<decimal> utList = new();
            List<decimal> utRevList = new();
            List<decimal> utiList = new();
            List<Signal> signalsList = new();

            try
            {
                int hvpLength = (int)Math.Ceiling(days / 0.7);

                var hvpList = CalculateHistoricalVolatilityPercentile(stockDataClass, hvpLength).Item4;
                var hvpSmaList = GetMovingAverageList("SimpleMovingAverage", hvpList, stockDataClass, hvpLength);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal currentVolume = stockDataClass.Volumes.ElementAtOrDefault(i);
                    decimal hvp = hvpList.ElementAtOrDefault(i);
                    decimal hvpSma = hvpSmaList.ElementAtOrDefault(i);

                    decimal adv = currentValue > prevValue ? currentValue - prevValue : 0;
                    advList.Add(adv);

                    decimal dec = currentValue < prevValue ? prevValue - currentValue : 0;
                    decList.Add(dec);

                    decimal advSum = advList.TakeLast(days).Sum();
                    advSumList.Add(advSum);

                    decimal decSum = decList.TakeLast(days).Sum();
                    decSumList.Add(decSum);

                    decimal advVol = currentValue > prevValue && advSum != 0 ? currentVolume / advSum : 0;
                    advVolList.Add(advVol);

                    decimal decVol = currentValue < prevValue && decSum != 0 ? currentVolume / decSum : 0;
                    decVolList.Add(decVol);

                    decimal advVolSum = advVolList.TakeLast(days).Sum();
                    advVolSumList.Add(advVolSum);

                    decimal decVolSum = decVolList.TakeLast(days).Sum();
                    decVolSumList.Add(decVolSum);

                    decimal top = decSum != 0 ? advSum / decSum : 0;
                    topList.Add(top);

                    decimal bot = decVolSum != 0 ? advVolSum / decVolSum : 0;
                    botList.Add(bot);

                    decimal ut = bot != 0 ? top / bot : 0;
                    utList.Add(ut);

                    decimal utRev = top != 0 ? -1 * bot / top : 0;
                    utRevList.Add(utRev);

                    decimal uti = ut + 1 != 0 ? (ut - 1) / (ut + 1) : 0;
                    utiList.Add(uti);

                    var signal = GetConditionSignal(uti > 0 && hvpSma < 45, hvp > 98 && hvp < hvpSma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (advVolList, decVolList, advVolSumList, decVolSumList, topList, botList, utList, utRevList, utiList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateMassThrustIndicator(StockData stockDataClass, string maType, int days = 14)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Mass Thrust Indicator script may be freely distributed under the MIT license.
            //study("Mass Thrust Indicator", shorttitle = "MTI", overlay = false)

            //length = input(title = "Length", type = input.integer, defval = 14, minval = 1)
            //src = input(title = "Source", type = input.source, defval = close)

            //advSum = sum(src > src[1] ? src - src[1] : 0, length)
            //decSum = sum(src < src[1] ? src[1] - src : 0, length)
            //advVolSum = sum(src > src[1] and advSum != 0 ? volume / advSum : 0, length)
            //decVolSum = sum(src < src[1] and decSum != 0 ? volume / decSum : 0, length)
            //mti = ema(((advSum * advVolSum) - (decSum * decVolSum)) / 1000000, length)

            //hline(0)
            //mtiColor = mti > 0 ? color.green : mti < 0 ? color.red : color.black
            //plot(mti, color = mtiColor, linewidth = 2)
            List<decimal> mtiList = new();
            List<decimal> mtiEmaList = new();
            List<Signal> signalsList = new();

            try
            {
                var utiList = CalculateUberTrendIndicator(stockDataClass, days);
                var advSumList = utiList.Item1;
                var decSumList = utiList.Item2;
                var advVolSumList = utiList.Item5;
                var decVolSumList = utiList.Item6;

                for (int h = 0; h < stockDataClass.InputValues.Count; h++)
                {
                    decimal advSum = advSumList.ElementAtOrDefault(h);
                    decimal decSum = decSumList.ElementAtOrDefault(h);
                    decimal advVolSum = advVolSumList.ElementAtOrDefault(h);
                    decimal decVolSum = decVolSumList.ElementAtOrDefault(h);

                    decimal mti = ((advSum * advVolSum) - (decSum * decVolSum)) / 1000000;
                    mtiList.Add(mti);
                }

                mtiEmaList = GetMovingAverageList(maType, mtiList, stockDataClass, days);
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal mtiEma = mtiEmaList.ElementAtOrDefault(i);
                    decimal prevMtiEma = i >= 1 ? mtiEmaList.ElementAtOrDefault(i - 1) : 0;

                    var signal = GetCompareSignal(mtiEma, prevMtiEma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (mtiList, mtiEmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateMassThrustOscillator(StockData stockDataClass, int days = 14)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Mass Thrust Oscillator script may be freely distributed under the MIT license.
            //study("Mass Thrust Oscillator", shorttitle = "MTO", overlay = false)

            //length = input(title = "Length", type = input.integer, defval = 14, minval = 1)
            //obLevel = input(title = "ObLevel", type = input.integer, defval = 50, minval = 1)
            //osLevel = input(title = "OsLevel", type = input.integer, defval = -50, minval = 1)
            //src = input(title = "Source", type = input.source, defval = close)

            //advSum = sum(src > src[1] ? src - src[1] : 0, length)
            //decSum = sum(src < src[1] ? src[1] - src : 0, length)
            //advVolSum = sum(src > src[1] and advSum != 0 ? volume / advSum : 0, length)
            //decVolSum = sum(src < src[1] and decSum != 0 ? volume / decSum : 0, length)
            //top = ((advSum * advVolSum) - (decSum * decVolSum))
            //bot = ((advSum * advVolSum) + (decSum * decVolSum))
            //mto = bot != 0 ? 100 * top / bot : 0
            //sig = ema(mto, length)

            //hline(obLevel, color = color.green)
            //hline(0)
            //hline(osLevel, color = color.red)
            //mtoColor = mto > sig or(mto[1] < osLevel and mto > osLevel) ? color.green : mto < sig or(mto[1] > obLevel and mto < obLevel) ? color.red : color.black
            //plot(mto, color = mtoColor, linewidth = 2)
            //plot(sig, color = color.black, linewidth = 1)
            List<decimal> topList = new();
            List<decimal> botList = new();
            List<decimal> mtoList = new();
            List<decimal> mtoEmaList = new();
            List<Signal> signalsList = new();

            try
            {
                var utiList = CalculateUberTrendIndicator(stockDataClass, days);
                var advSumList = utiList.Item1;
                var decSumList = utiList.Item2;
                var advVolSumList = utiList.Item5;
                var decVolSumList = utiList.Item6;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal advSum = advSumList.ElementAtOrDefault(i);
                    decimal decSum = decSumList.ElementAtOrDefault(i);
                    decimal advVolSum = advVolSumList.ElementAtOrDefault(i);
                    decimal decVolSum = decVolSumList.ElementAtOrDefault(i);

                    decimal top = ((advSum * advVolSum) - (decSum * decVolSum));
                    topList.Add(top);

                    decimal bot = ((advSum * advVolSum) - (decSum * decVolSum));
                    botList.Add(bot);

                    decimal prevMto = mtoList.LastOrDefault();
                    decimal mto = bot != 0 ? 100 * top / bot : 0;
                    mtoList.Add(mto);

                    decimal prevMtoEma = mtoEmaList.LastOrDefault();
                    decimal mtoEma = CalculateExponentialMovingAverage(mto, prevMtoEma, days);
                    mtoEmaList.Add(mtoEma);

                    var signal = GetRsiSignal(mto - mtoEma, prevMto - prevMtoEma, mto, prevMto, 50, -50);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (topList, botList, mtoList, mtoEmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateDoubleSmoothedMomenta(StockData stockDataClass, string maType, int days = 2)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // decimal Smoothed Momenta script may be freely distributed under the MIT license.
            //study("decimal Smoothed Momenta", shorttitle = "DSM", overlay = false)

            //aLength = input(title = "ALength", type = input.integer, defval = 2, minval = 1)
            //yLength = input(title = "YLength", type = input.integer, defval = 5, minval = 1)
            //zLength = input(title = "ZLength", type = input.integer, defval = 25, minval = 1)
            //src = input(title = "Source", type = input.source, defval = close)

            //hc = highest(src, aLength)
            //lc = lowest(src, aLength)
            //top = ema(ema(src - lc, yLength), zLength)
            //bot = ema(ema(hc - lc, yLength), zLength)
            //mom = bot != 0 ? 100 * top / bot : 0
            //sig = ema(mom, zLength)

            //hline(50)
            //momColor = mom > sig ? color.green : mom < sig ? color.red : color.black
            //plot(mom, color = momColor, linewidth = 1)
            //plot(sig, color = color.black, linewidth = 1)
            List<decimal> topEma1List = new();
            List<decimal> topEma2List = new();
            List<decimal> botEma1List = new();
            List<decimal> botEma2List = new();
            List<decimal> momList = new();
            List<decimal> momEmaList = new();
            List<decimal> srcLcList = new();
            List<decimal> hcLcList = new();
            List<Signal> signalsList = new();

            try
            {
                int yLength = (int)Math.Ceiling(days / 0.4);
                int zLength = yLength * 5;

                var list = GetMaxAndMinValuesList(stockDataClass.InputValues, days);
                var hcList = list.Item1;
                var lcList = list.Item2;

                for (int h = 0; h < stockDataClass.InputValues.Count; h++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(h);
                    decimal hc = hcList.ElementAtOrDefault(h);
                    decimal lc = lcList.ElementAtOrDefault(h);

                    decimal srcLc = currentValue - lc;
                    srcLcList.Add(srcLc);

                    decimal hcLc = hc - lc;
                    hcLcList.Add(hcLc);
                }

                topEma1List = GetMovingAverageList(maType, srcLcList, stockDataClass, yLength);
                topEma2List = GetMovingAverageList(maType, topEma1List, stockDataClass, zLength);
                botEma1List = GetMovingAverageList(maType, hcLcList, stockDataClass, yLength);
                botEma2List = GetMovingAverageList(maType, botEma1List, stockDataClass, zLength);
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal top = topEma2List.ElementAtOrDefault(i);
                    decimal bot = botEma2List.ElementAtOrDefault(i);

                    decimal prevMom = momList.LastOrDefault();
                    decimal mom = bot != 0 ? MinOrMax(100 * top / bot, 100, 0) : 0;
                    momList.Add(mom);

                    decimal prevMomEma = momEmaList.LastOrDefault();
                    decimal momEma = CalculateExponentialMovingAverage(mom, momEmaList.LastOrDefault(), zLength);
                    momEmaList.Add(momEma);

                    var signal = GetCompareSignal(mom - momEma, prevMom - prevMomEma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (topEma1List, topEma2List, botEma1List, botEma2List, momList, momEmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateMomentaRelativeStrengthIndex(StockData stockDataClass, string maType, int days = 2)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Momenta Relative Strength Index script may be freely distributed under the MIT license.
            //study("Momenta Relative Strength Index", shorttitle = "MRSI", overlay = false)

            //aLength = input(title = "ALength", type = input.integer, defval = 2, minval = 1)
            //zLength = input(title = "ZLength", type = input.integer, defval = 14, minval = 1)
            //src = input(title = "Source", type = input.source, defval = close)

            //hc = highest(src, aLength)
            //lc = lowest(src, aLength)
            //top = ema(src - lc, zLength)
            //bot = ema(hc - src, zLength)
            //rs = bot != 0 ? top / bot : 0
            //rsi = bot == 0 ? 100 : top == 0 ? 0 : 100 - (100 / (1 + rs))
            //sig = ema(rsi, zLength)

            //hline(80, color = color.green)
            //hline(50)
            //hline(20, color = color.red)
            //rsiColor = rsi > sig or(rsi[1] < 20 and rsi > 20) ? color.green : rsi < sig or(rsi[1] > 80 and rsi < 80) ? color.red : color.blue
            //plot(rsi, color = rsiColor, linewidth = 1)
            //plot(sig, color = color.black, linewidth = 1)
            List<decimal> topList = new();
            List<decimal> botList = new();
            List<decimal> rsList = new();
            List<decimal> rsiList = new();
            List<decimal> rsiEmaList = new();
            List<decimal> srcLcList = new();
            List<decimal> hcSrcList = new();
            List<Signal> signalsList = new();

            try
            {
                int zLength = days * 7;

                var list = GetMaxAndMinValuesList(stockDataClass.InputValues, days);
                var hcList = list.Item1;
                var lcList = list.Item2;

                for (int h = 0; h < stockDataClass.InputValues.Count; h++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(h);
                    decimal hc = hcList.ElementAtOrDefault(h);
                    decimal lc = lcList.ElementAtOrDefault(h);

                    decimal srcLc = currentValue - lc;
                    srcLcList.Add(srcLc);

                    decimal hcSrc = hc - currentValue;
                    hcSrcList.Add(hcSrc);
                }

                topList = GetMovingAverageList(maType, srcLcList, stockDataClass, zLength);
                botList = GetMovingAverageList(maType, hcSrcList, stockDataClass, zLength);
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal top = topList.ElementAtOrDefault(i);
                    decimal bot = botList.ElementAtOrDefault(i);

                    decimal rs = bot != 0 ? MinOrMax(top / bot, 1, 0) : 0;
                    rsList.Add(rs);

                    decimal prevRsi = rsiList.LastOrDefault();
                    decimal rsi = bot == 0 ? 100 : top == 0 ? 0 : MinOrMax(100 - (100 / (1 + rs)), 100, 0);
                    rsiList.Add(rsi);

                    decimal prevRsiEma = rsiEmaList.LastOrDefault();
                    decimal rsiEma = CalculateExponentialMovingAverage(rsi, prevRsiEma, zLength);
                    rsiEmaList.Add(rsiEma);

                    var signal = GetRsiSignal(rsi - rsiEma, prevRsi - prevRsiEma, rsi, prevRsi, 80, 20);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (topList, botList, rsList, rsiList, rsiEmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateDoubleSmoothedRelativeStrengthIndex(StockData stockDataClass, string maType, int days = 2)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // decimal Smoothed Relative Strength Index script may be freely distributed under the MIT license.
            //study("decimal Smoothed Relative Strength Index", shorttitle = "DSRSI", overlay = false)

            //aLength = input(title = "ALength", type = input.integer, defval = 2, minval = 1)
            //yLength = input(title = "YLength", type = input.integer, defval = 5, minval = 1)
            //zLength = input(title = "ZLength", type = input.integer, defval = 25, minval = 1)
            //src = input(title = "Source", type = input.source, defval = close)

            //hc = highest(src, aLength)
            //lc = lowest(src, aLength)
            //top = ema(ema(src - lc, yLength), zLength)
            //bot = ema(ema(hc - src, yLength), zLength)
            //rs = bot != 0 ? top / bot : 0
            //rsi = bot == 0 ? 100 : top == 0 ? 0 : 100 - (100 / (1 + rs))
            //sig = ema(rsi, zLength)

            //hline(70, color = color.green)
            //hline(50)
            //hline(30, color = color.red)
            //rsiColor = rsi > sig or(rsi[1] < 30 and rsi > 30) ? color.green : rsi < sig or(rsi[1] > 70 and rsi < 70) ? color.red : color.blue
            //plot(rsi, color = rsiColor, linewidth = 1)
            //plot(sig, color = color.black, linewidth = 1)
            List<decimal> botEma1List = new();
            List<decimal> botEma2List = new();
            List<decimal> rsList = new();
            List<decimal> rsiList = new();
            List<decimal> rsiEmaList = new();
            List<decimal> srcLcList = new();
            List<decimal> hcSrcList = new();
            List<Signal> signalsList = new();

            try
            {
                int yLength = (int)Math.Ceiling(days / 0.4);
                int zLength = yLength * 5;

                var list = GetMaxAndMinValuesList(stockDataClass.InputValues, days);
                var hcList = list.Item1;
                var lcList = list.Item2;

                for (int h = 0; h < stockDataClass.InputValues.Count; h++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(h);
                    decimal hc = hcList.ElementAtOrDefault(h);
                    decimal lc = lcList.ElementAtOrDefault(h);

                    decimal srcLc = currentValue - lc;
                    srcLcList.Add(srcLc);

                    decimal hcSrc = hc - currentValue;
                    hcSrcList.Add(hcSrc);
                }

                var topEma1List = GetMovingAverageList(maType, srcLcList, stockDataClass, yLength);
                var topEma2List = GetMovingAverageList(maType, topEma1List, stockDataClass, zLength);
                botEma1List = GetMovingAverageList(maType, hcSrcList, stockDataClass, yLength);
                botEma2List = GetMovingAverageList(maType, botEma1List, stockDataClass, zLength);
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal top = topEma2List.ElementAtOrDefault(i);
                    decimal bot = botEma2List.ElementAtOrDefault(i);

                    decimal rs = bot != 0 ? MinOrMax(top / bot, 1, 0) : 0;
                    rsList.Add(rs);

                    decimal prevRsi = rsiList.LastOrDefault();
                    decimal rsi = bot == 0 ? 100 : top == 0 ? 0 : MinOrMax(100 - (100 / (1 + rs)), 100, 0);
                    rsiList.Add(rsi);

                    decimal prevRsiEma = rsiEmaList.LastOrDefault();
                    decimal rsiEma = CalculateExponentialMovingAverage(rsi, prevRsiEma, zLength);
                    rsiEmaList.Add(rsiEma);

                    var signal = GetRsiSignal(rsi - rsiEma, prevRsi - prevRsiEma, rsi, prevRsi, 80, 20);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (botEma1List, botEma2List, rsList, rsiList, rsiEmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>)
            CalculateTrendDirectionForceIndex(StockData stockDataClass, string maType, int days = 5)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Trend Direction Force Index script may be freely distributed under the MIT license.
            //study("Trend Direction Force Index", shorttitle = "TDFI", overlay = false)

            //length = input(title = "Length", type = input.integer, defval = 10, minval = 1)
            //src = input(title = "Source", type = input.source, defval = close)

            //ema1 = ema(src * 1000, length / 2)
            //ema2 = ema(ema1, length / 2)
            //ema1Diff = ema1 - ema1[1]
            //ema2Diff = ema2 - ema2[1]
            //emaDiffAvg = (ema1Diff + ema2Diff) / 2
            //tdf = abs(ema1 - ema2) * pow(emaDiffAvg, 3)
            //tdfh = highest(abs(tdf), length * 3)
            //tdfi = tdfh != 0 ? tdf / tdfh : 0

            //tdfiColor = tdfi > 0 ? color.green : tdfi < 0 ? color.red : color.black
            //plot(tdfi, color = tdfiColor, linewidth = 3)
            List<decimal> srcList = new();
            List<decimal> ema1List = new();
            List<decimal> ema2List = new();
            List<decimal> ema1DiffList = new();
            List<decimal> ema2DiffList = new();
            List<decimal> emaDiffAvgList = new();
            List<decimal> tdfList = new();
            List<decimal> absTdfList = new();
            List<decimal> tdfhList = new();
            List<decimal> tdfiList = new();
            List<Signal> signalsList = new();

            try
            {
                int maxLength = days * 6;

                for (int h = 0; h < stockDataClass.InputValues.Count; h++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(h) * 1000;
                    srcList.Add(currentValue);
                }

                ema1List = GetMovingAverageList(maType, srcList, stockDataClass, days);
                ema2List = GetMovingAverageList(maType, ema1List, stockDataClass, days);
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal ema1 = ema1List.ElementAtOrDefault(i);
                    decimal ema2 = ema2List.ElementAtOrDefault(i);
                    decimal prevEma1 = i >= 1 ? ema1List.ElementAtOrDefault(i - 1) : 0;
                    decimal prevEma2 = i >= 1 ? ema2List.ElementAtOrDefault(i - 1) : 0;

                    decimal ema1Diff = ema1 - prevEma1;
                    ema1DiffList.Add(ema1Diff);

                    decimal ema2Diff = ema2 - prevEma2;
                    ema2DiffList.Add(ema2Diff);

                    decimal emaDiffAvg = (ema1Diff + ema2Diff) / 2;
                    emaDiffAvgList.Add(emaDiffAvg);

                    decimal tdf = 0;
                    try
                    {
                        tdf = Math.Abs(ema1 - ema2) * Pow(emaDiffAvg, 3);
                    }
                    catch (OverflowException)
                    {
                        tdf = decimal.MaxValue;
                    }
                    tdfList.Add(tdf);

                    decimal absTdf = Math.Abs(tdf);
                    absTdfList.Add(absTdf);

                    decimal tdfh = absTdfList.TakeLast(maxLength).Max();
                    tdfhList.Add(tdfh);

                    decimal prevTdfi = tdfiList.LastOrDefault();
                    decimal tdfi = tdfh != 0 ? tdf / tdfh : 0;
                    tdfiList.Add(tdfi);

                    var signal = GetCompareSignal(tdfi, prevTdfi);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (srcList, ema1List, ema2List, ema1DiffList, ema2DiffList, emaDiffAvgList, tdfList, absTdfList, tdfhList, tdfiList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateTrendExhaustionIndicator(StockData stockDataClass, int days = 10)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Trend Exhaustion Indicator script may be freely distributed under the MIT license.
            //study("Trend Exhaustion Indicator", shorttitle = "TEI", overlay = false)

            //length = input(title = "Length", type = input.integer, defval = 10, minval = 1)
            //src = input(title = "Source", type = input.source, defval = close)

            //sc = 2 / (length + 1)
            //aCount = cum(src > src[1] ? 1 : 0)
            //hCount = cum(high > highest(length)[1] ? 1 : 0)

            //haRatio = aCount != 0 ? hCount / aCount : 0
            //tei = 0.0
            //tei:= nz(tei[1]) + (sc * (haRatio - nz(tei[1])))
            //sig = sma(tei, length)

            //teiColor = tei > sig ? color.green : tei < sig ? color.red : color.black
            //plot(tei, color = teiColor, linewidth = 2)
            //plot(sig, color = color.black, linewidth = 1)
            List<decimal> teiList = new();
            List<decimal> teiSignalList = new();
            List<decimal> aCountList = new();
            List<decimal> hCountList = new();
            List<decimal> aList = new();
            List<decimal> hList = new();
            List<decimal> haRatioList = new();
            List<Signal> signalsList = new();

            try
            {
                decimal sc = (decimal)2 / (days + 1);

                var highestList = GetMaxAndMinValuesList(stockDataClass.HighPrices, days).Item1;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevHighest = i >= 1 ? highestList.ElementAtOrDefault(i - 1) : 0;
                    decimal currentHigh = stockDataClass.HighPrices.ElementAtOrDefault(i);

                    decimal a = currentValue > prevValue ? 1 : 0;
                    aList.Add(a);

                    decimal h = currentHigh > prevHighest ? 1 : 0;
                    hList.Add(h);

                    decimal aCount = aList.Sum();
                    aCountList.Add(aCount);

                    decimal hCount = hList.Sum();
                    hCountList.Add(hCount);

                    decimal haRatio = aCount != 0 ? hCount / aCount : 0;
                    haRatioList.Add(haRatio);

                    decimal prevTei = teiList.LastOrDefault();
                    decimal tei = prevTei + (sc * (haRatio - prevTei));
                    teiList.Add(tei);

                    decimal prevTeiSignal = teiSignalList.LastOrDefault();
                    decimal teiSignal = teiList.TakeLast(days).Average();
                    teiSignalList.Add(teiSignal);

                    var signal = GetCompareSignal(tei - teiSignal, prevTei - prevTeiSignal);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (hList, aCountList, hCountList, haRatioList, teiList, teiSignalList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateRatioOCHLAverager(StockData stockDataClass)
        {
            //@version=3
            //study("Ratio OCHL Averager", shorttitle = "R-OCHL", overlay = true)
            //Recursive = input(false)
            //----
            //H = security(tickerid, "M", high)
            //L = security(tickerid, "M", low)
            //d = 0.
            //----
            //a = Recursive ? nz(d[1], open) : open
            //b = abs(close - a) / (H - L)
            //c = b > 1 ? 1 : b
            //d:= c * close + (1 - c) * nz(d[1], close)
            //----
            //plot(d, color =#00bcd4,linewidth=2,transp=0)
            List<decimal> bList = new();
            List<decimal> cList = new();
            List<decimal> dList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.HighPrices.Count; i++)
                {
                    decimal currentHigh = stockDataClass.HighPrices.ElementAtOrDefault(i);
                    decimal currentLow = stockDataClass.LowPrices.ElementAtOrDefault(i);
                    decimal currentOpen = stockDataClass.OpenPrices.ElementAtOrDefault(i);
                    decimal currentClose = stockDataClass.ClosePrices.ElementAtOrDefault(i);
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal b = currentHigh - currentLow != 0 ? Math.Abs(currentClose - currentOpen) / (currentHigh - currentLow) : 0;
                    bList.Add(b);

                    decimal c = b > 1 ? 1 : b;
                    cList.Add(c);

                    decimal prevD = i >= 1 ? dList.ElementAtOrDefault(i - 1) : currentClose;
                    decimal d = (c * currentValue) + ((1 - c) * prevD);
                    dList.Add(d);

                    var signal = GetCompareSignal(currentValue - d, prevValue - prevD);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (bList, cList, dList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateGarmanKlassVolatility(StockData stockDataClass, int days = 7)
        {
            //@version=3
            //study("Garman Klass Volatility")
            //length = input(14)
            //
            //gcv = sqrt((n / length) * sum(0.5 * pow(log(high / low), 2) - (2 * log(2) - 1) * pow(log(close / open), 2), length))
            //plot(gcv, color = red, transp = 0)
            List<decimal> gcvList = new();
            List<decimal> gcvEmaList = new();
            List<decimal> logHlList = new();
            List<decimal> logCoList = new();
            List<decimal> logList = new();
            List<decimal> logSumList = new();
            List<Signal> signalsList = new();

            try
            {
                int signalPeriod = days;
                int length = days * 2;

                var emaList = CalculateExponentialMovingAverage(stockDataClass, length).Item1;

                for (int i = 0; i < stockDataClass.HighPrices.Count; i++)
                {
                    decimal currentHigh = stockDataClass.HighPrices.ElementAtOrDefault(i);
                    decimal currentLow = stockDataClass.LowPrices.ElementAtOrDefault(i);
                    decimal currentOpen = stockDataClass.OpenPrices.ElementAtOrDefault(i);
                    decimal currentClose = stockDataClass.ClosePrices.ElementAtOrDefault(i);
                    decimal ema = emaList.ElementAtOrDefault(i);
                    decimal prevClose = i >= 1 ? stockDataClass.ClosePrices.ElementAtOrDefault(i - 1) : 0;
                    decimal prevEma = i >= 1 ? emaList.ElementAtOrDefault(i - 1) : 0;

                    decimal logHl = currentLow != 0 ? (decimal)Log((double)(currentHigh / currentLow)) : 0;
                    logHlList.Add(logHl);

                    decimal logCo = currentOpen != 0 ? (decimal)Log((double)(currentClose / currentOpen)) : 0;
                    logCoList.Add(logCo);

                    decimal log = (decimal)(0.5m * Pow(logHl, 2)) - (((2 * (decimal)Log((double)2)) - 1) * Pow(logCo, 2));
                    logList.Add(log);

                    decimal logSum = logList.TakeLast(length).Sum();
                    logSumList.Add(logSum);

                    decimal gcv = (decimal)Sqrt((double)(i / length * logSum));
                    gcvList.Add(gcv);

                    decimal gcvEma = CalculateExponentialMovingAverage(gcv, gcvEmaList.LastOrDefault(), signalPeriod);
                    gcvEmaList.Add(gcvEma);

                    var signal = GetVolatilitySignal(currentClose - ema, prevClose - prevEma, gcv, gcvEma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (logHlList, logCoList, logList, logSumList, gcvList, gcvEmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateTurboTrigger(
            StockData stockDataClass, string maType, int days = 100)
        {
            //@version=3
            //study("Turbo Trigger")
            //length = input(100),smooth = input(2),mode = input(false, title = "Bull/Bear Mode")
            //----
            //c = sma(close, smooth)
            //o = sma(open, smooth)
            //h = sma(high, smooth)
            //l = sma(low, smooth)
            //----
            //y = sma(avg(c, o), length)
            //a = sma(h - y, length)
            //b = sma(y - l, length)
            //osc = sma(a - b, length)
            //----
            //plot(a, color =#2196f3,linewidth=2,transp=0),plot(mode ? b : osc,color=#e65100,linewidth=2,transp=0)
            List<decimal> yList = new();
            List<decimal> aList = new();
            List<decimal> bList = new();
            List<decimal> oscList = new();
            List<decimal> avgList = new();
            List<decimal> hyList = new();
            List<decimal> ylList = new();
            List<decimal> abList = new();
            List<Signal> signalsList = new();

            try
            {
                int smoothLength = MinOrMax((int)Math.Ceiling((decimal)days / 50));

                var cList = GetMovingAverageList(maType, stockDataClass.ClosePrices, stockDataClass, smoothLength);
                var oList = GetMovingAverageList(maType, stockDataClass.OpenPrices, stockDataClass, smoothLength);
                var hList = GetMovingAverageList(maType, stockDataClass.HighPrices, stockDataClass, smoothLength);
                var lList = GetMovingAverageList(maType, stockDataClass.LowPrices, stockDataClass, smoothLength);

                for (int h = 0; h < stockDataClass.HighPrices.Count; h++)
                {
                    decimal c = cList.ElementAtOrDefault(h);
                    decimal o = oList.ElementAtOrDefault(h);

                    decimal avg = (c + o) / 2;
                    avgList.Add(avg);
                }

                yList = GetMovingAverageList(maType, avgList, stockDataClass, days);
                for (int i = 0; i < stockDataClass.HighPrices.Count; i++)
                {
                    decimal y = yList.ElementAtOrDefault(i);
                    decimal h = hList.ElementAtOrDefault(i);
                    decimal l = lList.ElementAtOrDefault(i);

                    decimal hy = h - y;
                    hyList.Add(hy);

                    decimal yl = y - l;
                    ylList.Add(yl);
                }

                aList = GetMovingAverageList(maType, hyList, stockDataClass, days);
                bList = GetMovingAverageList(maType, ylList, stockDataClass, days);
                for (int j = 0; j < stockDataClass.HighPrices.Count; j++)
                {
                    decimal a = aList.ElementAtOrDefault(j);
                    decimal b = bList.ElementAtOrDefault(j);

                    decimal ab = a - b;
                    abList.Add(ab);
                }

                oscList = GetMovingAverageList(maType, abList, stockDataClass, days);
                for (int k = 0; k < stockDataClass.HighPrices.Count; k++)
                {
                    decimal osc = oscList.ElementAtOrDefault(k);
                    decimal prevOsc = k >= 1 ? oscList.ElementAtOrDefault(k - 1) : 0;
                    decimal a = aList.ElementAtOrDefault(k);
                    decimal prevA = k >= 1 ? aList.ElementAtOrDefault(k - 1) : 0;

                    var signal = GetCompareSignal(osc - a, prevOsc - prevA);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (avgList, yList, hyList, ylList, aList, bList, abList, oscList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateGopalakrishnanRangeIndex(StockData stockDataClass, int days = 5)
        {
            //@version=3
            // Copyright (c) 2018-present, Alex Orekhov (everget)
            // Gopalakrishnan Range Index script may be freely distributed under the MIT license.
            //study("Gopalakrishnan Range Index", shorttitle = "GAPO")

            //length = input(title = "Length", type = integer, defval = 5)

            //gapo = log(highest(length) - lowest(length)) / log(length)

            //gapoColor = gapo >= gapo[1] ? #0ebb23 : red
            //plot(gapo, title = "GAPO", linewidth = 2, color = gapoColor, transp = 0)
            List<decimal> gapoList = new();
            List<decimal> tempHighList = new();
            List<decimal> tempLowList = new();
            List<decimal> rangeLogList = new();
            List<decimal> gapoEmaList = new();
            List<Signal> signalsList = new();

            try
            {
                var minMaxList = GetMaxAndMinValuesList(stockDataClass.HighPrices, stockDataClass.LowPrices, days);

                for (int i = 0; i < stockDataClass.HighPrices.Count; i++)
                {
                    decimal highestHigh = minMaxList.Item1.ElementAtOrDefault(i);
                    decimal lowestLow = minMaxList.Item2.ElementAtOrDefault(i);
                    decimal range = highestHigh - lowestLow;

                    decimal rangeLog = range > 0 ? (decimal)Log((double)range) : 0;
                    rangeLogList.Add(rangeLog);

                    decimal prevGapo = gapoList.LastOrDefault();
                    decimal gapo = rangeLog / (decimal)Log((double)days);
                    gapoList.Add(gapo);

                    decimal prevGapoEma = gapoEmaList.LastOrDefault();
                    decimal gapoEma = CalculateExponentialMovingAverage(gapo, gapoEmaList.LastOrDefault(), days);
                    gapoEmaList.Add(gapoEma);

                    var signal = GetCompareSignal(gapo - gapoEma, prevGapo - prevGapoEma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (rangeLogList, gapoList, gapoEmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>)
            CalculateClosedFormDistanceVolatility(StockData stockDataClass, string maType, int days = 7)
        {
            //@version=3
            //study("Closed Form Distance Volatility", shorttitle = "CFDV")
            //length = input(14),method = input("Hellinger", options =["Hellinger", "Bhattacharyya", "Wasserstein"])
            //----
            //a = sum(high, length)
            //b = sum(low, length)
            //----
            //hv = sqrt(1 - pow(a, 0.25) * pow(b, 0.25) / pow(avg(a, b), 0.5))
            //bv = 0.5 * log(avg(a, b) / sqrt(a * b))
            //w = sqrt(percentile_linear_interpolation(a + b - 2 * sqrt(pow(a, 0.5) * b * pow(a, 0.5)), length, 50))
            //----
            //dv = method == "Hellinger" ? hv : method == "Bhattacharyya" ? bv : w
            //plot(dv, color =#e65100,transp=0)
            List<decimal> tempHighList = new();
            List<decimal> tempLowList = new();
            List<decimal> aList = new();
            List<decimal> bList = new();
            List<decimal> abList = new();
            List<decimal> abAvgList = new();
            List<decimal> hvList = new();
            List<decimal> hvEmaList = new();
            List<decimal> bvList = new();
            List<decimal> wList = new();
            List<decimal> wMedList = new();
            List<decimal> wSqrtList = new();
            List<Signal> signalsList = new();

            try
            {
                int signalPeriod = days;
                int length = days * 2;

                var medianList = CalculateMedianPrice(stockDataClass).Item2;
                var emaList = GetMovingAverageList(maType, medianList, stockDataClass, length);

                for (int i = 0; i < stockDataClass.HighPrices.Count; i++)
                {
                    decimal currentValue = medianList.ElementAtOrDefault(i);
                    decimal ema = emaList.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? medianList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevEma = i >= 1 ? emaList.ElementAtOrDefault(i - 1) : 0;

                    decimal currentHigh = stockDataClass.HighPrices.ElementAtOrDefault(i);
                    tempHighList.Add(currentHigh);

                    decimal currentLow = stockDataClass.LowPrices.ElementAtOrDefault(i);
                    tempLowList.Add(currentLow);

                    decimal a = tempHighList.TakeLast(length).Sum();
                    aList.Add(a);

                    decimal b = tempLowList.TakeLast(length).Sum();
                    bList.Add(b);

                    decimal ab = a * b;
                    abList.Add(ab);

                    decimal abAvg = (a + b) / 2;
                    abAvgList.Add(abAvg);

                    decimal hv = abAvg != 0 && a != b ? Sqrt((double)(1 - (Pow(a, 0.25) * Pow(b, 0.25) / Pow(abAvg, 0.5)))) : 0;
                    hvList.Add(hv);

                    decimal bv = ab != 0 && abAvg > 0 ? 0.5m * Log(abAvg / Sqrt(ab)) : 0;
                    bvList.Add(bv);

                    decimal w = ab != 0 ? a + b - (2 * (decimal)Sqrt((double)(Pow(a, 0.5) * b * Pow(a, 0.5)))) : 0;
                    wList.Add(w);

                    decimal wMedian = Median(wList.TakeLast(length));
                    wMedList.Add(wMedian);

                    decimal wSqrt = wMedian >= 0 ? (decimal)Sqrt((double)wMedian) : 0;
                    wSqrtList.Add(wSqrt);

                    decimal hvEma = CalculateExponentialMovingAverage(hv, hvEmaList.LastOrDefault(), signalPeriod);
                    hvEmaList.Add(hvEma);

                    var signal = GetVolatilitySignal(currentValue - ema, prevValue - prevEma, hv, hvEma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (aList, bList, abList, abAvgList, bvList, wList, wMedList, wSqrtList, hvList, hvEmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateWilliamsFractals(StockData stockDataClass, int days = 2)
        {
            //@version=4
            //study("Williams Fractals", shorttitle = "Fractals", format = format.price, precision = 0, overlay = true)
            // Define "n" as the number of periods and keep a minimum value of 2 for error handling.
            //n = input(title = "Periods", defval = 2, minval = 2, type = input.integer)

            //upFractal = ((high[n + 2] < high[n]) and(high[n + 1] < high[n]) and(high[n - 1] < high[n]) and(high[n - 2] < high[n]))
            //         or((high[n + 3] < high[n]) and(high[n + 2] < high[n]) and(high[n + 1] == high[n]) and(high[n - 1] < high[n]) and(high[n - 2] < high[n]))
            //         or((high[n + 4] < high[n]) and(high[n + 3] < high[n]) and(high[n + 2] == high[n]) and(high[n + 1] <= high[n]) and(high[n - 1] < high[n]) 
            //         and(high[n - 2] < high[n]))
            //         or((high[n + 5] < high[n]) and(high[n + 4] < high[n]) and(high[n + 3] == high[n]) and(high[n + 2] == high[n]) and(high[n + 1] <= high[n]) 
            //         and(high[n - 1] < high[n]) and(high[n - 2] < high[n]))
            //         or((high[n + 6] < high[n]) and(high[n + 5] < high[n]) and(high[n + 4] == high[n]) and(high[n + 3] <= high[n]) and(high[n + 2] == high[n]) 
            //         and(high[n + 1] <= high[n]) and(high[n - 1] < high[n]) and(high[n - 2] < high[n]))

            //dnFractal = ((low[n + 2] > low[n]) and(low[n + 1] > low[n]) and(low[n - 1] > low[n]) and(low[n - 2] > low[n]))
            //         or((low[n + 3] > low[n]) and(low[n + 2] > low[n]) and(low[n + 1] == low[n]) and(low[n - 1] > low[n]) and(low[n - 2] > low[n]))
            //         or((low[n + 4] > low[n]) and(low[n + 3] > low[n]) and(low[n + 2] == low[n]) and(low[n + 1] >= low[n]) and(low[n - 1] > low[n]) and(low[n - 2] > low[n]))
            //         or((low[n + 5] > low[n]) and(low[n + 4] > low[n]) and(low[n + 3] == low[n]) and(low[n + 2] == low[n]) and(low[n + 1] >= low[n]) 
            //         and(low[n - 1] > low[n]) and(low[n - 2] > low[n]))
            //         or((low[n + 6] > low[n]) and(low[n + 5] > low[n]) and(low[n + 4] == low[n]) and(low[n + 3] >= low[n]) and(low[n + 2] == low[n]) 
            //         and(low[n + 1] >= low[n]) and(low[n - 1] > low[n]) and(low[n - 2] > low[n]))

            // Plot the fractals as shapes on the chart.
            //plotshape(dnFractal, style = shape.triangledown, location = location.belowbar, offset = -2, color = color.maroon, transp = 0)
            //plotshape(upFractal, style = shape.triangleup, location = location.abovebar, offset = -2, color = color.olive, transp = 0)
            List<decimal> upFractalList = new();
            List<decimal> dnFractalList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.HighPrices.Count; i++)
                {
                    decimal prevHigh = i >= days - 2 ? stockDataClass.HighPrices.ElementAtOrDefault(i - (days - 2)) : 0;
                    decimal prevHigh1 = i >= days - 1 ? stockDataClass.HighPrices.ElementAtOrDefault(i - (days - 1)) : 0;
                    decimal prevHigh2 = i >= days ? stockDataClass.HighPrices.ElementAtOrDefault(i - days) : 0;
                    decimal prevHigh3 = i >= days + 1 ? stockDataClass.HighPrices.ElementAtOrDefault(i - (days + 1)) : 0;
                    decimal prevHigh4 = i >= days + 2 ? stockDataClass.HighPrices.ElementAtOrDefault(i - (days + 2)) : 0;
                    decimal prevHigh5 = i >= days + 3 ? stockDataClass.HighPrices.ElementAtOrDefault(i - (days + 3)) : 0;
                    decimal prevHigh6 = i >= days + 4 ? stockDataClass.HighPrices.ElementAtOrDefault(i - (days + 4)) : 0;
                    decimal prevHigh7 = i >= days + 5 ? stockDataClass.HighPrices.ElementAtOrDefault(i - (days + 5)) : 0;
                    decimal prevHigh8 = i >= days + 8 ? stockDataClass.HighPrices.ElementAtOrDefault(i - (days + 6)) : 0;
                    decimal prevLow = i >= days - 2 ? stockDataClass.LowPrices.ElementAtOrDefault(i - (days - 2)) : 0;
                    decimal prevLow1 = i >= days - 1 ? stockDataClass.LowPrices.ElementAtOrDefault(i - (days - 1)) : 0;
                    decimal prevLow2 = i >= days ? stockDataClass.LowPrices.ElementAtOrDefault(i - days) : 0;
                    decimal prevLow3 = i >= days + 1 ? stockDataClass.LowPrices.ElementAtOrDefault(i - (days + 1)) : 0;
                    decimal prevLow4 = i >= days + 2 ? stockDataClass.LowPrices.ElementAtOrDefault(i - (days + 2)) : 0;
                    decimal prevLow5 = i >= days + 3 ? stockDataClass.LowPrices.ElementAtOrDefault(i - (days + 3)) : 0;
                    decimal prevLow6 = i >= days + 4 ? stockDataClass.LowPrices.ElementAtOrDefault(i - (days + 4)) : 0;
                    decimal prevLow7 = i >= days + 5 ? stockDataClass.LowPrices.ElementAtOrDefault(i - (days + 5)) : 0;
                    decimal prevLow8 = i >= days + 8 ? stockDataClass.LowPrices.ElementAtOrDefault(i - (days + 6)) : 0;

                    decimal prevUpFractal = upFractalList.LastOrDefault();
                    decimal upFractal = (prevHigh4 < prevHigh2 && prevHigh3 < prevHigh2 && prevHigh1 < prevHigh2 && prevHigh < prevHigh2) ||
                        (prevHigh5 < prevHigh2 && prevHigh4 < prevHigh2 && prevHigh3 == prevHigh2 && prevHigh1 < prevHigh2 && prevHigh1 < prevHigh2) ||
                        (prevHigh6 < prevHigh2 && prevHigh5 < prevHigh2 && prevHigh4 == prevHigh2 && prevHigh3 <= prevHigh2 && prevHigh1 < prevHigh2 && prevHigh < prevHigh2) ||
                        (prevHigh7 < prevHigh2 && prevHigh6 < prevHigh2 && prevHigh5 == prevHigh2 && prevHigh4 == prevHigh2 && prevHigh3 <= prevHigh2 && prevHigh1 < prevHigh2 &&
                        prevHigh < prevHigh2) || (prevHigh8 < prevHigh2 && prevHigh7 < prevHigh2 && prevHigh6 == prevHigh2 && prevHigh5 <= prevHigh2 && prevHigh4 == prevHigh2 &&
                        prevHigh3 <= prevHigh2 && prevHigh1 < prevHigh2 && prevHigh < prevHigh2) ? 1 : 0;
                    upFractalList.Add(upFractal);

                    decimal prevDnFractal = dnFractalList.LastOrDefault();
                    decimal dnFractal = (prevLow4 > prevLow2 && prevLow3 > prevLow2 && prevLow1 > prevLow2 && prevLow > prevLow2) || (prevLow5 > prevLow2 && prevLow4 > prevLow2 &&
                        prevLow3 == prevLow2 && prevLow1 > prevLow2 && prevLow > prevLow2) || (prevLow6 > prevLow2 && prevLow5 > prevLow2 && prevLow4 == prevLow2 &&
                        prevLow3 >= prevLow2 && prevLow1 > prevLow2 && prevLow > prevLow2) || (prevLow7 > prevLow2 && prevLow6 > prevLow2 && prevLow5 == prevLow2 &&
                        prevLow4 == prevLow2 && prevLow3 >= prevLow2 && prevLow1 > prevLow2 && prevLow > prevLow2) || (prevLow8 > prevLow2 && prevLow7 > prevLow2 &&
                        prevLow6 == prevLow2 && prevLow5 >= prevLow2 && prevLow4 == prevLow2 && prevLow3 >= prevLow2 && prevLow1 > prevLow2 && prevLow > prevLow2) ? 1 : 0;
                    dnFractalList.Add(dnFractal);

                    var signal = GetCompareSignal(upFractal - dnFractal, prevUpFractal - prevDnFractal);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (upFractalList, dnFractalList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateTotalPowerIndicator(StockData stockDataClass, string maType, int days = 10)
        {
            //@version=3
            // Copyright (c) 2018-present, Alex Orekhov (everget)
            // Total Power Indicator script may be freely distributed under the MIT license.
            //study("Total Power Indicator", shorttitle = "TPI")

            //length = input(title = "Length", type = integer, defval = 45)
            //powersLength = input(title = "Elder Powers Length", type = integer, defval = 10)
            //adjustableLevel = input(title = "Adjustable Entry Level", type = integer, defval = 75)
            //applyFilling = input(title = "Apply Powers Filling ?", type = bool, defval = false)

            //elderBullPower = high - ema(close, powersLength)
            //elderBearPower = low - ema(close, powersLength)

            //adjust(value) => 100 * value / length

            //bullCount = sum(elderBullPower > 0 ? 1 : 0, length)
            //bearCount = sum(elderBearPower < 0 ? 1 : 0, length)
            //total = adjust(abs(bullCount - bearCount))
            //bull = adjust(bullCount)
            //bear = adjust(bearCount)

            //bullPlot = plot(bull, title = "Bull", linewidth = 2, color =#0ebb23, transp=0)
            //bearPlot = plot(bear, title = "Bear", linewidth = 2, color = red, transp = 0)
            //plot(total, title = "Total", linewidth = 2, color =#3c78d8, transp=0)

            //fillColor = applyFilling ? (bull > bear ? #0ebb23 : red) : color(white, 100) 
            //fill(bullPlot, bearPlot, color = fillColor, transp = 80)

            //hline(adjustableLevel, title = "Adjustable Entry Level", linestyle = dotted)
            //hline(50, title = "Middle Level", linestyle = dotted, color =#f49517)
            List<decimal> bullCountList = new();
            List<decimal> bearCountList = new();
            List<decimal> bullCountSumList = new();
            List<decimal> bearCountSumList = new();
            List<decimal> totalPowerList = new();
            List<decimal> adjBullCountList = new();
            List<decimal> adjBearCountList = new();
            List<Signal> signalsList = new();

            try
            {
                int powersLength = days;
                int length = MinOrMax((int)Math.Ceiling(powersLength * 4.5));

                var elderPowerList = CalculateElderRayBearandBullPower(stockDataClass, maType, powersLength);
                List<decimal> bullPowerList = elderPowerList.Item1;
                List<decimal> bearPowerList = elderPowerList.Item2;

                for (int i = 0; i < stockDataClass.HighPrices.Count; i++)
                {
                    decimal bullPower = bullPowerList.ElementAtOrDefault(i);
                    decimal bearPower = bearPowerList.ElementAtOrDefault(i);

                    decimal bullCount = bullPower > 0 ? 1 : 0;
                    bullCountList.Add(bullCount);

                    decimal bullCountSum = bullCountList.TakeLast(length).Sum();
                    bullCountSumList.Add(bullCountSum);

                    decimal bearCount = bearPower < 0 ? 1 : 0;
                    bearCountList.Add(bearCount);

                    decimal bearCountSum = bearCountList.TakeLast(length).Sum();
                    bearCountSumList.Add(bearCountSum);

                    decimal totalPower = 100 * Math.Abs(bullCountSum - bearCountSum) / length;
                    totalPowerList.Add(totalPower);

                    decimal prevAdjBullCount = adjBullCountList.LastOrDefault();
                    decimal adjBullCount = 100 * bullCountSum / length;
                    adjBullCountList.Add(adjBullCount);

                    decimal prevAdjBearCount = adjBearCountList.LastOrDefault();
                    decimal adjBearCount = 100 * bearCountSum / length;
                    adjBearCountList.Add(adjBearCount);

                    var signal = GetCompareSignal(adjBullCount - adjBearCount, prevAdjBullCount - prevAdjBearCount);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (bullCountList, bullCountSumList, bearCountList, bearCountSumList, totalPowerList, adjBullCountList, adjBearCountList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateAutoFilter(StockData stockDataClass, string maType, int days = 500)
        {
            //@version=2
            //study("Auto-Filter", overlay = true)
            //length = input(500)
            //
            //r = sma(close, 14)
            //dev = stdev(close, length)
            //x = close > nz(x[1], r) + dev ? close : close < nz(x[1], r) - dev ? close : x[1]
            //
            //y = close
            //x_ = sma(x, length)
            //y_ = sma(y, length)
            //mx = stdev(x, length)
            //my = stdev(y, length)
            //c = correlation(x, y, length)
            //
            //slope = c * (my / mx)
            //inter = y_ - slope * x_
            //reg = x * slope + inter
            //
            //plot(reg, color =#2E64FE,transp=0)
            List<decimal> xMaList = new();
            List<decimal> regList = new();
            List<decimal> corrList = new();
            List<decimal> interList = new();
            List<decimal> slopeList = new();
            List<decimal> mxList = new();
            List<decimal> tempList = new();
            List<decimal> tempXList = new();
            List<Signal> signalsList = new();

            try
            {
                var yMaList = GetMovingAverageList(maType, null, stockDataClass, days);
                var xList = CalculateAutoLine(stockDataClass, maType, days).Item1;
                var devList = CalculateStandardDeviationVolatility(null, stockDataClass, days).Item4;

                for (int h = 0; h < stockDataClass.HighPrices.Count; h++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(h);
                    tempList.Add(currentValue);

                    decimal x = xList.ElementAtOrDefault(h);
                    tempXList.Add(x);

                    var corr = GoodnessOfFit.R(tempList.TakeLast(days).Select(x => (double)x), tempXList.TakeLast(days).Select(x => (double)x));
                    corr = IsValueNullOrInfinity(corr) ? 0 : corr;
                    corrList.Add((decimal)corr);
                }

                xMaList = GetMovingAverageList(maType, xList, stockDataClass, days);
                mxList = CalculateStandardDeviationVolatility(xList, stockDataClass, days).Item4;
                for (int i = 0; i < stockDataClass.HighPrices.Count; i++)
                {
                    decimal my = devList.ElementAtOrDefault(i);
                    decimal mx = mxList.ElementAtOrDefault(i);
                    decimal corr = corrList.ElementAtOrDefault(i);
                    decimal yMa = yMaList.ElementAtOrDefault(i);
                    decimal xMa = xMaList.ElementAtOrDefault(i);
                    decimal x = xList.ElementAtOrDefault(i);
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal slope = mx != 0 ? corr * (my / mx) : 0;
                    slopeList.Add(slope);

                    decimal inter = yMa - (slope * xMa);
                    interList.Add(inter);

                    decimal prevReg = regList.LastOrDefault();
                    decimal reg = (x * slope) + inter;
                    regList.Add(reg);

                    var signal = GetCompareSignal(currentValue - reg, prevValue - prevReg);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (corrList, xMaList, mxList, slopeList, interList, regList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateLinearRegressionLine(StockData stockDataClass, string maType, int days = 14)
        {
            //@version=3
            //study("Linear Regression Line", overlay = true)
            //length = input(14)
            //
            //x = n
            //y = close
            //x_ = sma(x, length)
            //y_ = sma(y, length)
            //mx = stdev(x, length)
            //my = stdev(y, length)
            //c = correlation(x, y, length)
            //slope = c * (my / mx)
            //
            //inter = y_ - slope * x_
            //
            //reg = x * slope + inter
            //plot(reg, color = red, transp = 0)
            List<decimal> regList = new();
            List<decimal> corrList = new();
            List<decimal> interList = new();
            List<decimal> slopeList = new();
            List<decimal> yList = new();
            List<decimal> xList = new();
            List<Signal> signalsList = new();

            try
            {
                var yMaList = GetMovingAverageList(maType, null, stockDataClass, days);
                var myList = CalculateStandardDeviationVolatility(null, stockDataClass, days).Item4;

                for (int h = 0; h < stockDataClass.HighPrices.Count; h++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(h);
                    yList.Add(currentValue);

                    decimal x = h;
                    xList.Add(x);

                    var corr = GoodnessOfFit.R(yList.TakeLast(days).Select(x => (double)x), xList.TakeLast(days).Select(x => (double)x));
                    corr = IsValueNullOrInfinity(corr) ? 0 : corr;
                    corrList.Add((decimal)corr);
                }

                var xMaList = GetMovingAverageList(maType, xList, stockDataClass, days);
                var mxList = CalculateStandardDeviationVolatility(xList, stockDataClass, days).Item4;
                for (int i = 0; i < stockDataClass.HighPrices.Count; i++)
                {
                    decimal my = myList.ElementAtOrDefault(i);
                    decimal mx = mxList.ElementAtOrDefault(i);
                    decimal corr = corrList.ElementAtOrDefault(i);
                    decimal yMa = yMaList.ElementAtOrDefault(i);
                    decimal xMa = xMaList.ElementAtOrDefault(i);
                    decimal x = xList.ElementAtOrDefault(i);
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal slope = mx != 0 ? corr * (my / mx) : 0;
                    slopeList.Add(slope);

                    decimal inter = yMa - (slope * xMa);
                    interList.Add(inter);

                    decimal prevReg = regList.LastOrDefault();
                    decimal reg = (x * slope) + inter;
                    regList.Add(reg);

                    var signal = GetCompareSignal(currentValue - reg, prevValue - prevReg);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (slopeList, interList, regList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<Signal>) CalculateHirashimaSugitaRS(StockData stockDataClass, string maType, int days = 1000)
        {
            //@version=3
            //study("Hirashima Sugita R/S", overlay = true)
            //length = input(1000)
            //
            //ma = ema(close, length)
            //d = close - ma
            //
            //s = linreg(d, length, 0)
            //x = ma + s
            //
            //d_ = close - x
            //s_ = linreg(d_, length, 0)
            //basis = (ma + s) + change(s_)
            //
            //upper = basis + wma(abs(d), length)
            //lower = basis - wma(abs(d), length)
            //upper_ = upper + wma(abs(d), length)
            //lower_ = lower - wma(abs(d), length)
            //
            //plot(upper_, color = lime, transp = 0)
            //plot(upper, color = lime, transp = 50)
            //plot(basis, color = aqua, transp = 0)
            //plot(lower, color = red, transp = 0)
            //plot(lower_, color = red, transp = 0)
            List<decimal> s1List = new();
            List<decimal> d1List = new();
            List<decimal> absD1List = new();
            List<decimal> xList = new();
            List<decimal> d2List = new();
            List<decimal> s2List = new();
            List<decimal> basisList = new();
            List<decimal> upper1List = new();
            List<decimal> lower1List = new();
            List<decimal> upper2List = new();
            List<decimal> lower2List = new();
            List<decimal> wmaList = new();
            List<Signal> signalsList = new();

            try
            {
                var smaList = GetMovingAverageList(maType, null, stockDataClass, days);

                for (int h = 0; h < stockDataClass.HighPrices.Count; h++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(h);
                    decimal sma = smaList.ElementAtOrDefault(h);

                    decimal d1 = currentValue - sma;
                    d1List.Add(d1);

                    decimal absD1 = Math.Abs(d1);
                    absD1List.Add(absD1);
                }

                wmaList = GetMovingAverageList(maType, absD1List, stockDataClass, days);
                s1List = CalculateLinearRegression(d1List, stockDataClass, days).Item15;
                for (int i = 0; i < stockDataClass.HighPrices.Count; i++)
                {
                    decimal sma = smaList.ElementAtOrDefault(i);
                    decimal s1 = s1List.ElementAtOrDefault(i);
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);

                    decimal x = sma + s1;
                    xList.Add(x);

                    decimal d2 = currentValue - x;
                    d2List.Add(d2);
                }

                s2List = CalculateLinearRegression(d2List, stockDataClass, days).Item15;
                for (int j = 0; j < stockDataClass.HighPrices.Count; j++)
                {
                    decimal sma = smaList.ElementAtOrDefault(j);
                    decimal s1 = s1List.ElementAtOrDefault(j);
                    decimal s2 = s2List.ElementAtOrDefault(j);
                    decimal prevS2 = j >= 1 ? s2List.ElementAtOrDefault(j - 1) : 0;
                    decimal wma = wmaList.ElementAtOrDefault(j);
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(j);
                    decimal prevValue = j >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(j - 1) : 0;

                    decimal prevBasis = basisList.LastOrDefault();
                    decimal basis = (sma + s1) + (s2 - prevS2);
                    basisList.Add(basis);

                    decimal upper1 = basis + wma;
                    upper1List.Add(upper1);

                    decimal lower1 = basis - wma;
                    lower1List.Add(lower1);

                    decimal upper2 = upper1 + wma;
                    upper2List.Add(upper2);

                    decimal lower2 = lower1 - wma;
                    lower2List.Add(lower2);

                    var signal = GetCompareSignal(currentValue - basis, prevValue - prevBasis);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (absD1List, wmaList, s1List, xList, d2List, s2List, basisList, upper1List, lower1List, upper2List, lower2List, signalsList);
        }

        public static (List<decimal>, List<Signal>) CalculateAutoLine(StockData stockDataClass, string maType, int days = 14)
        {
            //@version=2
            //study("Auto-Line", overlay = true)
            //length = input(500)
            //
            //r = sma(close, 14)
            //dev = stdev(close, length)
            //a = close > nz(a[1], r) + dev ? close : close < nz(a[1], r) - dev ? close : a[1]
            //css = fixnan(a > a[1] ? #0080FF : a < a[1] ? #FF0000 : na)
            //plot(a, color = css, transp = 0, linewidth = 3)
            List<decimal> xList = new();
            List<Signal> signalsList = new();

            try
            {
                int smaLength = days;
                int length = (int)Math.Ceiling(days / 0.028);

                var rList = GetMovingAverageList(maType, null, stockDataClass, smaLength);
                var devList = CalculateStandardDeviationVolatility(null, stockDataClass, length).Item4;

                for (int i = 0; i < stockDataClass.HighPrices.Count; i++)
                {
                    decimal dev = devList.ElementAtOrDefault(i);
                    decimal r = rList.ElementAtOrDefault(i);
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal prevX = i >= 1 ? xList.ElementAtOrDefault(i - 1) : r;
                    decimal x = currentValue > prevX + dev ? currentValue : currentValue < prevX - dev ? currentValue : prevX;
                    xList.Add(x);

                    var signal = GetCompareSignal(currentValue - x, prevValue - prevX);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (xList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>)
            CalculateLinearQuadraticConvergenceDivergenceOscillator(StockData stockDataClass, string maType, int days = 25)
        {
            //@version=3
            //study("LQCD")
            //length = input(50),signal = input(25),differential = input(false),predictive = input(false, title = "Predictive Histogram")
            //----
            //y = close
            //x1 = n
            //x2 = pow(x1, 2)
            //----
            //S11 = sum(x2, length) - pow(sum(x1, length), 2) / length
            //S12 = sum(x1 * x2, length) - (sum(x1, length) * sum(x2, length)) / length
            //S22 = sum(pow(x2, 2), length) - pow(sum(x2, length), 2) / length
            //Sy1 = sum(y * x1, length) - (sum(y, length) * sum(x1, length)) / length
            //Sy2 = sum(y * x2, length) - (sum(y, length) * sum(x2, length)) / length
            //----
            //max1 = sma(x1, length)
            //max2 = sma(x2, length)
            //may = sma(y, length)
            //b2 = ((Sy1 * S22) - (Sy2 * S12)) / (S22 * S11 - pow(S12, 2))
            //b3 = ((Sy2 * S11) - (Sy1 * S12)) / (S22 * S11 - pow(S12, 2))
            //b1 = may - b2 * max1 - b3 * max2
            //Y = b1 + b2 * x1 + b3 * x2
            //----
            //lqcd = Y - linreg(close, length, 0)
            //sign = sma(lqcd, signal)
            //osc = differential ? change(Y, signal) - change(linreg(close, length, 0), signal) : lqcd - sign
            //hist = predictive ? osc - sign : osc
            //----
            //plot(hist, color = hist > 0 ? #26A69A : #EF5350,style=histogram,transp=75)
            //plot(lqcd, color =#0094ff,linewidth=1,transp=0)
            //plot(sign, color =#ff6a00,linewidth=1,transp=0)
            List<decimal> lqcdList = new();
            List<decimal> histList = new();
            List<decimal> histDifList = new();
            List<decimal> signList = new();
            List<decimal> oscList = new();
            List<decimal> oscDifList = new();
            List<Signal> signalsList = new();

            try
            {
                int signalLength = days;
                int length = days * 2;

                var linregList = CalculateLinearRegression(null, stockDataClass, length).Item15;
                var yList = CalculateQuadraticRegression(stockDataClass, maType, length).Item20;

                for (int i = 0; i < stockDataClass.HighPrices.Count; i++)
                {
                    decimal linreg = linregList.ElementAtOrDefault(i);
                    decimal y = yList.ElementAtOrDefault(i);

                    decimal lqcd = y - linreg;
                    lqcdList.Add(lqcd);
                }

                signList = GetMovingAverageList(maType, lqcdList, stockDataClass, length);
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal y = yList.ElementAtOrDefault(j);
                    decimal prevY = j >= signalLength ? yList.ElementAtOrDefault(j - signalLength) : 0;
                    decimal linreg = linregList.ElementAtOrDefault(j);
                    decimal prevLinreg = j >= signalLength ? linregList.ElementAtOrDefault(j - signalLength) : 0;
                    decimal sign = signList.ElementAtOrDefault(j);
                    decimal lqcd = lqcdList.ElementAtOrDefault(j);

                    decimal osc = lqcd - sign;
                    oscList.Add(osc);

                    decimal oscDif = (y - prevY) - (linreg - prevLinreg);
                    oscDifList.Add(oscDif);

                    decimal prevHist = histList.LastOrDefault();
                    decimal hist = osc - sign;
                    histList.Add(hist);

                    decimal histDif = oscDif - sign;
                    histDifList.Add(histDif);

                    var signal = GetCompareSignal(hist, prevHist);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (lqcdList, signList, oscList, oscDifList, histList, histDifList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateQuadraticRegression(StockData stockDataClass, string maType, int days = 50)
        {
            //@version=3
            //study("Quadratic Regression", overlay = true)
            //length = input(500)
            //
            //y = close
            //x1 = n
            //x2 = pow(x1, 2)
            //
            //S11 = sum(x2, length) - pow(sum(x1, length), 2) / length
            //S12 = sum(x1 * x2, length) - (sum(x1, length) * sum(x2, length)) / length
            //S22 = sum(pow(x2, 2), length) - pow(sum(x2, length), 2) / length
            //Sy1 = sum(y * x1, length) - (sum(y, length) * sum(x1, length)) / length
            //Sy2 = sum(y * x2, length) - (sum(y, length) * sum(x2, length)) / length
            //
            //max1 = sma(x1, length)
            //max2 = sma(x2, length)
            //may = sma(y, length)
            //b2 = ((Sy1 * S22) - (Sy2 * S12)) / (S22 * S11 - pow(S12, 2))
            //b3 = ((Sy2 * S11) - (Sy1 * S12)) / (S22 * S11 - pow(S12, 2))
            //b1 = may - b2 * max1 - b3 * max2
            //Y = b1 + b2 * x1 + b3 * x2
            //
            //plot(Y, color = red, transp = 0)
            List<decimal> tempList = new();
            List<decimal> x1List = new();
            List<decimal> x2List = new();
            List<decimal> max2List = new();
            List<decimal> x1SumList = new();
            List<decimal> x2SumList = new();
            List<decimal> x1x2List = new();
            List<decimal> x1x2SumList = new();
            List<decimal> x2PowList = new();
            List<decimal> x2PowSumList = new();
            List<decimal> ySumList = new();
            List<decimal> yx1List = new();
            List<decimal> yx2List = new();
            List<decimal> yx1SumList = new();
            List<decimal> yx2SumList = new();
            List<decimal> s11List = new();
            List<decimal> s12List = new();
            List<decimal> s22List = new();
            List<decimal> sy1List = new();
            List<decimal> sy2List = new();
            List<decimal> b2List = new();
            List<decimal> b3List = new();
            List<decimal> b1List = new();
            List<decimal> yList = new();
            List<decimal> botList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int h = 0; h < stockDataClass.HighPrices.Count; h++)
                {
                    decimal y = stockDataClass.InputValues.ElementAtOrDefault(h);
                    tempList.Add(y);

                    decimal x1 = h;
                    x1List.Add(x1);

                    decimal x2 = Pow(x1, 2);
                    x2List.Add(x2);

                    decimal x1x2 = x1 * x2;
                    x1x2List.Add(x1x2);

                    decimal yx1 = y * x1;
                    yx1List.Add(yx1);

                    decimal yx2 = y * x2;
                    yx2List.Add(yx2);

                    decimal x2Pow = Pow(x2, 2);
                    x2PowList.Add(x2Pow);

                    decimal ySum = tempList.TakeLast(days).Sum();
                    ySumList.Add(ySum);

                    decimal x1Sum = x1List.TakeLast(days).Sum();
                    x1SumList.Add(x1Sum);

                    decimal x2Sum = x2List.TakeLast(days).Sum();
                    x2SumList.Add(x2Sum);

                    decimal x1x2Sum = x1x2List.TakeLast(days).Sum();
                    x1x2SumList.Add(x1x2Sum);

                    decimal yx1Sum = yx1List.TakeLast(days).Sum();
                    yx1SumList.Add(yx1Sum);

                    decimal yx2Sum = yx2List.TakeLast(days).Sum();
                    yx2SumList.Add(yx2Sum);

                    decimal x2PowSum = x2PowList.TakeLast(days).Sum();
                    x2PowSumList.Add(x2PowSum);
                }

                var max1List = GetMovingAverageList(maType, x1List, stockDataClass, days);
                max2List = GetMovingAverageList(maType, x2List, stockDataClass, days);
                var mayList = GetMovingAverageList(maType, null, stockDataClass, days);
                for (int i = 0; i < stockDataClass.HighPrices.Count; i++)
                {
                    decimal x1Sum = x1SumList.ElementAtOrDefault(i);
                    decimal x2Sum = x2SumList.ElementAtOrDefault(i);
                    decimal x1x2Sum = x1x2SumList.ElementAtOrDefault(i);
                    decimal x2PowSum = x2PowSumList.ElementAtOrDefault(i);
                    decimal yx1Sum = yx1SumList.ElementAtOrDefault(i);
                    decimal yx2Sum = yx2SumList.ElementAtOrDefault(i);
                    decimal ySum = ySumList.ElementAtOrDefault(i);
                    decimal may = mayList.ElementAtOrDefault(i);
                    decimal max1 = max1List.ElementAtOrDefault(i);
                    decimal max2 = max2List.ElementAtOrDefault(i);
                    decimal x1 = x1List.ElementAtOrDefault(i);
                    decimal x2 = x2List.ElementAtOrDefault(i);
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal s11 = x2Sum - (Pow(x1Sum, 2) / days);
                    s11List.Add(s11);

                    decimal s12 = x1x2Sum - ((x1Sum * x2Sum) / days);
                    s12List.Add(s12);

                    decimal s22 = x2PowSum - (Pow(x2Sum, 2) / days);
                    s22List.Add(s22);

                    decimal sy1 = yx1Sum - ((ySum * x1Sum) / days);
                    sy1List.Add(sy1);

                    decimal sy2 = yx2Sum - ((ySum * x2Sum) / days);
                    sy2List.Add(sy2);

                    decimal bot = (s22 * s11) - Pow(s12, 2);
                    botList.Add(bot);

                    decimal b2 = bot != 0 ? ((sy1 * s22) - (sy2 * s12)) / bot : 0;
                    b2List.Add(b2);

                    decimal b3 = bot != 0 ? ((sy2 * s11) - (sy1 * s12)) / bot : 0;
                    b3List.Add(b3);

                    decimal b1 = may - (b2 * max1) - (b3 * max2);
                    b1List.Add(b1);

                    decimal prevY = yList.LastOrDefault();
                    decimal y = b1 + (b2 * x1) + (b3 * x2);
                    yList.Add(y);

                    var signal = GetCompareSignal(currentValue - y, prevValue - prevY);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (x1x2List, yx2List, x2PowList, x1SumList, x2SumList, x1x2SumList, yx1SumList, yx2SumList, x2PowSumList, max2List,
                s11List, s12List, s22List, sy1List, sy2List, botList, b2List, b3List, b1List, yList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>)
            CalculateOvershootReductionMovingAverage(StockData stockDataClass, string maType, int days = 7)
        {
            //@version=2
            //study("ROMA", overlay = true)
            //length = input(14)
            //----
            //a = (n - sma(n, length)) / stdev(n, length) * correlation(close, n, length)
            //b = sma(abs(nz(d[1], close[1]) - close), length / 2)
            //c = b / highest(b, length)
            //d = sma(close, length) + a * (stdev(close, length) * c)
            //----
            //plot(d, color =#e91e63,linewidth=2,transp=0)
            List<decimal> indexList = new();
            List<decimal> highestList = new();
            List<decimal> aList = new();
            List<decimal> bList = new();
            List<decimal> cList = new();
            List<decimal> dList = new();
            List<decimal> bSmaList = new();
            List<decimal> indexStdDevList = new();
            List<decimal> corrList = new();
            List<decimal> tempList = new();
            List<Signal> signalsList = new();

            try
            {
                int length1 = days;
                int length2 = days * 2;

                for (int h = 0; h < stockDataClass.HighPrices.Count; h++)
                {
                    decimal index = h;
                    indexList.Add(index);

                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(h);
                    tempList.Add(currentValue);

                    var corr = GoodnessOfFit.R(indexList.TakeLast(length2).Select(x => (double)x), tempList.TakeLast(length2).Select(x => (double)x));
                    corr = IsValueNullOrInfinity(corr) ? 0 : corr;
                    corrList.Add((decimal)corr);
                }

                var indexSmaList = GetMovingAverageList(maType, indexList, stockDataClass, length2);
                indexStdDevList = CalculateStandardDeviationVolatility(indexList, stockDataClass, length2).Item4;
                var smaList = GetMovingAverageList(maType, null, stockDataClass, length2);
                var stdDevList = CalculateStandardDeviationVolatility(null, stockDataClass, length2).Item4;

                for (int i = 0; i < stockDataClass.HighPrices.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal index = indexList.ElementAtOrDefault(i);
                    decimal indexSma = indexSmaList.ElementAtOrDefault(i);
                    decimal indexStdDev = indexStdDevList.ElementAtOrDefault(i);
                    decimal corr = corrList.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevD = i >= 1 ? dList.ElementAtOrDefault(i - 1) != 0 ? dList.ElementAtOrDefault(i - 1) : prevValue : prevValue;
                    decimal sma = smaList.ElementAtOrDefault(i);
                    decimal stdDev = stdDevList.ElementAtOrDefault(i);

                    decimal a = indexStdDev != 0 && corr != 0 ? (index - indexSma) / indexStdDev * corr : 0;
                    aList.Add(a);

                    decimal b = Math.Abs(prevD - currentValue);
                    bList.Add(b);

                    decimal bSma = bList.TakeLast(length1).Average();
                    bSmaList.Add(bSma);

                    decimal highest = bSmaList.TakeLast(length2).Max();
                    highestList.Add(highest);

                    decimal c = highest != 0 ? b / highest : 0;
                    cList.Add(c);

                    decimal d = sma + (a * (stdDev * c));
                    dList.Add(d);

                    var signal = GetCompareSignal(currentValue - d, prevValue - prevD);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (indexStdDevList, aList, bList, bSmaList, highestList, cList, dList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateElderMarketThermometer(StockData stockDataClass, int days = 22)
        {
            //
            // @author LazyBear 
            // List of all my indicators: 
            // https://docs.google.com/document/d/15AGCufJZ8CIUvwFJ9W-IKns88gkWOKBCvByMEvm5MLo/edit?usp=sharing
            //
            //study("Elder Market Thermometer [LazyBear]", shorttitle = "EMT_LB")
            //lengthMA = input(22, "EMA Length")
            //explosiveMktThreshold = input(3, title = "Explosive Market Threshold")
            //idleMarketThreshold = input(7, title = "Idle Market Threshold")

            //emt = iff(high < high[1] and low > low[1], 0,
            //        iff((high - high[1]) > (low[1] - low), abs(high - high[1]), abs(low[1] - low)))

            //aemt = ema(emt, lengthMA)
            //qc = aemt > emt ? nz(qc[1]) + 1 : 0
            //cemt = (emt < aemt) ? qc > idleMarketThreshold ? green : blue :
            //        ((emt > aemt) and(emt < aemt * explosiveMktThreshold)) ? orange: red

            //plot(emt, color = cemt, style = columns, linewidth = 2, title = "Market Thermometer")
            //plot(aemt, color =#FE00DE, title="EMA of Market Thermometer")
            List<decimal> emtList = new();
            List<decimal> aemtList = new();
            List<decimal> qcList = new();
            List<Signal> signalsList = new();

            try
            {
                List<decimal> emaList = CalculateExponentialMovingAverage(stockDataClass, days).Item1;

                for (int i = 0; i < stockDataClass.HighPrices.Count; i++)
                {
                    decimal currentHigh = stockDataClass.HighPrices.ElementAtOrDefault(i);
                    decimal currentLow = stockDataClass.LowPrices.ElementAtOrDefault(i);
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal currentEma = emaList.ElementAtOrDefault(i);
                    decimal prevHigh = i >= 1 ? stockDataClass.HighPrices.ElementAtOrDefault(i - 1) : 0;
                    decimal prevLow = i >= 1 ? stockDataClass.LowPrices.ElementAtOrDefault(i - 1) : 0;
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevEma = i >= 1 ? emaList.ElementAtOrDefault(i - 1) : 0;

                    decimal emt = currentHigh < prevHigh && currentLow > prevLow ? 0 : currentHigh - prevHigh > prevLow - currentLow ? Math.Abs(currentHigh - prevHigh) :
                        Math.Abs(prevLow - currentLow);
                    emtList.Add(emt);

                    decimal emtEma = CalculateExponentialMovingAverage(emt, aemtList.LastOrDefault(), days);
                    aemtList.Add(emtEma);

                    decimal prevQc = qcList.LastOrDefault();
                    decimal qc = emtEma > emt ? prevQc + 1 : 0;
                    qcList.Add(qc);

                    var signal = GetVolatilitySignal(currentValue - currentEma, prevValue - prevEma, emt, emtEma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (emtList, aemtList, qcList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>)
            CalculateWaddahAttarExplosion(StockData stockDataClass, string maType, int days = 20)
        {
            //
            // @author LazyBear 
            // List of all my indicators: 
            // https://docs.google.com/document/d/15AGCufJZ8CIUvwFJ9W-IKns88gkWOKBCvByMEvm5MLo/edit?usp=sharing
            //
            //study("Waddah Attar Explosion [LazyBear]", shorttitle = "WAE_LB")
            //sensitivity = input(150, title = "Sensitivity")
            //fastLength = input(20, title = "FastEMA Length")
            //slowLength = input(40, title = "SlowEMA Length")
            //channelLength = input(20, title = "BB Channel Length")
            //mult = input(2.0, title = "BB Stdev Multiplier")
            //deadZone = input(20, title = "No trade zone threshold")
            //
            //calc_macd(source, fastLength, slowLength) =>
            //    fastMA = ema(source, fastLength)            
            //    slowMA = ema(source, slowLength)
            //    fastMA - slowMA
            //
            //calc_BBUpper(source, length, mult) => 
            //    basis = sma(source, length)
            //    dev = mult * stdev(source, length)
            //    basis + dev
            //
            //calc_BBLower(source, length, mult) => 
            //    basis = sma(source, length)
            //    dev = mult * stdev(source, length)
            //    basis - dev
            //
            //t1 = (calc_macd(close, fastLength, slowLength) - calc_macd(close[1], fastLength, slowLength)) * sensitivity
            //t2 = (calc_macd(close[2], fastLength, slowLength) - calc_macd(close[3], fastLength, slowLength)) * sensitivity
            //e1 = (calc_BBUpper(close, channelLength, mult) - calc_BBLower(close, channelLength, mult))
            //
            //trendUp = (t1 >= 0) ? t1 : 0
            //trendDown = (t1 < 0) ? (-1 * t1) : 0
            //plot(trendUp, style = columns, linewidth = 1, color = (trendUp < trendUp[1]) ? lime : green, transp = 45, title = "UpTrend")
            //plot(trendDown, style = columns, linewidth = 1, color = (trendDown < trendDown[1]) ? orange : red, transp = 45, title = "DownTrend")
            //plot(e1, style = line, linewidth = 2, color =#A0522D, title="ExplosionLine")
            //hline(deadZone, color = blue, linewidth = 2, title = "DeadZoneLine")
            List<decimal> t1List = new();
            List<decimal> t2List = new();
            List<decimal> e1List = new();
            List<decimal> e2List = new();
            List<decimal> pwreList = new();
            List<decimal> pwrtList = new();
            List<decimal> temp1List = new();
            List<decimal> temp2List = new();
            List<decimal> temp3List = new();
            List<decimal> macd1List = new();
            List<decimal> macd2List = new();
            List<decimal> macd3List = new();
            List<decimal> trendHistogramList = new();
            List<decimal> trendUpList = new();
            List<decimal> trendDnList = new();
            List<Signal> signalsList = new();

            try
            {
                int fastLength = days;
                int sensitivity = 150;
                int slowLength = MinOrMax(fastLength * 2);

                List<decimal> emaFastList = GetMovingAverageList(maType, null, stockDataClass, fastLength);
                List<decimal> emaSlowList = GetMovingAverageList(maType, null, stockDataClass, slowLength);
                var bbList = CalculateBollingerBands(null, stockDataClass, 2, maType, fastLength);
                List<decimal> upperBollingerBandList = bbList.Item1;
                List<decimal> lowerBollingerBandList = bbList.Item2;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal prevValue1 = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    temp1List.Add(prevValue1);

                    decimal prevValue2 = i >= 2 ? stockDataClass.InputValues.ElementAtOrDefault(i - 2) : 0;
                    temp2List.Add(prevValue2);

                    decimal prevValue3 = i >= 3 ? stockDataClass.InputValues.ElementAtOrDefault(i - 3) : 0;
                    temp3List.Add(prevValue3);
                }

                var ema1FastList = GetMovingAverageList(maType, temp1List, stockDataClass, fastLength);
                var ema1SlowList = GetMovingAverageList(maType, temp1List, stockDataClass, slowLength);
                var ema2FastList = GetMovingAverageList(maType, temp2List, stockDataClass, fastLength);
                var ema2SlowList = GetMovingAverageList(maType, temp2List, stockDataClass, slowLength);
                var ema3FastList = GetMovingAverageList(maType, temp3List, stockDataClass, fastLength);
                var ema3SlowList = GetMovingAverageList(maType, temp3List, stockDataClass, slowLength);
                var bb2List = CalculateBollingerBands(temp1List, stockDataClass, 2, maType, fastLength);
                List<decimal> upperBollingerBand2List = bb2List.Item1;
                List<decimal> lowerBollingerBand2List = bb2List.Item2;
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal currentMacd = emaFastList.ElementAtOrDefault(j) - emaSlowList.ElementAtOrDefault(j);
                    decimal currentUpperBB = upperBollingerBandList.ElementAtOrDefault(j);
                    decimal currentLowerBB = lowerBollingerBandList.ElementAtOrDefault(j);
                    decimal currentUpperBB2 = upperBollingerBand2List.ElementAtOrDefault(j);
                    decimal currentLowerBB2 = lowerBollingerBand2List.ElementAtOrDefault(j);

                    decimal prevMacd1 = ema1FastList.ElementAtOrDefault(j) - ema1SlowList.ElementAtOrDefault(j);
                    macd1List.Add(prevMacd1);

                    decimal prevMacd2 = ema2FastList.ElementAtOrDefault(j) - ema2SlowList.ElementAtOrDefault(j);
                    macd2List.Add(prevMacd2);

                    decimal prevMacd3 = ema3FastList.ElementAtOrDefault(j) - ema3SlowList.ElementAtOrDefault(j);
                    macd3List.Add(prevMacd3);

                    decimal t1 = (currentMacd - prevMacd1) * sensitivity;
                    t1List.Add(t1);

                    decimal t2 = (prevMacd2 - prevMacd3) * sensitivity;
                    t2List.Add(t2);

                    decimal prevE1 = e1List.LastOrDefault();
                    decimal e1 = currentUpperBB - currentLowerBB;
                    e1List.Add(e1);

                    decimal e2 = currentUpperBB2 - currentLowerBB2;
                    e2List.Add(e2);

                    decimal pwrt = t1 != 0 ? 100 * ((Math.Abs(t1) - Math.Abs(t2)) / Math.Abs(t1)) : 0;
                    pwrtList.Add(pwrt);

                    decimal pwre = e1 != 0 ? 100 * ((e1 - e2) / e1) : 0;
                    pwreList.Add(pwre);

                    decimal trendHistogram = t1 >= 0 ? t1 : t1 * -1;
                    trendHistogramList.Add(trendHistogram);

                    decimal prevTrendUp = trendUpList.LastOrDefault();
                    decimal trendUp = (t1 >= 0) ? t1 : 0;
                    trendUpList.Add(trendUp);

                    decimal prevTrendDn = trendDnList.LastOrDefault();
                    decimal trendDown = (t1 < 0) ? (-1 * t1) : 0;
                    trendDnList.Add(trendDown);

                    var signal = GetConditionSignal(trendUp > prevTrendUp && trendUp > e1 && e1 > prevE1 && trendUp > days && e1 > days, trendUp < e1);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (macd1List, macd2List, macd3List, t1List, t2List, e1List, e2List, pwrtList, pwreList, trendHistogramList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateElliottWaveOscillator(StockData stockDataClass, string maType, int days = 5)
        {
            //input = price, user defined, default is Midpoint
            //method = moving average (ma), user defined, default is SMA
            //slowPeriod = user defined, default is 34
            //fastPeriod = user defined, default is 5
            //index = current bar number
            //MT= more than, LT= less than

            //slowMA = ma(method, index, slowPeriod, input);
            //fastMA = ma(method, index, fastPeriod, input);
            //diff = fastMA - slowMA;
            //prev = diff[index - 1];
            //if (prev MT diff) setcolor(downColor);
            //else setColor(upColor);
            //PlotHist: diff
            List<decimal> elliottWaveOscillatorList = new();
            List<decimal> ppoList = new();
            List<decimal> ppoHistogramList = new();
            List<decimal> ppoSignalLineList = new();
            List<decimal> elliottWaveOscillatorSignalLineList = new();
            List<decimal> elliottWaveOscillatorHistogramList = new();
            List<Signal> signalsList = new();

            try
            {
                int sma5Period = days;
                int sma34Period = MinOrMax((int)Math.Ceiling(sma5Period / 0.147));

                List<decimal> smaList = GetMovingAverageList(maType, null, stockDataClass, sma5Period);
                var sma34List = GetMovingAverageList(maType, null, stockDataClass, sma34Period);

                for (int i = 0; i < smaList.Count; i++)
                {
                    decimal currentSma5 = smaList.ElementAtOrDefault(i);
                    decimal currentSma34 = sma34List.ElementAtOrDefault(i);

                    decimal elliottWaveOscillator = currentSma5 - currentSma34;
                    elliottWaveOscillatorList.Add(elliottWaveOscillator);

                    decimal ppo = currentSma34 != 0 ? elliottWaveOscillator / currentSma34 * 100 : 0;
                    ppoList.Add(ppo);

                    decimal elliottWaveOscillatorSignalLine = elliottWaveOscillatorList.TakeLast(sma5Period).Average();
                    elliottWaveOscillatorSignalLineList.Add(elliottWaveOscillatorSignalLine);

                    decimal ppoSignalLine = ppoList.TakeLast(sma5Period).Average();
                    ppoSignalLineList.Add(ppoSignalLine);

                    decimal ppoHistogram = ppo - ppoSignalLine;
                    ppoHistogramList.Add(ppoHistogram);

                    decimal prevElliottWaveOscillatorHistogram = elliottWaveOscillatorHistogramList.LastOrDefault();
                    decimal elliottWaveOscillatorHistogram = elliottWaveOscillator - elliottWaveOscillatorSignalLine;
                    elliottWaveOscillatorHistogramList.Add(elliottWaveOscillatorHistogram);

                    var signal = GetCompareSignal(elliottWaveOscillatorHistogram, prevElliottWaveOscillatorHistogram);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (elliottWaveOscillatorSignalLineList, elliottWaveOscillatorHistogramList, ppoList, ppoSignalLineList, ppoHistogramList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>)
            CalculateModifiedGannHiloActivator(StockData stockDataClass, int days = 50)
        {
            //@version=3
            //study("Modified Gann HiLo Activator", overlay = true)
            //length = input(50),mult = input(1, minval = 0, maxval = 1),Method = input("SMA", options =["SMA", "Median"])
            //----
            //Avg(x)=> Method == "SMA" ? sma(x, length) : percentile_linear_interpolation(x, length, 50)
            //----
            //a = highest(length) - max(close, open)
            //b = min(close, open) - lowest(length)
            //c = max(close, open) + a * mult
            //d = min(close, open) - b * mult
            //----
            //e = Avg(c)
            //f = Avg(d)
            //g = 0
            //g:= cross(close, e) ? 1 : cross(close, f) ? 0 : nz(g[1])
            //---
            //hilo = g * f + (1 - g) * e
            //css = g == 1 ? #0080FF : #FE2E64
            //plot(hilo, color = css, linewidth = 2, transp = 0)
            List<decimal> gannHiloList = new();
            List<decimal> aList = new();
            List<decimal> bList = new();
            List<decimal> cList = new();
            List<decimal> dList = new();
            List<decimal> eList = new();
            List<decimal> fList = new();
            List<decimal> gList = new();
            List<Signal> signalsList = new();

            try
            {
                int mult = 1;
                var minMaxList = GetMaxAndMinValuesList(stockDataClass.HighPrices, stockDataClass.LowPrices, days);
                List<decimal> highestHighList = minMaxList.Item1;
                List<decimal> lowestLowList = minMaxList.Item2;

                for (int i = 0; i < highestHighList.Count; i++)
                {
                    decimal highestHigh = highestHighList.ElementAtOrDefault(i);
                    decimal lowestLow = lowestLowList.ElementAtOrDefault(i);
                    decimal currentClose = stockDataClass.ClosePrices.ElementAtOrDefault(i);
                    decimal currentOpen = stockDataClass.OpenPrices.ElementAtOrDefault(i);
                    decimal prevClose = i >= 1 ? stockDataClass.ClosePrices.ElementAtOrDefault(i - 1) : 0;
                    decimal max = Math.Max(currentClose, currentOpen);
                    decimal min = Math.Min(currentClose, currentOpen);

                    decimal a = highestHigh - max;
                    aList.Add(a);

                    decimal b = min - lowestLow;
                    bList.Add(b);

                    decimal c = max + (a * mult);
                    cList.Add(c);

                    decimal d = min - (b * mult);
                    dList.Add(d);

                    decimal e = cList.TakeLast(days).Average();
                    eList.Add(e);

                    decimal f = dList.TakeLast(days).Average();
                    fList.Add(f);

                    decimal prevG = gList.LastOrDefault();
                    decimal g = currentClose > e ? 1 : currentClose > f ? 0 : prevG;
                    gList.Add(g);

                    decimal prevGannHilo = gannHiloList.LastOrDefault();
                    decimal gannHilo = (g * f) + ((1 - g) * e);
                    gannHiloList.Add(gannHilo);

                    var signal = GetCompareSignal(currentClose - gannHilo, prevClose - prevGannHilo);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (aList, bList, cList, dList, eList, fList, gList, gannHiloList, signalsList);
        }

        public static (List<decimal>, List<Signal>) CalculateGannSwingOscillator(StockData stockDataClass, int days = 5)
        {
            //@version=2
            ////////////////////////////////////////////////////////////
            //  Copyright by HPotter v1.0 18/05/2017
            // The Gann Swing Oscillator has been adapted from Robert Krausz's book, 
            // "A W.D. Gann Treasure Discovered". The Gann Swing Oscillator helps 
            // define market swings. 
            ////////////////////////////////////////////////////////////
            //study(title = "Gann Swing Oscillator")
            //Length = input(5, minval = 1)
            //hline(0, color = gray, linestyle = dashed)
            //xHH = highest(Length)
            //xLL = lowest(Length)
            //xGSO = iff(xHH[2] > xHH[1] and xHH[0] > xHH[1], 1,
            //         iff(xLL[2] < xLL[1] and xLL[0] < xLL[1], -1, nz(xGSO[1], 0)))
            //plot(xGSO, color = blue, title = "GSO")
            List<decimal> gannSwingOscillatorList = new();
            List<Signal> signalsList = new();

            try
            {
                var minMaxList = VolumeInputCheck(stockDataClass, days, true);
                var highestList = minMaxList.Item1;
                var lowestList = minMaxList.Item2;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal highestHigh = highestList.ElementAtOrDefault(i);
                    decimal lowestLow = lowestList.ElementAtOrDefault(i);
                    decimal prevHighest1 = i >= 1 ? highestList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevLowest1 = i >= 1 ? lowestList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevHighest2 = i >= 2 ? highestList.ElementAtOrDefault(i - 2) : 0;
                    decimal prevLowest2 = i >= 2 ? lowestList.ElementAtOrDefault(i - 2) : 0;

                    decimal prevGso = gannSwingOscillatorList.LastOrDefault();
                    decimal gso = prevHighest2 > prevHighest1 && highestHigh > prevHighest1 ? 1 : prevLowest2 < prevLowest1 && lowestLow < prevLowest1 ? -1 : prevGso;
                    gannSwingOscillatorList.Add(gso);

                    var signal = GetCompareSignal(gso, prevGso);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (gannSwingOscillatorList, signalsList);
        }

        public static (List<decimal>, List<Signal>) CalculateGannTrendOscillator(StockData stockDataClass, int days = 3)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Gann Trend Oscillator script may be freely distributed under the MIT license.
            //study("Gann Trend Oscillator", shorttitle = "GTO")

            //src = input(title = "Source", type = input.source, defval = close)
            //length = input(title = "Length", type = input.integer, defval = 3, minval = 1)

            //hv = highest(src, length)
            //lv = lowest(src, length)

            //gto = 0
            //gto:= hv[2] > hv[1] and hv[0] > hv[1] ? 1 : lv[2] < lv[1] and lv[0] < lv[1] ? -1 : nz(gto[1], 0)

            //gtoColor = gto > 0 ? color.green : gto < 0 ? color.red : color.black
            //plot(gto, title = "GTO", linewidth = 2, color = gtoColor, transp = 0)
            List<decimal> gannTrendOscillatorList = new();
            List<Signal> signalsList = new();

            try
            {
                var minMaxList = GetMaxAndMinValuesList(stockDataClass.InputValues, days);
                var highestList = minMaxList.Item1;
                var lowestList = minMaxList.Item2;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal highestHigh = highestList.ElementAtOrDefault(i);
                    decimal lowestLow = lowestList.ElementAtOrDefault(i);
                    decimal prevHighest1 = i >= 1 ? highestList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevLowest1 = i >= 1 ? lowestList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevHighest2 = i >= 2 ? highestList.ElementAtOrDefault(i - 2) : 0;
                    decimal prevLowest2 = i >= 2 ? lowestList.ElementAtOrDefault(i - 2) : 0;

                    decimal prevGto = gannTrendOscillatorList.LastOrDefault();
                    decimal gto = prevHighest2 > prevHighest1 && highestHigh > prevHighest1 ? 1 : prevLowest2 < prevLowest1 && lowestLow < prevLowest1 ? -1 : prevGto;
                    gannTrendOscillatorList.Add(gto);

                    var signal = GetCompareSignal(gto, prevGto);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (gannTrendOscillatorList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<Signal>) CalculateRelativeVolatilityIndexOriginal(List<decimal>? customValuesList, StockData stockDataClass, string maType, int days = 10)
        {
            ////////////////////////////////////////////////////////////
            //  Copyright by HPotter v1.0 20/10/2017
            // The RVI is a modified form of the relative strength index (RSI). 
            // The original RSI calculation separates one-day net changes into 
            // positive closes and negative closes, then smoothes the data and 
            // normalizes the ratio on a scale of zero to 100 as the basis for the 
            // formula. The RVI uses the same basic formula but substitutes the 
            // 10-day standard deviation of the closing prices for either the up 
            // close or the down close. The goal is to create an indicator that 
            // measures the general direction of volatility. The volatility is 
            // being measured by the 10-days standard deviation of the closing prices. 
            //
            // WARNING:
            // - This script to change bars colors.
            ////////////////////////////////////////////////////////////
            //study(title = "Relative Volatility Index", shorttitle = "RVI")
            //Period = input(10, minval = 1)
            //BuyZone = input(30, minval = 1)
            //SellZone = input(70, minval = 1)
            //hline(0, color = purple, linestyle = dashed)
            //hline(BuyZone, color = red, linestyle = line)
            //hline(SellZone, color = green, linestyle = line)
            //xPrice = close
            //StdDev = stdev(xPrice, Period)
            //d = iff(close > close[1], 0, StdDev)
            //u = iff(close > close[1], StdDev, 0)
            //nU = (13 * nz(nU[1], 0) + u) / 14
            //nD = (13 * nz(nD[1], 0) + d) / 14
            //nRes = 100 * nU / (nU + nD)
            //pos = iff(nRes < BuyZone, -1,
            //      iff(nRes > SellZone, 1, nz(pos[1], 0)))
            //barcolor(pos == -1 ? red : pos == 1 ? green : blue)
            //plot(nRes, color = red, title = "RVI")
            List<decimal> upList = new();
            List<decimal> downList = new();
            List<decimal> upAvgList = new();
            List<decimal> downAvgList = new();
            List<decimal> rviOriginalList = new();
            List<decimal> diffList = new();
            List<decimal> rsList = new();
            List<Signal> signalsList = new();

            try
            {
                int sdPeriod = days;
                int smoothPeriod = MinOrMax((int)Math.Ceiling(sdPeriod / 0.7143));

                List<decimal> stdDeviationList = CalculateStandardDeviationVolatility(customValuesList, stockDataClass, sdPeriod).Item4;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentStdDeviation = stdDeviationList.ElementAtOrDefault(i);
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevStdDeviation = i >= 1 ? stdDeviationList.ElementAtOrDefault(i - 1) : 0;

                    decimal diff = currentStdDeviation - prevStdDeviation;
                    diffList.Add(diff);

                    decimal up = currentValue > prevValue ? currentStdDeviation : 0;
                    upList.Add(up);

                    decimal down = currentValue < prevValue ? currentStdDeviation : 0;
                    downList.Add(down);
                }

                upAvgList = GetMovingAverageList(maType, upList, stockDataClass, smoothPeriod);
                downAvgList = GetMovingAverageList(maType, downList, stockDataClass, smoothPeriod);
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal avgUp = upAvgList.ElementAtOrDefault(j);
                    decimal avgDown = downAvgList.ElementAtOrDefault(j);
                    decimal prevRvi1 = j >= 1 ? rviOriginalList.ElementAtOrDefault(j - 1) : 0;
                    decimal prevRvi2 = j >= 1 ? rviOriginalList.ElementAtOrDefault(j - 2) : 0;

                    decimal rs = avgDown != 0 ? avgUp / avgDown : 0;
                    rsList.Add(rs);

                    decimal rvi = avgDown == 0 ? 100 : avgUp == 0 ? 0 : MinOrMax(100 - (100 / (1 + rs)), 100, 0);
                    rviOriginalList.Add(rvi);

                    var signal = GetRsiSignal(rvi - prevRvi1, prevRvi1 - prevRvi2, rvi, prevRvi1, 70, 30);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (diffList, upList, downList, upAvgList, downAvgList, rsList, rviOriginalList, signalsList);
        }

        public static (List<decimal>, List<Signal>) CalculateRelativeVolatilityIndex(StockData stockDataClass, string maType, int days = 9)
        {
            // if current price is greater than prev price then
            // up = 9 period std deviation of the price
            // dn = 0
            // else
            // up = 0
            // dn = 9 period std deviation of the price
            // upavg = upavg * (n - 1) + up / n
            // dnavg = dnavg * (n - 1) + dn / n
            // rvi original = 100 * (upavg / upavg + dnavg)
            // rvi = origHigh + origLow / 2
            List<decimal> rviList = new();
            List<Signal> signalsList = new();

            try
            {
                List<decimal> rviHighList = CalculateRelativeVolatilityIndexOriginal(stockDataClass.HighPrices, stockDataClass, maType, days).Item7;
                List<decimal> rviLowList = CalculateRelativeVolatilityIndexOriginal(stockDataClass.LowPrices, stockDataClass, maType, days).Item7;

                for (int i = 0; i < rviHighList.Count; i++)
                {
                    decimal rviOriginalHigh = rviHighList.ElementAtOrDefault(i);
                    decimal rviOriginalLow = rviLowList.ElementAtOrDefault(i);
                    decimal prevRvi1 = i >= 1 ? rviList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevRvi2 = i >= 2 ? rviList.ElementAtOrDefault(i - 2) : 0;

                    decimal rvi = (rviOriginalHigh + rviOriginalLow) / 2;
                    rviList.Add(rvi);

                    var signal = GetRsiSignal(rvi - prevRvi1, prevRvi1 - prevRvi2, rvi, prevRvi1, 70, 30);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (rviList, signalsList);
        }

        public static (List<decimal>, List<Signal>) CalculateGannHiLoActivator(StockData stockDataClass, string maType, int days = 3)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Gann HiLo Activator [CC] script may be freely distributed under the MIT license.
            //study("Gann HiLo Activator [CC]", shorttitle = "GHLA", overlay = true)

            //f_security(_symbol, _res, _src, _repaint) => 
            //    security(_symbol, _res, _src[_repaint ? 0 : barstate.isrealtime ? 1 : 0])[_repaint ? 0 : barstate.isrealtime ? 0 : 1]

            //length = input(title = "Length", type = input.integer, defval = 3, minval = 1)
            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //h = f_security(syminfo.tickerid, res, high, rep)
            //l = f_security(syminfo.tickerid, res, low, rep)
            //c = f_security(syminfo.tickerid, res, close, rep)

            //highMa = sma(h, length)
            //lowMa = sma(l, length)

            //ghla = 0.0
            //ghla:= c > nz(highMa[1]) ? lowMa : c < nz(lowMa[1]) ? highMa : nz(ghla[1])

            //sig = c > ghla ? 1 : c < ghla ? -1 : 0
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //ghlaColor = sig > 0 ? color.green : sig < 0 ? color.red : color.black
            //barcolor(bar ? ghlaColor : na)
            //plot(ghla, title = "GHLA", color = ghlaColor, linewidth = 2)
            List<decimal> ghlaList = new();
            List<Signal> signalsList = new();

            try
            {
                var highMaList = GetMovingAverageList(maType, stockDataClass.HighPrices, stockDataClass, days);
                var lowMaList = GetMovingAverageList(maType, stockDataClass.LowPrices, stockDataClass, days);

                for (int i = 0; i < stockDataClass.HighPrices.Count; i++)
                {
                    decimal highMa = highMaList.ElementAtOrDefault(i);
                    decimal lowMa = lowMaList.ElementAtOrDefault(i);
                    decimal prevHighMa = i >= 1 ? highMaList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevLowMa = i >= 1 ? lowMaList.ElementAtOrDefault(i - 1) : 0;
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal prevGhla = ghlaList.LastOrDefault();
                    decimal ghla = currentValue > prevHighMa ? lowMa : currentValue < prevLowMa ? highMa : prevGhla;
                    ghlaList.Add(ghla);

                    var signal = GetCompareSignal(currentValue - ghla, prevValue - prevGhla);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (ghlaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateLinearRegression(List<decimal>? customValuesList, StockData stockDataClass, int days)
        {
            //Regression Formula: y = a + bx

            //Where
            //Y is close price of a bar in the selected period
            //X is the Bar's number
            //N is number of bars in the selected period

            //The slope and the intercept are calculated in the following way:
            //Slope(b) = (NΣXY - (ΣX)(ΣY)) / (NΣX2 - (ΣX)2)
            //Intercept(a) = (ΣY - b(ΣX)) / N
            //Standard Error = y - a - bx
            // normalized slope (b) = (b x 100) / Price
            // linear regression acceleration = current slope - previous slope
            List<decimal> slopeList = new();
            List<decimal> interceptList = new();
            List<decimal> predictedTomorrowList = new();
            List<decimal> stdErrorList = new();
            List<decimal> predictedTodayList = new();
            List<decimal> sumXYList = new();
            List<decimal> sumXList = new();
            List<decimal> sumYList = new();
            List<decimal> sumX2List = new();
            List<decimal> xList = new();
            List<decimal> yList = new();
            List<decimal> xyList = new();
            List<decimal> x2List = new();
            List<decimal> topList = new();
            List<decimal> bottomList = new();
            List<decimal> normalizedSlopeList = new();
            List<decimal> lrAccelerationList = new();
            List<Signal> signalsList = new();

            try
            {
                if (customValuesList != null)
                {
                    stockDataClass.InputValues = customValuesList;
                }

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal prevValue = yList.LastOrDefault();
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    yList.Add(currentValue);

                    decimal x = i;
                    xList.Add(x);

                    decimal x2 = Pow(x, 2);
                    x2List.Add(x2);

                    decimal xy = x * currentValue;
                    xyList.Add(xy);

                    decimal sumX = xList.TakeLast(days).Sum();
                    sumXList.Add(sumX);

                    decimal sumY = yList.TakeLast(days).Sum();
                    sumYList.Add(sumY);

                    decimal sumXY = xyList.TakeLast(days).Sum();
                    sumXYList.Add(sumXY);

                    decimal sumX2 = x2List.TakeLast(days).Sum();
                    sumX2List.Add(sumX2);

                    decimal top = (days * sumXY) - (sumX * sumY);
                    topList.Add(top);

                    decimal bottom = (days * sumX2) - Pow(sumX, 2);
                    bottomList.Add(bottom);

                    decimal b = bottom != 0 ? top / bottom : 0;
                    slopeList.Add(b);

                    decimal prevNormalizedSlope = normalizedSlopeList.LastOrDefault();
                    decimal normalizedSlope = currentValue != 0 ? b * 100 / currentValue : 0;
                    normalizedSlopeList.Add(normalizedSlope);

                    decimal lrAcceleration = normalizedSlope - prevNormalizedSlope;
                    lrAccelerationList.Add(lrAcceleration);

                    decimal a = (sumY - (b * sumX)) / days;
                    interceptList.Add(a);

                    decimal predictedToday = a + (b * x);
                    predictedTodayList.Add(predictedToday);

                    decimal prevPredictedNextDay = predictedTomorrowList.LastOrDefault();
                    decimal predictedNextDay = a + (b * (x + 1));
                    predictedTomorrowList.Add(predictedNextDay);

                    var stdError = GoodnessOfFit.PopulationStandardError(predictedTodayList.TakeLast(days).Select(x => (double)x), yList.TakeLast(days).Select(x => (double)x));
                    stdError = IsValueNullOrInfinity(stdError) ? 0 : stdError;
                    stdErrorList.Add((decimal)stdError);

                    var signal = GetCompareSignal(currentValue - predictedNextDay, prevValue - prevPredictedNextDay, true);
                    signalsList.Add(signal);
                }

                // reset the input values list
                stockDataClass = LoadCalculations.GetInputValuesList(stockDataClass.InputName, stockDataClass);
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (yList, xList, x2List, xyList, sumYList, sumXList, sumX2List, sumXYList, topList, bottomList, slopeList, normalizedSlopeList, lrAccelerationList, interceptList,
                predictedTodayList, predictedTomorrowList, stdErrorList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateInertiaIndicator(StockData stockDataClass, string maType, int days)
        {
            //@version=3
            // Copyright (c) 2019-present, Alex Orekhov (everget)
            // Dorsey Inertia script may be freely distributed under the MIT license.
            //study("Dorsey Inertia", shorttitle = "Inertia")

            //stdevLength = input(title = "Standard Deviation Length", type = integer, defval = 21)
            //rviSmoothLength = input(title = "RVI Smoothing Length", type = integer, defval = 14)
            //smoothLength = input(title = "Inertia Smoothing Length", type = integer, defval = 14)

            // Relative Volatility Index (1993)
            //  rviOriginal(src, stdevLength, smoothLength) =>
            //    stdev = stdev(src, stdevLength)

            //    upSum = ema(change(src) >= 0 ? stdev : 0, smoothLength)

            //    downSum = ema(change(src) >= 0 ? 0 : stdev, smoothLength)

            //    100 * upSum / (upSum + downSum)

            //rvi = avg(rviOriginal(high, stdevLength, rviSmoothLength), rviOriginal(low, stdevLength, rviSmoothLength))
            //inertia = linreg(rvi, smoothLength, 0)

            //inertiaColor = inertia > 50 ? #0ebb23 : red

            //plot(inertia, title = "Inertia", linewidth = 2, color = inertiaColor, transp = 0)
            //hline(50, title = "Middle Level", linestyle = dotted)
            List<Signal> signalsList = new();
            var rviList = CalculateRelativeVolatilityIndex(stockDataClass, maType, days).Item1;
            var inertiaList = CalculateLinearRegression(rviList, stockDataClass, days);

            try
            {
                var inertiaIndicatorList = inertiaList.Item15;

                for (int i = 0; i < inertiaIndicatorList.Count; i++)
                {
                    decimal inertiaIndicator = inertiaIndicatorList.ElementAtOrDefault(i);
                    decimal prevInertiaIndicator1 = i >= 1 ? inertiaIndicatorList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevInertiaIndicator2 = i >= 2 ? inertiaIndicatorList.ElementAtOrDefault(i - 2) : 0;

                    var signal = GetCompareSignal(inertiaIndicator - prevInertiaIndicator1, prevInertiaIndicator1 - prevInertiaIndicator2);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (inertiaList.Item1, inertiaList.Item2, inertiaList.Item3, inertiaList.Item4, inertiaList.Item5, inertiaList.Item6, inertiaList.Item7, inertiaList.Item8,
                inertiaList.Item9, inertiaList.Item10, inertiaList.Item11, inertiaList.Item12, inertiaList.Item13, inertiaList.Item14, inertiaList.Item15, inertiaList.Item16,
                inertiaList.Item17, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateMcClellanOscillator(StockData stockDataClass, string maType, int days = 9)
        {
            //
            // @author LazyBear 
            // List of all my indicators: 
            // https://docs.google.com/document/d/15AGCufJZ8CIUvwFJ9W-IKns88gkWOKBCvByMEvm5MLo/edit?usp=sharing
            //
            //study("McClellan Oscillator [LazyBear]", shorttitle = "MO_LB")
            //advissues = input(defval = "ADVN", title = "Advancing Stocks Symbol", type = symbol)
            //decissues = input(defval = "DECN", title = "Declining Stocks Symbol", type = symbol)
            //isRA = input(true, title = "Stockcharts version (Ratio Adjusted)?")
            //rm = input(defval = 1000, title = "RANA ratio multiplier")
            //showEMAs = input(false, title = "Show EMAs?")
            //showOsc = input(true, title = "Show Oscillator?")

            //useCTF = input(false, title = "Use Custom Timeframe?"), 
            //tf = useCTF ? input("D", type = resolution, title = "Custom Timeframe") : period
            //ai = security(advissues, tf, close), di = security(decissues, tf, close)
            //rana = rm * (ai - di) / (ai + di)
            //e1 = isRA ? ema(rana, 19) : ema(ai - di, 19),e2 = isRA ? ema(rana, 39) : ema(ai - di, 39)
            //mo = e1 - e2

            //hline(0, title = "ZeroLine")
            //plot(showOsc ? mo < 0 ? mo : 0 : na, style = area, color = red, title = "MO_Negative")
            //plot(showOsc ? mo >= 0 ? mo : 0 : na, style = area, color = green, title = "MO_Positive")
            //plot(showOsc ? mo : na, style = line, color = black, title = "MO", linewidth = 2)
            //plot(showEMAs ? e1 : na, color = blue, linewidth = 2, title = "19 EMA")
            //plot(showEMAs ? e2 : na, color = red, linewidth = 2, title = "39 EMA")
            decimal rm = 1000;
            List<decimal> advancesList = new();
            List<decimal> declinesList = new();
            List<decimal> advancesSumList = new();
            List<decimal> declinesSumList = new();
            List<decimal> ranaList = new();
            List<decimal> rana19EmaList = new();
            List<decimal> rana39EmaList = new();
            List<decimal> mcclellanOscillatorList = new();
            List<decimal> mcclellanSummationList = new();
            List<decimal> mcclellanHistogramList = new();
            List<decimal> mcclellanSignalLineList = new();
            List<Signal> signalsList = new();

            try
            {
                int fastPeriod = (int)Math.Ceiling(days / 0.4737);
                int slowPeriod = (int)Math.Ceiling(days / 0.2308);
                int signalPeriod = days;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal advance = currentValue > prevValue ? 1 : 0;
                    advancesList.Add(advance);

                    decimal decline = currentValue < prevValue ? 1 : 0;
                    declinesList.Add(decline);

                    decimal advanceSum = advancesList.TakeLast(fastPeriod).Sum();
                    advancesSumList.Add(advanceSum);

                    decimal declineSum = declinesList.TakeLast(fastPeriod).Sum();
                    declinesSumList.Add(declineSum);

                    decimal rana = advanceSum + declineSum != 0 ? rm * (advanceSum - declineSum) / (advanceSum + declineSum) : 0;
                    ranaList.Add(rana);
                }

                rana19EmaList = GetMovingAverageList(maType, ranaList, stockDataClass, fastPeriod);
                rana39EmaList = GetMovingAverageList(maType, ranaList, stockDataClass, slowPeriod);
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal rana19Ema = rana19EmaList.ElementAtOrDefault(j);
                    decimal rana39Ema = rana39EmaList.ElementAtOrDefault(j);

                    decimal mcclellanOscillator = rana19Ema - rana39Ema;
                    mcclellanOscillatorList.Add(mcclellanOscillator);

                    decimal mcclellanSignalLine = CalculateExponentialMovingAverage(mcclellanOscillator, mcclellanSignalLineList.LastOrDefault(), signalPeriod);
                    mcclellanSignalLineList.Add(mcclellanSignalLine);

                    decimal prevMcclellanHistogram = mcclellanHistogramList.LastOrDefault();
                    decimal mcclellanHistogram = mcclellanOscillator - mcclellanSignalLine;
                    mcclellanHistogramList.Add(mcclellanHistogram);

                    decimal prevMcClellanSummation = mcclellanSummationList.LastOrDefault();
                    decimal mcclellanSummation = prevMcClellanSummation + mcclellanOscillator;
                    mcclellanSummationList.Add(mcclellanSummation);

                    var signal = GetCompareSignal(mcclellanHistogram, prevMcclellanHistogram);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (advancesList, declinesList, advancesSumList, declinesSumList, ranaList, rana19EmaList, rana39EmaList, mcclellanOscillatorList, mcclellanSignalLineList,
                mcclellanHistogramList, mcclellanSummationList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateUTMIndicator(StockData stockDataClass, string maType, int days = 9)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // UTM Indicator [CC] script may be freely distributed under the MIT license.
            //study("UTM Indicator [CC]", shorttitle = "UTMI", overlay = false)

            //length1 = input(title = "Length1", type = input.integer, defval = 13, minval = 1)
            //length2 = input(title = "Length2", type = input.integer, defval = 19, minval = 1)
            //length3 = input(title = "Length3", type = input.integer, defval = 21, minval = 1)
            //length4 = input(title = "Length4", type = input.integer, defval = 39, minval = 1)
            //length5 = input(title = "Length5", type = input.integer, defval = 50, minval = 1)
            //length6 = input(title = "Length6", type = input.integer, defval = 200, minval = 1)
            //mult = input(title = "Mult", type = input.float, defval = 1.5, minval = 0.1)
            //inp = input(title = "Source", type = input.source, defval = close)
            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //src = security(syminfo.tickerid, res, inp[rep ? 0 : barstate.isrealtime ? 1 : 0])[rep ? 0 : barstate.isrealtime ? 0 : 1]

            //basis = sma(src, length6)
            //dev = stdev(src, length6) * mult
            //upperBand = basis + dev
            //lowerBand = basis - dev
            //bPct = upperBand - lowerBand != 0 ? (src - lowerBand) / (upperBand - lowerBand) : 0

            //advSum = sum(src > nz(src[1]) ? 1 : 0, length2)
            //decSum = sum(src < nz(src[1]) ? 1 : 0, length2)
            //ratio = decSum != 0 ? advSum / decSum : 0
            //rana = advSum + decSum != 0 ? (advSum - decSum) / (advSum + decSum) : 0
            //mo = ema(rana, length2) - ema(rana, length4)

            //utm = (200 * bPct) + (100 * ratio) + (2 * mo) + (1.5 * mfi(src, length5)) + (3 * mfi(src, length3)) + (3 * mfi(src, length1))
            //utmi = rsi(utm, length1)

            //sig = utmi > 50 ? 1 : utmi < 50 ? -1 : 0
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //utmiColor = sig > 0 ? color.green : sig < 0 ? color.red : color.black
            //barcolor(bar ? utmiColor : na)
            //plot(utmi, title = "UTMI", color = utmiColor, linewidth = 2)
            List<decimal> utmList = new();
            List<decimal> utmiList = new();
            List<Signal> signalsList = new();

            try
            {
                int length1 = days;
                int length2 = (int)Math.Ceiling(days / 0.6924);
                int length3 = (int)Math.Ceiling(days / 0.4286);
                int length4 = (int)Math.Ceiling(days / 0.18);
                int length5 = (int)Math.Ceiling(days / 0.045);

                var moVar = CalculateMcClellanOscillator(stockDataClass, maType, length1);
                var advSumList = moVar.Item3;
                var decSumList = moVar.Item4;
                var moList = moVar.Item8;
                var bbPctList = CalculateBollingerBands(null, stockDataClass, 1.5m, maType, length5).Item4;
                var mfi1List = CalculateMoneyFlowIndex(stockDataClass, length2).Item7;
                var mfi2List = CalculateMoneyFlowIndex(stockDataClass, length3).Item7;
                var mfi3List = CalculateMoneyFlowIndex(stockDataClass, length4).Item7;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal mo = moList.ElementAtOrDefault(i);
                    decimal bbPct = bbPctList.ElementAtOrDefault(i);
                    decimal mfi1 = mfi1List.ElementAtOrDefault(i);
                    decimal mfi2 = mfi2List.ElementAtOrDefault(i);
                    decimal mfi3 = mfi3List.ElementAtOrDefault(i);
                    decimal advSum = advSumList.ElementAtOrDefault(i);
                    decimal decSum = decSumList.ElementAtOrDefault(i);
                    decimal ratio = decSum != 0 ? advSum / decSum : 0;

                    decimal utm = (200 * bbPct) + (100 * ratio) + (2 * mo) + (1.5m * mfi3) + (3 * mfi2) + (3 * mfi1);
                    utmList.Add(utm);
                }

                utmiList = CalculateRelativeStrengthIndex(utmList, stockDataClass, maType, length2).Item4;
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal utmi = utmiList.ElementAtOrDefault(j);
                    decimal prevUtmi1 = j >= 1 ? utmiList.ElementAtOrDefault(j - 1) : 0;
                    decimal prevUtmi2 = j >= 2 ? utmiList.ElementAtOrDefault(j - 2) : 0;

                    var signal = GetCompareSignal(utmi - prevUtmi1, prevUtmi1 - prevUtmi2);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (utmList, utmiList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateRelativeStrength3DIndicator(StockData stockDataClass,
            StockData marketDataClass, string maType, int days = 4)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Relative Strength 3D Indicator [CC] script may be freely distributed under the MIT license.
            //study("Relative Strength 3D Indicator [CC]", shorttitle = "RS3DI", overlay = false)

            //length1 = input(title = "Length1", type = input.integer, defval = 4, minval = 1)
            //length2 = input(title = "Length2", type = input.integer, defval = 7, minval = 1)
            //length3 = input(title = "Length3", type = input.integer, defval = 10, minval = 1)
            //length4 = input(title = "Length4", type = input.integer, defval = 15, minval = 1)
            //length5 = input(title = "Length5", type = input.integer, defval = 30, minval = 1)
            //spSym = input(title = "S&P 500 Symbol", type = input.symbol, defval = "SPY")
            //inp = input(title = "Source", type = input.source, defval = close)
            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //src = security(syminfo.tickerid, res, inp[rep ? 0 : barstate.isrealtime ? 1 : 0])[rep ? 0 : barstate.isrealtime ? 0 : 1]
            //spSrc = security(spSym, res, inp[rep ? 0 : barstate.isrealtime ? 1 : 0])[rep ? 0 : barstate.isrealtime ? 0 : 1]

            //rs1 = 0.0
            //rs1:= spSrc > 0 ? src / spSrc * 100 : nz(rs1[1])

            //fastMa = ema(rs1, length3)
            //medMa = ema(fastMa, length2)
            //slowMa = ema(fastMa, length4)
            //vSlowMa = ema(slowMa, length5)

            //t1 = fastMa >= medMa and medMa >= slowMa and slowMa >= vSlowMa ? 10 : 0
            //t2 = fastMa >= medMa and medMa >= slowMa and slowMa<vSlowMa ? 9 : 0
            //t3 = fastMa < medMa and medMa >= slowMa and slowMa >= vSlowMa ? 9 : 0
            //t4 = fastMa < medMa and medMa >= slowMa and slowMa<vSlowMa ? 5 : 0
            //rs2 = t1 + t2 + t3 + t4
            //rs2Ma = ema(rs2, length1)

            //x = rs2 >= 8 ? 1 : 0
            //rs3 = rs2 >= 8 or rs2 > rs2Ma ? sum(x, length4) / length4 * 100 : 0

            //sig = rs3 > 50 ? 1 : rs3 < 50 ? -1 : 0
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //rs3Color = sig > 0 ? color.green : sig < 0 ? color.red : color.black
            //barcolor(bar ? rs3Color : na)
            //plot(rs3, title = "RS3", color = rs3Color, linewidth = 2)
            List<decimal> r1List = new();
            List<decimal> t1List = new();
            List<decimal> t2List = new();
            List<decimal> t3List = new();
            List<decimal> t4List = new();
            List<decimal> rs3List = new();
            List<decimal> rs2List = new();
            List<decimal> rs2MaList = new();
            List<decimal> xList = new();
            List<Signal> signalsList = new();

            try
            {
                int length1 = days;
                int length2 = (int)Math.Ceiling(days / 0.5715);
                int length3 = (int)Math.Ceiling(days / 0.4);
                int length4 = (int)Math.Ceiling(days / 0.2667);
                int length5 = length4 * 2;

                if (stockDataClass.InputValues.Count == marketDataClass.InputValues.Count)
                {
                    for (int h = 0; h < stockDataClass.InputValues.Count; h++)
                    {
                        decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(h);
                        decimal currentSp = marketDataClass.InputValues.ElementAtOrDefault(h);

                        decimal prevR1 = r1List.LastOrDefault();
                        decimal r1 = currentSp != 0 ? currentValue / currentSp * 100 : prevR1;
                        r1List.Add(r1);
                    }

                    var fastMaList = GetMovingAverageList(maType, r1List, stockDataClass, length3);
                    var medMaList = GetMovingAverageList(maType, fastMaList, stockDataClass, length2);
                    var slowMaList = GetMovingAverageList(maType, fastMaList, stockDataClass, length4);
                    var vSlowMaList = GetMovingAverageList(maType, slowMaList, stockDataClass, length5);

                    for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                    {
                        decimal fastMa = fastMaList.ElementAtOrDefault(i);
                        decimal medMa = medMaList.ElementAtOrDefault(i);
                        decimal slowMa = slowMaList.ElementAtOrDefault(i);
                        decimal vSlowMa = vSlowMaList.ElementAtOrDefault(i);

                        decimal t1 = fastMa >= medMa && medMa >= slowMa && slowMa >= vSlowMa ? 10 : 0;
                        t1List.Add(t1);

                        decimal t2 = fastMa >= medMa && medMa >= slowMa && slowMa < vSlowMa ? 9 : 0;
                        t2List.Add(t2);

                        decimal t3 = fastMa < medMa && medMa >= slowMa && slowMa >= vSlowMa ? 9 : 0;
                        t3List.Add(t3);

                        decimal t4 = fastMa < medMa && medMa >= slowMa && slowMa < vSlowMa ? 5 : 0;
                        t4List.Add(t4);

                        decimal rs2 = t1 + t2 + t3 + t4;
                        rs2List.Add(rs2);
                    }

                    rs2MaList = GetMovingAverageList(maType, rs2List, stockDataClass, length1);
                    for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                    {
                        decimal rs2 = rs2List.ElementAtOrDefault(j);
                        decimal rs2Ma = rs2MaList.ElementAtOrDefault(j);
                        decimal prevRs3_1 = j >= 1 ? rs3List.ElementAtOrDefault(j - 1) : 0;
                        decimal prevRs3_2 = j >= 2 ? rs3List.ElementAtOrDefault(j - 1) : 0;

                        decimal x = rs2 >= 5 ? 1 : 0;
                        xList.Add(x);

                        decimal rs3 = rs2 >= 5 || rs2 > rs2Ma ? xList.TakeLast(length4).Sum() / length4 * 100 : 0;
                        rs3List.Add(rs3);

                        var signal = GetCompareSignal(rs3 - prevRs3_1, prevRs3_1 - prevRs3_2);
                        signalsList.Add(signal);
                    }
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (t1List, t2List, t3List, t4List, rs2List, rs2MaList, xList, rs3List, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateZweigMarketBreadthIndicator(StockData stockDataClass, int days = 10)
        {
            //
            // @author LazyBear 
            // 
            // List of my public indicators: http://bit.ly/1LQaPK8 
            // List of my app-store indicators: http://blog.tradingview.com/?p=970 
            //
            //study(title = "Zweig Market Breadth Thrust Indicator [LazyBear]", shorttitle = "ZMBTI_LB")
            //t = input(defval = 2, maxval = 2, minval = 1, title = "MA Type (1=>SMA, 2=>EMA)")
            //lma = input(defval = 10, minval = 1, title = "MA Length")
            //mkt = input(defval = 1, minval = 0, maxval = 4, title = "Market (0=>AMEX/NASD/NYSE Combined, 1=NYSE, 2=NASDAQ, 3=AMEX, 4=CUSTOM)")
            //aic = input(defval = "ADVS", title = "CUSTOM: Advancing Stocks Symbol", type = symbol)
            //dic = input(defval = "DECS", title = "CUSTOM: Declining Stocks Symbol", type = symbol)
            //me = input(false, title = "Color OB/OS")
            //ma(s, l) => t == 1 ? sma(s, l) : ema(s, l)
            //res = "D"
            //advn = "ADVN", decn = "DECN" // NYSE
            //advnq = "ADVQ", decnq = "DECQ" // NASDAQ
            //advna = "ADVA", decna = "DECA" // AMEX
            //advc = "(ADVN+ADVQ+ADVA)/3.0", decc = "(DECN+DECQ+DECA)/3.0"
            //adv = security(mkt == 0 ? advc : mkt == 1 ? advn : mkt == 2 ? advnq : mkt == 3 ? advna : aic, res, close)
            //dec = security(mkt == 0 ? decc : mkt == 1 ? decn : mkt == 2 ? decnq : mkt == 3 ? decna : dic, res, close)
            //zmbti = ma(adv / (adv + dec), lma)
            List<decimal> zmbtiList = new();
            List<decimal> advDiffList = new();
            List<decimal> advancesList = new();
            List<decimal> declinesList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevZmbti1 = i >= 1 ? zmbtiList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevZmbti2 = i >= 2 ? zmbtiList.ElementAtOrDefault(i - 2) : 0;

                    decimal advance = currentValue > prevValue ? 1 : 0;
                    advancesList.Add(advance);

                    decimal decline = currentValue < prevValue ? 1 : 0;
                    declinesList.Add(decline);

                    decimal advSum = advancesList.TakeLast(days).Sum();
                    decimal decSum = declinesList.TakeLast(days).Sum();

                    decimal advDiff = advSum + decSum != 0 ? advSum / (advSum + decSum) : 0;
                    advDiffList.Add(advDiff);

                    decimal zmbti = CalculateExponentialMovingAverage(advDiff, prevZmbti1, days);
                    zmbtiList.Add(zmbti);

                    var signal = GetRsiSignal(zmbti - prevZmbti1, prevZmbti1 - prevZmbti2, zmbti, prevZmbti1, 0.615m, 0.4m);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (advDiffList, zmbtiList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<Signal>) CalculateHighLowIndex(StockData stockDataClass, string maType, int days = 10)
        {
            //
            // @author LazyBear 
            // 
            // List of my public indicators: http://bit.ly/1LQaPK8 
            // List of my app-store indicators: http://blog.tradingview.com/?p=970 
            //
            //study(title = "High-Low Index [LazyBear]", shorttitle = "HLIDX_LB")
            //res = input("D", title = "Timeframe")
            //t = input(defval = 1, maxval = 2, minval = 1, title = "MA Type (1=>SMA, 2=>EMA)")
            //lma = input(defval = 10, minval = 1, title = "MA Length")
            //mkt = input(defval = 1, minval = 0, maxval = 4, title = "Market (0=>AMEX/NASD/NYSE Combined, 1=NYSE, 2=NASDAQ, 3=AMEX, 4=CUSTOM)")
            //aic = input(defval = "MAHE", title = "CUSTOM: New Highs Symbol", type = symbol)
            //dic = input(defval = "MALE", title = "CUSTOM: New Lows Symbol", type = symbol)
            //sh = input(false, title = "Show only Record High %")
            //ma(s, l) => sh? s:(t == 1 ? sma(s, l) : ema(s, l))
            //hi = "MAHN", lon = "MALN" // NYSE
            //hiq = "MAHQ", lonq = "MALQ" // NASDAQ
            //hia = "MAHA", lona = "MALA" // AMEX
            //advc = "(HIGN+HIGQ+HIGA)/3.0", loc = "(LOWN+LOWQ+LOWA)/3.0"
            //adv = security(mkt == 0 ? advc : mkt == 1 ? hi : mkt == 2 ? hiq : mkt == 3 ? hia : aic, res, close)
            //lo = security(mkt == 0 ? loc : mkt == 1 ? lon : mkt == 2 ? lonq : mkt == 3 ? lona : dic, res, close)
            //hli = ma(adv / (adv + lo), lma) * 100
            //osd = plot(hli < 50 ? hli : 50, style = circles, linewidth = 0, title = "DummyOS")
            //obd = plot(hli > 50 ? hli : 50, style = circles, linewidth = 0, title = "DummyOB")
            //ml = plot(50, color = gray, title = "MidLine")
            //fill(osd, ml, red, transp = 60, title = "OSFill"), fill(obd, ml, green, transp = 60, title = "OBFill")
            //plot(hli, color = maroon, linewidth = 2, title = "HiLoIndex")
            List<decimal> hliList = new();
            List<decimal> advList = new();
            List<decimal> loList = new();
            List<decimal> advDiffList = new();
            List<decimal> zmbtiList = new();
            List<decimal> advSumList = new();
            List<decimal> loSumList = new();
            List<Signal> signalsList = new();

            try
            {
                var list = GetMaxAndMinValuesList(stockDataClass.HighPrices, stockDataClass.LowPrices, days);
                var highestList = list.Item1;
                var lowestList = list.Item2;

                for (int i = 0; i < stockDataClass.HighPrices.Count; i++)
                {
                    decimal prevHighest = i >= 1 ? highestList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevLowest = i >= 1 ? lowestList.ElementAtOrDefault(i - 1) : 0;
                    decimal highest = highestList.ElementAtOrDefault(i);
                    decimal lowest = lowestList.ElementAtOrDefault(i);

                    decimal adv = highest > prevHighest ? 1 : 0;
                    advList.Add(adv);

                    decimal lo = lowest < prevLowest ? 1 : 0;
                    loList.Add(lo);

                    decimal advSum = advList.TakeLast(days).Sum();
                    advSumList.Add(advSum);

                    decimal loSum = loList.TakeLast(days).Sum();
                    loSumList.Add(loSum);

                    decimal advDiff = advSum + loSum != 0 ? MinOrMax(advSum / (advSum + loSum), 1, 0) : 0;
                    advDiffList.Add(advDiff);
                }

                zmbtiList = GetMovingAverageList(maType, advDiffList, stockDataClass, days);
                for (int j = 0; j < stockDataClass.HighPrices.Count; j++)
                {
                    decimal zmbti = zmbtiList.ElementAtOrDefault(j);
                    decimal prevHli1 = j >= 1 ? hliList.ElementAtOrDefault(j - 1) : 0;
                    decimal prevHli2 = j >= 2 ? hliList.ElementAtOrDefault(j - 2) : 0;

                    decimal hli = zmbti * 100;
                    hliList.Add(hli);

                    var signal = GetRsiSignal(hli - prevHli1, prevHli1 - prevHli2, hli, prevHli1, 70, 30);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (advList, loList, advSumList, loSumList, advDiffList, zmbtiList, hliList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<decimal>, List<decimal>, List<Signal>) CalculateInsyncIndex(StockData stockDataClass, string maType, int days = 3)
        {
            //
            // @author LazyBear
            // List of all my indicators: http://bit.ly/1LQaPK8
            //
            // v02, April0215, Updated to have dynamic levels
            //
            //study(title = "Insync Index [LazyBear]", shorttitle = "II_LB")
            //src = close
            //Line95 = input(95), Line75 = input(75), Line25 = input(25), Line5 = input(5)
            //div = input(10000, title = "EMO Divisor", minval = 1)
            //emoLength = input(14, minval = 1, title = "EMO length")
            //fastLength = input(12, minval = 1, title = "MACD Fast EMA Length")
            //slowLength = input(26, minval = 1, title = "MACD Slow EMA Length")
            //signalLength = input(9, minval = 1, title = "MACD Signal Length")
            //mfiLength = input(20, minval = 1, title = "MFI Length")

            //calc_emo() => sma(div * change(hl2) * (high - low) / volume, emoLength)
            //calc_macd(source) =>
            //    fastMA = ema(source, fastLength)
            //    slowMA = ema(source, slowLength)
            //    fastMA - slowMA

            //calc_mfi(length) =>
            //    src = hlc3
            //    upper = sum(volume * (change(src) <= 0 ? 0 : src), length)
            //    lower = sum(volume * (change(src) >= 0 ? 0 : src), length)
            //    mf = rsi(upper, lower)
            //    mf

            //calc_dpo(period_) =>
            //    isCentered = false
            //    barsback = period_ / 2 + 1
            //    ma = sma(close, period_)
            //    dpo = isCentered ? close[barsback] - ma : close - ma[barsback]
            //    dpo

            //calc_roc(source, length) =>
            //    roc = 100 * (source - source[length]) / source[length]
            //    roc

            //calc_stochD(length, smoothD, smoothK) =>
            //    k = sma(stoch(close, high, low, length), smoothK)
            //    d = sma(k, smoothD)
            //    d

            //calc_stochK(length, smoothD, smoothK) =>
            //    k = sma(stoch(close, high, low, length), smoothK)
            //    //d = sma(k, smoothD)
            //    k

            //lengthBB = input(20, title = "BB Length"),
            //multBB = input(2.0, title = "BB Multiplier")
            //lengthCCI = input(14, title = "CCI Length")
            //dpoLength = input(18, title = "DPO Length")
            //lengthROC = input(10, title = "ROC Length")
            //lengthRSI = input(14, title = "RSI Length")
            //lengthStoch = input(14, title = "Stoch Length"),
            //lengthD = input(3, title = "Stoch D Length"),
            //lengthK = input(1, title = "Stoch K Length")
            //lengthSMA = input(10, title = "MA Length")

            //bolinslb = sma(src, lengthBB) - multBB * (stdev(src, lengthBB))
            //bolinsub = sma(src, lengthBB) + multBB * (stdev(src, lengthBB))
            //bolins2 = (src - bolinslb) / (bolinsub - bolinslb)
            //bolinsll = (bolins2 < 0.05 ? -5 : (bolins2 > 0.95 ? 5 : 0))
            //cciins = (cci(src, lengthCCI) > 100 ? 5 : (cci(src, lengthCCI) < -100 ? -5 : 0))
            //emvins2 = calc_emo() - sma(calc_emo(), lengthSMA)
            //emvinsb = (emvins2 < 0 ? (sma(calc_emo(), lengthSMA) < 0 ? -5 : 0) : 0)
            //emvinss = (emvins2 > 0 ? (sma(calc_emo(), lengthSMA) > 0 ? 5 : 0) : 0)
            //macdins2 = calc_macd(src) - sma(calc_macd(src), lengthSMA)
            //macdinsb = (macdins2 < 0 ? (sma(calc_macd(src), lengthSMA) < 0 ? -5 : 0) : 0)
            //macdinss = (macdins2 > 0 ? (sma(calc_macd(src), lengthSMA) > 0 ? 5 : 0) : 0)
            //mfiins = (calc_mfi(mfiLength) > 80 ? 5 : (calc_mfi(mfiLength) < 20 ? -5 : 0))
            //pdoins2 = calc_dpo(dpoLength) - sma(calc_dpo(dpoLength), lengthSMA)
            //pdoinsb = (pdoins2 < 0 ? (sma(calc_dpo(dpoLength), lengthSMA) < 0 ? -5 : 0) : 0)
            //pdoinss = (pdoins2 > 0 ? (sma(calc_dpo(dpoLength), lengthSMA) > 0 ? 5 : 0) : 0)
            //rocins2 = calc_roc(src, lengthROC) - sma(calc_roc(src, lengthROC), lengthSMA)
            //rocinsb = (rocins2 < 0 ? (sma(calc_roc(src, lengthROC), lengthSMA) < 0 ? -5 : 0) : 0)
            //rocinss = (rocins2 > 0 ? (sma(calc_roc(src, lengthROC), lengthSMA) > 0 ? 5 : 0) : 0)
            //rsiins = (rsi(src, lengthRSI) > 70 ? 5 : (rsi(src, lengthRSI) < 30 ? -5 : 0))

            //stopdins = (calc_stochD(lengthStoch, lengthD, lengthK) > 80 ? 5 : (calc_stochD(lengthStoch, lengthD, lengthK) < 20 ? -5 : 0))
            //stopkins = (calc_stochK(lengthStoch, lengthD, lengthK) > 80 ? 5 : (calc_stochK(lengthStoch, lengthD, lengthK) < 20 ? -5 : 0))

            //iidx = 50 + cciins + bolinsll + rsiins + stopkins + stopdins + mfiins + emvinsb + emvinss + rocinss + rocinsb + nz(pdoinss[10]) + nz(pdoinsb[10]) + macdinss + macdinsb
            //ml = plot(50, color = gray, title = "Line50")
            //ll = plot(5, color = green, title = "Line5")
            //ul = plot(95, color = red, title = "Line95")

            //plot(25, color = green, style = 3, title = "Line25")
            //plot(75, color = red, style = 3, title = "Line75")

            //fill(ml, ll, color = red)
            //fill(ml, ul, color = green)

            //il = plot(iidx, color = maroon, linewidth = 2, title = "InsyncIndex")
            //fill(ml, il, black)

            //bc = iidx >= 50 ? (iidx >= 95 ? #336600 : iidx >= 75 ? #33CC00 : #00FF00) : 
            //    (iidx <= 5 ? #990000 : iidx <= 25? #CC3300 :  #CC9900)

            //ebc = input(false, title = "Enable Barcolors")
            //barcolor(ebc ? bc : na)
            List<decimal> iidxList = new();
            List<decimal> tempMacdList = new();
            List<decimal> tempDpoList = new();
            List<decimal> tempRocList = new();
            List<decimal> cciinsList = new();
            List<decimal> bolinsllList = new();
            List<decimal> pdoinsbList = new();
            List<decimal> pdoinssList = new();
            List<decimal> rocinsbList = new();
            List<decimal> rsiinsList = new();
            List<decimal> mfiinsList = new();
            List<decimal> emvinsbList = new();
            List<decimal> macdinsbList = new();
            List<decimal> stopdinsList = new();
            List<decimal> stopkinsList = new();
            List<decimal> emoList = new();
            List<decimal> emoSmaList = new();
            List<Signal> signalsList = new();

            try
            {
                int fastLength = days * 4;
                int slowLength = (int)Math.Ceiling(days / 0.1154);
                int emoLength = (int)Math.Ceiling(days / 0.2143);
                int signalLength = days * 3;
                int cciLength = emoLength;
                int dpoLength = (int)Math.Ceiling(days / 0.1667);
                int rocLength = (int)Math.Ceiling(days / 0.3);
                int rsiLength = emoLength;
                int stochLength = emoLength;
                int stochDLength = days;
                int stochKLength = MinOrMax((int)Math.Ceiling((decimal)days / 3));
                int smaLength = rocLength;
                int prevPdoLength = rocLength;
                int mfiLength = rocLength * 2;
                int bbLength = mfiLength;

                var rsiList = CalculateRelativeStrengthIndex(null, stockDataClass, maType, rsiLength).Item4;
                var cciList = CalculateCommodityChannelIndex(stockDataClass, cciLength).Item4;
                var mfiList = CalculateMoneyFlowIndex(stockDataClass, mfiLength).Item7;
                var macdList = CalculateMovingAverageConvergenceDivergence(stockDataClass, maType, signalLength).Item1;
                var bbIndicatorList = CalculateBollingerBands(null, stockDataClass, 2, maType, bbLength).Item4;
                var dpoList = CalculateDetrendedPriceOscillator(stockDataClass, dpoLength).Item1;
                var rocList = CalculateRateOfChange(null, stockDataClass, rocLength).Item1;
                var stochasticList = CalculateStochasticOscillator(null, stockDataClass, maType, stochLength);
                var stochKList = stochasticList.Item3;
                var stochDList = stochasticList.Item4;
                var emvList = CalculateEaseOfMovement(stockDataClass, emoLength).Item4;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal bolins2 = bbIndicatorList.ElementAtOrDefault(i);
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal currentHigh = stockDataClass.HighPrices.ElementAtOrDefault(i);
                    decimal currentLow = stockDataClass.LowPrices.ElementAtOrDefault(i);
                    decimal currentVolume = stockDataClass.Volumes.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevPdoinss10 = i >= smaLength ? pdoinssList.ElementAtOrDefault(i - smaLength) : 0;
                    decimal prevPdoinsb10 = i >= smaLength ? pdoinsbList.ElementAtOrDefault(i - smaLength) : 0;
                    decimal cci = cciList.ElementAtOrDefault(i);
                    decimal mfi = mfiList.ElementAtOrDefault(i);
                    decimal rsi = rsiList.ElementAtOrDefault(i);
                    decimal stochD = stochDList.ElementAtOrDefault(i);
                    decimal stochK = stochKList.ElementAtOrDefault(i);
                    decimal prevIidx1 = i >= 1 ? iidxList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevIidx2 = i >= 2 ? iidxList.ElementAtOrDefault(i - 2) : 0;

                    decimal bolinsll = bolins2 < 0.05m ? -5 : bolins2 > 0.95m ? 5 : 0;
                    bolinsllList.Add(bolinsll);

                    decimal cciins = cci > 100 ? 5 : cci < -100 ? -5 : 0;
                    cciinsList.Add(cciins);

                    decimal emo = emvList.ElementAtOrDefault(i);
                    emoList.Add(emo);

                    decimal emoSma = emoList.TakeLast(smaLength).Average();
                    emoSmaList.Add(emoSma);

                    decimal emvins2 = emo - emoSma;
                    decimal emvinsb = emvins2 < 0 ? emoSma < 0 ? -5 : 0 : emoSma > 0 ? 5 : 0;
                    emvinsbList.Add(emvinsb);

                    decimal macd = macdList.ElementAtOrDefault(i);
                    tempMacdList.Add(macd);

                    decimal macdSma = tempMacdList.TakeLast(smaLength).Average();
                    decimal macdins2 = macd - macdSma;
                    decimal macdinsb = macdins2 < 0 ? macdSma < 0 ? -5 : 0 : macdSma > 0 ? 5 : 0;
                    macdinsbList.Add(macdinsb);

                    decimal mfiins = mfi > 80 ? 5 : mfi < 20 ? -5 : 0;
                    mfiinsList.Add(mfiins);

                    decimal dpo = dpoList.ElementAtOrDefault(i);
                    tempDpoList.Add(dpo);

                    decimal dpoSma = tempDpoList.TakeLast(smaLength).Average();
                    decimal pdoins2 = dpo - dpoSma;
                    decimal pdoinsb = pdoins2 < 0 ? dpoSma < 0 ? -5 : 0 : dpoSma > 0 ? 5 : 0;
                    pdoinsbList.Add(pdoinsb);

                    decimal pdoinss = pdoins2 > 0 ? dpoSma > 0 ? 5 : 0 : dpoSma < 0 ? -5 : 0;
                    pdoinssList.Add(pdoinss);

                    decimal roc = rocList.ElementAtOrDefault(i);
                    tempRocList.Add(roc);

                    decimal rocSma = tempRocList.TakeLast(smaLength).Average();
                    decimal rocins2 = roc - rocSma;
                    decimal rocinsb = rocins2 < 0 ? rocSma < 0 ? -5 : 0 : rocSma > 0 ? 5 : 0;
                    rocinsbList.Add(rocinsb);

                    decimal rsiins = rsi > 70 ? 5 : rsi < 30 ? -5 : 0;
                    rsiinsList.Add(rsiins);

                    decimal stopdins = stochD > 80 ? 5 : stochD < 20 ? -5 : 0;
                    stopdinsList.Add(stopdins);

                    decimal stopkins = stochK > 80 ? 5 : stochK < 20 ? -5 : 0;
                    stopkinsList.Add(stopkins);

                    decimal iidx = 50 + cciins + bolinsll + rsiins + stopkins + stopdins + mfiins + emvinsb + rocinsb + prevPdoinss10 + prevPdoinsb10 + macdinsb;
                    iidxList.Add(iidx);

                    var signal = GetRsiSignal(iidx - prevIidx1, prevIidx1 - prevIidx2, iidx, prevIidx1, 95, 5);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (cciinsList, bolinsllList, rsiinsList, stopkinsList, stopdinsList, mfiinsList, emvinsbList, rocinsbList, pdoinssList, pdoinsbList,
                macdinsbList, iidxList, emoSmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateFireflyOscillator(StockData stockDataClass, string maType, int days = 3)
        {
            //
            // @author LazyBear 
            // 
            // List of my public indicators: http://bit.ly/1LQaPK8 
            // List of my app-store indicators: http://blog.tradingview.com/?p=970 
            //
            // Original idea from a public Amibroker indicator published by @Yasu
            //
            //study(title = "Firefly Oscillator [LazyBear]", shorttitle = "FIREFLY_LB")
            //m = input(10, title = "Lookback Length", minval = 5, maxval = 20)
            //n1 = input(3, title = "Signal Smoothing", minval = 3, maxval = 10)
            //as= input(false, title = "decimal smooth Osc")
            //bt = input(false, title = "Use ZLEMA")
            //seb = input(false, title = "Show Enclosing BB")
            //lbb = input(20, title = "Enclosing BB Length")
            //mbb1 = input(2.0, title = "Enclosing BB Multiplier")
            //hbr = input(false, title = "Highlight Breaches")
            //ebc = input(false, title = "Enable bar colors")
            //calc_zlema(src, length) =>
            //    ema1 = ema(src, length)
            //    ema2 = ema(ema1, length)
            //    d = ema1 - ema2
            //    ema1 + d
            //ma(s, l) => bt == false ? ema(s, l) : calc_zlema(s, l)
            //v2 = (high + low + close * 2) / 4
            //v3 = ma(v2, m)
            //v4 = stdev(v2, m)
            //v5 = (v2 - v3) * 100 / iff(v4 == 0, 1, v4)
            //v6 = ma(v5, n1)
            //v7 =as? ma(v6, n1) : v6
            //ww = (ma(v7, m) + 100) / 2 - 4
            //mm = highest(ww, n1)
            //d = ww > 50 ? min(ww, mm) : mm < 50 ? max(ww, mm) : na
            //basis = seb ? sma(ww, lbb) : na
            //dev = seb ? mbb1 * stdev(ww, lbb) : na
            //upper = seb ? basis + dev : na
            //lower = seb ? basis - dev : na
            decimal mbb1 = 2;
            List<decimal> v2List = new();
            List<decimal> v3List = new();
            List<decimal> v4List = new();
            List<decimal> v5List = new();
            List<decimal> v6List = new();
            List<decimal> v7List = new();
            List<decimal> wwZLagEmaList = new();
            List<decimal> wwList = new();
            List<decimal> mmList = new();
            List<decimal> dList = new();
            List<decimal> basisList = new();
            List<decimal> devList = new();
            List<decimal> upperList = new();
            List<decimal> lowerList = new();
            List<Signal> signalsList = new();

            try
            {
                int n1 = days;
                int m = (int)Math.Ceiling(days / 0.3);
                int lbb = m * 2;

                for (int i = 0; i < stockDataClass.HighPrices.Count; i++)
                {
                    decimal currentHigh = stockDataClass.HighPrices.ElementAtOrDefault(i);
                    decimal currentLow = stockDataClass.LowPrices.ElementAtOrDefault(i);
                    decimal currentClose = stockDataClass.ClosePrices.ElementAtOrDefault(i);

                    decimal v2 = (currentHigh + currentLow + (currentClose * 2)) / 4;
                    v2List.Add(v2);
                }

                v3List = GetMovingAverageList(maType, v2List, stockDataClass, m);
                v4List = CalculateStandardDeviationVolatility(v2List, stockDataClass, m).Item4;
                for (int j = 0; j < stockDataClass.HighPrices.Count; j++)
                {
                    decimal v2 = v2List.ElementAtOrDefault(j);
                    decimal v3 = v3List.ElementAtOrDefault(j);
                    decimal v4 = v4List.ElementAtOrDefault(j);

                    decimal v5 = v4 == 0 ? (v2 - v3) * 100 : (v2 - v3) * 100 / v4;
                    v5List.Add(v5);
                }

                v6List = GetMovingAverageList(maType, v5List, stockDataClass, n1);
                v7List = GetMovingAverageList(maType, v6List, stockDataClass, n1);
                wwZLagEmaList = GetMovingAverageList(maType, v7List, stockDataClass, m);
                for (int k = 0; k < stockDataClass.HighPrices.Count; k++)
                {
                    decimal wwZlagEma = wwZLagEmaList.ElementAtOrDefault(k);
                    decimal prevWw1 = k >= 1 ? wwList.ElementAtOrDefault(k - 1) : 0;
                    decimal prevWw2 = k >= 2 ? wwList.ElementAtOrDefault(k - 2) : 0;

                    decimal ww = ((wwZlagEma + 100) / 2) - 4;
                    wwList.Add(ww);

                    decimal mm = wwList.TakeLast(n1).Max();
                    mmList.Add(mm);

                    decimal d = ww > 50 ? Math.Min(ww, mm) : mm < 50 ? Math.Max(ww, mm) : 0;
                    dList.Add(d);

                    decimal basis = wwList.TakeLast(lbb).Average();
                    basisList.Add(basis);

                    var signal = GetRsiSignal(ww - prevWw1, prevWw1 - prevWw2, ww, prevWw1, 80, 20);
                    signalsList.Add(signal);
                }

                List<decimal> wwStdDevList = CalculateStandardDeviationVolatility(wwList, stockDataClass, lbb).Item4;
                for (int l = 0; l < stockDataClass.HighPrices.Count; l++)
                {
                    decimal wwStdDev = wwStdDevList.ElementAtOrDefault(l);
                    decimal basis = basisList.ElementAtOrDefault(l);

                    decimal dev = mbb1 * wwStdDev;
                    devList.Add(dev);

                    decimal upper = basis + dev;
                    upperList.Add(upper);

                    decimal lower = basis - dev;
                    lowerList.Add(lower);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (v2List, v3List, v4List, v5List, v6List, v7List, wwZLagEmaList, wwList, mmList, dList, basisList, devList, upperList, lowerList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>)
            CalculateBreakoutRelativeStrengthIndex(StockData stockDataClass, int days = 14)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Breakout Relative Strength Index script may be freely distributed under the MIT license.
            //study("Breakout Relative Strength Index", shorttitle = "BRSI")

            //length = input(title = "Length", type = input.integer, defval = 14, minval = 1)

            //boPrice = ohlc4
            //boVolume = sum(volume, 2)

            //boStrength = high - low != 0 ? (close - open) / (high - low) : 0
            //boPower = boPrice * boStrength * boVolume

            //posPower = boPower > boPower[1] ? boPower : 0
            //negPower = boPower < boPower[1] ? boPower : 0

            //p = sum(posPower, length)
            //n = sum(abs(negPower), length)

            //boRatio = n != 0 ? p / n : 0

            //brsi = 100 - (100 / (1 + boRatio))

            //hline(50)
            //hline(80)
            //hline(20)

            //brsiColor = (brsi > 80 ? color.red : brsi < 20 ? color.green : brsi > 50 ? color.green : brsi < 50 ? color.red : color.black)
            //plot(brsi, title = "BRSI", linewidth = 2, color = brsiColor, transp = 0)
            List<decimal> brsiList = new();
            List<decimal> posPowerList = new();
            List<decimal> posPowerSumList = new();
            List<decimal> boPowerList = new();
            List<decimal> negPowerList = new();
            List<decimal> negPowerSumList = new();
            List<decimal> boRatioList = new();
            List<decimal> tempList = new();
            List<Signal> signalsList = new();

            try
            {
                int length = days;
                int volLength = MinOrMax((int)Math.Ceiling((decimal)length / 7));

                for (int i = 0; i < stockDataClass.HighPrices.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal currentHigh = stockDataClass.HighPrices.ElementAtOrDefault(i);
                    decimal currentLow = stockDataClass.LowPrices.ElementAtOrDefault(i);
                    decimal currentClose = stockDataClass.ClosePrices.ElementAtOrDefault(i);
                    decimal currentOpen = stockDataClass.OpenPrices.ElementAtOrDefault(i);
                    decimal prevBrsi1 = i >= 1 ? brsiList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevBrsi2 = i >= 2 ? brsiList.ElementAtOrDefault(i - 2) : 0;

                    decimal currentVolume = stockDataClass.Volumes.ElementAtOrDefault(i);
                    tempList.Add(currentVolume);

                    decimal boVolume = tempList.TakeLast(volLength).Sum();
                    decimal boStrength = currentHigh - currentLow != 0 ? (currentClose - currentOpen) / (currentHigh - currentLow) : 0;

                    decimal prevBoPower = boPowerList.LastOrDefault();
                    decimal boPower = currentValue * boStrength * boVolume;
                    boPowerList.Add(boPower);

                    decimal posPower = boPower > prevBoPower ? Math.Abs(boPower) : 0;
                    posPowerList.Add(posPower);

                    decimal negPower = boPower < prevBoPower ? Math.Abs(boPower) : 0;
                    negPowerList.Add(negPower);

                    decimal posPowerSum = posPowerList.TakeLast(length).Sum();
                    posPowerSumList.Add(posPowerSum);

                    decimal negPowerSum = negPowerList.TakeLast(length).Sum();
                    negPowerSumList.Add(negPowerSum);

                    decimal boRatio = negPowerSum != 0 ? posPowerSum / negPowerSum : 0;
                    boRatioList.Add(boRatio);

                    decimal brsi = negPowerSum == 0 ? 100 : posPowerSum == 0 ? 0 : MinOrMax(100 - (100 / (1 + boRatio)), 100, 0);
                    brsiList.Add(brsi);

                    var signal = GetRsiSignal(brsi - prevBrsi1, prevBrsi1 - prevBrsi2, brsi, prevBrsi1, 80, 20);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (boPowerList, posPowerList, negPowerList, posPowerSumList, negPowerSumList, boRatioList, brsiList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateSellGravitationIndex(StockData stockDataClass, int days = 20)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Sell Gravitation Index script may be freely distributed under the MIT license.
            //study("Sell Gravitation Index", shorttitle = "SGI", overlay = false)

            //length = input(title = "Length", type = input.integer, defval = 20, minval = 1)

            //v3Sum = 0.0
            //for i = 0 to length - 1
            //    v1 = close[i] - open[i]
            //    v2 = high[i] - low[i]
            //    v3 = v2 != 0 ? v1 / v2 : 0
            //    v3Sum := v3Sum + v3

            //sgi = v3Sum / length
            //sig = ema(sgi, length)

            //hline(0)
            //hline(0.38)
            //hline(-0.38)
            //plot(sig, color = color.black)
            //sgiColor = (sgi > sig ? color.green : sgi < sig ? color.red : color.black)
            //plot(sgi, color = sgiColor, linewidth = 1)
            List<decimal> sgiList = new();
            List<decimal> sigList = new();
            List<decimal> v3List = new();
            List<decimal> v3SumList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.HighPrices.Count; i++)
                {
                    decimal currentHigh = stockDataClass.HighPrices.ElementAtOrDefault(i);
                    decimal currentLow = stockDataClass.LowPrices.ElementAtOrDefault(i);
                    decimal currentClose = stockDataClass.ClosePrices.ElementAtOrDefault(i);
                    decimal currentOpen = stockDataClass.OpenPrices.ElementAtOrDefault(i);
                    decimal v1 = currentClose - currentOpen;
                    decimal v2 = currentHigh - currentLow;

                    decimal v3 = v2 != 0 ? v1 / v2 : 0;
                    v3List.Add(v3);

                    decimal v3Sum = v3List.TakeLast(days).Sum();
                    v3SumList.Add(v3Sum);

                    decimal prevSgi = sgiList.LastOrDefault();
                    decimal sgi = v3Sum / days;
                    sgiList.Add(sgi);

                    decimal prevSig = sigList.LastOrDefault();
                    decimal sig = CalculateExponentialMovingAverage(sgi, sigList.LastOrDefault(), days);
                    sigList.Add(sig);

                    var signal = GetCompareSignal(sgi - sig, prevSgi - prevSig);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (v3List, v3SumList, sgiList, sigList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateChoppinessIndex(StockData stockDataClass, string maType, int days = 14)
        {
            //period = user defined, default is 14
            //top guide = user defined, default is (fibonacci number) 61.8
            //bottom guide = user defined, default is (fibonacci number) 38.2
            //index = current bar number

            //atr = atr(index, period);
            //total = sum(index, period, ATR);
            //lowest = lowest(index, period, LOW);
            //highest = highest(index, period, HIGH);
            //diff = highest - lowest;
            //temp = (total / diff);
            //Plot: chop = 100 * Math.log10(temp) / Math.log10(period);
            List<decimal> choppinessIndexList = new();
            List<decimal> tempAvgTrueRangeList = new();
            List<decimal> tempList = new();
            List<decimal> atrSumList = new();
            List<Signal> signalsList = new();

            try
            {
                List<decimal> emaList = CalculateExponentialMovingAverage(stockDataClass, days).Item1;
                var atrList = CalculateAverageTrueRange(stockDataClass, maType, days).Item1;
                var minMaxList = VolumeInputCheck(stockDataClass, days, true);
                var highList = minMaxList.Item1;
                var lowList = minMaxList.Item2;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal currentEma = emaList.ElementAtOrDefault(i);
                    decimal maxHigh = highList.ElementAtOrDefault(i);
                    decimal minLow = lowList.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevEma = i >= 1 ? emaList.ElementAtOrDefault(i - 1) : 0;

                    decimal avgTrueRange = atrList.ElementAtOrDefault(i);
                    tempAvgTrueRangeList.Add(avgTrueRange);

                    decimal sumAvgTrueRange = tempAvgTrueRangeList.TakeLast(days).Sum();
                    atrSumList.Add(sumAvgTrueRange);

                    decimal temp = maxHigh - minLow != 0 ? sumAvgTrueRange / (maxHigh - minLow) : 0;
                    tempList.Add(temp);

                    decimal choppinessIndex = temp > 0 ? 100 * (Log10(temp) / Log10((double)days)) : 0;
                    choppinessIndexList.Add(choppinessIndex);

                    var signal = GetVolatilitySignal(currentValue - currentEma, prevValue - prevEma, choppinessIndex, 38.2m);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (atrSumList, tempList, choppinessIndexList, signalsList);
        }

        public static (List<decimal>, List<Signal>) CalculateTriangularMovingAverage(StockData stockDataClass, string maType, int days = 20)
        {
            //@version=3
            // Copyright (c) 2018-present, Alex Orekhov (everget)
            // Triangular Moving Average script may be freely distributed under the MIT license.
            //study("Triangular Moving Average", shorttitle = "TMA", overlay = true)

            //length = input(title = "Length", type = integer, minval = 1, defval = 20)
            //highlightMovements = input(title = "Highlight Movements ?", type = bool, defval = true)
            //src = input(title = "Source", type = source, defval = close)

            //tma = sma(sma(src, ceil(length / 2)), floor(length / 2) + 1)
            //tmaColor = highlightMovements ? (tma > tma[1] ? green : red) : #6d1e7f

            //plot(tma, title = "TMA", linewidth = 2, color = tmaColor, transp = 0)
            List<decimal> tmaList = new();
            List<Signal> signalsList = new();

            try
            {
                int length = days;
                int ceilingLength = MinOrMax((int)Math.Ceiling((decimal)length / 2));
                int floorLength = MinOrMax((int)Math.Floor((decimal)length / 2) + 1);

                List<decimal> sma1List = GetMovingAverageList(maType, null, stockDataClass, ceilingLength);
                tmaList = GetMovingAverageList(maType, sma1List, stockDataClass, floorLength);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal tma = tmaList.ElementAtOrDefault(i);
                    decimal prevTma = i >= 1 ? tmaList.ElementAtOrDefault(i - 1) : 0;

                    var signal = GetCompareSignal(currentValue - tma, prevValue - prevTma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (tmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateAdaptiveLeastSquares(StockData stockDataClass, int days = 500)
        {
            //@version=2
            //study("Adaptive Least Squares", overlay = true)
            //length = input(500),smooth = input(1.5)
            //
            //alpha = pow(tr / highest(tr, length), smooth)
            //m(a) =>
            //    p = alpha * a + (1 - alpha) * nz(p[1], a)
            //
            //x = n
            //y = close
            //x_ = m(x)
            //y_ = m(y)
            //
            //dx = abs(x - x_)
            //dy = abs(y - y_)
            //mx = m(dx)
            //my = m(dy)
            //
            //a1 = pow(2 / alpha + 1, 2) * m(x * y) - ((2 / alpha + 1) * m(x)) * ((2 / alpha + 1) * m(y))
            //b1 = sqrt((pow(2 / alpha + 1, 2) * m(x * x) - pow((2 / alpha + 1) * m(x), 2)) * (pow(2 / alpha + 1, 2) * m(y * y) - pow((2 / alpha + 1) * m(y), 2)))
            //r = a1 / b1
            //
            //a = r * (my / mx)
            //b = y_ - a * x_
            //reg = x * a + b
            //
            //plot(reg, color = red, transp = 0)
            List<decimal> alphaList = new();
            List<decimal> xList = new();
            List<decimal> yList = new();
            List<decimal> dxList = new();
            List<decimal> dyList = new();
            List<decimal> mxList = new();
            List<decimal> myList = new();
            List<decimal> a1List = new();
            List<decimal> b1List = new();
            List<decimal> rList = new();
            List<decimal> aList = new();
            List<decimal> bList = new();
            List<decimal> regList = new();
            List<decimal> indexList = new();
            List<decimal> tempList = new();
            List<decimal> highestList = new();
            List<decimal> xxList = new();
            List<decimal> yyList = new();
            List<decimal> xyList = new();
            List<decimal> mxxList = new();
            List<decimal> myyList = new();
            List<decimal> mxyList = new();
            List<Signal> signalsList = new();
            decimal smooth = 1.5m;

            try
            {
                var trList = CalculateVortexIndicator(stockDataClass, days).Item5;

                for (int h = 0; h < stockDataClass.InputValues.Count; h++)
                {
                    decimal index = h;
                    indexList.Add(index);
                }

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal index = indexList.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal tr = trList.ElementAtOrDefault(i);
                    tempList.Add(tr);

                    decimal highest = tempList.TakeLast(days).Max();
                    highestList.Add(highest);

                    decimal alpha = highest != 0 ? MinOrMax(Pow(tr / highest, (double)smooth), 0.99m, 0.01m) : 0.01m;
                    alphaList.Add(alpha);

                    decimal xx = index * index;
                    xxList.Add(xx);

                    decimal yy = currentValue * currentValue;
                    yyList.Add(yy);

                    decimal xy = index * currentValue;
                    xyList.Add(xy);

                    decimal prevX = i >= 1 ? xList.ElementAtOrDefault(i - 1) : index;
                    decimal x = (alpha * index) + ((1 - alpha) * prevX);
                    xList.Add(x);

                    decimal prevY = i >= 1 ? yList.ElementAtOrDefault(i - 1) : currentValue;
                    decimal y = (alpha * currentValue) + ((1 - alpha) * prevY);
                    yList.Add(y);

                    decimal dx = Math.Abs(index - x);
                    dxList.Add(dx);

                    decimal dy = Math.Abs(currentValue - y);
                    dyList.Add(dy);

                    decimal prevMx = i >= 1 ? mxList.ElementAtOrDefault(i - 1) : dx;
                    decimal mx = (alpha * dx) + ((1 - alpha) * prevMx);
                    mxList.Add(mx);

                    decimal prevMy = i >= 1 ? myList.ElementAtOrDefault(i - 1) : dy;
                    decimal my = (alpha * dy) + ((1 - alpha) * prevMy);
                    myList.Add(my);

                    decimal prevMxx = i >= 1 ? mxxList.ElementAtOrDefault(i - 1) : xx;
                    decimal mxx = (alpha * xx) + ((1 - alpha) * prevMxx);
                    mxxList.Add(mxx);

                    decimal prevMyy = i >= 1 ? myyList.ElementAtOrDefault(i - 1) : yy;
                    decimal myy = (alpha * yy) + ((1 - alpha) * prevMyy);
                    myyList.Add(myy);

                    decimal prevMxy = i >= 1 ? mxyList.ElementAtOrDefault(i - 1) : xy;
                    decimal mxy = (alpha * xy) + ((1 - alpha) * prevMxy);
                    mxyList.Add(mxy);

                    decimal alphaVal = (2 / alpha) + 1;
                    decimal a1 = alpha != 0 ? (Pow(alphaVal, 2) * mxy) - ((alphaVal * mx) * (alphaVal * my)) : 0;
                    a1List.Add(a1);

                    decimal tempVal = ((Pow(alphaVal, 2) * mxx) - Pow(alphaVal * mx, 2)) * ((Pow(alphaVal, 2) * myy) - Pow(alphaVal * my, 2));
                    decimal b1 = tempVal >= 0 ? (decimal)Sqrt((double)tempVal) : 0;
                    b1List.Add(b1);

                    decimal r = b1 != 0 ? a1 / b1 : 0;
                    rList.Add(r);

                    decimal a = mx != 0 ? r * (my / mx) : 0;
                    aList.Add(a);

                    decimal b = y - (a * x);
                    bList.Add(b);

                    decimal prevReg = regList.LastOrDefault();
                    decimal reg = (x * a) + b;
                    regList.Add(reg);

                    var signal = GetCompareSignal(currentValue - reg, prevValue - prevReg);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (highestList, alphaList, xList, yList, dxList, dyList, mxList, myList, mxxList, myyList, mxyList, a1List, b1List, rList, aList, bList, regList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateChartmillValueIndicator(StockData stockDataClass, string maType, int days = 5)
        {
            //method = moving average, user defined, default is SMA
            //x = period, user defined, default is 5
            //type = price bar type, default is Candlesticks
            //index = current bar number

            //f = ma(method, index, x, MIDPOINT);//MIDPOINT=(high+low)/2
            //v = ma(method, index, x, TR);//TR=True Range
            //cmvC = (close - f) / v;
            //cmvH = (high - f) / v;
            //cmvL = (low - f) / v;
            //cmvO = (open - f) / v;
            //prevCmvO = cmvO[index - 1];
            //prevCmvH = cmvH[index - 1];
            //prevCmvL = cmvL[index - 1];
            //prevCmvC = cmvC[index - 1];
            //Figure fig = new PriceBar(ctx, index, type, cmvO, cmvH, cmvL, cmvC, prevCmvO, prevCmvH, prevCmvL, prevCmvC);
            //addFigure(fig);
            //Modified Chartmill Value Indicator (MCVI) = (C – VC) / (ATR * (n ^ 0.5))
            List<decimal> fList = new();
            List<decimal> cmvCList = new();
            List<Signal> signalsList = new();

            try
            {
                var atrList = CalculateAverageTrueRange(stockDataClass, maType, days).Item1;
                var midpointList = CalculateMidpoint(stockDataClass, days).Item2;
                fList = GetMovingAverageList(maType, midpointList, stockDataClass, days);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal currentHigh = stockDataClass.HighPrices.ElementAtOrDefault(i);
                    decimal currentLow = stockDataClass.LowPrices.ElementAtOrDefault(i);
                    decimal prevClose = i >= 1 ? stockDataClass.ClosePrices.ElementAtOrDefault(i - 1) : 0;
                    decimal v = atrList.ElementAtOrDefault(i);
                    decimal f = fList.ElementAtOrDefault(i);
                    decimal prevCmvc1 = i >= 1 ? cmvCList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevCmvc2 = i >= 2 ? cmvCList.ElementAtOrDefault(i - 2) : 0;

                    decimal cmvC = v != 0 ? MinOrMax((currentValue - f) / (v * Pow(days, 0.5)), 1, -1) : 0;
                    cmvCList.Add(cmvC);

                    var signal = GetRsiSignal(cmvC - prevCmvc1, prevCmvc1 - prevCmvc2, cmvC, prevCmvc1, 0.5m, -0.5m);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (fList, cmvCList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateConditionalAccumulator(StockData stockDataClass, int days)
        {
            //condition = default is (low moreThan prevHigh)
            //increment = user defined, default is 1
            //startValue = user defined, default is 0
            //index = current bar number, LOE = less or equal

            //endIndex = getEndIndex() - 1;
            //value = startValue;
            //for (i = 1; i LOE endIndex; i++)
            //if (trendUp)
            //prevHigh = high[i - 1];
            //low = low[i];
            //if (low moreOr = prevHigh) value = value + increment;
            //else
            //prevLow = low[i - 1];
            //high = high[i];
            //if (high lessOr = prevLow) value = value - increment;
            //endIf
            //endFor
            decimal increment = 1;
            List<decimal> valueList = new();
            List<decimal> valueEmaList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.HighPrices.Count; i++)
                {
                    decimal currentHigh = stockDataClass.HighPrices.ElementAtOrDefault(i);
                    decimal currentLow = stockDataClass.LowPrices.ElementAtOrDefault(i);
                    decimal prevHigh = i >= 1 ? stockDataClass.HighPrices.ElementAtOrDefault(i - 1) : 0;
                    decimal prevLow = i >= 1 ? stockDataClass.LowPrices.ElementAtOrDefault(i - 1) : 0;

                    decimal prevValue = valueList.LastOrDefault();
                    decimal value = currentLow >= prevHigh ? prevValue + increment : currentHigh <= prevLow ? prevValue - increment : prevValue;
                    valueList.Add(value);

                    decimal prevValueEma = valueEmaList.LastOrDefault();
                    decimal valueEma = CalculateExponentialMovingAverage(value, valueEmaList.LastOrDefault(), days);
                    valueEmaList.Add(valueEma);

                    var signal = GetCompareSignal(value - valueEma, prevValue - prevValueEma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (valueList, valueEmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateContractHighLow(StockData stockDataClass)
        {
            //con = contract
            //index = current bar number

            //conHi = ifNull(high, conHi[index - 1]);
            //conLow = ifNull(low, conLow[index - 1]);
            //if (high moreThan conHi) conHi = hi;
            //if (low lessThan conLow) conLow = low;
            //Plot1: conHi;
            //Plot2: conLow
            List<decimal> conHiList = new();
            List<decimal> conLowList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.HighPrices.Count; i++)
                {
                    decimal currentHigh = stockDataClass.HighPrices.ElementAtOrDefault(i);
                    decimal currentLow = stockDataClass.LowPrices.ElementAtOrDefault(i);

                    decimal prevConHi = conHiList.LastOrDefault();
                    decimal conHi = i >= 1 ? Math.Max(prevConHi, currentHigh) : currentHigh;
                    conHiList.Add(conHi);

                    decimal prevConLow = conLowList.LastOrDefault();
                    decimal conLow = i >= 1 ? Math.Min(prevConLow, currentLow) : currentLow;
                    conLowList.Add(conLow);

                    var signal = GetConditionSignal(conHi > prevConHi, conLow < prevConLow);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (conHiList, conLowList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<decimal>, List<Signal>) CalculateDMIStochastic(StockData stockDataClass, string maType, int days = 3)
        {
            //input = price, user defined, default is closing price
            //dmiPeriod = user defined, default is 10
            //fastKPeriod = user defined, default is 10
            //slowKPeriod = user defined, default is 3
            //smoothPeriod = user defined, default is 3
            //stochasticMethod = moving average, user defined, default is SMA
            //maPeriod = user defined, default is 50
            //maMethod = moving average, user defined, default is SMA //index = current bar number

            //Calculate the +DM, -DM and TR 
            //pDm = series.getPositiveDM(index);
            //nDm = series.getNegativeDM(index);
            //tr = series.getTrueRange(index);

            //Calculate the Average +DM, -DM and TR 
            //pdMa = series.smma(index, dmiPd, PDM);
            //ndMa = series.smma(index, dmiPd, NDM);
            //tra = series.smma(index, dmiPd, TR);

            //Determine the +DI, -DI and DX 
            //pdi = pdMa / tra * 100;
            //ndi = ndMa / tra * 100;
            //Plot: dmiOsc = ndi - pdi;
            //if (dmiOsc moreThan midGuide) series.setBarColor(index, DMI_OSC, upColor);
            //else series.setBarColor(index, DMI_OSC, downColor);

            //DMI Stochastic
            //lowest = series.lowest(index, fastkPd, DMI_OSC);
            //highest = series.highest(index, fastkPd, DMI_OSC);
            //fastK = (dmiOsc - lowest) / (highest - lowest) * 100.0;
            //slowK = series.ma(stochMethod, index, slowkPd, FAST_K);
            //Plot: dmiStoch = series.ma(stochMethod, index, stochSmPd, SLOW_K);

            //MA
            //Plot: ma = series.ma(maMethod, index, maPd, input);
            List<decimal> dmiOscillatorList = new();
            List<decimal> highestList = new();
            List<decimal> lowestList = new();
            List<decimal> fastKList = new();
            List<decimal> slowKList = new();
            List<decimal> dmiStochList = new();
            List<decimal> dmiStochSmaList = new();
            List<decimal> pdmaList = new();
            List<decimal> ndmaList = new();
            List<decimal> traList = new();
            List<decimal> pdiList = new();
            List<decimal> ndiList = new();
            List<Signal> signalsList = new();

            try
            {
                int dmiPeriod = (int)Math.Ceiling(days / 0.3);
                int fastKPeriod = dmiPeriod;
                int smoothPeriod = days;
                int slowKPeriod = smoothPeriod;
                int maPeriod = dmiPeriod * 5;

                var adiList = CalculateAverageDirectionalIndex(stockDataClass, maType, days);
                var dmPlusList = adiList.Item1;
                var dmMinusList = adiList.Item2;
                var trueRangeList = CalculateVortexIndicator(stockDataClass, days).Item5;
                pdmaList = GetMovingAverageList(maType, dmPlusList, stockDataClass, dmiPeriod);
                ndmaList = GetMovingAverageList(maType, dmMinusList, stockDataClass, dmiPeriod);
                traList = GetMovingAverageList(maType, trueRangeList, stockDataClass, dmiPeriod);

                for (int i = 0; i < pdmaList.Count; i++)
                {
                    decimal pdma = pdmaList.ElementAtOrDefault(i);
                    decimal ndma = ndmaList.ElementAtOrDefault(i);
                    decimal tra = traList.ElementAtOrDefault(i);

                    decimal pdi = tra != 0 ? pdma / tra * 100 : 0;
                    pdiList.Add(pdi);

                    decimal ndi = tra != 0 ? ndma / tra * 100 : 0;
                    ndiList.Add(ndi);

                    decimal dmiOscillator = ndi - pdi;
                    dmiOscillatorList.Add(dmiOscillator);

                    decimal lowest = dmiOscillatorList.TakeLast(fastKPeriod).Min();
                    lowestList.Add(lowest);

                    decimal highest = dmiOscillatorList.TakeLast(fastKPeriod).Max();
                    highestList.Add(highest);

                    decimal fastK = highest - lowest != 0 ? MinOrMax((dmiOscillator - lowest) / (highest - lowest) * 100, 100, 0) : 0;
                    fastKList.Add(fastK);

                    decimal slowK = fastKList.TakeLast(slowKPeriod).Average();
                    slowKList.Add(slowK);

                    decimal prevDmiStoch = dmiStochList.LastOrDefault();
                    decimal dmiStoch = slowKList.TakeLast(smoothPeriod).Average();
                    dmiStochList.Add(dmiStoch);

                    decimal prevDmiStochSma = dmiStochSmaList.LastOrDefault();
                    decimal dmiStochSma = dmiStochList.TakeLast(maPeriod).Average();
                    dmiStochSmaList.Add(dmiStochSma);

                    var signal = GetRsiSignal(dmiStoch - dmiStochSma, prevDmiStoch - prevDmiStochSma, dmiStoch, prevDmiStoch, 90, 10);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (pdmaList, ndmaList, traList, pdiList, ndiList, dmiOscillatorList, lowestList, highestList, fastKList, slowKList, dmiStochList, dmiStochSmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateMoveTracker(StockData stockDataClass)
        {
            //input = price, user defined, default is close
            //prev = previous, sig = signal
            //index = current bar number

            //prevP = price[index - 1];
            //Plot1: mt = price - prevP;
            //prevMt = mt[index - 1];
            //Plot2: sig = mt - prevMt;
            List<decimal> mtList = new();
            List<decimal> mtSignalList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal prevMt = mtList.LastOrDefault();
                    decimal mt = currentValue - prevValue;
                    mtList.Add(mt);

                    decimal prevMtSignal = mtSignalList.LastOrDefault();
                    decimal mtSignal = mt - prevMt;
                    mtSignalList.Add(mtSignal);

                    var signal = GetCompareSignal(mt - mtSignal, prevMt - prevMtSignal);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (mtList, mtSignalList, signalsList);
        }

        public static (List<decimal>, List<Signal>) CalculateMultiLevelIndicator(StockData stockDataClass, int days)
        {
            //input = tFrame, user defined, default is 5 Minute
            //factor = user defined, default is 10000
            //i = current bar number, prev = previous

            //BarSize bar1 = series.getBarSize();
            //barMin1 = bar1.getInterval();
            //if (barMin1 != 1)
            //return;
            //endif
            //xBarMin = convert(tFrame);
            //size = size();
            //if (size lessThan xBarMin ) return;

            //for (int i = xBarMin; i lessThan size; i++)
            //close = series.getClose(i);
            //open1 = series.getOpen(i);
            //openx = series.getOpen(i - xBarMin);
            //Plot: z = ((close - open1) - (close - openx)) * factor;
            //Signals
            //boolean sell = prevZ lessThan topGuide AND z moreThan topGuide;
            //boolean buy = prevZ moreThan bottomBuide AND z lessThan bottomGuide;
            //endFor
            decimal factor = 10000, topGuide = 5, bottomGuide = -5;
            List<decimal> zList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.OpenPrices.Count; i++)
                {
                    decimal prevOpen = i >= days ? stockDataClass.OpenPrices.ElementAtOrDefault(i - days) : 0;
                    decimal currentOpen = stockDataClass.OpenPrices.ElementAtOrDefault(i);
                    decimal currentClose = stockDataClass.ClosePrices.ElementAtOrDefault(i);
                    decimal prevZ1 = i >= 1 ? zList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevZ2 = i >= 2 ? zList.ElementAtOrDefault(i - 2) : 0;

                    decimal z = ((currentClose - currentOpen) - (currentClose - prevOpen)) * factor;
                    zList.Add(z);

                    var signal = GetRsiSignal(z - prevZ1, prevZ1 - prevZ2, z, prevZ1, topGuide, bottomGuide);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (zList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateOscar(StockData stockDataClass, int days = 8)
        {
            //input = price, user defined, default is closing price
            //period = user defined, default is 8
            //index = current bar number

            //lowest = lowest(index, period, LOW);
            //highest = highest(index, period, HIGH);
            //rough = ((price - lowest) / (highest - lowest)) * 100;
            //prevOscar = oscar[index - 1];
            //Plot: oscar = ((prevOscar / 3) * 2) + (rough / 3);
            List<decimal> roughList = new();
            List<decimal> oscarList = new();
            List<decimal> oscarEmaList = new();
            List<Signal> signalsList = new();

            try
            {
                int signalPeriod = MinOrMax((int)Math.Ceiling((decimal)days / 2));

                var list = VolumeInputCheck(stockDataClass, days, true);
                var highList = list.Item1;
                var lowList = list.Item2;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal highest = highList.ElementAtOrDefault(i);
                    decimal lowest = lowList.ElementAtOrDefault(i);

                    decimal rough = highest - lowest != 0 ? MinOrMax((currentValue - lowest) / (highest - lowest) * 100, 100, 0) : 0;
                    roughList.Add(rough);

                    decimal prevOscar = oscarList.LastOrDefault();
                    decimal oscar = (prevOscar / 6) + (rough / 3);
                    oscarList.Add(oscar);

                    decimal prevOscarEma = oscarEmaList.LastOrDefault();
                    decimal oscarEma = CalculateExponentialMovingAverage(oscar, prevOscarEma, signalPeriod);
                    oscarEmaList.Add(oscarEma);

                    var signal = GetRsiSignal(oscar - oscarEma, prevOscar - prevOscarEma, oscar, prevOscar, 80, 20);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (roughList, oscarList, oscarEmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculatePhaseCalculation(StockData stockDataClass, int days = 5)
        {
            //input = price, user defined, default is close
            //period = user defined, default is 15
            //sin = sine, cos = cosine, tan = tangent
            //abs = absolute value, asin = arc sine, atan = arc tangent
            //imagP = imaginary part, realP = real part
            //index =current bar number, LOE = less or equal

            //weight = 0;
            //realP = 0;
            //imagP = 0;
            //j = 0;
            //radians = 0;
            //phase = 0;
            //for i = index - period + 1; i LOE index; i++)
            //weight = price[i];
            //radians = toRadians(360 * j / period);
            //realP = realP + cos(radians) * weight;
            //imagP = imagP + sin(radians) * weight;
            //j++;
            //endFor
            //if (abs(realP) moreThan .001) phase = toDegrees(atan(imagP / realP));
            //else phase = 90 * toDegrees(asin(imagP));
            //if (realP lessThan 0) phase = phase + 180;
            //phase = phase + 90;
            //if (phase lessThan 0) phase = phase + 360;
            //if (phase moreThan 360) phase = phase - 360;
            List<decimal> radiansList = new();
            List<decimal> cosWeightList = new();
            List<decimal> sinWeightList = new();
            List<decimal> phaseList = new();
            List<decimal> realPList = new();
            List<decimal> imagPList = new();
            List<decimal> phaseEmaList = new();
            List<Signal> signalsList = new();

            try
            {
                int signalPeriod = days;
                int length = days * 3;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);

                    decimal radians = (decimal)Math.PI * 2 * i / length;
                    radiansList.Add(radians);

                    decimal cosWeight = (decimal)Cos((double)radians) * currentValue;
                    cosWeightList.Add(cosWeight);

                    decimal sinWeight = (decimal)Sin((double)radians) * currentValue;
                    sinWeightList.Add(sinWeight);

                    decimal realP = cosWeightList.TakeLast(length).Sum();
                    realPList.Add(realP);

                    decimal imagP = sinWeightList.TakeLast(length).Sum();
                    imagPList.Add(imagP);

                    decimal prevPhase = phaseList.LastOrDefault();
                    decimal phase = Math.Abs(realP) > 0.001m ? (decimal)Atan((double)(imagP / realP)) : (decimal)(Math.PI / 2 * Math.Sign(imagP));
                    if (realP < 0) phase += (decimal)Math.PI / 2;
                    if (phase < 0) phase += (decimal)Math.PI * 2;
                    if (phase > (decimal)Math.PI * 2) phase -= (decimal)Math.PI * 2;
                    phase = (180 * phase / (decimal)Math.PI);
                    phaseList.Add(phase);

                    decimal prevPhaseEma = phaseEmaList.LastOrDefault();
                    decimal phaseEma = CalculateExponentialMovingAverage(phase, phaseEmaList.LastOrDefault(), signalPeriod);
                    phaseEmaList.Add(phaseEma);

                    var signal = GetCompareSignal(phase - phaseEma, prevPhase - prevPhaseEma, true);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (realPList, imagPList, phaseList, phaseEmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>)
            CalculatePriceHeadleyAccelerationBands(StockData stockDataClass, string maType, int days = 20)
        {
            //@version=3
            // Copyright (c) 2018-present, Alex Orekhov (everget)
            // Acceleration Bands indicator script may be freely distributed under the MIT license.
            //study(title = "Acceleration Bands", shorttitle = "ABANDS", overlay = true)

            //length = input(title = "Length", type = integer, defval = 20)
            //factor = input(title = "Factor", type = float, defval = 0.001, step = 0.0001)
            //src = input(title = "Source", type = source, defval = close)

            //mult = 4 * factor * 1000 * (high - low) / (high + low)

            //upperBandSrc = high * (1 + mult)
            //upperBand = sma(upperBandSrc, length)

            //basis = sma(src, length)

            //lowerBandSrc = low * (1 - mult)
            //lowerBand = sma(lowerBandSrc, length)

            //upperBandPlot = plot(upperBand, title = "Upper", linewidth = 1, color =#138484, transp=0)

            //plot(basis, title = "Basis", linewidth = 1, color =#741b47, transp=0)

            //lowerBandPlot = plot(lowerBand, title = "Lower", linewidth = 1, color =#138484, transp=0)

            //fill(upperBandPlot, lowerBandPlot, title = "Background", color = color(#ffd966, 84))
            List<decimal> ubList = new();
            List<decimal> lbList = new();
            List<decimal> suList = new();
            List<decimal> slList = new();
            List<decimal> tempList = new();
            List<decimal> innerUbList = new();
            List<decimal> innerLbList = new();
            List<decimal> innerSuList = new();
            List<decimal> innerSlList = new();
            List<decimal> multList = new();
            List<decimal> innerMultList = new();
            List<Signal> signalsList = new();
            decimal factor = 0.001m;

            try
            {
                List<decimal> middleBandList = GetMovingAverageList(maType, null, stockDataClass, days);

                for (int i = 0; i < stockDataClass.HighPrices.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    tempList.Add(currentValue);

                    decimal currentHigh = stockDataClass.HighPrices.ElementAtOrDefault(i);
                    decimal currentLow = stockDataClass.LowPrices.ElementAtOrDefault(i);

                    if (currentValue > currentHigh)
                    {
                        currentHigh = tempList.TakeLast(days).Max();
                        currentLow = tempList.TakeLast(days).Min();
                    }

                    decimal mult = currentHigh + currentLow != 0 ? 4 * factor * 1000 * (currentHigh - currentLow) / (currentHigh + currentLow) : 0;
                    multList.Add(mult);

                    decimal innerMult = mult / 2;
                    innerMultList.Add(innerMult);

                    decimal outerUb = currentHigh * (1 + mult);
                    ubList.Add(outerUb);

                    decimal outerLb = currentLow * (1 - mult);
                    lbList.Add(outerLb);

                    decimal innerUb = currentHigh * (1 + innerMult);
                    innerUbList.Add(innerUb);

                    decimal innerLb = currentLow * (1 - innerMult);
                    innerLbList.Add(innerLb);
                }

                suList = GetMovingAverageList(maType, ubList, stockDataClass, days);
                slList = GetMovingAverageList(maType, lbList, stockDataClass, days);
                innerSuList = GetMovingAverageList(maType, innerUbList, stockDataClass, days);
                innerSlList = GetMovingAverageList(maType, innerLbList, stockDataClass, days);
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(j);
                    decimal prevValue = j >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(j - 1) : 0;
                    decimal middleBand = middleBandList.ElementAtOrDefault(j);
                    decimal prevMiddleBand = j >= 1 ? middleBandList.ElementAtOrDefault(j - 1) : 0;
                    decimal outerUbSma = suList.ElementAtOrDefault(j);
                    decimal prevOuterUbSma = j >= 1 ? suList.ElementAtOrDefault(j - 1) : 0;
                    decimal outerLbSma = slList.ElementAtOrDefault(j);
                    decimal prevOuterLbSma = j >= 1 ? slList.ElementAtOrDefault(j - 1) : 0;
                    decimal innerUbSma = innerSuList.ElementAtOrDefault(j);
                    decimal innerLbSma = innerSlList.ElementAtOrDefault(j);

                    var signal = GetBollingerBandsSignal(currentValue - middleBand, prevValue - prevMiddleBand, currentValue, prevValue, outerUbSma, prevOuterUbSma, outerLbSma, prevOuterLbSma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (multList, ubList, suList, lbList, slList, innerMultList, innerUbList, innerSuList, innerLbList, innerSlList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculatePremierStochasticOscillator(StockData stockDataClass, string maType, int days = 8)
        {
            //
            // @author LazyBear
            //
            //study("Premier Stochastic Oscillator [LazyBear]", shorttitle = "PSO_LB")
            //stochlen = input(8, title = "Stoch length")
            //smoothlen = input(25, title = "Smooth length")
            //sk = stoch(close, high, low, stochlen)
            //len = round(sqrt(smoothlen))
            //nsk = 0.1 * (sk - 50)
            //ss = ema(ema(nsk, len), len)
            //expss = exp(ss)
            //pso = (expss - 1) / (expss + 1)
            //plot(pso, title = "Premier Stoch", color = black, linewidth = 2)
            //plot(pso, color = iff(pso < 0, red, blue), style = histogram)
            //plot(0, color = gray)
            //plot(0.2, color = blue, style = 3)
            //plot(0.9, color = blue)
            //plot(-0.2, color = red, style = 3)
            //plot(-0.9, color = red)
            List<decimal> nskList = new();
            List<decimal> nskEmaList = new();
            List<decimal> ssList = new();
            List<decimal> expssList = new();
            List<decimal> psoList = new();
            List<Signal> signalsList = new();

            try
            {
                int smoothLen = MinOrMax((int)Math.Ceiling(days / 0.32));
                int len = MinOrMax((int)Math.Ceiling(Sqrt((double)smoothLen)));

                var stochasticRsiList = CalculateStochasticOscillator(null, stockDataClass, maType, days).Item3;

                for (int i = 0; i < stochasticRsiList.Count; i++)
                {
                    decimal sk = stochasticRsiList.ElementAtOrDefault(i);

                    decimal nsk = 0.1m * (sk - 50);
                    nskList.Add(nsk);
                }

                nskEmaList = GetMovingAverageList(maType, nskList, stockDataClass, len);
                ssList = GetMovingAverageList(maType, nskEmaList, stockDataClass, len);
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal ss = ssList.ElementAtOrDefault(j);
                    decimal prevPso1 = j >= 1 ? psoList.ElementAtOrDefault(j - 1) : 0;
                    decimal prevPso2 = j >= 2 ? psoList.ElementAtOrDefault(j - 2) : 0;

                    decimal expss = Exp(ss);
                    expssList.Add(expss);

                    decimal pso = expss + 1 != 0 ? MinOrMax((expss - 1) / (expss + 1), 1, -1) : 0;
                    psoList.Add(pso);

                    var signal = GetRsiSignal(pso - prevPso1, prevPso1 - prevPso2, pso, prevPso1, 0.9m, -0.9m);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (nskList, nskEmaList, ssList, expssList, psoList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateOceanIndicator(StockData stockDataClass, string maType, int days = 14)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Ocean Indicator [CC] script may be freely distributed under the MIT license.
            //study("Ocean Indicator [CC]", overlay = false)

            //inp = input(title = "Source", type = input.source, defval = close)
            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //src = security(syminfo.tickerid, res, inp[rep ? 0 : barstate.isrealtime ? 1 : 0])[rep ? 0 : barstate.isrealtime ? 0 : 1]
            //length = input(title = "Length", type = input.integer, defval = 14, minval = 1)

            //ln = log(src) * 1000
            //oi = (ln - nz(ln[length])) / sqrt(length) * 100
            //oiEma = ema(oi, length)

            //slo = oiEma - nz(oiEma[1])
            //sig = slo > 0 ? slo > nz(slo[1]) ? 2 : 1 : slo < 0 ? slo < nz(slo[1]) ? -2 : -1 : 0
            //alertcondition(crossover(sig, 1), "Strong Buy Signal", "Strong Bullish Change Detected")
            //alertcondition(crossunder(sig, -1), "Strong Sell Signal", "Strong Bearish Change Detected")
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //oiColor = sig > 1 ? color.green : sig > 0 ? color.lime : sig < -1 ? color.maroon : sig < 0 ? color.red : color.black
            //barcolor(bar ? oiColor : na)
            //hline(0)
            //plot(oiEma, color = oiColor, linewidth = 2)
            List<decimal> lnList = new();
            List<decimal> oiList = new();
            List<decimal> oiEmaList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevLn = i >= days ? lnList.ElementAtOrDefault(i - days) : 0;

                    decimal ln = currentValue > 0 ? (decimal)Log((double)currentValue) * 1000 : 0;
                    lnList.Add(ln);

                    decimal oi = (ln - prevLn) / (decimal)Sqrt((double)days) * 100;
                    oiList.Add(oi);
                }

                oiEmaList = GetMovingAverageList(maType, oiList, stockDataClass, days);
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal oiEma = oiEmaList.ElementAtOrDefault(j);
                    decimal prevOiEma1 = j >= 1 ? oiEmaList.ElementAtOrDefault(j - 1) : 0;
                    decimal prevOiEma2 = j >= 2 ? oiEmaList.ElementAtOrDefault(j - 2) : 0;

                    var signal = GetCompareSignal(oiEma - prevOiEma1, prevOiEma1 - prevOiEma2);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (lnList, oiList, oiEmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateNaturalMarketMirror(StockData stockDataClass, string maType, int days = 40)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Natural Market Mirror [CC] script may be freely distributed under the MIT license.
            //study("Natural Market Mirror [CC]", overlay = false)

            //inp = input(title = "Source", type = input.source, defval = close)
            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //src = security(syminfo.tickerid, res, inp[rep ? 0 : barstate.isrealtime ? 1 : 0])[rep ? 0 : barstate.isrealtime ? 0 : 1]
            //length = input(title = "Length", type = input.integer, defval = 40, minval = 1)

            //ln = log(src) * 1000
            //oiSum = 0.0
            //for i = 1 to length
            //    oiSum += (ln - nz(ln[i])) / sqrt(i) * 100
            //nmm = ema(oiSum / length, length)

            //slo = nmm - nz(nmm[1])
            //sig = slo > 0 ? slo > nz(slo[1]) ? 2 : 1 : slo < 0 ? slo < nz(slo[1]) ? -2 : -1 : 0
            //alertcondition(crossover(sig, 1), "Strong Buy Signal", "Strong Bullish Change Detected")
            //alertcondition(crossunder(sig, -1), "Strong Sell Signal", "Strong Bearish Change Detected")
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //nmmColor = sig > 1 ? color.green : sig > 0 ? color.lime : sig < -1 ? color.maroon : sig < 0 ? color.red : color.black
            //barcolor(bar ? nmmColor : na)
            //hline(0)
            //plot(nmm, color = nmmColor, linewidth = 2)
            List<decimal> lnList = new();
            List<decimal> oiSumList = new();
            List<decimal> oiAvgList = new();
            List<decimal> nmmList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);

                    decimal ln = currentValue > 0 ? (decimal)Log((double)currentValue) * 1000 : 0;
                    lnList.Add(ln);

                    decimal oiSum = 0;
                    for (int j = 1; j <= days; j++)
                    {
                        decimal prevLn = i >= j ? lnList.ElementAtOrDefault(i - j) : 0;
                        oiSum += (ln - prevLn) / (decimal)Sqrt((double)j) * 100;
                    }
                    oiSumList.Add(oiSum);

                    decimal oiAvg = oiSum / days;
                    oiAvgList.Add(oiAvg);
                }

                nmmList = GetMovingAverageList(maType, oiAvgList, stockDataClass, days);
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal nmm = nmmList.ElementAtOrDefault(j);
                    decimal prevNmm1 = j >= 1 ? nmmList.ElementAtOrDefault(j - 1) : 0;
                    decimal prevNmm2 = j >= 2 ? nmmList.ElementAtOrDefault(j - 2) : 0;

                    var signal = GetCompareSignal(nmm - prevNmm1, prevNmm1 - prevNmm2);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (oiSumList, oiAvgList, nmmList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateNaturalMarketRiver(StockData stockDataClass, string maType, int days = 40)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Natural Market River [CC] script may be freely distributed under the MIT license.
            //study("Natural Market River [CC]", overlay = false)

            //inp = input(title = "Source", type = input.source, defval = close)
            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //src = security(syminfo.tickerid, res, inp[rep ? 0 : barstate.isrealtime ? 1 : 0])[rep ? 0 : barstate.isrealtime ? 0 : 1]
            //length = input(title = "Length", type = input.integer, defval = 40, minval = 1)

            //ln = log(src) * 1000
            //nmrSum = 0.0
            //for i = 1 to length
            //    nmrSum += ((nz(ln[i - 1]) - nz(ln[i])) * (sqrt(i) - sqrt(i - 1)))
            //nmr = ema(nmrSum, length)

            //slo = nmr - nz(nmr[1])
            //sig = slo > 0 ? slo > nz(slo[1]) ? 2 : 1 : slo < 0 ? slo < nz(slo[1]) ? -2 : -1 : 0
            //alertcondition(crossover(sig, 1), "Strong Buy Signal", "Strong Bullish Change Detected")
            //alertcondition(crossunder(sig, -1), "Strong Sell Signal", "Strong Bearish Change Detected")
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //nmrColor = sig > 1 ? color.green : sig > 0 ? color.lime : sig < -1 ? color.maroon : sig < 0 ? color.red : color.black
            //barcolor(bar ? nmrColor : na)
            //hline(0)
            //plot(nmr, color = nmrColor, linewidth = 2)
            List<decimal> lnList = new();
            List<decimal> oiSumList = new();
            List<decimal> nmrList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);

                    decimal ln = currentValue > 0 ? (decimal)Log((double)currentValue) * 1000 : 0;
                    lnList.Add(ln);

                    decimal oiSum = 0;
                    for (int j = 0; j < days; j++)
                    {
                        decimal currentLn = i >= j ? lnList.ElementAtOrDefault(i - j) : 0;
                        decimal prevLn = i >= j + 1 ? lnList.ElementAtOrDefault(i - (j + 1)) : 0;

                        oiSum += ((prevLn - currentLn) * (decimal)((Sqrt((double)j) - Sqrt((double)j + 1))));
                    }
                    oiSumList.Add(oiSum);
                }

                nmrList = GetMovingAverageList(maType, oiSumList, stockDataClass, days);
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal nmr = nmrList.ElementAtOrDefault(j);
                    decimal prevNmr1 = j >= 1 ? nmrList.ElementAtOrDefault(j - 1) : 0;
                    decimal prevNmr2 = j >= 2 ? nmrList.ElementAtOrDefault(j - 2) : 0;

                    var signal = GetCompareSignal(nmr - prevNmr1, prevNmr1 - prevNmr2);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (oiSumList, nmrList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateNaturalMarketCombo(StockData stockDataClass, string maType, int days = 20)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Natural Market Combo [CC] script may be freely distributed under the MIT license.
            //study("Natural Market Combo [CC]", overlay = false)

            //inp = input(title = "Source", type = input.source, defval = close)
            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //src = security(syminfo.tickerid, res, inp[rep ? 0 : barstate.isrealtime ? 1 : 0])[rep ? 0 : barstate.isrealtime ? 0 : 1]
            //length = input(title = "Length", type = input.integer, defval = 40, minval = 1)
            //smoothLength = input(title = "SmoothLength", type = input.integer, defval = 20, minval = 1)

            //ln = src > 0 ? log(src) * 1000 : 0

            //nmr = 0.0
            //for i = 1 to length
            //    nmr += ((nz(ln[i - 1]) - nz(ln[i])) * (sqrt(i) - sqrt(i - 1)))

            //nmm = 0.0
            //for i = 1 to length
            //    nmm += ((ln - nz(ln[i])) / sqrt(i))

            //v3 = sign(nmm) != sign(nmr) ? nmm * nmr : ((abs(nmm) * nmr) + (abs(nmr) * nmm)) / 2
            //nmc = wma(sign(v3) * sqrt(abs(v3)), smoothLength)

            //slo = nmc - nz(nmc[1])
            //sig = slo > 0 ? slo > nz(slo[1]) ? 2 : 1 : slo < 0 ? slo < nz(slo[1]) ? -2 : -1 : 0
            //alertcondition(crossover(sig, 1), "Strong Buy Signal", "Strong Bullish Change Detected")
            //alertcondition(crossunder(sig, -1), "Strong Sell Signal", "Strong Bearish Change Detected")
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //nmcColor = sig > 1 ? color.green : sig > 0 ? color.lime : sig < -1 ? color.maroon : sig < 0 ? color.red : color.black
            //barcolor(bar ? nmcColor : na)
            //hline(0)
            //plot(nmc, color = nmcColor, linewidth = 2)
            List<decimal> v3List = new();
            List<decimal> nmcList = new();
            List<decimal> nmcMaList = new();
            List<Signal> signalsList = new();

            try
            {
                int smoothLength = days;
                int length = days * 2;

                var nmrList = CalculateNaturalMarketRiver(stockDataClass, maType, length).Item1;
                var nmmList = CalculateNaturalMarketMirror(stockDataClass, maType, length).Item2;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal ln = currentValue > 0 ? (decimal)Log((double)currentValue) * 1000 : 0;
                    decimal nmr = nmrList.ElementAtOrDefault(i);
                    decimal nmm = nmmList.ElementAtOrDefault(i);

                    decimal v3 = Math.Sign(nmm) != Math.Sign(nmr) ? nmm * nmr : ((Math.Abs(nmm) * nmr) + (Math.Abs(nmr) * nmm)) / 2;
                    v3List.Add(v3);

                    decimal nmc = Math.Sign(v3) * (decimal)Sqrt((double)Math.Abs(v3));
                    nmcList.Add(nmc);
                }

                nmcMaList = GetMovingAverageList(maType, nmcList, stockDataClass, smoothLength);
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal nmc = nmcMaList.ElementAtOrDefault(j);
                    decimal prevNmc1 = j >= 1 ? nmcMaList.ElementAtOrDefault(j - 1) : 0;
                    decimal prevNmc2 = j >= 2 ? nmcMaList.ElementAtOrDefault(j - 2) : 0;

                    var signal = GetCompareSignal(nmc - prevNmc1, prevNmc1 - prevNmc2);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (v3List, nmcList, nmcMaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateNaturalDirectionalIndex(StockData stockDataClass, string maType, int days = 20)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Natural Directional Index [CC] script may be freely distributed under the MIT license.
            //study("Natural Directional Index [CC]", overlay = false)

            //inp = input(title = "Source", type = input.source, defval = close)
            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //src = security(syminfo.tickerid, res, inp[rep ? 0 : barstate.isrealtime ? 1 : 0])[rep ? 0 : barstate.isrealtime ? 0 : 1]
            //length = input(title = "Length", type = input.integer, defval = 40, minval = 1)
            //smoothLength = input(title = "SmoothLength", type = input.integer, defval = 20, minval = 1)

            //ln = src > 0 ? log(src) * 1000 : 0

            //weightSum = 0.0, denomSum = 0.0, absSum = 0.0
            //for i = 1 to length
            //    diff = nz(ln[i - 1]) - nz(ln[i])
            //    absSum := absSum + abs(diff)
            //    frac = absSum != 0 ? (ln - nz(ln[i])) / absSum : 0
            //    ratio = 1 / sqrt(i)
            //    weightSum := weightSum + (frac * ratio)
            //    denomSum := denomSum + ratio

            //rawNdx = denomSum != 0 ? weightSum / denomSum * 100 : 0
            //ndx = ema(rawNdx, smoothLength)

            //slo = ndx - nz(ndx[1])
            //sig = slo > 0 ? slo > nz(slo[1]) ? 2 : 1 : slo < 0 ? slo < nz(slo[1]) ? -2 : -1 : 0
            //alertcondition(crossover(sig, 1), "Strong Buy Signal", "Strong Bullish Change Detected")
            //alertcondition(crossunder(sig, -1), "Strong Sell Signal", "Strong Bearish Change Detected")
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //ndxColor = sig > 1 ? color.green : sig > 0 ? color.lime : sig < -1 ? color.maroon : sig < 0 ? color.red : color.black
            //barcolor(bar ? ndxColor : na)
            //hline(0)
            //plot(ndx, color = ndxColor, linewidth = 2)
            List<decimal> lnList = new();
            List<decimal> weightSumList = new();
            List<decimal> denomSumList = new();
            List<decimal> absSumList = new();
            List<decimal> rawNdxList = new();
            List<decimal> ndxList = new();
            List<Signal> signalsList = new();

            try
            {
                int smoothLength = days;
                int length = days * 2;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);

                    decimal ln = currentValue > 0 ? (decimal)Log((double)currentValue) * 1000 : 0;
                    lnList.Add(ln);

                    decimal weightSum = 0, denomSum = 0, absSum = 0;
                    for (int j = 0; j < length; j++)
                    {
                        decimal prevLn = i >= j + 1 ? lnList.ElementAtOrDefault(i - (j + 1)) : 0;
                        decimal currLn = i >= j ? lnList.ElementAtOrDefault(i - j) : 0;
                        decimal diff = prevLn - currLn;
                        absSum += Math.Abs(diff);
                        decimal frac = absSum != 0 ? (ln - currLn) / absSum : 0;
                        decimal ratio = 1 / (decimal)Sqrt((double)j + 1);
                        weightSum += frac * ratio;
                        denomSum += ratio;
                    }
                    weightSumList.Add(weightSum);
                    denomSumList.Add(denomSum);
                    absSumList.Add(absSum);

                    decimal rawNdx = denomSum != 0 ? weightSum / denomSum * 100 : 0;
                    rawNdxList.Add(rawNdx);
                }

                ndxList = GetMovingAverageList(maType, rawNdxList, stockDataClass, smoothLength);
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal ndx = ndxList.ElementAtOrDefault(j);
                    decimal prevNdx1 = j >= 1 ? ndxList.ElementAtOrDefault(j - 1) : 0;
                    decimal prevNdx2 = j >= 2 ? ndxList.ElementAtOrDefault(j - 2) : 0;

                    var signal = GetCompareSignal(ndx - prevNdx1, prevNdx1 - prevNdx2);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (weightSumList, denomSumList, absSumList, rawNdxList, ndxList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateNaturalStochasticIndicator(StockData stockDataClass, string maType, int days = 10)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Natural Stochastic Indicator [CC] script may be freely distributed under the MIT license.
            //study("Natural Stochastic Indicator [CC]", overlay = false)

            //f_security(_symbol, _res, _src, _repaint) => 
            //    security(_symbol, _res, _src[_repaint ? 0 : barstate.isrealtime ? 1 : 0])[_repaint ? 0 : barstate.isrealtime ? 0 : 1]

            //inp = input(title = "Source", type = input.source, defval = close)
            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //length = input(title = "Length", type = input.integer, defval = 20, minval = 1)
            //smoothLength = input(title = "SmoothLength", type = input.integer, defval = 10, minval = 1)
            //c = f_security(syminfo.tickerid, res, close, rep)
            //h = f_security(syminfo.tickerid, res, high, rep)
            //l = f_security(syminfo.tickerid, res, low, rep)

            //hh = highest(h, length)
            //ll = lowest(l, length)

            //weightSum = 0.0, denomSum = 0.0
            //for i = 0 to length
            //    currHigh = nz(hh[i])
            //    currLow = nz(ll[i])
            //    range = currHigh - currLow
            //    frac = range != 0 ? (nz(c[i]) - currLow) / range : 0
            //    ratio = 1 / sqrt(i + 1)
            //    weightSum := weightSum + (frac * ratio)
            //    denomSum := denomSum + ratio

            //rawNst = denomSum != 0 ? (200 * weightSum / denomSum) - 100 : 0
            //nst = ema(rawNst, smoothLength)

            //slo = nst - nz(nst[1])
            //sig = slo > 0 ? slo > nz(slo[1]) ? 2 : 1 : slo < 0 ? slo < nz(slo[1]) ? -2 : -1 : 0
            //alertcondition(crossover(sig, 1), "Strong Buy Signal", "Strong Bullish Change Detected")
            //alertcondition(crossunder(sig, -1), "Strong Sell Signal", "Strong Bearish Change Detected")
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //nstColor = sig > 1 ? color.green : sig > 0 ? color.lime : sig < -1 ? color.maroon : sig < 0 ? color.red : color.black
            //barcolor(bar ? nstColor : na)
            //hline(0)
            //plot(nst, color = nstColor, linewidth = 2)
            List<decimal> weightSumList = new();
            List<decimal> denomSumList = new();
            List<decimal> rawNstList = new();
            List<decimal> nstList = new();
            List<Signal> signalsList = new();

            try
            {
                int smoothLength = days;
                int length = days * 2;

                var volCheckList = VolumeInputCheck(stockDataClass, length, true);
                var hhList = volCheckList.Item1;
                var llList = volCheckList.Item2;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal weightSum = 0, denomSum = 0;
                    for (int j = 0; j < length; j++)
                    {
                        decimal hh = i >= j ? hhList.ElementAtOrDefault(i - j) : 0;
                        decimal ll = i >= j ? llList.ElementAtOrDefault(i - j) : 0;
                        decimal c = i >= j ? stockDataClass.InputValues.ElementAtOrDefault(i - j) : 0;
                        decimal range = hh - ll;
                        decimal frac = range != 0 ? (c - ll) / range : 0;
                        decimal ratio = 1 / (decimal)Sqrt((double)j + 1);
                        weightSum += frac * ratio;
                        denomSum += ratio;
                    }
                    weightSumList.Add(weightSum);
                    denomSumList.Add(denomSum);

                    decimal rawNst = denomSum != 0 ? (200 * weightSum / denomSum) - 100 : 0;
                    rawNstList.Add(rawNst);
                }

                nstList = GetMovingAverageList(maType, rawNstList, stockDataClass, smoothLength);
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal nst = nstList.ElementAtOrDefault(j);
                    decimal prevNst1 = j >= 1 ? nstList.ElementAtOrDefault(j - 1) : 0;
                    decimal prevNst2 = j >= 2 ? nstList.ElementAtOrDefault(j - 2) : 0;

                    var signal = GetCompareSignal(nst - prevNst1, prevNst1 - prevNst2);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (weightSumList, denomSumList, rawNstList, nstList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateNaturalDirectionalCombo(StockData stockDataClass, string maType, int days = 20)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Natural Directional Combo [CC] script may be freely distributed under the MIT license.
            //study("Natural Directional Combo [CC]", overlay = false)

            //f_security(_symbol, _res, _src, _repaint) => 
            //    security(_symbol, _res, _src[_repaint ? 0 : barstate.isrealtime ? 1 : 0])[_repaint ? 0 : barstate.isrealtime ? 0 : 1]

            //inp = input(title = "Source", type = input.source, defval = close)
            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //length = input(title = "Length", type = input.integer, defval = 40, minval = 1)
            //smoothLength = input(title = "SmoothLength", type = input.integer, defval = 20, minval = 1)
            //c = f_security(syminfo.tickerid, res, close, rep)
            //h = f_security(syminfo.tickerid, res, high, rep)
            //l = f_security(syminfo.tickerid, res, low, rep)

            //hh = highest(h, length)
            //ll = lowest(l, length)
            //ln = c > 0 ? log(c) * 1000 : 0

            //nstWeightSum = 0.0, nstDenomSum = 0.0
            //for i = 0 to length
            //    currHigh = nz(hh[i])
            //    currLow = nz(ll[i])
            //    range = currHigh - currLow
            //    frac = range != 0 ? (nz(c[i]) - currLow) / range : 0
            //    ratio = 1 / sqrt(i + 1)
            //    nstWeightSum := nstWeightSum + (frac * ratio)
            //    nstDenomSum := nstDenomSum + ratio

            //rawNst = nstDenomSum != 0 ? (200 * nstWeightSum / nstDenomSum) - 100 : 0
            //nst = ema(rawNst, smoothLength)

            //ndxWeightSum = 0.0, ndxDenomSum = 0.0, absSum = 0.0
            //for i = 1 to length
            //    diff = nz(ln[i - 1]) - nz(ln[i])
            //    absSum := absSum + abs(diff)
            //    frac = absSum != 0 ? (ln - nz(ln[i])) / absSum : 0
            //    ratio = 1 / sqrt(i)
            //    ndxWeightSum := ndxWeightSum + (frac * ratio)
            //    ndxDenomSum := ndxDenomSum + ratio

            //rawNdx = ndxDenomSum != 0 ? ndxWeightSum / ndxDenomSum * 100 : 0
            //ndx = ema(rawNdx, smoothLength)

            //v3 = sign(ndx) != sign(nst) ? ndx * nst : ((abs(ndx) * nst) + (abs(nst) * ndx)) / 2
            //nxc = sign(v3) * sqrt(abs(v3))

            //slo = nxc - nz(nxc[1])
            //sig = slo > 0 ? slo > nz(slo[1]) ? 2 : 1 : slo < 0 ? slo < nz(slo[1]) ? -2 : -1 : 0
            //alertcondition(crossover(sig, 1), "Strong Buy Signal", "Strong Bullish Change Detected")
            //alertcondition(crossunder(sig, -1), "Strong Sell Signal", "Strong Bearish Change Detected")
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //nxcColor = sig > 1 ? color.green : sig > 0 ? color.lime : sig < -1 ? color.maroon : sig < 0 ? color.red : color.black
            //barcolor(bar ? nxcColor : na)
            //hline(0)
            //plot(nxc, color = nxcColor, linewidth = 2)
            List<decimal> v3List = new();
            List<decimal> nxcList = new();
            List<Signal> signalsList = new();

            try
            {
                int smoothLength = days;
                int length = days * 2;

                var ndxList = CalculateNaturalDirectionalIndex(stockDataClass, maType, smoothLength).Item5;
                var nstList = CalculateNaturalStochasticIndicator(stockDataClass, maType, smoothLength).Item4;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal ndx = ndxList.ElementAtOrDefault(i);
                    decimal nst = nstList.ElementAtOrDefault(i);
                    decimal prevNxc1 = i >= 1 ? nxcList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevNxc2 = i >= 2 ? nxcList.ElementAtOrDefault(i - 2) : 0;

                    decimal v3 = Math.Sign(ndx) != Math.Sign(nst) ? ndx * nst : ((Math.Abs(ndx) * nst) + (Math.Abs(nst) * ndx)) / 2;
                    v3List.Add(v3);

                    decimal nxc = Math.Sign(v3) * (decimal)Sqrt((double)Math.Abs(v3));
                    nxcList.Add(nxc);

                    var signal = GetCompareSignal(nxc - prevNxc1, prevNxc1 - prevNxc2);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (v3List, nxcList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateKwanIndicator(StockData stockDataClass, string maType, int days = 2)
        {
            //@version=4
            ////////////////////////////////////////////////////////////
            //  Copyright by HPotter v1.0 23/07/2021
            // To calculate the coordinates in which the kink of the line will cross, 
            //the standard Forex instruments are used - Relative Strenght Index, Stochastic and Momentum.
            //It is very easy to optimize them for the existing trading strategy: they all have very 
            //flexible and easily customizable parameters. var to enter the market can be 2 situations:
            //    Change of color of the indicator line from red to blue. At the same time, it is worth entering into the purchase;
            //    Change of color of the indicator line from blue to red. In this case, it is worth entering for sale.
            //The signals are extremely clear and can be used in practice even by beginners. The indicator 
            //itself shows when to make deals: the user only has to accompany them and set the values 
            //of Take Profit and Stop Loss. As a rule, the signal to complete trading is the approach of 
            //the indicator level to the levels of the maximum or minimum of the previous time period.  
            ////////////////////////////////////////////////////////////
            //study(title = "Kwan NRP", shorttitle = "KNRP")
            //xPrice = open
            //Length_Momentum = input(9, minval = 1)
            //Length_RSI = input(9, minval = 1)
            //Length_Stoch = input(9, minval = 1)
            //Length_NRP = input(2, minval = 1)
            //var xKNRP = array.new_float(1, na)
            //xMom = close / close[Length_Momentum] * 100
            //xRSI = rsi(xPrice, Length_RSI)
            //xStoch = stoch(xPrice, high, low, 9)
            //if xMom != 0
            //    val = xStoch * xRSI / xMom
            //    array.push(xKNRP, val)
            //    nz(na)
            //avr = 0.0
            //if array.size(xKNRP) > Length_NRP
            //    for i = array.size(xKNRP) - Length_NRP to array.size(xKNRP) - 1

            //        avr += array.get(xKNRP, i)
            //    nz(na)
            //avr := avr / Length_NRP
            //clr = avr > avr[1] ? color.blue : color.red
            //plot(avr, color = clr, title = "RMI")
            List<decimal> vrList = new();
            List<decimal> prevList = new();
            List<decimal> vrSumList = new();
            List<decimal> knrpList = new();
            List<Signal> signalsList = new();

            try
            {
                int nrpLength = days;
                int length = (int)Math.Ceiling(days / 0.223);

                var rsiList = CalculateRelativeStrengthIndex(null, stockDataClass, maType, length).Item4;
                var minMaxList = VolumeInputCheck(stockDataClass, length, true);
                var hhList = minMaxList.Item1;
                var llList = minMaxList.Item2;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentClose = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal priorClose = i >= length ? stockDataClass.InputValues.ElementAtOrDefault(i - length) : 0;
                    decimal currentOpen = stockDataClass.OpenPrices.ElementAtOrDefault(i);
                    decimal mom = priorClose != 0 ? currentClose / priorClose * 100 : 0;
                    decimal rsi = rsiList.ElementAtOrDefault(i);
                    decimal hh = hhList.ElementAtOrDefault(i);
                    decimal ll = llList.ElementAtOrDefault(i);
                    decimal sto = hh - ll != 0 ? (currentClose - ll) / (hh - ll) * 100 : 0;
                    decimal prevVr = i >= nrpLength ? vrList.ElementAtOrDefault(i - nrpLength) : 0;
                    decimal prevKnrp1 = i >= 1 ? knrpList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevKnrp2 = i >= 2 ? knrpList.ElementAtOrDefault(i - 2) : 0;

                    decimal vr = mom != 0 ? sto * rsi / mom : 0;
                    vrList.Add(vr);

                    decimal prev = prevVr;
                    prevList.Add(prev);

                    decimal vrSum = prevList.Sum();
                    vrSumList.Add(vrSum);

                    decimal knrp = vrSum / nrpLength;
                    knrpList.Add(knrp);

                    var signal = GetCompareSignal(knrp - prevKnrp1, prevKnrp1 - prevKnrp2);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (vrList, prevList, vrSumList, knrpList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateNaturalMarketSlope(StockData stockDataClass, int days = 40)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Natural Market Slope [CC] script may be freely distributed under the MIT license.
            //study("Natural Market Slope [CC]", overlay = false)

            //inp = input(title = "Source", type = input.source, defval = close)
            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //src = security(syminfo.tickerid, res, inp[rep ? 0 : barstate.isrealtime ? 1 : 0])[rep ? 0 : barstate.isrealtime ? 0 : 1]
            //length = input(title = "Length", type = input.integer, defval = 40, minval = 1)

            //ln = src > 0 ? log(src) * 1000 : 0
            //nms = (linreg(ln, length, 0) - linreg(ln, length, 1)) * sqrt(length)

            // original calculation
            //ln = log(src)
            //nms = 0.0
            //for i = 1 to length
            //    nms += ((linreg(ln, i, 0) - linreg(ln, i, 1)) * sqrt(i))

            //slo = nms - nz(nms[1])
            //sig = slo > 0 ? slo > nz(slo[1]) ? 2 : 1 : slo < 0 ? slo < nz(slo[1]) ? -2 : -1 : 0
            //alertcondition(crossover(sig, 1), "Strong Buy Signal", "Strong Bullish Change Detected")
            //alertcondition(crossunder(sig, -1), "Strong Sell Signal", "Strong Bearish Change Detected")
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //nmsColor = sig > 1 ? color.green : sig > 0 ? color.lime : sig < -1 ? color.maroon : sig < 0 ? color.red : color.black
            //barcolor(bar ? nmsColor : na)
            //hline(0)
            //plot(nms, color = nmsColor, linewidth = 2)
            List<decimal> lnList = new();
            List<decimal> linRegList = new();
            List<decimal> nmsList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);

                    decimal prevLn = lnList.LastOrDefault();
                    decimal ln = currentValue > 0 ? (decimal)Log((double)currentValue) * 1000 : 0;
                    lnList.Add(ln);
                }

                linRegList = CalculateLinearRegression(lnList, stockDataClass, days).Item15;
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal linReg = linRegList.ElementAtOrDefault(j);
                    decimal prevLinReg = j >= 1 ? linRegList.ElementAtOrDefault(j - 1) : 0;
                    decimal prevNms1 = j >= 1 ? nmsList.ElementAtOrDefault(j - 1) : 0;
                    decimal prevNms2 = j >= 2 ? nmsList.ElementAtOrDefault(j - 2) : 0;

                    decimal nms = (linReg - prevLinReg) * Log((double)days);
                    nmsList.Add(nms);

                    var signal = GetCompareSignal(nms - prevNms1, prevNms1 - prevNms2);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (linRegList, nmsList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateNaturalMovingAverage(StockData stockDataClass, int days = 40)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Natural Moving Average [CC] script may be freely distributed under the MIT license.
            //study("Natural Moving Average [CC]", overlay = true)

            //inp = input(title = "Source", type = input.source, defval = close)
            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //src = security(syminfo.tickerid, res, inp[rep ? 0 : barstate.isrealtime ? 1 : 0])[rep ? 0 : barstate.isrealtime ? 0 : 1]
            //length = input(title = "Length", type = input.integer, defval = 40, minval = 1)

            //ln = log(src) * 1000
            //num = 0.0, denom = 0.0
            //for i = 0 to length - 1
            //    oi = abs(nz(ln[i]) - nz(ln[i + 1]))
            //    num += oi * (sqrt(i + 1) - sqrt(i))
            //    denom += oi

            //ratio = denom != 0 ? num / denom : 0
            //nma = (src * ratio) + (nz(src[1]) * (1 - ratio))

            //slo = src - nma
            //sig = slo > 0 ? slo > nz(slo[1]) ? 2 : 1 : slo < 0 ? slo < nz(slo[1]) ? -2 : -1 : 0
            //alertcondition(crossover(sig, 1), "Strong Buy Signal", "Strong Bullish Change Detected")
            //alertcondition(crossunder(sig, -1), "Strong Sell Signal", "Strong Bearish Change Detected")
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //nmaColor = sig > 1 ? color.green : sig > 0 ? color.lime : sig < -1 ? color.maroon : sig < 0 ? color.red : color.black
            //barcolor(bar ? nmaColor : na)
            //plot(nma, color = nmaColor, linewidth = 2)
            List<decimal> lnList = new();
            List<decimal> numList = new();
            List<decimal> denomList = new();
            List<decimal> ratioList = new();
            List<decimal> nmaList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal ln = currentValue > 0 ? (decimal)Log((double)currentValue) * 1000 : 0;
                    lnList.Add(ln);

                    decimal num = 0, denom = 0;
                    for (int j = 0; j < days; j++)
                    {
                        decimal currentLn = i >= j ? lnList.ElementAtOrDefault(i - j) : 0;
                        decimal prevLn = i >= j + 1 ? lnList.ElementAtOrDefault(i - (j + 1)) : 0;
                        decimal oi = Math.Abs(currentLn - prevLn);
                        num += oi * (Sqrt((double)j + 1) - Sqrt((double)j));
                        denom += oi;
                    }
                    numList.Add(num);
                    denomList.Add(denom);

                    decimal ratio = denom != 0 ? num / denom : 0;
                    ratioList.Add(ratio);

                    decimal prevNma = nmaList.LastOrDefault();
                    decimal nma = (currentValue * ratio) + (prevValue * (1 - ratio));
                    nmaList.Add(nma);

                    var signal = GetCompareSignal(currentValue - nma, prevValue - prevNma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (numList, denomList, ratioList, nmaList, signalsList);
        }

        public static (List<decimal>, List<Signal>) CalculateExponentialMovingAverage(StockData stockDataClass, int days)
        {
            // EMA smoothing factor is 2/samples + 1
            // EMA = ( P - EMAp ) * K + EMAp
            // EMA = Price(t) * k + EMA(y) * (1 – k)
            List<decimal> emaList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal prevEma = emaList.LastOrDefault();
                    decimal ema = CalculateExponentialMovingAverage(currentValue, emaList.LastOrDefault(), days);
                    emaList.Add(ema);

                    var signal = GetCompareSignal(currentValue - ema, prevValue - prevEma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (emaList, signalsList);
        }

        public static decimal CalculateExponentialMovingAverage(decimal currentValue, decimal prevEma, int emaPeriod)
        {
            // EMA=Price(t)×k + EMA(y)×(1−k)
            decimal ema = 0;

            try
            {
                decimal k = (decimal)2 / (emaPeriod + 1);
                ema = (currentValue * k) + (prevEma * (1 - k));
            }
            catch (Exception ex)
            {
                Program.ThrowExceptionInfo(ex).GetAwaiter().GetResult();
            }

            return ema;
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateEhlersZeroLagExponentialMovingAverage(StockData stockDataClass, int days = 14)
        {
            //@version=3
            // Copyright (c) 2018-present, Alex Orekhov (everget)
            // Zero Lag Exponential Moving Average script may be freely distributed under the MIT license.
            //study("Zero Lag Exponential Moving Average", shorttitle = "ZLEMA", overlay = true)

            //length = input(title = "Length", type = integer, defval = 14)
            //highlightMovements = input(title = "Highlight Movements ?", type = bool, defval = true)
            //src = input(title = "Source", type = source, defval = close)

            //lag = floor((length - 1) / 2)

            //zlema = ema(src + (src - src[lag]), length)

            //zlemaColor = highlightMovements ? (zlema > zlema[1] ? green : red) : #6d1e7f
            //plot(zlema, title = "ZLEMA", linewidth = 2, color = zlemaColor, transp = 0)
            List<decimal> zemaList = new();
            List<decimal> dList = new();
            List<Signal> signalsList = new();

            try
            {
                int lag = MinOrMax((int)Math.Floor((decimal)(days - 1) / 2));

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= lag ? stockDataClass.InputValues.ElementAtOrDefault(i - lag) : 0;

                    decimal d = currentValue + (currentValue - prevValue);
                    dList.Add(d);

                    decimal prevZema = zemaList.LastOrDefault();
                    decimal zema = CalculateExponentialMovingAverage(d, zemaList.LastOrDefault(), days);
                    zemaList.Add(zema);

                    var signal = GetCompareSignal(currentValue - zema, prevValue - prevZema);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (dList, zemaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<decimal>, List<Signal>) CalculateMultiDepthZeroLagExponentialMovingAverage(StockData stockDataClass, int days = 50)
        {
            //@version=2
            //study("Multi Depth Zero-Lag Exponential Moving Average", shorttitle = "MD-ZLEMA", overlay = true)
            //length = input(50),p = input(2, title = "Poles", minval = 1, maxval = 3)
            //
            //pi = 3.14
            //a = p == 1 ? 2 / (length + 1) : p == 2 ? exp(-sqrt(2) * pi / length) : exp(-pi / length)
            //b = p == 2 ? 2 * a * cos(sqrt(2) * pi / length) : 2 * a * cos(sqrt(3) * pi / length)
            //c = exp(-2 * pi / length)
            //
            //price = input(close)
            //alpha = if p == 1
            //    (1 - a) * nz(alpha[1], price) + a * price
            //else
            //    if p == 2
            //        b* nz(alpha[1], price) -a * a * nz(alpha[2], price) + (1 - b + a * a) * price
            //    else
            //        if p == 3
            //            (b + c) * nz(alpha[1], price) - (c + b * c) * nz(alpha[2], price) + c * c * nz(alpha[3], price) + (1 - b + c) * (1 - c) * price
            //detrend = price - alpha
            //beta = if p == 1
            //    (1 - a) * nz(beta[1]) + a * detrend
            //else
            //    if p == 2
            //        b* nz(beta[1]) -a * a * nz(beta[2]) + (1 - b + a * a) * detrend
            //    else
            //        if p == 3
            //            (b + c) * nz(beta[2]) - (c + b * c) * nz(beta[2]) + c * c * nz(beta[3]) + (1 - b + c) * (1 - c) * detrend
            //
            //mda = alpha + 1 / p * beta
            //plot(mda, color =#2E9AFE,transp=0)
            List<decimal> alpha1List = new();
            List<decimal> beta1List = new();
            List<decimal> detrend1List = new();
            List<decimal> alpha2List = new();
            List<decimal> beta2List = new();
            List<decimal> detrend2List = new();
            List<decimal> alpha3List = new();
            List<decimal> beta3List = new();
            List<decimal> detrend3List = new();
            List<decimal> mda1List = new();
            List<decimal> mda2List = new();
            List<decimal> mda3List = new();
            List<Signal> signalsList = new();

            try
            {
                decimal a1 = (decimal)2 / (days + 1);
                decimal a2 = Exp(-Math.Sqrt(2) * Math.PI / days);
                decimal a3 = Exp(-Math.PI / days);
                decimal b1 = 2 * a1 * Cos(Math.Sqrt(3) * Math.PI / days);
                decimal b2 = 2 * a2 * Cos(Math.Sqrt(2) * Math.PI / days);
                decimal b3 = 2 * a3 * Cos(Math.Sqrt(3) * Math.PI / days);
                decimal c = Exp(-2 * Math.PI / days);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal prevAlpha1 = i >= 1 ? alpha1List.ElementAtOrDefault(i - 1) : currentValue;
                    decimal alpha1 = (a1 * currentValue) + ((1 - a1) * prevAlpha1);
                    alpha1List.Add(alpha1);

                    decimal prevAlpha2 = i >= 1 ? alpha2List.ElementAtOrDefault(i - 1) : currentValue;
                    decimal priorAlpha2 = i >= 2 ? alpha2List.ElementAtOrDefault(i - 2) : currentValue;
                    decimal alpha2 = (b2 * prevAlpha2) - (a2 * a2 * priorAlpha2) + ((1 - b2 + (a2 * a2)) * currentValue);
                    alpha2List.Add(alpha2);

                    decimal prevAlpha3 = i >= 1 ? alpha3List.ElementAtOrDefault(i - 1) : currentValue;
                    decimal prevAlpha3_2 = i >= 2 ? alpha3List.ElementAtOrDefault(i - 2) : currentValue;
                    decimal prevAlpha3_3 = i >= 3 ? alpha3List.ElementAtOrDefault(i - 3) : currentValue;
                    decimal alpha3 = ((b3 + c) * prevAlpha3) - ((c + (b3 * c)) * prevAlpha3_2) + (c * c * prevAlpha3_3) + ((1 - b3 + c) * (1 - c) * currentValue);
                    alpha3List.Add(alpha3);

                    decimal detrend1 = currentValue - alpha1;
                    detrend1List.Add(detrend1);

                    decimal detrend2 = currentValue - alpha2;
                    detrend2List.Add(detrend2);

                    decimal detrend3 = currentValue - alpha3;
                    detrend3List.Add(detrend3);

                    decimal prevBeta1 = i >= 1 ? beta1List.ElementAtOrDefault(i - 1) : 0;
                    decimal beta1 = (a1 * detrend1) + ((1 - a1) * prevBeta1);
                    beta1List.Add(beta1);

                    decimal prevBeta2 = i >= 1 ? beta2List.ElementAtOrDefault(i - 1) : 0;
                    decimal prevBeta2_2 = i >= 2 ? beta2List.ElementAtOrDefault(i - 2) : 0;
                    decimal beta2 = (b2 * prevBeta2) - (a2 * a2 * prevBeta2_2) + ((1 - b2 + (a2 * a2)) * detrend2);
                    beta2List.Add(beta2);

                    decimal prevBeta3_2 = i >= 2 ? beta3List.ElementAtOrDefault(i - 2) : 0;
                    decimal prevBeta3_3 = i >= 3 ? beta3List.ElementAtOrDefault(i - 3) : 0;
                    decimal beta3 = ((b3 + c) * prevBeta3_2) - ((c + (b3 * c)) * prevBeta3_2) + (c * c * prevBeta3_3) + ((1 - b3 + c) * (1 - c) * detrend3);
                    beta3List.Add(beta3);

                    decimal mda1 = alpha1 + ((decimal)1 / 1 * beta1);
                    mda1List.Add(mda1);

                    decimal prevMda2 = mda2List.LastOrDefault();
                    decimal mda2 = alpha2 + ((decimal)1 / 2 * beta2);
                    mda2List.Add(mda2);

                    decimal mda3 = alpha3 + ((decimal)1 / 3 * beta3);
                    mda3List.Add(mda3);

                    var signal = GetCompareSignal(currentValue - mda2, prevValue - prevMda2);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (alpha1List, alpha2List, alpha3List, detrend1List, detrend2List, detrend3List, beta1List, beta2List, beta3List, mda1List, mda2List, mda3List, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateSimpleLines(StockData stockDataClass, int days = 10)
        {
            //@version=2
            //study("Simple Lines", overlay = true)
            //length = input(10),emphasis = input(1),mult = input(10),point = input(false),paint = input(false, title = "Color Based On Direction")
            //
            //x = close + change(nz(a[0], close), emphasis) * mult
            //s = point ? syminfo.pointvalue * 10 * (1 / length) : syminfo.mintick * 100 * (1 / length)
            //a = x > nz(a[0], x) + s ? nz(a[0], x) + s : x < nz(a[0], x) - s ? nz(a[0], x) - s : nz(a[0], x)
            //
            //css = paint ? (a > a[1] ? #0080FF : #FE2E64) : #FE2E64
            //plot(a, color = css, linewidth = 2, transp = 0)
            List<decimal> xList = new();
            List<decimal> aList = new();
            List<Signal> signalsList = new();
            decimal mult = 10;

            try
            {
                decimal s = 0.01m * 100 * ((decimal)1.0m / days);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevA = i >= 1 ? aList.ElementAtOrDefault(i - 1) : currentValue;
                    decimal prevA2 = i >= 2 ? aList.ElementAtOrDefault(i - 2) : currentValue;

                    decimal x = currentValue + ((prevA - prevA2) * mult);
                    xList.Add(x);

                    prevA = i >= 1 ? aList.ElementAtOrDefault(i - 1) : x;
                    decimal a = x > prevA + s ? prevA + s : x < prevA - s ? prevA - s : prevA;
                    aList.Add(a);

                    var signal = GetCompareSignal(a - prevA, prevA - prevA2);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (xList, aList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateFlaggingBands(StockData stockDataClass, int days = 14)
        {
            //@version=2
            //study("Flagging Bands", overlay = true)
            //length = input(14, maxval = 100),Ts = input(false, title = "Trailing Stop Mod")
            //
            //l = 1 / length * stdev(close, length)
            //a = close > nz(a[0], close) ? nz(a[0], close) + (close - nz(a[0], close)) : nz(a[1], close) == nz(a[2], close) ? nz(a[1], close) - l : nz(a[1], close)
            //b = close < nz(b[0], close) ? nz(b[0], close) + (close - nz(b[0], close)) : nz(b[1], close) == nz(b[2], close) ? nz(b[1], close) + l : nz(b[1], close)
            //avg = avg(a, b)
            //
            //tos = close > a[1] ? 1 : close < b[1] ? 0 : tos[1]
            //tavg = tos == 1 ? avg(a, avg) : avg(b, avg)
            //ts = Ts ? tos * b + (1 - tos) * a : na
            //css = Ts ? na : #0080FF
            //cas = Ts ? na : orange
            //cts = tos == 1 ?#0080FF:orange
            //
            //A = plot(a, color = css, title = "Upper Band", transp = 0)
            //plot(tavg, color = cas, title = "Average", transp = 0)
            //B = plot(b, color = css, title = "Lower Band", transp = 0)
            //plot(ts, color = cts, title = "Trailing Stop", transp = 0)
            List<decimal> aList = new();
            List<decimal> bList = new();
            List<decimal> lList = new();
            List<decimal> avgList = new();
            List<decimal> tavgList = new();
            List<decimal> tsList = new();
            List<decimal> tosList = new();
            List<Signal> signalsList = new();

            try
            {
                var stdDevList = CalculateStandardDeviationVolatility(null, stockDataClass, days).Item4;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal stdDev = stdDevList.ElementAtOrDefault(i);
                    decimal prevA1 = i >= 1 ? aList.ElementAtOrDefault(i - 1) : currentValue;
                    decimal prevB1 = i >= 1 ? bList.ElementAtOrDefault(i - 1) : currentValue;
                    decimal prevA2 = i >= 2 ? aList.ElementAtOrDefault(i - 2) : currentValue;
                    decimal prevB2 = i >= 2 ? bList.ElementAtOrDefault(i - 2) : currentValue;
                    decimal prevA3 = i >= 3 ? aList.ElementAtOrDefault(i - 3) : currentValue;
                    decimal prevB3 = i >= 3 ? bList.ElementAtOrDefault(i - 3) : currentValue;
                    decimal prevTos = tosList.LastOrDefault();

                    decimal l = ((decimal)1 / days) * stdDev;
                    lList.Add(l);

                    decimal a = currentValue > prevA1 ? prevA1 + (currentValue - prevA1) : prevA2 == prevA3 ? prevA2 - 1 : prevA2;
                    aList.Add(a);

                    decimal b = currentValue < prevB1 ? prevB1 + (currentValue - prevB1) : prevB2 == prevB3 ? prevB2 + 1 : prevB2;
                    bList.Add(b);

                    decimal avg = (a + b) / 2;
                    avgList.Add(avg);

                    decimal tos = currentValue > prevA2 ? 1 : currentValue < prevB2 ? 0 : prevTos;
                    tosList.Add(tos);

                    decimal prevTavg = tavgList.LastOrDefault();
                    decimal tavg = tos == 1 ? (a + avg) / 2 : (b + avg) / 2;
                    tavgList.Add(tavg);

                    decimal ts = (tos * b) + ((1 - tos) * a);
                    tsList.Add(ts);

                    var signal = GetCompareSignal(currentValue - tavg, prevValue - prevTavg);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (lList, aList, bList, avgList, tosList, tavgList, tsList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateSurfaceRoughnessEstimator(StockData stockDataClass, int days = 50)
        {
            //@version=3
            //study("Surface Roughness Estimator")
            //length = input(100)
            //
            //y(x) =>
            //    a = 1 - (correlation(x, x[1], length) + 1) / 2
            //
            //A = y(close)
            //plot(A, color = orange, transp = 0)
            List<decimal> aList = new();
            List<decimal> corrList = new();
            List<decimal> tempList = new();
            List<decimal> prevList = new();
            List<decimal> aEmaList = new();
            List<Signal> signalsList = new();

            try
            {
                int signalPeriod = days;
                int length = days * 2;

                var emaList = CalculateExponentialMovingAverage(stockDataClass, length).Item1;

                for (int h = 0; h < stockDataClass.InputValues.Count; h++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(h);
                    tempList.Add(currentValue);

                    decimal prevValue = h >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(h - 1) : 0;
                    prevList.Add(prevValue);

                    var corr = GoodnessOfFit.R(prevList.TakeLast(length).Select(x => (double)x), tempList.TakeLast(length).Select(x => (double)x));
                    corr = IsValueNullOrInfinity(corr) ? 0 : corr;
                    corrList.Add((decimal)corr);
                }

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal corr = corrList.ElementAtOrDefault(i);
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal ema = emaList.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevEma = i >= 1 ? emaList.ElementAtOrDefault(i - 1) : 0;

                    decimal a = 1 - ((corr + 1) / 2);
                    aList.Add(a);

                    decimal aEma = CalculateExponentialMovingAverage(a, aEmaList.LastOrDefault(), signalPeriod);
                    aEmaList.Add(aEma);

                    var signal = GetVolatilitySignal(currentValue - ema, prevValue - prevEma, a, aEma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (corrList, aList, aEmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateGeneralFilterEstimator(StockData stockDataClass, int days = 100)
        {
            //@version=2
            //study("General Filter Estimator", overlay = true)
            //length = input(100),beta = input(5.25),gamma = input(1, maxval = 1),zeta = input(1, maxval = 1)
            ////////////////////////////////////////////////////////////////
            //Coefficients Table :
            //
            //MA : beta = 2/gamma = 0.5
            //EMA : beta = 3/gamma = 0.4
            //HMA = beta = 4/gamma = 0.85
            //LSMA : beta = 3.5/gamma = 0.9 
            //QLSMA : beta = 5.25/gamma = 1
            //JMA : beta = pow*2/gamma = 0.5
            //3 Poles Butterworth Filter : beta = 5.5/gamma = 0.5/zeta = 0
            //
            ////////////////////////////////////////////////////////////////
            //p = length / beta
            //a = close - nz(b[p], close)
            //b = nz(b[1], close) + a / p * gamma
            //c = b - nz(d[p], b)
            //d = nz(d[1], close) + (zeta * a + (1 - zeta) * c) / p * gamma
            //
            //plot(d, color =#FF0040,transp=0)
            List<decimal> aMList = new();
            List<decimal> bMList = new();
            List<decimal> cMList = new();
            List<decimal> dMList = new();
            List<decimal> aEList = new();
            List<decimal> bEList = new();
            List<decimal> cEList = new();
            List<decimal> dEList = new();
            List<decimal> aHList = new();
            List<decimal> bHList = new();
            List<decimal> cHList = new();
            List<decimal> dHList = new();
            List<decimal> aLList = new();
            List<decimal> bLList = new();
            List<decimal> cLList = new();
            List<decimal> dLList = new();
            List<decimal> aQList = new();
            List<decimal> bQList = new();
            List<decimal> cQList = new();
            List<decimal> dQList = new();
            List<decimal> aJList = new();
            List<decimal> bJList = new();
            List<decimal> cJList = new();
            List<decimal> dJList = new();
            List<decimal> aBList = new();
            List<decimal> bBList = new();
            List<decimal> cBList = new();
            List<decimal> dBList = new();
            List<Signal> signalsList = new();
            decimal betaM = 2, gammaM = 0.5m, zetaM = 1, betaE = 3, gammaE = 0.4m, zetaE = 1, betaH = 4, gammaH = 0.85m, zetaH = 1, betaL = 3.5m, gammaL = 0.9m, zetaL = 1,
                    betaQ = 5.25m, gammaQ = 1, zetaQ = 1, betaJ = 10, gammaJ = 0.5m, zetaJ = 1, betaB = 5.5m, gammaB = 0.5m, zetaB = 0;

            try
            {
                int pM = MinOrMax((int)Math.Ceiling(days / betaM));
                int pE = MinOrMax((int)Math.Ceiling(days / betaE));
                int pH = MinOrMax((int)Math.Ceiling(days / betaH));
                int pL = MinOrMax((int)Math.Ceiling(days / betaL));
                int pQ = MinOrMax((int)Math.Ceiling(days / betaQ));
                int pJ = MinOrMax((int)Math.Ceiling(days / betaJ));
                int pB = MinOrMax((int)Math.Ceiling(days / betaB));

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevBM = i >= pM ? bMList.ElementAtOrDefault(i - pM) : currentValue;
                    decimal prevBE = i >= pE ? bEList.ElementAtOrDefault(i - pE) : currentValue;
                    decimal prevBH = i >= pH ? bHList.ElementAtOrDefault(i - pH) : currentValue;
                    decimal prevBL = i >= pL ? bLList.ElementAtOrDefault(i - pL) : currentValue;
                    decimal prevBQ = i >= pQ ? bQList.ElementAtOrDefault(i - pQ) : currentValue;
                    decimal prevBJ = i >= pJ ? bJList.ElementAtOrDefault(i - pJ) : currentValue;
                    decimal prevBB = i >= pB ? bBList.ElementAtOrDefault(i - pB) : currentValue;

                    decimal aM = currentValue - prevBM;
                    aMList.Add(aM);

                    decimal aE = currentValue - prevBE;
                    aEList.Add(aE);

                    decimal aH = currentValue - prevBH;
                    aHList.Add(aH);

                    decimal aL = currentValue - prevBL;
                    aLList.Add(aL);

                    decimal aQ = currentValue - prevBQ;
                    aQList.Add(aQ);

                    decimal aJ = currentValue - prevBJ;
                    aJList.Add(aJ);

                    decimal aB = currentValue - prevBB;
                    aBList.Add(aB);

                    decimal prevBM1 = i >= 1 ? bMList.ElementAtOrDefault(i - 1) : currentValue;
                    decimal bM = prevBM1 + (aM / pM * gammaM);
                    bMList.Add(bM);

                    decimal prevBE1 = i >= 1 ? bEList.ElementAtOrDefault(i - 1) : currentValue;
                    decimal bE = prevBE1 + (aE / pE * gammaE);
                    bEList.Add(bE);

                    decimal prevBH1 = i >= 1 ? bHList.ElementAtOrDefault(i - 1) : currentValue;
                    decimal bH = prevBH1 + (aH / pH * gammaH);
                    bHList.Add(bH);

                    decimal prevBL1 = i >= 1 ? bLList.ElementAtOrDefault(i - 1) : currentValue;
                    decimal bL = prevBL1 + (aL / pL * gammaL);
                    bLList.Add(bL);

                    decimal prevBQ1 = i >= 1 ? bQList.ElementAtOrDefault(i - 1) : currentValue;
                    decimal bQ = prevBQ1 + (aQ / pQ * gammaQ);
                    bQList.Add(bQ);

                    decimal prevBJ1 = i >= 1 ? bJList.ElementAtOrDefault(i - 1) : currentValue;
                    decimal bJ = prevBJ1 + (aJ / pJ * gammaJ);
                    bJList.Add(bJ);

                    decimal prevBB1 = i >= 1 ? bBList.ElementAtOrDefault(i - 1) : currentValue;
                    decimal bB = prevBB1 + (aB / pB * gammaB);
                    bBList.Add(bB);

                    decimal prevDM = i >= pM ? dMList.ElementAtOrDefault(i - pM) : bM;
                    decimal cM = bM - prevDM;
                    cMList.Add(cM);

                    decimal prevDE = i >= pE ? dEList.ElementAtOrDefault(i - pE) : bE;
                    decimal cE = bE - prevDE;
                    cEList.Add(cE);

                    decimal prevDH = i >= pH ? dHList.ElementAtOrDefault(i - pH) : bH;
                    decimal cH = bH - prevDH;
                    cHList.Add(cH);

                    decimal prevDL = i >= pL ? dLList.ElementAtOrDefault(i - pL) : bL;
                    decimal cL = bL - prevDL;
                    cLList.Add(cL);

                    decimal prevDQ = i >= pQ ? dQList.ElementAtOrDefault(i - pQ) : bQ;
                    decimal cQ = bQ - prevDQ;
                    cQList.Add(cQ);

                    decimal prevDJ = i >= pJ ? dJList.ElementAtOrDefault(i - pJ) : bJ;
                    decimal cJ = bJ - prevDJ;
                    cJList.Add(cJ);

                    decimal prevDB = i >= pB ? dBList.ElementAtOrDefault(i - pB) : bB;
                    decimal cB = bB - prevDB;
                    cBList.Add(cB);

                    decimal prevDM1 = i >= 1 ? dMList.ElementAtOrDefault(i - 1) : currentValue;
                    decimal dM = prevDM1 + (((zetaM * aM) + ((1 - zetaM) * cM)) / pM * gammaM);
                    dMList.Add(dM);

                    decimal prevDE1 = i >= 1 ? dEList.ElementAtOrDefault(i - 1) : currentValue;
                    decimal dE = prevDE1 + (((zetaE * aE) + ((1 - zetaE) * cE)) / pE * gammaE);
                    dEList.Add(dE);

                    decimal prevDH1 = i >= 1 ? dHList.ElementAtOrDefault(i - 1) : currentValue;
                    decimal dH = prevDH1 + (((zetaH * aH) + ((1 - zetaH) * cH)) / pH * gammaH);
                    dHList.Add(dH);

                    decimal prevDL1 = i >= 1 ? dLList.ElementAtOrDefault(i - 1) : currentValue;
                    decimal dL = prevDL1 + (((zetaL * aL) + ((1 - zetaL) * cL)) / pL * gammaL);
                    dLList.Add(dL);

                    decimal prevDQ1 = i >= 1 ? dQList.ElementAtOrDefault(i - 1) : currentValue;
                    decimal dQ = prevDQ1 + (((zetaQ * aQ) + ((1 - zetaQ) * cQ)) / pQ * gammaQ);
                    dQList.Add(dQ);

                    decimal prevDJ1 = i >= 1 ? dJList.ElementAtOrDefault(i - 1) : currentValue;
                    decimal dJ = prevDJ1 + (((zetaJ * aJ) + ((1 - zetaJ) * cJ)) / pJ * gammaJ);
                    dJList.Add(dJ);

                    decimal prevDB1 = i >= 1 ? dBList.ElementAtOrDefault(i - 1) : currentValue;
                    decimal dB = prevDB1 + (((zetaB * aB) + ((1 - zetaB) * cB)) / pB * gammaB);
                    dBList.Add(dB);

                    var signal = GetCompareSignal(currentValue - dQ, prevValue - prevDQ1);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (aMList, aEList, aHList, aLList, aQList, aJList, aBList, bMList, bEList, bHList, bLList, bQList, bJList, bBList, cMList, cEList, cHList, cLList, cQList, cJList,
                cBList, dMList, dEList, dHList, dLList, dQList, dJList, dBList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateMotionToAttractionTrailingStop(StockData stockDataClass, int days = 14)
        {
            //@version=3
            //study("MTA-Traling Stop", overlay = true)
            //length = input(14)
            //----
            //A = 0.
            //B = 0.
            //a = 0.
            //b = 0.
            //c = 0.
            //d = 0.
            //os = 0
            //----
            //alpha = 1 / length
            //a:= close > nz(A[1], close) ? close : nz(a[1], close)
            //b:= close < nz(B[1], close) ? close : nz(b[1], close)
            //c:= change(b) ? nz(c[1]) + alpha : change(a) ? 0 : nz(c[1])
            //d:= change(a) ? nz(d[1]) + alpha : change(b) ? 0 : nz(d[1])
            //----
            //avg = avg(a, b)
            //A:= c * avg + (1 - c) * a
            //B:= d * avg + (1 - d) * b
            //os:= close > A[1] ? 1 : close < B[1] ? 0 : os[1]
            //ts = os * B + (1 - os) * A
            //-----
            //plot(ts, color = os == 1 ?#2E64FE:#FF0040,linewidth=2,transp=0)
            List<decimal> osList = new();
            List<decimal> tsList = new();
            List<Signal> signalsList = new();

            try
            {
                var mtaList = CalculateMotionToAttractionChannels(stockDataClass, days);
                var aList = mtaList.Item6;
                var bList = mtaList.Item7;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevA = i >= 1 ? aList.ElementAtOrDefault(i - 1) : currentValue;
                    decimal prevB = i >= 1 ? bList.ElementAtOrDefault(i - 1) : currentValue;
                    decimal a = aList.ElementAtOrDefault(i);
                    decimal b = bList.ElementAtOrDefault(i);

                    decimal prevOs = osList.LastOrDefault();
                    decimal os = currentValue > prevA ? 1 : currentValue < prevB ? 0 : prevOs;
                    osList.Add(os);

                    decimal prevTs = tsList.LastOrDefault();
                    decimal ts = (os * b) + ((1 - os) * a);
                    tsList.Add(ts);

                    var signal = GetCompareSignal(currentValue - ts, prevValue - prevTs);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (osList, tsList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>)
            CalculateMotionToAttractionChannels(StockData stockDataClass, int days = 14)
        {
            //@version=2
            //study("Motion To Attraction Channels", shorttitle = "MTA-Channels", overlay = true)
            //length = input(14)
            //
            //alpha = 1 / length
            //a = close > nz(A[1], close) ? close : nz(a[1], close)
            //b = close < nz(B[1], close) ? close : nz(b[1], close)
            //c = change(b) ? nz(c[1]) + alpha : change(a) ? 0 : nz(c[1])
            //d = change(a) ? nz(d[1]) + alpha : change(b) ? 0 : nz(d[1])
            //
            //avg = avg(a, b)
            //A = c * avg + (1 - c) * a
            //B = d * avg + (1 - d) * b
            //
            //plot(A, color =#0080FF,transp=0),plot(B,color=#FF0040,transp=0)
            List<decimal> aList = new();
            List<decimal> bList = new();
            List<decimal> cList = new();
            List<decimal> dList = new();
            List<decimal> avgList = new();
            List<decimal> aMaList = new();
            List<decimal> bMaList = new();
            List<decimal> avgMaList = new();
            List<Signal> signalsList = new();

            try
            {
                decimal alpha = (decimal)1 / days;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevAMa = i >= 1 ? aMaList.ElementAtOrDefault(i - 1) : currentValue;
                    decimal prevBMa = i >= 1 ? bMaList.ElementAtOrDefault(i - 1) : currentValue;

                    decimal prevA = i >= 1 ? aList.ElementAtOrDefault(i - 1) : currentValue;
                    decimal a = currentValue > prevAMa ? currentValue : prevA;
                    aList.Add(a);

                    decimal prevB = i >= 1 ? bList.ElementAtOrDefault(i - 1) : currentValue;
                    decimal b = currentValue < prevBMa ? currentValue : prevB;
                    bList.Add(b);

                    decimal prevC = cList.LastOrDefault();
                    decimal c = b - prevB != 0 ? prevC + alpha : a - prevA != 0 ? 0 : prevC;
                    cList.Add(c);

                    decimal prevD = dList.LastOrDefault();
                    decimal d = a - prevA != 0 ? prevD + alpha : b - prevB != 0 ? 0 : prevD;
                    dList.Add(d);

                    decimal avg = (a + b) / 2;
                    avgList.Add(avg);

                    decimal aMa = (c * avg) + ((1 - c) * a);
                    aMaList.Add(aMa);

                    decimal bMa = (d * avg) + ((1 - d) * b);
                    bMaList.Add(bMa);

                    decimal prevAvgMa = avgMaList.LastOrDefault();
                    decimal avgMa = (aMa + bMa) / 2;
                    avgMaList.Add(avgMa);

                    var signal = GetCompareSignal(currentValue - avgMa, prevValue - prevAvgMa);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (aList, bList, cList, dList, avgList, aMaList, bMaList, avgMaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<Signal>) CalculateRobustWeightingOscillator(StockData stockDataClass, string maType, int days = 200)
        {
            //@version=2
            //study("Robust Weighting Oscillator", overlay = false)
            //length = input(200),smooth = input(true, title = "Smoother Oscillator")
            //
            //y = close
            //x = n
            //
            //a = correlation(y, n, length) * (stdev(y, length) / stdev(x, length))
            //b = sma(y, length) - a * sma(n, length)
            //Y = a * x + b
            //
            //g = abs(abs(y - Y) / percentile_linear_interpolation(abs(y - Y), length, 50))
            //Ga = g < 1 ? pow(1 - pow(abs(y - Y) / percentile_linear_interpolation(abs(y - Y), length, 50), 2), 2) : 0
            //Gb = smooth ? 1 : Ga
            //L = sma(Gb * (y - a - b * y), length)
            //
            //css = L > L[1] ? #00b600 : #434651
            //plot(L, title = "Oscillator", color = css, linewidth = 2, transp = 0)
            List<decimal> indexList = new();
            List<decimal> tempList = new();
            List<decimal> corrList = new();
            List<decimal> aList = new();
            List<decimal> bList = new();
            List<decimal> yList = new();
            List<decimal> gList = new();
            List<decimal> gaList = new();
            List<decimal> lList = new();
            List<decimal> lgaList = new();
            List<decimal> absYyList = new();
            List<decimal> absYyMedList = new();
            List<decimal> lSmaList = new();
            List<decimal> lgaSmaList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int h = 0; h < stockDataClass.InputValues.Count; h++)
                {
                    decimal index = h;
                    indexList.Add(index);

                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(h);
                    tempList.Add(currentValue);

                    var corr = GoodnessOfFit.R(indexList.TakeLast(days).Select(x => (double)x), tempList.TakeLast(days).Select(x => (double)x));
                    corr = IsValueNullOrInfinity(corr) ? 0 : corr;
                    corrList.Add((decimal)corr);
                }

                var smaList = GetMovingAverageList(maType, null, stockDataClass, days);
                var indexSmaList = GetMovingAverageList(maType, indexList, stockDataClass, days);
                var stdDevList = CalculateStandardDeviationVolatility(null, stockDataClass, days).Item4;
                var indexStdDevList = CalculateStandardDeviationVolatility(indexList, stockDataClass, days).Item4;
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal corr = corrList.ElementAtOrDefault(i);
                    decimal stdDev = stdDevList.ElementAtOrDefault(i);
                    decimal indexStdDev = indexStdDevList.ElementAtOrDefault(i);
                    decimal sma = smaList.ElementAtOrDefault(i);
                    decimal indexSma = indexSmaList.ElementAtOrDefault(i);

                    decimal a = indexStdDev != 0 ? corr * (stdDev / indexStdDev) : 0;
                    aList.Add(a);

                    decimal b = sma - (a * indexSma);
                    bList.Add(b);

                    decimal y = (a * i) + b;
                    yList.Add(y);

                    decimal absYy = Math.Abs(currentValue - y);
                    absYyList.Add(absYy);

                    decimal absYyMed = Median(absYyList.TakeLast(days));
                    absYyMedList.Add(absYyMed);

                    decimal g = absYyMed != 0 ? Math.Abs(absYy / absYyMed) : 0;
                    gList.Add(g);

                    decimal ga = g < 1 && absYyMed != 0 ? Pow(1 - Pow(absYy / absYyMed, 2), 2) : 0;
                    gaList.Add(ga);

                    decimal l = currentValue - a - (b * currentValue);
                    lList.Add(l);

                    decimal lga = ga * l;
                    lgaList.Add(lga);
                }

                lSmaList = GetMovingAverageList(maType, lList, stockDataClass, days);
                lgaSmaList = GetMovingAverageList(maType, lgaList, stockDataClass, days);
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal l = lSmaList.ElementAtOrDefault(j);
                    decimal prevL1 = j >= 1 ? lSmaList.ElementAtOrDefault(j - 1) : 0;
                    decimal prevL2 = j >= 2 ? lSmaList.ElementAtOrDefault(j - 2) : 0;

                    var signal = GetCompareSignal(l - prevL1, prevL1 - prevL2);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (absYyList, absYyMedList, gList, gaList, lList, lgaList, lSmaList, lgaSmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateZeroLagExponentialMovingAverage(StockData stockDataClass, string maType, int days = 14)
        {
            //calc_zlema(src, length) =>
            //    ema1 = ema(src, length)
            //    ema2 = ema(ema1, length)
            //    d = ema1 - ema2
            //    zema = ema1 + d
            List<decimal> zemaList = new();
            List<decimal> dList = new();
            List<Signal> signalsList = new();

            try
            {
                var ema1List = GetMovingAverageList(maType, null, stockDataClass, days);
                var ema2List = GetMovingAverageList(maType, ema1List, stockDataClass, days);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal ema1 = ema1List.ElementAtOrDefault(i);
                    decimal ema2 = ema2List.ElementAtOrDefault(i);

                    decimal d = ema1 - ema2;
                    dList.Add(d);

                    decimal prevZema = zemaList.LastOrDefault();
                    decimal zema = ema1 + d;
                    zemaList.Add(zema);

                    var signal = GetCompareSignal(currentValue - zema, prevValue - prevZema);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (dList, zemaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateZeroLowLagMovingAverage(StockData stockDataClass, int days = 50)
        {
            // This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
            // © alexgrover

            //@version=4
            //study("ZLMA", overlay = true)
            //length = input(50),lag = input(1.4, minval = 1, maxval = 2, step = .1),src = input(close)
            //----
            //a = 0.,b = 0.
            //a := nz(lag * src + (1 - lag) * b[length / 2] + a[1], src)
            //b:= change(a, length) / length
            //----
            //plot(b, "Plot",#ff1100,2)
            List<decimal> aList = new();
            List<decimal> aDiffList = new();
            List<decimal> bList = new();
            List<Signal> signalsList = new();
            decimal lag = 1.4m;

            try
            {
                int lbPeriod = MinOrMax((int)Math.Ceiling((decimal)days / 2));

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal priorB = i >= lbPeriod ? bList.ElementAtOrDefault(i - lbPeriod) : currentValue;
                    decimal priorA = i >= days ? aList.ElementAtOrDefault(i - days) : 0;

                    decimal prevA = aList.LastOrDefault();
                    decimal a = (lag * currentValue) + ((1 - lag) * priorB) + prevA;
                    aList.Add(a);

                    decimal aDiff = a - priorA;
                    aDiffList.Add(aDiff);

                    decimal prevB = bList.LastOrDefault();
                    decimal b = aDiff / days;
                    bList.Add(b);

                    var signal = GetCompareSignal(currentValue - b, prevValue - prevB);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (aList, aDiffList, bList, signalsList);
        }

        public static (List<decimal>, List<Signal>) CalculateRegularizedExponentialMovingAverage(StockData stockDataClass, int days = 14)
        {
            //@version=3
            // Copyright (c) 2018-present, Alex Orekhov (everget)
            // Regularized Exponential Moving Average script may be freely distributed under the MIT license.
            //study("Regularized Exponential Moving Average", shorttitle = "REMA", overlay = true)

            //length = input(title = "Length", type = integer, defval = 14)
            //lambda = input(title = "Regularization Constant", type = float, minval = 0, defval = 0.5)
            //highlightMovements = input(title = "Highlight Movements ?", type = bool, defval = true)
            //src = input(title = "Source", type = source, defval = close)

            //alpha = 2 / (length + 1)

            //rema = 0.0
            //rema:= (nz(rema[1]) + alpha * (src - nz(rema[1])) + lambda * (2 * nz(rema[1]) - nz(rema[2]))) / (lambda + 1)

            //remaColor = highlightMovements ? (rema > rema[1] ? green : red) : #6d1e7f
            //plot(rema, title = "REMA", linewidth = 2, color = remaColor, transp = 0)
            List<decimal> remaList = new();
            List<Signal> signalsList = new();
            decimal lambda = 0.5m;

            try
            {
                decimal alpha = (decimal)2 / (days + 1);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevRema1 = i >= 1 ? remaList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevRema2 = i >= 2 ? remaList.ElementAtOrDefault(i - 2) : 0;

                    decimal rema = (prevRema1 + (alpha * (currentValue - prevRema1)) + (lambda * ((2 * prevRema1) - prevRema2))) / (lambda + 1);
                    remaList.Add(rema);

                    var signal = GetCompareSignal(currentValue - rema, prevValue - prevRema1);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (remaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateAdaptiveStochastic(StockData stockDataClass, int days = 50)
        {
            //@version=2
            //study("Adaptive Stochastic")
            //length = input(50),fast = input(50),slow = input(200)
            //
            //src = linreg(close, abs(slow - fast), 0)
            //sc = abs(change(close, length)) / sum(abs(change(close)), length)
            //a = sc * highest(src, fast) + (1 - sc) * highest(src, slow)
            //b = sc * lowest(src, fast) + (1 - sc) * lowest(src, slow)
            //stc = (src - b) / (a - b)
            //
            //plot(stc, color =#58FAD0,transp=0)
            List<decimal> highest1List = new();
            List<decimal> lowest1List = new();
            List<decimal> aList = new();
            List<decimal> bList = new();
            List<decimal> stcList = new();
            List<Signal> signalsList = new();

            try
            {
                int slowLength = days * 4;

                var srcList = CalculateLinearRegression(null, stockDataClass, Math.Abs(slowLength - days)).Item15;
                var erList = CalculateKaufmanAdaptiveMovingAverage(stockDataClass, days).Item3;
                var minMax1List = GetMaxAndMinValuesList(srcList, days);
                highest1List = minMax1List.Item1;
                lowest1List = minMax1List.Item2;
                var minMax2List = GetMaxAndMinValuesList(srcList, slowLength);
                var highest2List = minMax2List.Item1;
                var lowest2List = minMax2List.Item2;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal er = erList.ElementAtOrDefault(i);
                    decimal src = srcList.ElementAtOrDefault(i);
                    decimal highest1 = highest1List.ElementAtOrDefault(i);
                    decimal lowest1 = lowest1List.ElementAtOrDefault(i);
                    decimal highest2 = highest2List.ElementAtOrDefault(i);
                    decimal lowest2 = lowest2List.ElementAtOrDefault(i);
                    decimal prevStc1 = i >= 1 ? stcList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevStc2 = i >= 2 ? stcList.ElementAtOrDefault(i - 2) : 0;

                    decimal a = (er * highest1) + ((1 - er) * highest2);
                    aList.Add(a);

                    decimal b = (er * lowest1) + ((1 - er) * lowest2);
                    bList.Add(b);

                    decimal stc = a - b != 0 ? MinOrMax((src - b) / (a - b), 1, 0) : 0;
                    stcList.Add(stc);

                    var signal = GetRsiSignal(stc - prevStc1, prevStc1 - prevStc2, stc, prevStc1, 0.8m, 0.2m);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (highest1List, lowest1List, aList, bList, stcList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateEfficientPrice(StockData stockDataClass, int days = 25)
        {
            //@version=2
            //study("Efficient Price")
            //length = input(50)
            //
            //src = input(close)
            //er = abs(change(src, length)) / sum(abs(change(src)), length)
            //ep = cum(change(close) * er)
            //
            //plot(ep, color =#FE2E9A)
            List<decimal> epList = new();
            List<decimal> chgErList = new();
            List<decimal> epEmaList = new();
            List<Signal> signalsList = new();

            try
            {
                int signalPeriod = days;
                int length = days * 2;

                var erList = CalculateKaufmanAdaptiveMovingAverage(stockDataClass, length).Item3;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal er = erList.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal chgEr = (currentValue - prevValue) * er;
                    chgErList.Add(chgEr);

                    decimal ep = chgErList.Sum();
                    epList.Add(ep);

                    decimal prevEpEma = epEmaList.LastOrDefault();
                    decimal epEma = CalculateExponentialMovingAverage(ep, epEmaList.LastOrDefault(), signalPeriod);
                    epEmaList.Add(epEma);

                    var signal = GetCompareSignal(currentValue - epEma, prevValue - prevEpEma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (chgErList, epList, epEmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateRecursiveStochastic(StockData stockDataClass, int days = 200)
        {
            //@version=2
            //study("Recursive Stochastic")
            //length = input(200),alpha = input(0.1, minval = 0, maxval = 1)
            //
            //src = input(close)
            //s(x) =>
            //    s = stoch(x, x, x, length)
            //st = s(src)
            //k = s(alpha * st + (1 - alpha) * nz(k[1]))
            //
            //plot(k, color = orange, transp = 0)
            List<decimal> kList = new();
            List<decimal> maList = new();
            List<decimal> highestMaList = new();
            List<decimal> lowestMaList = new();
            List<Signal> signalsList = new();
            decimal alpha = 0.1m;

            try
            {
                var highLowList = VolumeInputCheck(stockDataClass, days, true);
                var highestList = highLowList.Item1;
                var lowestList = highLowList.Item2;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal highest = highestList.ElementAtOrDefault(i);
                    decimal lowest = lowestList.ElementAtOrDefault(i);
                    decimal stoch = highest - lowest != 0 ? (currentValue - lowest) / (highest - lowest) * 100 : 0;
                    decimal prevK1 = i >= 1 ? kList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevK2 = i >= 2 ? kList.ElementAtOrDefault(i - 2) : 0;

                    decimal ma = (alpha * stoch) + ((1 - alpha) * prevK1);
                    maList.Add(ma);

                    var lbList = maList.TakeLast(days).ToList();
                    decimal highestMa = lbList.Max();
                    highestMaList.Add(highestMa);

                    decimal lowestMa = lbList.Min();
                    lowestMaList.Add(lowestMa);

                    decimal k = highestMa - lowestMa != 0 ? MinOrMax((ma - lowestMa) / (highestMa - lowestMa) * 100, 100, 0) : 0;
                    kList.Add(k);

                    var signal = GetRsiSignal(k - prevK1, prevK1 - prevK2, k, prevK1, 80, 20);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (maList, highestMaList, lowestMaList, kList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>)
            CalculateRetentionAccelerationFilter(StockData stockDataClass, int days = 50)
        {
            //@version=2
            //study("Retention-Acceleration Filter", overlay = true)
            //length = input(50)
            //
            //AR = 2 * (highest(length) - lowest(length))
            //BR = 2 * (highest(length * 2) - lowest(length * 2))
            //k1 = (1 - AR) / AR
            //k2 = (1 - BR) / BR
            //
            //alpha = k2 / k1
            //R1 = sqrt(highest(length)) / 4 * ((alpha - 1) / alpha) * (k2 / (k2 + 1))
            //R2 = sqrt(highest(length * 2)) / 4 * (alpha - 1) * (k1 / (k1 + 1))
            //Factor = R2 / R1
            //
            //AltK = fixnan(pow(Factor >= 1 ? 1 : Factor, sqrt(length))) * (1 / length)
            //altma = AltK * close + (1 - AltK) * nz(altma[1], close)
            //
            //plot(altma, color =#2ECCFA,transp=0)
            List<decimal> arList = new();
            List<decimal> brList = new();
            List<decimal> k1List = new();
            List<decimal> k2List = new();
            List<decimal> alphaList = new();
            List<decimal> r1List = new();
            List<decimal> r2List = new();
            List<decimal> factorList = new();
            List<decimal> altkList = new();
            List<decimal> altmaList = new();
            List<Signal> signalsList = new();

            try
            {
                var minMax1List = VolumeInputCheck(stockDataClass, days, true);
                var highest1List = minMax1List.Item1;
                var lowest1List = minMax1List.Item2;
                var minMax2List = VolumeInputCheck(stockDataClass, days * 2, true);
                var highest2List = minMax2List.Item1;
                var lowest2List = minMax2List.Item2;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal highest1 = highest1List.ElementAtOrDefault(i);
                    decimal lowest1 = lowest1List.ElementAtOrDefault(i);
                    decimal highest2 = highest2List.ElementAtOrDefault(i);
                    decimal lowest2 = lowest2List.ElementAtOrDefault(i);

                    decimal ar = 2 * (highest1 - lowest1);
                    arList.Add(ar);

                    decimal br = 2 * (highest2 - lowest2);
                    brList.Add(br);

                    decimal k1 = ar != 0 ? (1 - ar) / ar : 0;
                    k1List.Add(k1);

                    decimal k2 = br != 0 ? (1 - br) / br : 0;
                    k2List.Add(k2);

                    decimal alpha = k1 != 0 ? k2 / k1 : 0;
                    alphaList.Add(alpha);

                    decimal r1 = alpha != 0 && highest1 >= 0 ? (decimal)Sqrt((double)highest1) / 4 * ((alpha - 1) / alpha) * (k2 / (k2 + 1)) : 0;
                    r1List.Add(r1);

                    decimal r2 = highest2 >= 0 ? (decimal)Sqrt((double)highest2) / 4 * (alpha - 1) * (k1 / (k1 + 1)) : 0;
                    r2List.Add(r2);

                    decimal factor = r1 != 0 ? r2 / r1 : 0;
                    factorList.Add(factor);

                    decimal altk = Pow(factor >= 1 ? 1 : factor, Math.Sqrt(days)) * ((decimal)1 / days);
                    altkList.Add(altk);

                    decimal prevAltma = i >= 1 ? altmaList.ElementAtOrDefault(i - 1) : currentValue;
                    decimal altma = (altk * currentValue) + ((1 - altk) * prevAltma);
                    altmaList.Add(altma);

                    var signal = GetCompareSignal(currentValue - altma, prevValue - prevAltma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (arList, brList, k1List, k2List, alphaList, r1List, r2List, factorList, altkList, altmaList, signalsList);
        }

        public static (List<decimal>, List<Signal>) CalculateQuadrupleExponentialMovingAverage(StockData stockDataClass, string maType, int days = 20)
        {
            //@version=3
            // Copyright (c) 2010-present, Bruno Pio
            // Copyright (c) 2019-present, Alex Orekhov (everget)
            // Quadruple Exponential Moving Average script may be freely distributed under the MIT license.
            //study("Quadruple Exponential Moving Average", shorttitle = "QEMA", overlay = true)

            //length = input(title = "Length", type = integer, defval = 20)
            //highlightMovements = input(title = "Highlight Movements ?", type = bool, defval = true)
            //src = input(title = "Source", type = source, defval = close)

            //ema1 = ema(src, length)
            //ema2 = ema(ema1, length)
            //ema3 = ema(ema2, length)
            //ema4 = ema(ema3, length)
            //ema5 = ema(ema4, length)

            //qema = 5 * ema1 - 10 * ema2 + 10 * ema3 - 5 * ema4 + ema5

            //qemaColor = highlightMovements ? (qema > qema[1] ? green : red) : #6d1e7f
            //plot(qema, title = "QEMA", linewidth = 2, color = qemaColor, transp = 0)
            List<decimal> qemaList = new();
            List<Signal> signalsList = new();

            try
            {
                List<decimal> ema1List = GetMovingAverageList(maType, null, stockDataClass, days);
                List<decimal> ema2List = GetMovingAverageList(maType, ema1List, stockDataClass, days);
                List<decimal> ema3List = GetMovingAverageList(maType, ema2List, stockDataClass, days);
                List<decimal> ema4List = GetMovingAverageList(maType, ema3List, stockDataClass, days);
                List<decimal> ema5List = GetMovingAverageList(maType, ema4List, stockDataClass, days);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal ema1 = ema1List.ElementAtOrDefault(i);
                    decimal ema2 = ema2List.ElementAtOrDefault(i);
                    decimal ema3 = ema3List.ElementAtOrDefault(i);
                    decimal ema4 = ema4List.ElementAtOrDefault(i);
                    decimal ema5 = ema5List.ElementAtOrDefault(i);

                    decimal prevQema = qemaList.LastOrDefault();
                    decimal qema = (5 * ema1) - (10 * ema2) + (10 * ema3) - (5 * ema4) + ema5;
                    qemaList.Add(qema);

                    var signal = GetCompareSignal(currentValue - qema, prevValue - prevQema);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (qemaList, signalsList);
        }

        public static (List<decimal>, List<Signal>) CalculateQuadraticMovingAverage(StockData stockDataClass, int days = 14)
        {
            //@version=3
            //study("QMA/SMA Difference", overlay = false)
            //length = input(14)
            //----
            //src = input(close)
            //a = sma(src, length)
            //b = sqrt(sma(pow(src, 2), length))
            //c = b - a
            //----
            //plot(c, title = "QMA-SMA", color =#ab47bc,transp=0)
            List<decimal> qmaList = new();
            List<decimal> powList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal pow = Pow(currentValue, 2);
                    powList.Add(pow);

                    decimal prevQma = qmaList.LastOrDefault();
                    decimal powSma = powList.TakeLast(days).Average();
                    decimal qma = powSma >= 0 ? (decimal)Sqrt((double)powSma) : 0;
                    qmaList.Add(qma);

                    var signal = GetCompareSignal(currentValue - qma, prevValue - prevQma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (qmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateQmaSmaDifference(StockData stockDataClass, int days = 7)
        {
            //@version=3
            //study("QMA/SMA Difference", overlay = false)
            //length = input(14)
            //----
            //src = input(close)
            //a = sma(src, length)
            //b = sqrt(sma(pow(src, 2), length))
            //c = b - a
            //----
            //plot(c, title = "QMA-SMA", color =#ab47bc,transp=0)
            List<decimal> cList = new();
            List<decimal> cEmaList = new();
            List<Signal> signalsList = new();

            try
            {
                int signalPeriod = days;
                int length = days * 2;

                var qmaList = CalculateQuadraticMovingAverage(stockDataClass, length).Item1;
                var smaList = CalculateSimpleMovingAverage(stockDataClass, length).Item1;
                var emaList = CalculateExponentialMovingAverage(stockDataClass, length).Item1;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal currentEma = emaList.ElementAtOrDefault(i);
                    decimal sma = smaList.ElementAtOrDefault(i);
                    decimal qma = qmaList.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevEma = i >= 1 ? emaList.ElementAtOrDefault(i - 1) : 0;

                    decimal c = qma - sma;
                    cList.Add(c);

                    decimal cEma = CalculateExponentialMovingAverage(c, cEmaList.LastOrDefault(), signalPeriod);
                    cEmaList.Add(cEma);

                    var signal = GetVolatilitySignal(currentValue - currentEma, prevValue - prevEma, c, cEma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (cList, cEmaList, signalsList);
        }

        public static (List<decimal>, List<Signal>) CalculatePentupleExponentialMovingAverage(StockData stockDataClass, string maType, int days = 20)
        {
            //@version=3
            // Copyright (c) 2010-present, Bruno Pio
            // Copyright (c) 2019-present, Alex Orekhov (everget)
            // Pentuple Exponential Moving Average script may be freely distributed under the MIT license.
            //study("Pentuple Exponential Moving Average", shorttitle = "PEMA", overlay = true)

            //length = input(title = "Length", type = integer, defval = 20)
            //highlightMovements = input(title = "Highlight Movements ?", type = bool, defval = true)
            //src = input(title = "Source", type = source, defval = close)

            //ema1 = ema(src, length)
            //ema2 = ema(ema1, length)
            //ema3 = ema(ema2, length)
            //ema4 = ema(ema3, length)
            //ema5 = ema(ema4, length)
            //ema6 = ema(ema5, length)
            //ema7 = ema(ema6, length)
            //ema8 = ema(ema7, length)

            //pema = 8 * ema1 - 28 * ema2 + 56 * ema3 - 70 * ema4 + 56 * ema5 - 28 * ema6 + 8 * ema7 - ema8

            //pemaColor = highlightMovements ? (pema > pema[1] ? green : red) : #6d1e7f
            //plot(pema, title = "PEMA", linewidth = 2, color = pemaColor, transp = 0)
            List<decimal> pemaList = new();
            List<Signal> signalsList = new();

            try
            {
                List<decimal> ema1List = GetMovingAverageList(maType, null, stockDataClass, days);
                List<decimal> ema2List = GetMovingAverageList(maType, ema1List, stockDataClass, days);
                List<decimal> ema3List = GetMovingAverageList(maType, ema2List, stockDataClass, days);
                List<decimal> ema4List = GetMovingAverageList(maType, ema3List, stockDataClass, days);
                List<decimal> ema5List = GetMovingAverageList(maType, ema4List, stockDataClass, days);
                List<decimal> ema6List = GetMovingAverageList(maType, ema5List, stockDataClass, days);
                List<decimal> ema7List = GetMovingAverageList(maType, ema6List, stockDataClass, days);
                List<decimal> ema8List = GetMovingAverageList(maType, ema7List, stockDataClass, days);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal ema1 = ema1List.ElementAtOrDefault(i);
                    decimal ema2 = ema2List.ElementAtOrDefault(i);
                    decimal ema3 = ema3List.ElementAtOrDefault(i);
                    decimal ema4 = ema4List.ElementAtOrDefault(i);
                    decimal ema5 = ema5List.ElementAtOrDefault(i);
                    decimal ema6 = ema6List.ElementAtOrDefault(i);
                    decimal ema7 = ema7List.ElementAtOrDefault(i);
                    decimal ema8 = ema8List.ElementAtOrDefault(i);

                    decimal prevPema = pemaList.LastOrDefault();
                    decimal pema = (8 * ema1) - (28 * ema2) + (56 * ema3) - (70 * ema4) + (56 * ema5) - (28 * ema6) + (8 * ema7) - ema8;
                    pemaList.Add(pema);

                    var signal = GetCompareSignal(currentValue - pema, prevValue - prevPema);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (pemaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateZeroLagTripleExponentialMovingAverage(StockData stockDataClass, string maType, int days = 14)
        {
            //calc_zltema(src, length) => 
            //tma1 = calc_tema(src, length)
            //tma2 = calc_tema(tma1, length)
            //diff = tma1 - tma2

            //tma1 + diff
            List<decimal> diffList = new();
            List<decimal> zlTemaList = new();
            List<Signal> signalsList = new();

            try
            {
                var ema1List = GetMovingAverageList(maType, null, stockDataClass, days);
                var ema2List = GetMovingAverageList(maType, ema1List, stockDataClass, days);
                var tma1List = GetMovingAverageList(maType, ema2List, stockDataClass, days);
                var ema3List = GetMovingAverageList(maType, tma1List, stockDataClass, days);
                var ema4List = GetMovingAverageList(maType, ema3List, stockDataClass, days);
                var tma2List = GetMovingAverageList(maType, ema4List, stockDataClass, days);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal tma1 = tma1List.ElementAtOrDefault(i);
                    decimal tma2 = tma2List.ElementAtOrDefault(i);

                    decimal diff = tma1 - tma2;
                    diffList.Add(diff);

                    decimal prevZltema = zlTemaList.LastOrDefault();
                    decimal zltema = tma1 + diff;
                    zlTemaList.Add(zltema);

                    var signal = GetCompareSignal(currentValue - zltema, prevValue - prevZltema);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (diffList, zlTemaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateDTOscillator(StockData stockDataClass, string maType, int days = 3)
        {
            //
            // @author LazyBear
            // List of all my indicators:
            // https://docs.google.com/document/d/15AGCufJZ8CIUvwFJ9W-IKns88gkWOKBCvByMEvm5MLo/edit?usp=sharing
            //
            //study("DT Oscillator [LazyBear]", shorttitle = "DTOsc_LB")
            //rsiLength = input(13, title = "RSI period")
            //stochLength = input(8, title = "Stoch period")
            //maType = input(1, title = "MA type: 1=>SMA, 2=>EMA")
            //kPeriod = input(5, title = "K period")
            //dPeriod = input(3, title = "D period")
            //upper = input(70, title = "Upper band")
            //lower = input(30, title = "Lower band")
            //src = close
            //WiMA(src, length) =>
            //        ms = (src + nz(ms[1] * (length - 1))) / length
            //        ms

            //ma(ma, s, l) =>
            //    ma == 1 ? sma(s, l) : ema(s, l)

            //stoRSI = 100 * ((WiMA(src, rsiLength) - lowest(WiMA(src, rsiLength), stochLength)) / ((highest(WiMA(src, rsiLength), stochLength)) - 
            //lowest(WiMA(src, rsiLength), stochLength)))
            //sk = ma(maType, stoRSI, kPeriod)
            //sd = ma(maType, sk, dPeriod)
            //plot(sk, color = blue, title = "DTOscK")
            //plot(sd, color = gray, title = "DTOscD")
            //plot(50)
            //ul = plot(upper, color = red)
            //ll = plot(lower, color = green)
            //fill(ul, ll)
            List<decimal> stoRsiList = new();
            List<decimal> skList = new();
            List<decimal> sdList = new();
            List<Signal> signalsList = new();

            try
            {
                int stochLength = (int)Math.Ceiling(days / 0.375);
                int kPeriod = (int)Math.Ceiling(days / 0.6);
                int dPeriod = days;
                int rsiLength = (int)Math.Ceiling(days / 0.2308);

                List<decimal> wilderMovingAvgList = GetMovingAverageList(maType, null, stockDataClass, rsiLength);
                var minMaxList = GetMaxAndMinValuesList(wilderMovingAvgList, rsiLength);
                var highestList = minMaxList.Item1;
                var lowestList = minMaxList.Item2;

                for (int i = 0; i < wilderMovingAvgList.Count; i++)
                {
                    decimal wima = wilderMovingAvgList.ElementAtOrDefault(i);
                    decimal highest = highestList.ElementAtOrDefault(i);
                    decimal lowest = lowestList.ElementAtOrDefault(i);
                    decimal prevSd1 = i >= 1 ? sdList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevSd2 = i >= 2 ? sdList.ElementAtOrDefault(i - 2) : 0;

                    decimal stoRsi = highest - lowest != 0 ? MinOrMax(100 * (wima - lowest) / (highest - lowest), 100, 0) : 0;
                    stoRsiList.Add(stoRsi);

                    decimal sk = stoRsiList.TakeLast(kPeriod).Average();
                    skList.Add(sk);

                    decimal sd = skList.TakeLast(dPeriod).Average();
                    sdList.Add(sd);

                    var signal = GetRsiSignal(sd - prevSd1, prevSd1 - prevSd2, sd, prevSd1, 70, 30);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (stoRsiList, skList, sdList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateDema2Lines(StockData stockDataClass, string maType, int days = 10)
        {
            //price = median price;
            //method = moving average(ma), user defined, default is EMA
            //period1 = user defined, default = 10
            //period2 = user defined, default = 40
            //ema = expotential moving average

            //price = (high + low) / 2;
            //ema1 = ma(method, period1, price);
            //ema2 = ma(method, period2, price);
            //Plot1: dema1 = ma(method, period1, ema1);
            //Plot2: dema2 = ma(method, period2, ema2);
            //Signals
            //buy = crossedAbove(DEMA1, DEMA2);
            //sell = crossedBelow(DEMA1, DEMA2);
            List<decimal> dema1List = new();
            List<decimal> dema2List = new();
            List<Signal> signalsList = new();

            try
            {
                int period1 = days;
                int period2 = MinOrMax(period1 * 4);

                List<decimal> ema1List = GetMovingAverageList(maType, null, stockDataClass, period1);
                List<decimal> ema2List = GetMovingAverageList(maType, null, stockDataClass, period2);
                dema1List = GetMovingAverageList(maType, ema1List, stockDataClass, period1);
                dema2List = GetMovingAverageList(maType, ema2List, stockDataClass, period2);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal dema1 = dema1List.ElementAtOrDefault(i);
                    decimal dema2 = dema2List.ElementAtOrDefault(i);
                    decimal prevDema1 = i >= 1 ? dema1List.ElementAtOrDefault(i - 1) : 0;
                    decimal prevDema2 = i >= 1 ? dema2List.ElementAtOrDefault(i - 1) : 0;

                    var signal = GetCompareSignal(dema1 - dema2, prevDema1 - prevDema2);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (dema1List, dema2List, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateDetrendedSyntheticPrice(StockData stockDataClass, int days = 14)
        {
            //period = user defined, default is 14
            //prev = previous, index = current bar number

            //prevHigh = high[index - 1];
            //prevLow = low[index - 1];
            //if (prevHigh moreThan high) high = prevHigh;
            //if (prevLow lessThan low) low = prevLow;
            //price = (high + low) / 2;
            //alpha = .67;
            //if (period moreThan 2) alpha = 2 / (period + 1);
            //prevEma1 = ifNull(price, ema1[index - 1]); //returns price on first try
            //ema1 = (alpha * price) + ((1 - alpha) * prevEma1);
            //prevEma2 = ifNull(price, ema2[index - 1]);
            //ema2 = ((alpha / 2) * price) + ((1 - (alpha / 2)) * prevEma2);
            //Plot: dsp = ema1 - ema2;
            List<decimal> dspList = new();
            List<decimal> ema1List = new();
            List<decimal> ema2List = new();
            List<Signal> signalsList = new();

            try
            {
                decimal alpha = days > 2 ? (decimal)2 / (days + 1) : 0.67m;

                for (int i = 0; i < stockDataClass.HighPrices.Count; i++)
                {
                    decimal currentHigh = stockDataClass.HighPrices.ElementAtOrDefault(i);
                    decimal currentLow = stockDataClass.LowPrices.ElementAtOrDefault(i);
                    decimal prevHigh = i >= 1 ? stockDataClass.HighPrices.ElementAtOrDefault(i - 1) : 0;
                    decimal prevLow = i >= 1 ? stockDataClass.LowPrices.ElementAtOrDefault(i - 1) : 0;
                    decimal high = Math.Max(currentHigh, prevHigh);
                    decimal low = Math.Min(currentLow, prevLow);
                    decimal price = (high + low) / 2;
                    decimal prevEma1 = i >= 1 ? ema1List.ElementAtOrDefault(i - 1) : price;
                    decimal prevEma2 = i >= 1 ? ema2List.ElementAtOrDefault(i - 1) : price;

                    decimal ema1 = (alpha * price) + ((1 - alpha) * prevEma1);
                    ema1List.Add(ema1);

                    decimal ema2 = ((alpha / 2) * price) + ((1 - (alpha / 2)) * prevEma2);
                    ema2List.Add(ema2);

                    decimal prevDsp = dspList.LastOrDefault();
                    decimal dsp = ema1 - ema2;
                    dspList.Add(dsp);

                    var signal = GetCompareSignal(dsp, prevDsp);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (ema1List, ema2List, dspList, signalsList);
        }

        public static (List<decimal>, List<Signal>) CalculateDoubleExponentialMovingAverage(StockData stockDataClass, string maType, int days)
        {
            // DEMA = ( 2 * EMA(n)) - (EMA(EMA(n)) ), where n= period
            List<decimal> demaList = new();
            List<Signal> signalsList = new();

            try
            {
                List<decimal> ema1List = GetMovingAverageList(maType, null, stockDataClass, days);
                List<decimal> ema2List = GetMovingAverageList(maType, ema1List, stockDataClass, days);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal currentEma = ema1List.ElementAtOrDefault(i);
                    decimal currentEma2 = ema2List.ElementAtOrDefault(i);

                    decimal prevDema = demaList.LastOrDefault();
                    decimal dema = (2 * currentEma) - currentEma2;
                    demaList.Add(dema);

                    var signal = GetCompareSignal(currentValue - dema, prevValue - prevDema);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (demaList, signalsList);
        }

        public static (List<decimal>, List<Signal>) CalculateTripleExponentialMovingAverage(StockData stockDataClass, string maType, int days)
        {
            // TEMA = (3 * Ema1) - (3 * Ema2) + Ema3
            List<decimal> temaList = new();
            List<Signal> signalsList = new();

            try
            {
                var ema1List = GetMovingAverageList(maType, null, stockDataClass, days);
                var ema2List = GetMovingAverageList(maType, ema1List, stockDataClass, days);
                var ema3List = GetMovingAverageList(maType, ema2List, stockDataClass, days);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal currentEma1 = ema1List.ElementAtOrDefault(i);
                    decimal currentEma2 = ema2List.ElementAtOrDefault(i);
                    decimal currentEma3 = ema3List.ElementAtOrDefault(i);

                    decimal prevTema = temaList.LastOrDefault();
                    decimal tema = (3 * currentEma1) - (3 * currentEma2) + currentEma3;
                    temaList.Add(tema);

                    var signal = GetCompareSignal(currentValue - tema, prevValue - prevTema);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (temaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>)
            CalculateMovingAverageAdaptiveFilter(StockData stockDataClass, int days = 10)
        {
            //input = price, user defined, default is close
            //period = user defined, default is 10
            //filter = user defined, default is .15
            //prev = previous, abs = absolute value
            //pow = power, index = current bar number
            //std = standard deviation

            //fastest = 0.667;
            //slowest = 0.0645;
            //prevP = price[index - 1];
            //diff = abs(price - prevP);
            //priorP = price[index - period];
            //signal = abs(price - priorP);
            //noise = sum(period, DIFF);
            //ratio = signal / noise;
            //sm = pow(ratio * (fastest - slowest) + slowest, 2);
            //prevAma = ifNull(price, ama[index - 1]);  //returns price on first try
            //ama = prevAma + sm * (price - prevAma);
            //amaDiff = ama - prevAma;
            //PlotHist: MAAF = std(index, period, amaDiff) * filter;
            decimal filter = 0.15m;
            List<decimal> amaList = new();
            List<decimal> amaDiffList = new();
            List<decimal> avgDiffList = new();
            List<decimal> deviationList = new();
            List<decimal> deviationSquaredList = new();
            List<decimal> divisionOfSumList = new();
            List<decimal> stdDevVolatilityList = new();
            List<decimal> maafList = new();
            List<Signal> signalsList = new();

            try
            {
                int signalPeriod = days;
                int period = (int)Math.Ceiling(days / 0.3);

                var smList = CalculateKaufmanAdaptiveMovingAverage(stockDataClass, period).Item4;
                var emaList = CalculateExponentialMovingAverage(stockDataClass, signalPeriod).Item1;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevAma = i >= 1 ? amaList.ElementAtOrDefault(i - 1) : currentValue;
                    decimal sm = smList.ElementAtOrDefault(i);
                    decimal ema = emaList.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevEma = i >= 1 ? emaList.ElementAtOrDefault(i - 1) : 0;

                    decimal ama = prevAma + (sm * (currentValue - prevAma));
                    amaList.Add(ama);

                    decimal amaDiff = ama - prevAma;
                    amaDiffList.Add(amaDiff);

                    decimal avgDiff = amaDiffList.TakeLast(period).Average();
                    avgDiffList.Add(avgDiff);

                    decimal currentDeviation = amaDiff - avgDiff;
                    deviationList.Add(currentDeviation);

                    decimal deviationSquared = Pow(currentDeviation, 2);
                    deviationSquaredList.Add(deviationSquared);

                    decimal divisionOfSum = deviationSquaredList.TakeLast(period).Average();
                    divisionOfSumList.Add(divisionOfSum);

                    decimal stdDevVolatility = divisionOfSum >= 0 ? Sqrt(divisionOfSum) : 0;
                    stdDevVolatilityList.Add(stdDevVolatility);

                    decimal prevMaaf = maafList.LastOrDefault();
                    decimal maaf = stdDevVolatility * filter;
                    maafList.Add(maaf);

                    var signal = GetVolatilitySignal(currentValue - ema, prevValue - prevEma, maaf, prevMaaf);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (amaList, amaDiffList, avgDiffList, deviationList, deviationSquaredList, divisionOfSumList, stdDevVolatilityList, maafList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateMovingAverageAdaptiveQ(StockData stockDataClass, int days = 10)
        {
            //input = price, user defined, default is close
            //period = user defined, default is 10
            //prev = previous, abs = absolute value
            //pow = power, index = current bar number
            //lrv[0] = a in the line equasion y = a + mx

            //fastest = 0.667;
            //slowest = 0.0645;
            //prevP = price[index - 1];
            //diff = abs(price - prevP);
            //priorP = price[index - period];
            //priorDiff = abs(price - priorP);
            //sumPrev = sum(period, DIFF);
            //prevMaaq = ifNull(price, maa[1]);  //returns price on first try
            //temp = ((priorDiff / sumPrev) * fastest) + slowest;
            //Plot: maaq = prevMaaq + pow(temp, 2) * (price - prevMaaq);
            decimal fastest = 0.667m, slowest = 0.0645m;
            List<decimal> tempList = new();
            List<decimal> maaqList = new();
            List<Signal> signalsList = new();

            try
            {
                var erList = CalculateKaufmanAdaptiveMovingAverage(stockDataClass, days).Item3;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevMaaq = i >= 1 ? maaqList.ElementAtOrDefault(i - 1) : currentValue;
                    decimal er = erList.ElementAtOrDefault(i);

                    decimal temp = (er * fastest) + slowest;
                    tempList.Add(temp);

                    decimal maaq = prevMaaq + (Pow(temp, 2) * (currentValue - prevMaaq));
                    maaqList.Add(maaq);

                    var signal = GetCompareSignal(currentValue - maaq, prevValue - prevMaaq);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (tempList, maaqList, signalsList);
        }

        public static (List<decimal>, List<Signal>) CalculateGeneralizeddecimalExponentialMovingAverage(StockData stockDataClass, string maType, int days = 5)
        {
            //@version=3
            // Copyright (c) 2018-present, Alex Orekhov (everget)
            // T3 script may be freely distributed under the MIT license.
            //study(title = "T3", shorttitle = "T3", overlay = true)

            //length = input(title = "Length", type = integer, defval = 5)
            //factor = input(title = "Factor", type = float, minval = 0, maxval = 1, defval = 0.7)
            //highlightMovements = input(title = "Highlight Movements ?", type = bool, defval = true)
            //src = input(title = "Source", type = source, defval = close)

            //gd(src, length) =>
            //    ema(src, length) * (1 + factor) - ema(ema(src, length), length) * factor

            //t3 = gd(gd(gd(src, length), length), length)

            //t3Color = highlightMovements ? (t3 > t3[1] ? green : red) : #6d1e7f
            //plot(t3, title = "T3", linewidth = 2, color = t3Color, transp = 0)
            decimal factor = 0.7m;
            List<decimal> gdList = new();
            List<Signal> signalsList = new();

            try
            {
                List<decimal> ema1List = GetMovingAverageList(maType, null, stockDataClass, days);
                List<decimal> ema2List = GetMovingAverageList(maType, ema1List, stockDataClass, days);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal currentEma1 = ema1List.ElementAtOrDefault(i);
                    decimal currentEma2 = ema2List.ElementAtOrDefault(i);

                    decimal prevGd = gdList.LastOrDefault();
                    decimal gd = (currentEma1 * (1 + factor)) - (currentEma2 * factor);
                    gdList.Add(gd);

                    var signal = GetCompareSignal(currentValue - gd, prevValue - prevGd);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (gdList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateAdaptiveRelativeStrengthIndex(StockData stockDataClass, string maType, int days = 14)
        {
            //@version=3
            // Copyright (c) 2018-present, Alex Orekhov (everget)
            // Adaptive RSI script may be freely distributed under the MIT license.
            //study(title = "Adaptive RSI", shorttitle = "ARSI", overlay = true)

            //length = input(title = "Length", type = integer, defval = 14)
            //highlightMovements = input(title = "Highlight Movements ?", type = bool, defval = true)
            //src = input(title = "Source", type = source, defval = close)

            //alpha = 2 * abs(rsi(src, length) / 100 - 0.5)

            //arsi = 0.0
            //arsi:= alpha * src + (1 - alpha) * nz(arsi[1])

            //arsiColor = highlightMovements ? (arsi > arsi[1] ? green : red) : #6d1e7f
            //plot(arsi, title = "ARSI", linewidth = 2, color = arsiColor, transp = 0)
            List<decimal> arsiList = new();
            List<decimal> alphaList = new();
            List<Signal> signalsList = new();

            try
            {
                List<decimal> rsiList = CalculateRelativeStrengthIndex(null, stockDataClass, maType, days).Item4;

                for (int i = 0; i < rsiList.Count; i++)
                {
                    decimal rsi = rsiList.ElementAtOrDefault(i);
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal alpha = 2 * Math.Abs((rsi / 100) - 0.5m);
                    alphaList.Add(alpha);

                    decimal prevArsi = arsiList.LastOrDefault();
                    decimal arsi = (alpha * currentValue) + ((1 - alpha) * prevArsi);
                    arsiList.Add(arsi);

                    var signal = GetCompareSignal(currentValue - arsi, prevValue - prevArsi);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (alphaList, arsiList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateTrendContinuationFactor(StockData stockDataClass, int days = 35)
        {
            //@version=3
            // Copyright (c) 2018-present, Alex Orekhov (everget)
            // Trend Continuation Factor script may be freely distributed under the MIT license.
            //study("Trend Continuation Factor", shorttitle = "TCF")

            //length = input(title = "Length", type = integer, defval = 35)
            //highlightCrossovers = input(title = "Highlight Crossovers ?", type = bool, defval = true)
            //highlightBreakouts = input(title = "Highlight Breakouts?", type = bool, defval = true)
            //src = input(title = "Source", type = source, defval = close)

            //plusChange(src) => change(src) > 0 ? change(src) : 0.0
            //minusChange(src) => change(src) > 0 ? 0.0 : -change(src)

            //plusCF = 0.0
            //plusCF:= plusChange(src) == 0 ? 0.0 : plusChange(src) + nz(plusCF[1])

            //minusCF = 0.0
            //minusCF:= minusChange(src) == 0 ? 0.0 : minusChange(src) + nz(minusCF[1])

            //plusTCF = sum(plusChange(src) - minusCF, length)
            //minusTCF = sum(minusChange(src) - plusCF, length)

            //plot(plusTCF, title = "+TCF", color =#45a338, transp=0)
            //plot(minusTCF, title = "-TCF", color =#ff3013, transp=0)

            //plotshape(highlightCrossovers and crossover(plusTCF, minusTCF) and plusTCF < 0 ? avg(plusTCF, minusTCF) : na, title = "Crossover", location = location.absolute, style = shape.circle, size = size.tiny, color = green, transp = 20)
            //plotshape(highlightCrossovers and crossunder(plusTCF, minusTCF) and plusTCF < 0 ? avg(plusTCF, minusTCF) : na, title = "Crossunder", location = location.absolute, style = shape.circle, size = size.tiny, color = red, transp = 20)

            //hline(0, title = "Zero Level", linestyle = dotted, color =#e69138)

            //transparent = color(white, 100)
            //breakoutFillColor = highlightBreakouts ? (plusTCF > 0 ? green : minusTCF > 0 ? red : transparent) : transparent
            //bgcolor(color = breakoutFillColor, title = "Breakout Background", transp = 90)
            List<decimal> tcfPlusList = new();
            List<decimal> tcfMinusList = new();
            List<decimal> chgPlusList = new();
            List<decimal> chgMinusList = new();
            List<decimal> cfPlusList = new();
            List<decimal> cfMinusList = new();
            List<decimal> sumChgPlusList = new();
            List<decimal> sumChgMinusList = new();
            List<decimal> sumCfPlusList = new();
            List<decimal> sumCfMinusList = new();
            List<decimal> diffPlusList = new();
            List<decimal> diffMinusList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal priceChg = currentValue - prevValue;

                    decimal chgPlus = priceChg > 0 ? priceChg : 0;
                    chgPlusList.Add(chgPlus);

                    decimal chgMinus = priceChg < 0 ? Math.Abs(priceChg) : 0;
                    chgMinusList.Add(chgMinus);

                    decimal prevCfPlus = cfPlusList.LastOrDefault();
                    decimal cfPlus = chgPlus == 0 ? 0 : chgPlus + prevCfPlus;
                    cfPlusList.Add(cfPlus);

                    decimal prevCfMinus = cfMinusList.LastOrDefault();
                    decimal cfMinus = chgMinus == 0 ? 0 : chgMinus + prevCfMinus;
                    cfMinusList.Add(cfMinus);

                    decimal diffPlus = chgPlus - cfMinus;
                    diffPlusList.Add(diffPlus);

                    decimal diffMinus = chgMinus - cfPlus;
                    diffMinusList.Add(diffMinus);

                    decimal sumChgPlus = chgPlusList.TakeLast(days).Sum();
                    sumChgPlusList.Add(sumChgPlus);

                    decimal sumChgMinus = chgMinusList.TakeLast(days).Sum();
                    sumChgMinusList.Add(sumChgMinus);

                    decimal sumCfPlus = cfPlusList.TakeLast(days).Sum();
                    sumCfPlusList.Add(sumCfPlus);

                    decimal sumCfMinus = cfMinusList.TakeLast(days).Sum();
                    sumCfMinusList.Add(sumCfMinus);

                    decimal prevTcfPlus = tcfPlusList.LastOrDefault();
                    decimal tcfPlus = diffPlusList.TakeLast(days).Sum();
                    tcfPlusList.Add(tcfPlus);

                    decimal prevTcfMinus = tcfMinusList.LastOrDefault();
                    decimal tcfMinus = diffMinusList.TakeLast(days).Sum();
                    tcfMinusList.Add(tcfMinus);

                    var signal = GetCompareSignal(tcfPlus - tcfMinus, prevTcfPlus - prevTcfMinus);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (cfPlusList, cfMinusList, sumCfPlusList, sumCfMinusList, diffPlusList, diffMinusList, tcfPlusList, tcfMinusList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateReverseEngineeringRelativeStrengthIndex(StockData stockDataClass,
            int days = 14)
        {
            //@version=2
            ////////////////////////////////////////////////////////////
            //  Copyright by HPotter v1.0 24/10/2017
            // The related article is copyrighted material from
            // Stocks & Commodities.
            ////////////////////////////////////////////////////////////
            //study(title = "Reverse Engineering RSI, by Giorgos Siligardos", overlay = true)
            //Value = input(50, minval = 1)
            //WildPer = input(14, minval = 1)
            //ExpPer = 2 * WildPer - 1
            //K = 2 / (ExpPer + 1)
            //AUC = iff(close > close[1], K * (close - close[1]) + (1 - K) * nz(AUC[1], 1), (1 - K) * nz(AUC[1], 1))
            //ADC = iff(close > close[1], (1 - K) * nz(ADC[1], 1), K * (close[1] - close) + (1 - K) * nz(ADC[1], 1))
            //nVal = (WildPer - 1) * (ADC * Value / (100 - Value) - AUC)
            //nRes = iff(nVal >= 0, close + nVal, close + nVal * (100 - Value) / Value)
            //pos = iff(nRes > close, -1,
            //      iff(nRes < close, 1, nz(pos[1], 0)))
            //barcolor(pos == -1 ? red : pos == 1 ? green : blue)
            //plot(nRes, color = blue, title = "Reverse Engineering RSI")
            List<decimal> aucList = new();
            List<decimal> adcList = new();
            List<decimal> rsiValueList = new();
            List<decimal> revRsiList = new();
            List<Signal> signalsList = new();
            decimal value = 50;

            try
            {
                decimal expPeriod = (2 * days) - 1;
                decimal k = 2 / (expPeriod + 1);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevAuc = i >= 1 ? aucList.ElementAtOrDefault(i - 1) : 1;
                    decimal prevAdc = i >= 1 ? adcList.ElementAtOrDefault(i - 1) : 1;

                    decimal auc = currentValue > prevValue ? (k * (currentValue - prevValue)) + ((1 - k) * prevAuc) : (1 - k) * prevAuc;
                    aucList.Add(auc);

                    decimal adc = currentValue > prevValue ? ((1 - k) * prevAdc) : (k * (prevValue - currentValue)) + ((1 - k) * prevAdc);
                    adcList.Add(adc);

                    decimal rsiValue = (days - 1) * ((adc * value / (100 - value)) - auc);
                    rsiValueList.Add(rsiValue);

                    decimal prevRevRsi = revRsiList.LastOrDefault();
                    decimal revRsi = rsiValue >= 0 ? currentValue + rsiValue : currentValue + (rsiValue * (100 - value) / value);
                    revRsiList.Add(revRsi);

                    var signal = GetCompareSignal(currentValue - revRsi, prevValue - prevRevRsi);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (aucList, adcList, rsiValueList, revRsiList, signalsList);
        }

        public static (List<decimal>, List<Signal>) CalculatePivotDetectorOscillator(StockData stockDataClass,
            string maType, int days = 14)
        {
            //@version=2
            ////////////////////////////////////////////////////////////
            //  Copyright by HPotter v1.0 02/10/2017
            // The Pivot Detector Oscillator, by Giorgos E. Siligardos
            // The related article is copyrighted material from Stocks & Commodities 2009 Sep
            ////////////////////////////////////////////////////////////
            //study(title = "The Pivot Detector Oscillator, by Giorgos E. Siligardos")
            //Length_MA = input(200, minval = 1)
            //Length_RSI = input(14, minval = 1)
            //UpBand = input(100, minval = 1)
            //DownBand = input(0)
            //MidlleBand = input(50)
            //hline(MidlleBand, color = black, linestyle = dashed)
            //hline(UpBand, color = red, linestyle = line)
            //hline(DownBand, color = green, linestyle = line)
            //xMA = sma(close, Length_MA)
            //xRSI = rsi(close, Length_RSI)
            //nRes = iff(close > xMA, (xRSI - 35) / (85 - 35),
            //       iff(close <= xMA, (xRSI - 20) / (70 - 20), 0))
            //pos = iff(nRes * 100 > 50, 1,
            //      iff(nRes * 100 < 50, -1, nz(pos[1], 0)))
            //barcolor(pos == -1 ? red : pos == 1 ? green : blue)
            //plot(nRes * 100, color = blue, title = "Pivot Detector Oscillator")
            List<decimal> pdoList = new();
            List<Signal> signalsList = new();

            try
            {
                int smaPeriod = MinOrMax((int)Math.Ceiling(days / 0.07));

                var rsiList = CalculateRelativeStrengthIndex(null, stockDataClass, maType, days).Item4;
                var smaList = CalculateSimpleMovingAverage(stockDataClass, smaPeriod).Item1;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal sma = smaList.ElementAtOrDefault(i);
                    decimal rsi = rsiList.ElementAtOrDefault(i);
                    decimal prevPdo1 = i >= 1 ? pdoList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevPdo2 = i >= 2 ? pdoList.ElementAtOrDefault(i - 2) : 0;

                    decimal pdo = currentValue > sma ? (rsi - 35) / (85 - 35) * 100 : currentValue <= sma ? (rsi - 20) / (70 - 20) * 100 : 0;
                    pdoList.Add(pdo);

                    var signal = GetCompareSignal(pdo - prevPdo1, prevPdo1 - prevPdo2);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (pdoList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateTrendIntensityIndex(StockData stockDataClass, string maType, int days = 30)
        {
            //@version=3
            // Copyright (c) 2018-present, Alex Orekhov (everget)
            // Trend Intensity Index script may be freely distributed under the MIT license.
            //study("Trend Intensity Index", shorttitle = "TII")

            //majorLength = input(title = "Major Length", type = integer, defval = 60)
            //minorLength = input(title = "Minor Length", type = integer, defval = 30)
            //upperLevel = input(title = "Upper Level", type = integer, defval = 80)
            //lowerLevel = input(title = "Lower Level", type = integer, defval = 20)
            //highlightBreakouts = input(title = "Highlight Overbought/Oversold Breakouts ?", type = bool, defval = true)
            //src = input(title = "Source", type = source, defval = close)

            //sma = sma(src, majorLength)

            //positiveSum = 0.0
            //negativeSum = 0.0

            //for i = 0 to minorLength - 1
            //    price = nz(src[i])
            //    avg = nz(sma[i])
            //    positiveSum := positiveSum + (price > avg ? price - avg : 0)
            //    negativeSum := negativeSum + (price > avg ? 0 : avg - price)

            //tii = 100 * positiveSum / (positiveSum + negativeSum)

            //tiiColor = tii > upperLevel ? #0ebb23 : tii < lowerLevel ? #ff0000 : #f4b77d
            //plot(tii, title = "TII", linewidth = 2, color = tiiColor, transp = 0)

            //transparent = color(white, 100)

            //maxLevelPlot = hline(100, title = "Max Level", linestyle = dotted, color = transparent)
            //upperLevelPlot = hline(upperLevel, title = "Upper Level", linestyle = dotted)
            //hline(50, title = "Middle Level", linestyle = dotted)
            //lowerLevelPlot = hline(lowerLevel, title = "Lower Level", linestyle = dotted)
            //minLevelPlot = hline(0, title = "Min Level", linestyle = dotted, color = transparent)

            //fill(upperLevelPlot, lowerLevelPlot, color = purple, transp = 95)

            //upperFillColor = tii > upperLevel and highlightBreakouts ? green : transparent
            //lowerFillColor = tii < lowerLevel and highlightBreakouts ? red : transparent

            //fill(maxLevelPlot, upperLevelPlot, color = upperFillColor, transp = 90)
            //fill(minLevelPlot, lowerLevelPlot, color = lowerFillColor, transp = 90)
            List<decimal> tiiList = new();
            List<decimal> sdPlusList = new();
            List<decimal> sdMinusList = new();
            List<decimal> deviationUpList = new();
            List<decimal> deviationDownList = new();
            List<Signal> signalsList = new();

            try
            {
                int period = days;
                int maPeriod = MinOrMax(days * 2);

                var smaList = GetMovingAverageList(maType, null, stockDataClass, maPeriod);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal currentSma = smaList.ElementAtOrDefault(i);
                    decimal prevTii1 = i >= 1 ? tiiList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevTii2 = i >= 2 ? tiiList.ElementAtOrDefault(i - 2) : 0;

                    decimal deviationUp = currentValue > currentSma ? currentValue - currentSma : 0;
                    deviationUpList.Add(deviationUp);

                    decimal deviationDown = currentValue < currentSma ? currentSma - currentValue : 0;
                    deviationDownList.Add(deviationDown);

                    decimal sdPlus = deviationUpList.TakeLast(period).Sum();
                    sdPlusList.Add(sdPlus);

                    decimal sdMinus = deviationDownList.TakeLast(period).Sum();
                    sdMinusList.Add(sdMinus);

                    decimal tii = sdPlus + sdMinus != 0 ? sdPlus / (sdPlus + sdMinus) * 100 : 0;
                    tiiList.Add(tii);

                    var signal = GetRsiSignal(tii - prevTii1, prevTii1 - prevTii2, tii, prevTii1, 80, 20);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (deviationUpList, deviationDownList, sdPlusList, sdMinusList, tiiList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateTrendTriggerFactorIndicator(StockData stockDataClass, int days = 15)
        {
            //@version=3
            // Copyright (c) 2018-present, Alex Orekhov (everget)
            // Trend Trigger Factor script may be freely distributed under the MIT license.
            //study("Trend Trigger Factor", shorttitle = "TTF")

            //length = input(title = "Lookback Length", type = integer, defval = 15)
            //upperLevel = input(title = "Upper Trigger Level", type = integer, defval = 100, minval = 1)
            //lowerLevel = input(title = "Lower Trigger Level", type = integer, defval = -100, maxval = -1)
            //highlightBreakouts = input(title = "Highlight Overbought/Oversold Breakouts ?", type = bool, defval = true)
            //src = input(title = "Source", type = source, defval = close)

            //hh = highest(length)
            //ll = lowest(length)

            //buyPower = hh - nz(ll[length])
            //sellPower = nz(hh[length]) - ll

            //ttf = 200 * (buyPower - sellPower) / (buyPower + sellPower)

            //ttfColor = ttf > upperLevel ? #0ebb23 : ttf < lowerLevel ? #ff0000 : #f4b77d
            //plot(ttf, title = "TTF", linewidth = 2, color = ttfColor, transp = 0)

            //transparent = color(white, 100)

            //maxLevelPlot = hline(200, title = "Max Level", linestyle = dotted, color = transparent)
            //upperLevelPlot = hline(upperLevel, title = "Upper Trigger Level", linestyle = dotted)
            //hline(0, title = "Zero Level", linestyle = dotted)
            //lowerLevelPlot = hline(lowerLevel, title = "Lower Trigger Level", linestyle = dotted)
            //minLevelPlot = hline(-200, title = "Min Level", linestyle = dotted, color = transparent)

            //fill(upperLevelPlot, lowerLevelPlot, color = purple, transp = 95)

            //upperFillColor = ttf > upperLevel and highlightBreakouts ? green: transparent
            //lowerFillColor = ttf < lowerLevel and highlightBreakouts ? red: transparent

            //fill(maxLevelPlot, upperLevelPlot, color = upperFillColor, transp = 90)
            //fill(minLevelPlot, lowerLevelPlot, color = lowerFillColor, transp = 90)
            List<decimal> buyPowerList = new();
            List<decimal> sellPowerList = new();
            List<decimal> ttfList = new();
            List<Signal> signalsList = new();

            try
            {
                var minMaxList = VolumeInputCheck(stockDataClass, days, true);
                var highestList = minMaxList.Item1;
                var lowestList = minMaxList.Item2;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal highest = highestList.ElementAtOrDefault(i);
                    decimal lowest = lowestList.ElementAtOrDefault(i);
                    decimal prevHighest = i >= days ? highestList.ElementAtOrDefault(i - days) : 0;
                    decimal prevLowest = i >= days ? lowestList.ElementAtOrDefault(i - days) : 0;

                    decimal buyPower = highest - prevLowest;
                    buyPowerList.Add(buyPower);

                    decimal sellPower = prevHighest - lowest;
                    sellPowerList.Add(sellPower);

                    decimal prevTtf = ttfList.LastOrDefault();
                    decimal ttf = buyPower + sellPower != 0 ? 200 * (buyPower - sellPower) / (buyPower + sellPower) : 0;
                    ttfList.Add(ttf);

                    var signal = GetCompareSignal(ttf, prevTtf);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (buyPowerList, sellPowerList, ttfList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateEfficientAutoLine(StockData stockDataClass, int days = 19)
        {
            //@version=2
            //study("Efficient Auto Line", overlay = true)
            //length = input(19),fast = input(0.0001),slow = input(0.005)
            //
            //src = close
            //er = abs(change(src, length)) / sum(abs(change(src)), length)
            //dev = er * fast + (1 - er) * slow
            //a = n < 9 ? src : src > a[1] + dev ? src : src < a[1] - dev ? src : a[1]
            //
            //css = fixnan(a > a[1] ? #2E9AFE : a < a[1] ? #FA5858 : na)
            //plot(a, color = css, transp = 0, linewidth = 3)
            List<decimal> aList = new();
            List<decimal> devList = new();
            List<Signal> signalsList = new();
            decimal fast = 0.0001m, slow = 0.005m;

            try
            {
                var erList = CalculateKaufmanAdaptiveMovingAverage(stockDataClass, days).Item3;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal er = erList.ElementAtOrDefault(i);

                    decimal dev = (er * fast) + ((1 - er) * slow);
                    devList.Add(dev);

                    decimal prevA = aList.LastOrDefault();
                    decimal a = i < 9 ? currentValue : currentValue > prevA + dev ? currentValue : currentValue < prevA - dev ? currentValue : prevA;
                    aList.Add(a);

                    var signal = GetCompareSignal(currentValue - a, prevValue - prevA);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (devList, aList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateMovingAverageConvergenceDivergence(StockData stockDataClass, string maType, int days = 9)
        {
            ////////////////////////////////////////////////////////////
            //  Copyright by HPotter v1.0 18/06/2014
            // MACD – Moving Average Convergence Divergence. The MACD is calculated 
            // by subtracting a 26-day moving average of a security's price from a 
            // 12-day moving average of its price. The result is an indicator that 
            // oscillates above and below zero. When the MACD is above zero, it means 
            // the 12-day moving average is higher than the 26-day moving average. 
            // This is bullish as it shows that current expectations (i.e., the 12-day 
            // moving average) are more bullish than previous expectations (i.e., the 
            // 26-day average). This implies a bullish, or upward, shift in the supply/demand 
            // lines. When the MACD falls below zero, it means that the 12-day moving average 
            // is less than the 26-day moving average, implying a bearish shift in the 
            // supply/demand lines.
            // A 9-day moving average of the MACD (not of the security's price) is usually 
            // plotted on top of the MACD indicator. This line is referred to as the "signal" 
            // line. The signal line anticipates the convergence of the two moving averages 
            // (i.e., the movement of the MACD toward the zero line).
            // Let's consider the rational behind this technique. The MACD is the difference 
            // between two moving averages of price. When the shorter-term moving average rises 
            // above the longer-term moving average (i.e., the MACD rises above zero), it means 
            // that investor expectations are becoming more bullish (i.e., there has been an 
            // upward shift in the supply/demand lines). By plotting a 9-day moving average of 
            // the MACD, we can see the changing of expectations (i.e., the shifting of the 
            // supply/demand lines) as they occur.
            ////////////////////////////////////////////////////////////
            //study(title = "MACD", shorttitle = "MACD")
            //fastLength = input(12, minval = 1)
            //slowLength = input(26, minval = 1)
            //signalLength = input(9, minval = 1)
            //hline(0, color = purple, linestyle = dashed)
            //fastMA = ema(close, fastLength)
            //slowMA = ema(close, slowLength)
            //macd = fastMA - slowMA
            //signal = ema(macd, signalLength)
            //histogram = macd - signal
            //pos = iff(signal < macd, 1,
            //        iff(signal > macd, -1, nz(pos[1], 0)))
            //barcolor(pos == -1 ? red : pos == 1 ? green : blue)
            //plot(signal, color = red, title = "SIGNAL")
            //plot(macd, color = blue, title = "MACD")
            List<decimal> macdList = new();
            List<decimal> macdSignalLineList = new();
            List<decimal> macdHistogramList = new();
            List<Signal> signalsList = new();

            try
            {
                int fastLength = (int)Math.Ceiling(days / 0.75);
                int slowLength = (int)Math.Ceiling(days / 0.3462);
                int signalLength = days;

                List<decimal> fastEmaList = GetMovingAverageList(maType, null, stockDataClass, fastLength);
                List<decimal> slowEmaList = GetMovingAverageList(maType, null, stockDataClass, slowLength);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal fastEma = fastEmaList.ElementAtOrDefault(i);
                    decimal slowEma = slowEmaList.ElementAtOrDefault(i);

                    decimal macd = fastEma - slowEma;
                    macdList.Add(macd);
                }

                macdSignalLineList = GetMovingAverageList(maType, macdList, stockDataClass, signalLength);
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal macd = macdList.ElementAtOrDefault(j);
                    decimal macdSignalLine = macdSignalLineList.ElementAtOrDefault(j);

                    decimal prevMacdHistogram = macdHistogramList.LastOrDefault();
                    decimal macdHistogram = macd - macdSignalLine;
                    macdHistogramList.Add(macdHistogram);

                    var signal = GetCompareSignal(macdHistogram, prevMacdHistogram);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (macdList, macdSignalLineList, macdHistogramList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateStochasticMovingAverageConvergenceDivergenceOscillator(
            StockData stockDataClass, string maType, int days = 9)
        {
            //@version=4
            //study("Modified Stochastic MACD Oscillator - Vitali Apirine", "MSMACDO", false, format.inherit, 1)

            //periodStochastic = input(45, "Stochastic Period", input.integer, minval = 1)
            //periodFast = input(12, "Fast Average Period", input.integer, minval = 1)
            //periodSlow = input(26, "Slow Average Period", input.integer, minval = 2)
            //periodSignal = input(9, "Signal Period", input.integer, minval = 2)
            //showHistogram = input(true, "========= Show Histogram ==========", input.bool)
            //histogramScheme = input("#1", "Histogram Color Scheme", input.string, options =["#1", "#2"])
            //showMomentumBGC = input(true, "Show Momentum Background Coloring", input.bool)
            //lineThickness = input(2, "Line Thickness", input.integer, options =[1, 2])
            //showCrossovers = input(true, "===== Show Crossovers Markers ======", input.bool)
            //levelOverBought = input(1.0, "Overbought Level", input.float, minval = 0.5, step = 0.05)
            //levelOverSold = input(-1.0, "Oversold Level", input.float, maxval = -0.5, step = 0.05)

            //bgcolor(color.new (#000000,15), title="Dark Background")
            //plot(0, color = color.new (color.olive, 80), linewidth = 7, editable = false)
            //hline(0, color =#FFFFFFff, linestyle=hline.style_dotted, editable=false)
            //hline(levelOverBought, "Overbought", color =#FF0000ff)
            //hline(levelOverSold, "Oversold", color =#00FF00ff)

            //lowestLow = lowest(low, periodStochastic)
            //HHMinusLL = highest(high, periodStochastic) - lowestLow
            //stochasticFast = HHMinusLL == 0.0 ? 0.0 : (ema(close, periodFast) - lowestLow) / HHMinusLL
            //stochasticSlow = HHMinusLL == 0.0 ? 0.0 : (ema(close, periodSlow) - lowestLow) / HHMinusLL
            //stochasticMACD = 10 * (stochasticFast - stochasticSlow)
            //signal = ema(stochasticMACD, periodSignal)
            //histogram = stochasticMACD - signal
            //colorHistogram = histogramScheme == "#1" ?
            //histogram > 0.0 ? #FF00FFff : #800080ff :
            //histogram > nz(histogram[1]) ? #FF00FFff : #800080ff

            //bgcolor(showMomentumBGC ? histogram > 0.0 ? color.new (#00FF00, 90) : color.new(#FF0000, 90) : color(na), editable=false)
            //plot(showHistogram ? histogram : na, color = colorHistogram, linewidth = 2, title = "Histogram", style = plot.style_histogram, editable = false)
            //plot(stochasticMACD, color =#0066FFff     , linewidth=lineThickness, title="Stochastic MACD")
            //plot(signal, color =#FF6600ff     , linewidth=lineThickness, title="Signal")
            //plotshape(showCrossovers and crossover(stochasticMACD, signal), color =#00FF00ff, size=size.tiny, style=shape.triangleup  , location=location.bottom, editable=false)
            //plotshape(showCrossovers and crossunder(stochasticMACD, signal), color =#FF0000ff, size=size.tiny, style=shape.triangledown, location=location.top   , editable=false)
            List<decimal> macdStochasticSignalLineList = new();
            List<decimal> macdStochasticHistogramList = new();
            List<decimal> tempHighList = new();
            List<decimal> tempLowList = new();
            List<decimal> tempList = new();
            List<decimal> fastStochasticList = new();
            List<decimal> slowStochasticList = new();
            List<decimal> macdStochasticList = new();
            List<Signal> signalsList = new();

            try
            {
                int fastLength = (int)Math.Ceiling(days / 0.75);
                int slowLength = (int)Math.Ceiling(days / 0.3462);
                int signalLength = days;
                int stochasticLength = days * 5;

                List<decimal> fastEmaList = GetMovingAverageList(maType, null, stockDataClass, fastLength);
                List<decimal> slowEmaList = GetMovingAverageList(maType, null, stockDataClass, slowLength);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal fastEma = fastEmaList.ElementAtOrDefault(i);
                    decimal slowEma = slowEmaList.ElementAtOrDefault(i);

                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    tempList.Add(currentValue);

                    decimal currentHigh = stockDataClass.HighPrices.ElementAtOrDefault(i);
                    tempHighList.Add(currentHigh);

                    decimal currentLow = stockDataClass.LowPrices.ElementAtOrDefault(i);
                    tempLowList.Add(currentLow);

                    decimal hh = currentValue > currentHigh ? tempList.TakeLast(stochasticLength).Max() : tempHighList.TakeLast(stochasticLength).Max();
                    decimal ll = currentValue > currentHigh ? tempList.TakeLast(stochasticLength).Min() : tempLowList.TakeLast(stochasticLength).Min();
                    decimal range = hh - ll;

                    decimal fastStochastic = range != 0 ? (fastEma - ll) / range : 0;
                    fastStochasticList.Add(fastStochastic);

                    decimal slowStochastic = range != 0 ? (slowEma - ll) / range : 0;
                    slowStochasticList.Add(slowStochastic);

                    decimal macdStochastic = 10 * (fastStochastic - slowStochastic);
                    macdStochasticList.Add(macdStochastic);

                    decimal macdStochasticSignalLine = CalculateExponentialMovingAverage(macdStochastic, macdStochasticSignalLineList.LastOrDefault(), signalLength);
                    macdStochasticSignalLineList.Add(macdStochasticSignalLine);

                    decimal prevMacdHistogram = macdStochasticHistogramList.LastOrDefault();
                    decimal macdHistogram = macdStochastic - macdStochasticSignalLine;
                    macdStochasticHistogramList.Add(macdHistogram);

                    var signal = GetCompareSignal(macdHistogram, prevMacdHistogram);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (fastStochasticList, slowStochasticList, macdStochasticList, macdStochasticSignalLineList, macdStochasticHistogramList, signalsList);
        }

        public static (List<decimal>, List<Signal>) Calculate1LCLeastSquaresMovingAverage(StockData stockDataClass, string maType, int days = 14)
        {
            //@version=3
            //study("1LC-LSMA", overlay = true)
            //length = input(14)
            //
            //y = sma(close, length) + correlation(close, n, length) * stdev(close, length) * 1.7
            //plot(y, color =#FF0040,transp=0)
            List<decimal> yList = new();
            List<decimal> tempList = new();
            List<decimal> corrList = new();
            List<decimal> indexList = new();
            List<Signal> signalsList = new();

            try
            {
                var smaList = GetMovingAverageList(maType, null, stockDataClass, days);
                var stdDevList = CalculateStandardDeviationVolatility(null, stockDataClass, days).Item4;

                for (int h = 0; h < stockDataClass.InputValues.Count; h++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(h);
                    tempList.Add(currentValue);

                    decimal index = h;
                    indexList.Add(index);

                    var corr = GoodnessOfFit.R(indexList.TakeLast(days).Select(x => (double)x), tempList.TakeLast(days).Select(x => (double)x));
                    corr = IsValueNullOrInfinity(corr) ? 0 : corr;
                    corrList.Add((decimal)corr);
                }

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal sma = smaList.ElementAtOrDefault(i);
                    decimal corr = corrList.ElementAtOrDefault(i);
                    decimal stdDev = stdDevList.ElementAtOrDefault(i);
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal prevY = yList.LastOrDefault();
                    decimal y = sma + (corr * stdDev * 1.7m);
                    yList.Add(y);

                    var signal = GetCompareSignal(currentValue - y, prevValue - prevY);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (yList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateLightLeastSquaresMovingAverage(StockData stockDataClass, string maType, int days = 250)
        {
            //@version=2
            //study("Light LSMA", overlay = true)
            //length = input(250)
            //
            //c = (sma(close, length / 2) - sma(close, length)) / stdev(close, length)
            //z = (n - sma(n, length)) / stdev(n, length) * c
            //y = sma(close, length) + z * stdev(close, length)
            //plot(y, color =#2E64FE,transp=0)
            List<decimal> yList = new();
            List<decimal> cList = new();
            List<decimal> zList = new();
            List<decimal> indexList = new();
            List<Signal> signalsList = new();

            try
            {
                int length = MinOrMax((int)Math.Ceiling((decimal)days / 2));

                for (int h = 0; h < stockDataClass.InputValues.Count; h++)
                {
                    decimal index = h;
                    indexList.Add(index);
                }

                var sma1List = GetMovingAverageList(maType, null, stockDataClass, days);
                var sma2List = GetMovingAverageList(maType, null, stockDataClass, length);
                var stdDevList = CalculateStandardDeviationVolatility(null, stockDataClass, days).Item4;
                var indexStdDevList = CalculateStandardDeviationVolatility(indexList, stockDataClass, days).Item4;
                var indexSmaList = GetMovingAverageList(maType, indexList, stockDataClass, days);
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal sma1 = sma1List.ElementAtOrDefault(i);
                    decimal sma2 = sma2List.ElementAtOrDefault(i);
                    decimal stdDev = stdDevList.ElementAtOrDefault(i);
                    decimal indexStdDev = indexStdDevList.ElementAtOrDefault(i);
                    decimal indexSma = indexSmaList.ElementAtOrDefault(i);
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal c = stdDev != 0 ? (sma2 - sma1) / stdDev : 0;
                    cList.Add(c);

                    decimal z = indexStdDev != 0 && c != 0 ? (i - indexSma) / indexStdDev * c : 0;
                    zList.Add(z);

                    decimal prevY = yList.LastOrDefault();
                    decimal y = sma1 + (z * stdDev);
                    yList.Add(y);

                    var signal = GetCompareSignal(currentValue - y, prevValue - prevY);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (cList, zList, yList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateDiNapoliMovingAverageConvergenceDivergence(StockData stockDataClass)
        {
            //
            // @author LazyBear 
            // 
            // List of my public indicators: http://bit.ly/1LQaPK8 
            // List of my app-store indicators: http://blog.tradingview.com/?p=970 
            //
            //study(title = "DiNapoli MACD [LazyBear]", shorttitle = "DMACD_LB", overlay = false)
            //lc = input(17.5185, title = "Long Cycle")
            //sc = input(8.3896, title = "Short Cycle")
            //sp = input(9.0503, title = "Signal Length")
            //src = input(close, title = "Source")
            //fs = nz(fs[1]) + 2.0 / (1.0 + sc) * (src - nz(fs[1]))
            //ss = nz(ss[1]) + 2.0 / (1.0 + lc) * (src - nz(ss[1]))
            //r = fs - ss
            //s = nz(s[1]) + 2.0 / (1 + sp) * (r - nz(s[1]))
            //plot(r, style = columns, color = r > 0 ? green : red, transp = 80, title = "Histo")
            //plot(s, color = teal, linewidth = 2, title = "Dinapoli MACD")
            List<decimal> fsList = new();
            List<decimal> ssList = new();
            List<decimal> rList = new();
            List<decimal> sList = new();
            List<decimal> hList = new();
            List<Signal> signalsList = new();
            decimal lc = 17.5185m, sc = 8.3896m, sp = 9.0503m;

            try
            {
                decimal scAlpha = 2 / (1 + sc);
                decimal lcAlpha = 2 / (1 + lc);
                decimal spAlpha = 2 / (1 + sp);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);

                    decimal prevFs = fsList.LastOrDefault();
                    decimal fs = prevFs + (scAlpha * (currentValue - prevFs));
                    fsList.Add(fs);

                    decimal prevSs = ssList.LastOrDefault();
                    decimal ss = prevSs + (lcAlpha * (currentValue - prevSs));
                    ssList.Add(ss);

                    decimal r = fs - ss;
                    rList.Add(r);

                    decimal prevS = sList.LastOrDefault();
                    decimal s = prevS + (spAlpha * (r - prevS));
                    sList.Add(s);

                    decimal prevH = hList.LastOrDefault();
                    decimal h = r - s;
                    hList.Add(h);

                    var signal = GetCompareSignal(h, prevH);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (fsList, ssList, rList, sList, hList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateDiNapoliPercentagePriceOscillator(StockData stockDataClass)
        {
            //
            // @author LazyBear 
            // 
            // List of my public indicators: http://bit.ly/1LQaPK8 
            // List of my app-store indicators: http://blog.tradingview.com/?p=970 
            //
            //study(title = "DiNapoli MACD [LazyBear]", shorttitle = "DMACD_LB", overlay = false)
            //lc = input(17.5185, title = "Long Cycle")
            //sc = input(8.3896, title = "Short Cycle")
            //sp = input(9.0503, title = "Signal Length")
            //src = input(close, title = "Source")
            //fs = nz(fs[1]) + 2.0 / (1.0 + sc) * (src - nz(fs[1]))
            //ss = nz(ss[1]) + 2.0 / (1.0 + lc) * (src - nz(ss[1]))
            //r = fs - ss
            //s = nz(s[1]) + 2.0 / (1 + sp) * (r - nz(s[1]))
            //plot(r, style = columns, color = r > 0 ? green : red, transp = 80, title = "Histo")
            //plot(s, color = teal, linewidth = 2, title = "Dinapoli MACD")
            List<decimal> ppoList = new();
            List<decimal> sList = new();
            List<decimal> hList = new();
            List<Signal> signalsList = new();
            decimal sp = 9.0503m;

            try
            {
                decimal spAlpha = 2 / (1 + sp);

                var dinapoliMacdList = CalculateDiNapoliMovingAverageConvergenceDivergence(stockDataClass);
                var ssList = dinapoliMacdList.Item2;
                var rList = dinapoliMacdList.Item3;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal ss = ssList.ElementAtOrDefault(i);
                    decimal r = rList.ElementAtOrDefault(i);

                    decimal ppo = ss != 0 ? 100 * r / ss : 0;
                    ppoList.Add(ppo);

                    decimal prevS = sList.LastOrDefault();
                    decimal s = prevS + (spAlpha * (ppo - prevS));
                    sList.Add(s);

                    decimal prevH = hList.LastOrDefault();
                    decimal h = ppo - s;
                    hList.Add(h);

                    var signal = GetCompareSignal(h, prevH);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (ppoList, sList, hList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateDiNapoliPreferredStochasticOscillator(StockData stockDataClass, int days = 3)
        {
            //
            // @author LazyBear 
            // 
            // List of my public indicators: http://bit.ly/1LQaPK8 
            // List of my app-store indicators: http://blog.tradingview.com/?p=970 
            //
            //study(title = "DiNapoli Preferred Stochastic Oscillator [LazyBear]", shorttitle = "DPSTOCH_LB", overlay = false)
            //fk = input(8, title = "Fast K")
            //sk = input(3, title = "Slow K")
            //sd = input(3, title = "Slow D")
            //min_ = lowest(low, fk)
            //max_ = highest(high, fk)
            //fast = (close - min_) / (max_ - min_) * 100
            //r = nz(r[1]) + (fast - nz(r[1])) / sk
            //s = nz(s[1]) + (r - nz(s[1])) / sd
            ///ob = hline(70, title = "OBLevel"), os = hline(30, title = "OSLevel"), fill(ob, os, gray)
            //plot(r, color = blue, title = "Dinapoli Stoch"), plot(s, color = red, title = "Signal")
            List<decimal> fastList = new();
            List<decimal> rList = new();
            List<decimal> sList = new();
            List<Signal> signalsList = new();

            try
            {
                int fk = (int)Math.Ceiling(days / 0.375);
                int sk = days;

                var list = VolumeInputCheck(stockDataClass, fk, true);
                var highList = list.Item1;
                var lowList = list.Item2;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal max = highList.ElementAtOrDefault(i);
                    decimal min = lowList.ElementAtOrDefault(i);

                    decimal fast = max - min != 0 ? MinOrMax((currentValue - min) / (max - min) * 100, 100, 0) : 0;
                    fastList.Add(fast);

                    decimal prevR = rList.LastOrDefault();
                    decimal r = prevR + ((fast - prevR) / sk);
                    rList.Add(r);

                    decimal prevS = sList.LastOrDefault();
                    decimal s = prevS + ((r - prevS) / sk);
                    sList.Add(s);

                    var signal = GetRsiSignal(r - s, prevR - prevS, r, prevR, 70, 30);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (fastList, rList, sList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculatePercentagePriceOscillator(StockData stockDataClass, string maType, int days = 9)
        {
            //@version=3
            // Copyright (c) 2018-present, Alex Orekhov (everget)
            // Percentage Price Oscillator script may be freely distributed under the MIT license.
            //study("Percentage Price Oscillator", shorttitle = "PPO")

            //fastLength = input(title = "Fast Length", type = integer, defval = 12)
            //slowLength = input(title = "Slow Length", type = integer, defval = 26)
            //signalLength = input(title = "Signal Length", type = integer, defval = 9)
            //src = input(title = "Source", type = source, defval = close)
            //showHistogram = input(title = "Show Histogram ?", type = bool, defval = true)
            //highlightCrossovers = input(title = "Highlight PPO/Signal Crossovers ?", type = bool, defval = true)
            //highlightZeroCrossovers = input(title = "Highlight Zero Line Crossovers ?", type = bool, defval = false)
            //applyFilling = input(title = "Apply Ribbon Filling ?", type = bool, defval = false)

            //ppo = 100 * (ema(src, fastLength) - ema(src, slowLength)) / ema(src, slowLength)
            //signal = ema(ppo, signalLength)

            //hist = ppo - signal
            //histColor = hist >= 0 ? (hist[1] < hist ? #26A69A : #B2DFDB) : (hist[1] < hist ? #FFCDD2 : #EF5350)

            //plot(showHistogram ? hist : na, title = "Histogram", style = columns, color = histColor, transp = 0)
            //hline(0, title = "Zero Line", linestyle = dotted)

            //trendColor = ppo > signal ? #0ebb23 : red

            //ppoColor = applyFilling ? trendColor : #0094ff
            //signalColor = applyFilling ? trendColor : #ff6a00

            //ppoPlot = plot(ppo, title = "PPO", color = ppoColor, transp = 0)
            //signalPlot = plot(signal, title = "Signal", color = signalColor, transp = 0)

            //transparent = color(white, 100)

            //fillColor = applyFilling ? trendColor : transparent
            //fill(ppoPlot, signalPlot, color = fillColor, transp = 70)

            //zeroCrossBgColor = highlightZeroCrossovers ? (ppo > 0 ? green : red) : transparent
            //bgcolor(zeroCrossBgColor, transp = 90)

            //plotshape(highlightCrossovers and crossover(ppo, signal) ? ppo : na, title = "Crossover", location = location.absolute, style = shape.circle, size = size.tiny, color = green, transp = 0)
            //plotshape(highlightCrossovers and crossunder(ppo, signal) ? ppo : na, title = "Crossunder", location = location.absolute, style = shape.circle, size = size.tiny, color = red, transp = 0)
            List<decimal> ppoList = new();
            List<decimal> ppoSignalLineList = new();
            List<decimal> ppoHistogramList = new();
            List<Signal> signalsList = new();

            try
            {
                int fastLength = (int)Math.Ceiling(days / 0.75);
                int slowLength = (int)Math.Ceiling(days / 0.3462);
                int signalLength = days;

                List<decimal> fastEmaList = GetMovingAverageList(maType, null, stockDataClass, fastLength);
                List<decimal> slowEmaList = GetMovingAverageList(maType, null, stockDataClass, slowLength);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal fastEma = fastEmaList.ElementAtOrDefault(i);
                    decimal slowEma = slowEmaList.ElementAtOrDefault(i);

                    decimal ppo = slowEma != 0 ? 100 * (fastEma - slowEma) / slowEma : 0;
                    ppoList.Add(ppo);
                }

                ppoSignalLineList = GetMovingAverageList(maType, ppoList, stockDataClass, signalLength);
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal ppo = ppoList.ElementAtOrDefault(j);
                    decimal ppoSignalLine = ppoSignalLineList.ElementAtOrDefault(j);

                    decimal prevPpoHistogram = ppoHistogramList.LastOrDefault();
                    decimal ppoHistogram = ppo - ppoSignalLine;
                    ppoHistogramList.Add(ppoHistogram);

                    var signal = GetCompareSignal(ppoHistogram, prevPpoHistogram);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (ppoList, ppoSignalLineList, ppoHistogramList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateMirroredPercentagePriceOscillator(
            StockData stockDataClass, string maType, int days = 9)
        {
            //@version=3
            // Copyright (c) 2018-present, Alex Orekhov (everget)
            // Percentage Price Oscillator script may be freely distributed under the MIT license.
            //study("Percentage Price Oscillator", shorttitle = "PPO")

            //fastLength = input(title = "Fast Length", type = integer, defval = 12)
            //slowLength = input(title = "Slow Length", type = integer, defval = 26)
            //signalLength = input(title = "Signal Length", type = integer, defval = 9)
            //src = input(title = "Source", type = source, defval = close)
            //showHistogram = input(title = "Show Histogram ?", type = bool, defval = true)
            //highlightCrossovers = input(title = "Highlight PPO/Signal Crossovers ?", type = bool, defval = true)
            //highlightZeroCrossovers = input(title = "Highlight Zero Line Crossovers ?", type = bool, defval = false)
            //applyFilling = input(title = "Apply Ribbon Filling ?", type = bool, defval = false)

            //ppo = 100 * (ema(src, fastLength) - ema(src, slowLength)) / ema(src, slowLength)
            //signal = ema(ppo, signalLength)

            //hist = ppo - signal
            //histColor = hist >= 0 ? (hist[1] < hist ? #26A69A : #B2DFDB) : (hist[1] < hist ? #FFCDD2 : #EF5350)

            //plot(showHistogram ? hist : na, title = "Histogram", style = columns, color = histColor, transp = 0)
            //hline(0, title = "Zero Line", linestyle = dotted)

            //trendColor = ppo > signal ? #0ebb23 : red

            //ppoColor = applyFilling ? trendColor : #0094ff
            //signalColor = applyFilling ? trendColor : #ff6a00

            //ppoPlot = plot(ppo, title = "PPO", color = ppoColor, transp = 0)
            //signalPlot = plot(signal, title = "Signal", color = signalColor, transp = 0)

            //transparent = color(white, 100)

            //fillColor = applyFilling ? trendColor : transparent
            //fill(ppoPlot, signalPlot, color = fillColor, transp = 70)

            //zeroCrossBgColor = highlightZeroCrossovers ? (ppo > 0 ? green : red) : transparent
            //bgcolor(zeroCrossBgColor, transp = 90)

            //plotshape(highlightCrossovers and crossover(ppo, signal) ? ppo : na, title = "Crossover", location = location.absolute, style = shape.circle, size = size.tiny, color = green, transp = 0)
            //plotshape(highlightCrossovers and crossunder(ppo, signal) ? ppo : na, title = "Crossunder", location = location.absolute, style = shape.circle, size = size.tiny, color = red, transp = 0)

            // @author lazybear 
            // list of all my indicators: 
            // https://docs.google.com/document/d/15agcufjz8ciuvwfj9w-ikns88gkwokbcvbymevm5mlo/edit?usp=sharing
            //
            //study("Mirrored MACD [LazyBear]", shorttitle = "MIRRMACD_LB")
            //length = input(20), siglength = input(9)
            //colorBars = input(false, title = "Color bars?")
            //ma(s, l) => ema(s, l)
            //mao = ma(open, length), mac = ma(close, length)
            //mc = mac - mao, mo = mao - mac, signal = sma(mc, siglength)
            //plot(0, title = "ZeroLine", color = gray)

            //plot(mc, color = green, linewidth = 2, style = histogram, title = "BullHisto")
            //plot(mo, color = red, linewidth = 2, style = histogram, title = "BearHisto")
            //plot(mo, color = red, linewidth = 2, title = "BearLine")
            //plot(mc, color = green, linewidth = 2, title = "BullLine")
            //plot(signal, color = blue, linewidth = 2, title = "Signal")

            //us = max(mc, mo), bc = us >= signal ? (us == mc ? lime : maroon) : na
            //barcolor(colorBars ? bc : na)
            List<decimal> ppoList = new();
            List<decimal> ppoSignalLineList = new();
            List<decimal> ppoHistogramList = new();
            List<decimal> ppoMirrorList = new();
            List<decimal> ppoMirrorSignalLineList = new();
            List<decimal> ppoMirrorHistogramList = new();
            List<Signal> signalsList = new();

            try
            {
                int length = (int)Math.Ceiling(days / 0.45);
                int signalPeriod = days;

                List<decimal> emaOpenList = GetMovingAverageList(maType, stockDataClass.OpenPrices, stockDataClass, length);
                List<decimal> emaCloseList = GetMovingAverageList(maType, stockDataClass.ClosePrices, stockDataClass, length);

                for (int i = 0; i < stockDataClass.OpenPrices.Count; i++)
                {
                    decimal mao = emaOpenList.ElementAtOrDefault(i);
                    decimal mac = emaCloseList.ElementAtOrDefault(i);
                    decimal macd = mac - mao;
                    decimal macdMirror = mao - mac;

                    decimal ppo = mao != 0 ? macd / mao * 100 : 0;
                    ppoList.Add(ppo);

                    decimal ppoMirror = mac != 0 ? macdMirror / mac * 100 : 0;
                    ppoMirrorList.Add(ppoMirror);
                }

                ppoSignalLineList = GetMovingAverageList(maType, ppoList, stockDataClass, signalPeriod);
                ppoMirrorSignalLineList = GetMovingAverageList(maType, ppoMirrorList, stockDataClass, signalPeriod);
                for (int j = 0; j < stockDataClass.OpenPrices.Count; j++)
                {
                    decimal ppo = ppoList.ElementAtOrDefault(j);
                    decimal ppoSignalLine = ppoSignalLineList.ElementAtOrDefault(j);
                    decimal ppoMirror = ppoMirrorList.ElementAtOrDefault(j);
                    decimal ppoMirrorSignalLine = ppoMirrorSignalLineList.ElementAtOrDefault(j);

                    decimal prevPpoHistogram = ppoHistogramList.LastOrDefault();
                    decimal ppoHistogram = ppo - ppoSignalLine;
                    ppoHistogramList.Add(ppoHistogram);

                    decimal ppoMirrorHistogram = ppoMirror - ppoMirrorSignalLine;
                    ppoMirrorHistogramList.Add(ppoMirrorHistogram);

                    var signal = GetCompareSignal(ppoHistogram, prevPpoHistogram);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (ppoList, ppoMirrorList, ppoSignalLineList, ppoMirrorSignalLineList, ppoHistogramList, ppoMirrorHistogramList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateDidiIndex(StockData stockDataClass, string maType, int days = 3)
        {
            //@version=3
            // Copyright (c) 2018-present, Alex Orekhov (everget)
            // Didi Index script may be freely distributed under the MIT license.
            //study("Didi Index")

            //curtaLength = input(title = "Curta (Short) Length", type = integer, defval = 3)
            //mediaLength = input(title = "Media (Medium) Length", type = integer, defval = 8)
            //longaLength = input(title = "Longa (Long) Length", type = integer, defval = 20)
            //src = input(title = "Source", type = source, defval = close)
            //applyFilling = input(title = "Apply Ribbon Filling ?", type = bool, defval = true)
            //highlightCrossovers = input(title = "Highlight Crossovers ?", type = bool, defval = true)

            //media = sma(src, mediaLength)
            //curta = sma(src, curtaLength) / media
            //longa = sma(src, longaLength) / media

            //curtaPlot = plot(curta, title = "Curta", color = green)
            //plot(1, title = "Media", color = black, transp = 0)
            //longaPlot = plot(longa, title = "Longa", color = red)

            //fillColor = applyFilling ? (curta > longa ? #0ebb23 : red) : color(white, 100) 
            //fill(curtaPlot, longaPlot, color = fillColor, transp = 80)

            //plotshape(crossover(curta, longa) and highlightCrossovers ? avg(longa, longa[1]) : na, title = "Crossover", location = location.absolute, style = shape.circle, size = size.tiny, color = green, transp = 20)
            //plotshape(crossunder(curta, longa) and highlightCrossovers ? avg(longa, longa[1]) : na, title = "Crossunder", location = location.absolute, style = shape.circle, size = size.tiny, color = red, transp = 20)
            List<decimal> curtaList = new();
            List<decimal> longaList = new();
            List<Signal> signalsList = new();

            try
            {
                int shortLength = days;
                int mediumLength = (int)Math.Ceiling(days / 0.375);
                int longLength = (int)Math.Ceiling(days / 0.15);

                var mediumSmaList = GetMovingAverageList(maType, null, stockDataClass, mediumLength);
                var shortSmaList = GetMovingAverageList(maType, null, stockDataClass, shortLength);
                var longSmaList = GetMovingAverageList(maType, null, stockDataClass, longLength);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal mediumSma = mediumSmaList.ElementAtOrDefault(i);
                    decimal shortSma = shortSmaList.ElementAtOrDefault(i);
                    decimal longSma = longSmaList.ElementAtOrDefault(i);

                    decimal prevCurta = curtaList.LastOrDefault();
                    decimal curta = mediumSma != 0 ? shortSma / mediumSma : 0;
                    curtaList.Add(curta);

                    decimal prevLonga = longaList.LastOrDefault();
                    decimal longa = mediumSma != 0 ? longSma / mediumSma : 0;
                    longaList.Add(longa);

                    var signal = GetCompareSignal(curta - longa, prevCurta - prevLonga);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (curtaList, longaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateStiffnessIndicator(StockData stockDataClass, int days = 60)
        {
            //@version=3
            // Copyright (c) 2018-present, Alex Orekhov (everget)
            // Stiffness Indicator script may be freely distributed under the MIT license.
            //study("Stiffness Indicator", shorttitle = "Stiffness")

            //maLength = input(title = "Moving Average Length", minval = 1, defval = 100)
            //stiffLength = input(title = "Stiffness Length", minval = 1, defval = 60)
            //stiffSmooth = input(title = "Stiffness Smoothing Length", minval = 1, defval = 3)
            //threshold = input(title = "Threshold", minval = 1, defval = 90)
            //highlightThresholdCrossovers = input(title = "Highlight Threshold Crossovers ?", type = bool, defval = false)

            //bound = sma(close, maLength) - 0.2 * stdev(close, maLength)
            //sumAbove = sum(close > bound ? 1 : 0, stiffLength)
            //stiffness = ema(sumAbove * 100 / stiffLength, stiffSmooth)

            //transparent = color(white, 100)

            //bgColor = highlightThresholdCrossovers ? (stiffness > threshold ? #0ebb23 : red) : transparent
            //bgcolor(bgColor, transp = 90)

            //plot(stiffness, title = "Stiffness", style = histogram, color =#f5c75e, transp=0)
            //plot(threshold, title = "Threshold", color = red, transp = 0)
            List<decimal> boundList = new();
            List<decimal> sumAboveList = new();
            List<decimal> aboveList = new();
            List<decimal> stiffValueList = new();
            List<decimal> stiffnessList = new();
            List<Signal> signalsList = new();
            decimal threshold = 90;

            try
            {
                int stiffLength = days;
                int maLength = MinOrMax((int)Math.Ceiling(stiffLength / 0.6));
                int smoothLength = MinOrMax((int)Math.Ceiling(stiffLength / 0.05));

                var smaList = CalculateSimpleMovingAverage(stockDataClass, maLength).Item1;
                var stdDevList = CalculateStandardDeviationVolatility(null, stockDataClass, maLength).Item4;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal sma = smaList.ElementAtOrDefault(i);
                    decimal stdDev = stdDevList.ElementAtOrDefault(i);

                    decimal bound = sma - (0.2m * stdDev);
                    boundList.Add(bound);

                    decimal above = currentValue > bound ? 1 : 0;
                    aboveList.Add(above);

                    decimal aboveSum = aboveList.TakeLast(stiffLength).Sum();
                    sumAboveList.Add(aboveSum);

                    decimal stiffValue = stiffLength != 0 ? aboveSum * 100 / stiffLength : 0;
                    stiffValueList.Add(stiffValue);

                    decimal prevStiffnessEma = stiffnessList.LastOrDefault();
                    decimal stiffnessEma = CalculateExponentialMovingAverage(stiffValue, stiffnessList.LastOrDefault(), smoothLength);
                    stiffnessList.Add(stiffnessEma);

                    var signal = GetCompareSignal(stiffnessEma - threshold, prevStiffnessEma - threshold);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (boundList, aboveList, sumAboveList, stiffValueList, stiffnessList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateTrendDetectionIndex(StockData stockDataClass, int days = 20)
        {
            //@version=3
            // Copyright (c) 2018-present, Alex Orekhov (everget)
            // Trend Detection Index script may be freely distributed under the MIT license.
            //study("Trend Detection Index", shorttitle = "TDI")

            //length = input(title = "Length", type = integer, defval = 20)
            //highlightCrossovers = input(title = "Highlight Crossovers ?", type = bool, defval = true)
            //src = input(title = "Source", type = source, defval = close)

            //mom = change(src, length)
            //tdi = abs(sum(mom, length)) - sum(abs(mom), length * 2) + sum(abs(mom), length)

            // Direction Indicator
            //tdiDirection = sum(mom, length)

            //plot(tdi, title = "TDI", color =#45a338, transp=0)
            //plot(tdiDirection, title = "Direction", color =#ff3013, transp=0)

            //hline(0, title = "Zero Level", linestyle = dotted)

            //plotshape(crossover(tdi, tdiDirection) and highlightCrossovers ? avg(tdi, tdiDirection) : na, title = "Crossover", location = location.absolute, style = shape.circle, size = size.tiny, color = green, transp = 20)
            //plotshape(crossunder(tdi, tdiDirection) and highlightCrossovers ? avg(tdi, tdiDirection) : na, title = "Crossunder", location = location.absolute, style = shape.circle, size = size.tiny, color = red, transp = 20)
            List<decimal> tdiList = new();
            List<decimal> momList = new();
            List<decimal> tdiDirectionList = new();
            List<decimal> momAbsList = new();
            List<decimal> momAbsSum1List = new();
            List<decimal> momAbsSum2List = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= days ? stockDataClass.InputValues.ElementAtOrDefault(i - days) : 0;

                    decimal mom = currentValue - prevValue;
                    momList.Add(mom);

                    decimal momAbs = Math.Abs(mom);
                    momAbsList.Add(momAbs);

                    decimal prevTdiDirection = tdiDirectionList.LastOrDefault();
                    decimal tdiDirection = momList.TakeLast(days).Sum();
                    tdiDirectionList.Add(tdiDirection);

                    decimal momAbsSum1 = momAbsList.TakeLast(days).Sum();
                    momAbsSum1List.Add(momAbsSum1);

                    decimal momAbsSum2 = momAbsList.TakeLast(days * 2).Sum();
                    momAbsSum2List.Add(momAbsSum2);

                    decimal prevTdi = tdiList.LastOrDefault();
                    decimal tdi = Math.Abs(tdiDirection) - momAbsSum2 + momAbsSum1;
                    tdiList.Add(tdi);

                    var signal = GetCompareSignal(tdiDirection - tdi, prevTdiDirection - prevTdi);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (tdiDirectionList, momAbsSum1List, momAbsSum2List, tdiList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateMorphedSineWave(StockData stockDataClass, int days = 14)
        {
            //@version=3
            //study("Morphed Sine Wave", overlay = true)
            //length = input(14),power = input(100, type = float)
            //
            //src = input(close)
            //p = length / (2 * 3.14159)
            //c = (src * power) + sin(n / p)
            //s = c / power
            //
            //plot(s, title = "Morphed", color =#ff9800,linewidth=2,transp=0)
            //plot(s, title = "Forecast", color =#2196f3,linewidth=2,transp=0,offset=length)
            List<decimal> cList = new();
            List<decimal> sList = new();
            List<Signal> signalsList = new();
            decimal power = 100;

            try
            {
                decimal p = days / (2 * (decimal)Math.PI);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevS1 = i >= 1 ? sList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevS2 = i >= 2 ? sList.ElementAtOrDefault(i - 2) : 0;

                    decimal c = (currentValue * power) + (decimal)Sin(i / (double)p);
                    cList.Add(c);

                    decimal s = c / power;
                    sList.Add(s);

                    var signal = GetCompareSignal(s - prevS1, prevS1 - prevS2);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (cList, sList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateDynamicallyAdjustableFilter(StockData stockDataClass, int days = 14)
        {
            //@version=3
            //study("Dynamically Adjustable Filter", overlay = true)
            //length = input(14),ac = input(false, title = "Lag Reduction")
            //----
            //source = input(close)
            //AC = ac ? 1 : 0
            //out = 0.
            //K = 0.
            //----
            //src = source + (source - nz(out[1], source))
            //out := nz(out[1], src) + nz(K[1]) * (src - nz(out[1], src)) + AC * (nz(K[1]) * (src - sma(src, length)))
            //K:= abs(src - out) / (abs(src - out) + stdev(src, length) * length)
            //----
            //plot(out, color = red, linewidth = 2, transp = 0)
            List<decimal> outList = new();
            List<decimal> outLagList = new();
            List<decimal> kList = new();
            List<decimal> kLagList = new();
            List<decimal> srcList = new();
            List<decimal> srcLagList = new();
            List<decimal> srcSmaList = new();
            List<decimal> srcDevList = new();
            List<decimal> srcPowList = new();
            List<decimal> srcPowAvgList = new();
            List<decimal> srcStdDevList = new();
            List<decimal> srcSmaLagList = new();
            List<decimal> srcDevLagList = new();
            List<decimal> srcPowLagList = new();
            List<decimal> srcPowAvgLagList = new();
            List<decimal> srcStdDevLagList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevOut = i >= 1 ? outList.ElementAtOrDefault(i - 1) : currentValue;
                    decimal prevOutLag = i >= 1 ? outLagList.ElementAtOrDefault(i - 1) : currentValue;
                    decimal prevK = i >= 1 ? kList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevKLag = i >= 1 ? kLagList.ElementAtOrDefault(i - 1) : 0;

                    decimal src = currentValue + (currentValue - prevOut);
                    srcList.Add(src);

                    decimal srcLag = currentValue + (currentValue - prevOutLag);
                    srcLagList.Add(srcLag);

                    decimal outVal = prevOut + (prevK * (src - prevOut));
                    outList.Add(outVal);

                    decimal srcSma = srcList.TakeLast(days).Average();
                    srcSmaList.Add(srcSma);

                    decimal srcSmaLag = srcLagList.TakeLast(days).Average();
                    srcSmaLagList.Add(srcSmaLag);

                    decimal outValLag = prevOutLag + (prevKLag * (srcLag - prevOutLag)) + (prevKLag * (srcLag - srcSmaLag));
                    outLagList.Add(outValLag);

                    decimal srcDev = src - srcSma;
                    srcDevList.Add(srcDev);

                    decimal srcPow = Pow(srcDev, 2);
                    srcPowList.Add(srcPow);

                    decimal srcPowAvg = srcPowList.TakeLast(days).Average();
                    srcPowAvgList.Add(srcPowAvg);

                    decimal srcStdDev = srcPowAvg >= 0 ? (decimal)Sqrt((double)srcPowAvg) : 0;
                    srcStdDevList.Add(srcStdDev);

                    decimal srcDevLag = srcLag - srcSmaLag;
                    srcDevLagList.Add(srcDevLag);

                    decimal srcPowLag = Pow(srcDevLag, 2);
                    srcPowLagList.Add(srcPowLag);

                    decimal srcPowAvgLag = srcPowLagList.TakeLast(days).Average();
                    srcPowAvgLagList.Add(srcPowAvgLag);

                    decimal srcStdDevLag = srcPowAvgLag >= 0 ? (decimal)Sqrt((double)srcPowAvgLag) : 0;
                    srcStdDevLagList.Add(srcStdDevLag);

                    decimal k = src - outVal != 0 ? Math.Abs(src - outVal) / (Math.Abs(src - outVal) + (srcStdDev * days)) : 0;
                    kList.Add(k);

                    decimal kLag = srcLag - outValLag != 0 ? Math.Abs(srcLag - outValLag) / (Math.Abs(srcLag - outValLag) + (srcStdDevLag * days)) : 0;
                    kLagList.Add(kLag);

                    var signal = GetCompareSignal(currentValue - outVal, prevValue - prevOut);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (srcList, srcSmaList, srcDevList, srcPowList, srcPowAvgList, srcStdDevList, kList, outList,
                srcLagList, srcSmaLagList, srcDevLagList, srcPowLagList, srcPowAvgLagList, srcStdDevLagList, kLagList, outLagList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateDynamicallyAdjustableMovingAverage(StockData stockDataClass, int days = 6)
        {
            //@version=2
            //study("Dynamically Adjustable Moving Average", shorttitle = "AMA", overlay = true)
            //short = input(6),long = input(200), Css = input(false, title = "Conditional Colors")
            //
            //a = stdev(close, short)
            //b = stdev(close, long)
            //v = b / a + short
            //----
            //p = round(v)
            //k = cum(close)
            //ama = (k - k[p]) / p
            //----
            //css = Css ? iff(close > ama,#40FF00,#FF0000) : #2E9AFE
            //plot(ama, color = css, linewidth = 2, transp = 0)
            List<decimal> vList = new();
            List<decimal> kList = new();
            List<decimal> amaList = new();
            List<decimal> tempList = new();
            List<Signal> signalsList = new();

            try
            {
                int longLength = MinOrMax((int)Math.Ceiling(days / 0.03));

                var shortStdDevList = CalculateStandardDeviationVolatility(null, stockDataClass, days).Item4;
                var longStdDevList = CalculateStandardDeviationVolatility(null, stockDataClass, longLength).Item4;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal a = shortStdDevList.ElementAtOrDefault(i);
                    decimal b = longStdDevList.ElementAtOrDefault(i);

                    decimal prevValue = tempList.LastOrDefault();
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    tempList.Add(currentValue);

                    decimal v = a != 0 ? (b / a) + days : days;
                    vList.Add(v);

                    int p = 0;
                    try
                    {
                        p = (int)Math.Round(v);
                    }
                    catch
                    {
                        p = longLength;
                    }

                    decimal prevK = i >= p ? kList.ElementAtOrDefault(i - p) : 0;
                    decimal k = tempList.Sum();
                    kList.Add(k);

                    decimal prevAma = amaList.LastOrDefault();
                    decimal ama = p != 0 ? (k - prevK) / p : 0;
                    amaList.Add(ama);

                    var signal = GetCompareSignal(currentValue - ama, prevValue - prevAma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (vList, kList, amaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculatePhaseChangeIndex(StockData stockDataClass, string maType, int days = 3)
        {
            //@version=3
            // Copyright (c) 2018-present, Alex Orekhov (everget)
            // Phase Change Index script may be freely distributed under the MIT license.
            //study("Phase Change Index", shorttitle = "PCI")

            //length = input(title = "Length", type = integer, minval = 1, defval = 35)
            //upperLevel = input(title = "Upper Level", type = integer, defval = 80)
            //lowerLevel = input(title = "Lower Level", type = integer, defval = 20)
            //highlightBreakouts = input(title = "Highlight Overbought/Oversold Breakouts ?", type = bool, defval = true)
            //applySmoothing = input(title = "Apply Smoothing ?", type = bool, defval = false)
            //smoothingType = input(title = "Smoothing Type", defval = "SMA", options =["EMA", "SMA", "VWMA", "WMA"])
            //smoothingLength = input(title = "Smoothing Length", type = integer, minval = 1, defval = 3)
            //src = input(title = "Source", type = source, defval = close)

            //getMA(src, length) =>
            //    ma = 0.0
            //    if smoothingType == "EMA"
            //        ma:= ema(src, length)
            //    if smoothingType == "SMA"
            //        ma:= sma(src, length)
            //    if smoothingType == "VWMA"
            //        ma:= vwma(src, length)
            //    if smoothingType == "WMA"
            //        ma:= wma(src, length)
            //    ma

            //mom = change(src, length)
            //positiveSum = 0.0
            //negativeSum = 0.0

            //for i = 0 to length - 1

            //    gradient = nz(src[length]) + mom * (length - i) / (length - 1)
            //    deviation = nz(src[length - i]) - gradient

            //    if deviation > 0
            //        positiveSum:= positiveSum + deviation
            //    else
            //        negativeSum:= negativeSum - deviation

            //sum = positiveSum + negativeSum
            //pci = sum != 0 ? 100 * positiveSum / sum : 0
            //pci:= applySmoothing ? getMA(pci, smoothingLength) : pci

            //pciColor = pci > upperLevel ? #0ebb23 : pci < lowerLevel ? #ff0000 : #f4b77d
            //plot(pci, title = "PCI", linewidth = 2, color = pciColor, transp = 0)

            //transparent = color(white, 100)

            //maxLevelPlot = hline(100, title = "Max Level", linestyle = dotted, color = transparent)
            //upperLevelPlot = hline(upperLevel, title = "Upper Level", linestyle = dotted)
            //hline(50, title = "Middle Level", linestyle = dotted)
            //lowerLevelPlot = hline(lowerLevel, title = "Lower Level", linestyle = dotted)
            //minLevelPlot = hline(0, title = "Min Level", linestyle = dotted, color = transparent)

            //fill(upperLevelPlot, lowerLevelPlot, color = purple, transp = 95)

            //upperFillColor = pci > upperLevel and highlightBreakouts ? green: transparent
            //lowerFillColor = pci < lowerLevel and highlightBreakouts ? red: transparent

            //fill(maxLevelPlot, upperLevelPlot, color = upperFillColor, transp = 90)
            //fill(minLevelPlot, lowerLevelPlot, color = lowerFillColor, transp = 90)
            List<decimal> pciList = new();
            List<decimal> pciSmoothedList = new();
            List<decimal> positiveSumList = new();
            List<decimal> negativeSumList = new();
            List<decimal> sumList = new();
            List<Signal> signalsList = new();

            try
            {
                int smoothLength = days;
                int length = (int)Math.Ceiling(days / 0.0858);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= length ? stockDataClass.InputValues.ElementAtOrDefault(i - length) : 0;
                    decimal mom = currentValue - prevValue;

                    decimal positiveSum = 0, negativeSum = 0;
                    for (int j = 0; j <= length - 1; j++)
                    {
                        decimal prevValue2 = i >= length - j ? stockDataClass.InputValues.ElementAtOrDefault(i - (length - j)) : 0;
                        decimal gradient = prevValue + (mom * (length - j) / (length - 1));
                        decimal deviation = prevValue2 - gradient;

                        positiveSum = deviation > 0 ? positiveSum + deviation : positiveSum + 0;
                        negativeSum = deviation < 0 ? negativeSum - deviation : negativeSum + 0;
                    }
                    positiveSumList.Add(positiveSum);
                    negativeSumList.Add(negativeSum);

                    decimal sum = positiveSum + negativeSum;
                    sumList.Add(sum);

                    decimal pci = sum != 0 ? MinOrMax(100 * positiveSum / sum, 100, 0) : 0;
                    pciList.Add(pci);
                }

                pciSmoothedList = GetMovingAverageList(maType, pciList, stockDataClass, smoothLength);
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal pciSmoothed = pciSmoothedList.ElementAtOrDefault(j);
                    decimal prevPciSmoothed1 = j >= 1 ? pciSmoothedList.ElementAtOrDefault(j - 1) : 0;
                    decimal prevPciSmoothed2 = j >= 2 ? pciSmoothedList.ElementAtOrDefault(j - 2) : 0;

                    var signal = GetRsiSignal(pciSmoothed - prevPciSmoothed1, prevPciSmoothed1 - prevPciSmoothed2, pciSmoothed, prevPciSmoothed1, 80, 20);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (positiveSumList, negativeSumList, sumList, pciList, pciSmoothedList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateVolatilityRatio(StockData stockDataClass,
             int days = 14)
        {
            //@version=3
            // Copyright (c) 2018-present, Alex Orekhov (everget)
            // Volatility Ratio script may be freely distributed under the MIT license.
            //study("Volatility Ratio", shorttitle = "VR")

            //length = input(title = "Length", type = integer, minval = 1, defval = 14)
            //breakoutLevel = input(title = "Breakout Level", type = float, minval = 0, step = 0.1, defval = 0.5)

            //_highest(length, start) =>
            //    out = nz(high[start])
            //    for i = start + 1 to length - 1
            //        prev = nz(high[i])
            //        out := out < prev ? prev : out
            //    out

            //_lowest(length, start) =>
            //    out = nz(low[start])
            //    for i = start + 1 to length - 1
            //        prev = nz(low[i])
            //        out := out > prev ? prev : out
            //    out

            //max = max(_highest(length, 1), close[length + 1])
            //min = min(_lowest(length, 1), close[length + 1])

            //vr = tr(true) / (max - min)

            //vrColor = vr >= breakoutLevel ? #ff9800 : #3c78d8

            //plot(vr, title = "VR", color = vrColor, transp = 0)

            //hline(breakoutLevel, title = "Breakout Level", linestyle = dotted)

            //breakoutFillColor = vr >= breakoutLevel ? #ff9800 : color(white, 100)
            //bgcolor(breakoutFillColor, transp = 90)
            List<decimal> maxList = new();
            List<decimal> minList = new();
            List<decimal> vrList = new();
            List<Signal> signalsList = new();
            decimal breakoutLevel = 0.5m;

            try
            {
                var trList = CalculateVortexIndicator(stockDataClass, days).Item5;
                List<decimal> emaList = CalculateExponentialMovingAverage(stockDataClass, days).Item1;
                var minMaxList = VolumeInputCheck(stockDataClass, days, true);
                var highestList = minMaxList.Item1;
                var lowestList = minMaxList.Item2;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal currentTrueRange = trList.ElementAtOrDefault(i);
                    decimal currentEma = emaList.ElementAtOrDefault(i);
                    decimal prevHighest = i >= 1 ? highestList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevLowest = i >= 1 ? lowestList.ElementAtOrDefault(i - 1) : 0;
                    decimal priorValue = i >= days + 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - (days + 1)) : 0;
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevEma = i >= 1 ? emaList.ElementAtOrDefault(i - 1) : 0;

                    decimal max = priorValue != 0 ? Math.Max(prevHighest, priorValue) : prevHighest;
                    maxList.Add(max);

                    decimal min = priorValue != 0 ? Math.Min(prevLowest, priorValue) : prevLowest;
                    minList.Add(min);

                    decimal vr = max - min != 0 ? currentTrueRange / (max - min) : 0;
                    vrList.Add(vr);

                    var signal = GetVolatilitySignal(currentValue - currentEma, prevValue - prevEma, vr, breakoutLevel);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (maxList, minList, vrList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateDampingIndex(StockData stockDataClass, int days = 5)
        {
            //@version=3
            // Copyright (c) 2018-present, Alex Orekhov (everget)
            // Damping Index script may be freely distributed under the MIT license.
            //study("Damping Index", shorttitle = "DI")

            //smaLength = input(title = "SMA Length", type = integer, defval = 5)
            //threshold = input(title = "Threshold", type = float, step = 0.1, defval = 1.5)

            //sma = sma(high - low, smaLength)

            //di = sma[1] / sma[6]

            //diColor = di >= threshold ? #ff9800 : #3c78d8
            //plot(di, color = diColor, transp = 0)

            //hline(threshold, title = "Threshold", linestyle = dotted)

            //breakoutFillColor = di >= threshold ? #ff9800 : color(white, 100)
            //bgcolor(breakoutFillColor, transp = 90)
            List<decimal> rangeList = new();
            List<decimal> rangeSmaList = new();
            List<decimal> diList = new();
            List<Signal> signalsList = new();
            decimal threshold = 1.5m;

            try
            {
                List<decimal> emaList = CalculateExponentialMovingAverage(stockDataClass, days).Item1;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal currentHigh = stockDataClass.HighPrices.ElementAtOrDefault(i);
                    decimal currentLow = stockDataClass.LowPrices.ElementAtOrDefault(i);
                    decimal currentEma = emaList.ElementAtOrDefault(i);
                    decimal prevSma1 = i >= 1 ? rangeSmaList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevSma6 = i >= 6 ? rangeSmaList.ElementAtOrDefault(i - 6) : 0;
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevEma = i >= 1 ? emaList.ElementAtOrDefault(i - 1) : 0;

                    decimal range = currentHigh - currentLow;
                    rangeList.Add(range);

                    decimal rangeSma = rangeList.TakeLast(days).Average();
                    rangeSmaList.Add(rangeSma);

                    decimal di = prevSma6 != 0 ? prevSma1 / prevSma6 : 0;
                    diList.Add(di);

                    var signal = GetVolatilitySignal(currentValue - currentEma, prevValue - prevEma, di, threshold);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (rangeSmaList, diList, signalsList);
        }

        public static (List<decimal>, List<Signal>) CalculateMayerMultiple(StockData stockDataClass, string maType, int days = 200)
        {
            //@version=3
            // Copyright (c) 2018-present, Alex Orekhov (everget)
            // Mayer Multiple script may be freely distributed under the MIT license.
            //study("Mayer Multiple", shorttitle = "MM")

            //smaLength = input(title = "SMA Length", type = integer, defval = 200)
            //threshold = input(title = "Threshold", type = float, step = 0.1, defval = 2.4)

            //price = nz(security("BTCUSD", period, close))

            //mm = price / sma(price, smaLength)

            //mmColor = mm > threshold ? #ff9800 : #3c78d8
            //plot(mm, color = mmColor, transp = 0)

            //hline(threshold, title = "Threshold", linestyle = dotted)

            //breakoutFillColor = mm > threshold ? #ff9800 : color(white, 100)
            //bgcolor(breakoutFillColor, transp = 90)
            List<decimal> mmList = new();
            List<Signal> signalsList = new();
            decimal threshold = 2.4m;

            try
            {
                List<decimal> emaList = CalculateExponentialMovingAverage(stockDataClass, days).Item1;
                List<decimal> smaList = GetMovingAverageList(maType, null, stockDataClass, days);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal currentSma = smaList.ElementAtOrDefault(i);
                    decimal currentEma = emaList.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevEma = i >= 1 ? emaList.ElementAtOrDefault(i - 1) : 0;

                    decimal mm = currentSma != 0 ? currentValue / currentSma : 0;
                    mmList.Add(mm);

                    var signal = GetVolatilitySignal(currentValue - currentEma, prevValue - prevEma, mm, threshold);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (mmList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateMirroredMovingAverageConvergenceDivergence(
            StockData stockDataClass, string maType, int days = 9)
        {
            // @author lazybear 
            // list of all my indicators: 
            // https://docs.google.com/document/d/15agcufjz8ciuvwfj9w-ikns88gkwokbcvbymevm5mlo/edit?usp=sharing
            //
            //study("Mirrored MACD [LazyBear]", shorttitle = "MIRRMACD_LB")
            //length = input(20),
            //siglength = input(9)
            //colorBars = input(false, title = "Color bars?")
            //ma(s, l) => ema(s, l)
            //mao = ma(open, length), mac = ma(close, length)
            //mc = mac - mao, mo = mao - mac, signal = sma(mc, siglength)
            //plot(0, title = "ZeroLine", color = gray)

            //plot(mc, color = green, linewidth = 2, style = histogram, title = "BullHisto")
            //plot(mo, color = red, linewidth = 2, style = histogram, title = "BearHisto")
            //plot(mo, color = red, linewidth = 2, title = "BearLine")
            //plot(mc, color = green, linewidth = 2, title = "BullLine")
            //plot(signal, color = blue, linewidth = 2, title = "Signal")

            //us = max(mc, mo), bc = us >= signal ? (us == mc ? lime : maroon) : na
            //barcolor(colorBars ? bc : na)
            List<decimal> macdList = new();
            List<decimal> macdSignalLineList = new();
            List<decimal> macdHistogramList = new();
            List<decimal> macdMirrorList = new();
            List<decimal> macdMirrorSignalLineList = new();
            List<decimal> macdMirrorHistogramList = new();
            List<Signal> signalsList = new();

            try
            {
                int length = (int)Math.Ceiling(days / 0.45);
                int signalPeriod = days;

                List<decimal> emaOpenList = GetMovingAverageList(maType, stockDataClass.OpenPrices, stockDataClass, length);
                List<decimal> emaCloseList = GetMovingAverageList(maType, stockDataClass.ClosePrices, stockDataClass, length);

                for (int i = 0; i < emaOpenList.Count; i++)
                {
                    decimal mao = emaOpenList.ElementAtOrDefault(i);
                    decimal mac = emaCloseList.ElementAtOrDefault(i);

                    decimal macd = mac - mao;
                    macdList.Add(macd);

                    decimal macdMirror = mao - mac;
                    macdMirrorList.Add(macdMirror);

                    decimal macdSignalLine = CalculateExponentialMovingAverage(macd, macdSignalLineList.LastOrDefault(), signalPeriod);
                    macdSignalLineList.Add(macdSignalLine);

                    decimal macdMirrorSignalLine = CalculateExponentialMovingAverage(macdMirror, macdMirrorSignalLineList.LastOrDefault(), signalPeriod);
                    macdMirrorSignalLineList.Add(macdMirrorSignalLine);

                    decimal prevMacdHistogram = macdHistogramList.LastOrDefault();
                    decimal macdHistogram = macd - macdSignalLine;
                    macdHistogramList.Add(macdHistogram);

                    decimal macdMirrorHistogram = macdMirror - macdMirrorSignalLine;
                    macdMirrorHistogramList.Add(macdMirrorHistogram);

                    var signal = GetCompareSignal(macdHistogram, prevMacdHistogram);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (macdList, macdMirrorList, macdSignalLineList, macdMirrorSignalLineList, macdHistogramList, macdMirrorHistogramList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateImpulseMovingAverageConvergenceDivergence(StockData stockDataClass, string maType, int days = 9)
        {
            // @author LazyBear 
            // 
            // List of my public indicators: http://bit.ly/1LQaPK8 
            // List of my app-store indicators: http://blog.tradingview.com/?p=970 
            //
            //
            //study("Impulse MACD [LazyBear]", shorttitle = "IMACD_LB", overlay = false)
            //lengthMA = input(34)
            //lengthSignal = input(9)
            //calc_smma(src, len) =>
            //    smma = na(smma[1]) ? sma(src, len) : (smma[1] * (len - 1) + src) / len

            //calc_zlema(src, length) =>
            //    ema1 = ema(src, length)
            //    ema2 = ema(ema1, length)
            //    d = ema1 - ema2
            //    ema1 + d

            //src = hlc3
            //hi = calc_smma(high, lengthMA)
            //lo = calc_smma(low, lengthMA)
            //mi = calc_zlema(src, lengthMA)

            //md = (mi > hi) ? (mi - hi) : (mi < lo) ? (mi - lo) : 0
            //sb = sma(md, lengthSignal)
            //sh = md - sb
            //mdc = src > mi ? src > hi ? lime : green : src < lo ? red : orange
            //plot(0, color = gray, linewidth = 1, title = "MidLine")
            //plot(md, color = mdc, linewidth = 2, title = "ImpulseMACD", style = histogram)
            //plot(sh, color = blue, linewidth = 2, title = "ImpulseHisto", style = histogram)
            //plot(sb, color = maroon, linewidth = 2, title = "ImpulseMACDCDSignal")

            //ebc = input(false, title = "Enable bar colors")
            //barcolor(ebc ? mdc : na)
            List<decimal> macdList = new();
            List<decimal> macdSignalLineList = new();
            List<decimal> macdHistogramList = new();
            List<Signal> signalsList = new();

            try
            {
                int signalPeriod = days;
                int length = (int)Math.Ceiling(days / 0.2648);

                List<decimal> typicalPriceZeroLagEmaList = GetMovingAverageList("ZeroLagExponentialMovingAverage", null, stockDataClass, length);
                List<decimal> wellesWilderHighMovingAvgList = GetMovingAverageList(maType, stockDataClass.HighPrices, stockDataClass, length);
                List<decimal> wellesWilderLowMovingAvgList = GetMovingAverageList(maType, stockDataClass.LowPrices, stockDataClass, length);

                for (int i = 0; i < typicalPriceZeroLagEmaList.Count; i++)
                {
                    decimal hi = wellesWilderHighMovingAvgList.ElementAtOrDefault(i);
                    decimal lo = wellesWilderLowMovingAvgList.ElementAtOrDefault(i);
                    decimal mi = typicalPriceZeroLagEmaList.ElementAtOrDefault(i);

                    decimal macd = mi > hi ? mi - hi : mi < lo ? mi - lo : 0;
                    macdList.Add(macd);

                    decimal macdSignalLine = CalculateExponentialMovingAverage(macd, macdSignalLineList.LastOrDefault(), signalPeriod);
                    macdSignalLineList.Add(macdSignalLine);

                    decimal prevMacdHistogram = macdHistogramList.LastOrDefault();
                    decimal macdHistogram = macd - macdSignalLine;
                    macdHistogramList.Add(macdHistogram);

                    var signal = GetCompareSignal(macdHistogram, prevMacdHistogram);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (macdList, macdSignalLineList, macdHistogramList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateImpulsePercentagePriceOscillator(StockData stockDataClass, string maType, int days = 9)
        {
            // @author LazyBear 
            // 
            // List of my public indicators: http://bit.ly/1LQaPK8 
            // List of my app-store indicators: http://blog.tradingview.com/?p=970 
            //
            //
            //study("Impulse MACD [LazyBear]", shorttitle = "IMACD_LB", overlay = false)
            //lengthMA = input(34)
            //lengthSignal = input(9)
            //calc_smma(src, len) =>
            //    smma = na(smma[1]) ? sma(src, len) : (smma[1] * (len - 1) + src) / len

            //calc_zlema(src, length) =>
            //    ema1 = ema(src, length)
            //    ema2 = ema(ema1, length)
            //    d = ema1 - ema2
            //    ema1 + d

            //src = hlc3
            //hi = calc_smma(high, lengthMA)
            //lo = calc_smma(low, lengthMA)
            //mi = calc_zlema(src, lengthMA)

            //md = (mi > hi) ? (mi - hi) : (mi < lo) ? (mi - lo) : 0
            //sb = sma(md, lengthSignal)
            //sh = md - sb
            //mdc = src > mi ? src > hi ? lime : green : src < lo ? red : orange
            //plot(0, color = gray, linewidth = 1, title = "MidLine")
            //plot(md, color = mdc, linewidth = 2, title = "ImpulseMACD", style = histogram)
            //plot(sh, color = blue, linewidth = 2, title = "ImpulseHisto", style = histogram)
            //plot(sb, color = maroon, linewidth = 2, title = "ImpulseMACDCDSignal")

            //ebc = input(false, title = "Enable bar colors")
            //barcolor(ebc ? mdc : na)
            List<decimal> ppoList = new();
            List<decimal> ppoSignalLineList = new();
            List<decimal> ppoHistogramList = new();
            List<Signal> signalsList = new();

            try
            {
                int length = (int)Math.Ceiling(days / 0.2648);
                int signalPeriod = days;

                List<decimal> typicalPriceZeroLagEmaList = CalculateZeroLagExponentialMovingAverage(stockDataClass, "ExponentialMovingAverage", length).Item2;
                List<decimal> wellesWilderHighMovingAvgList = GetMovingAverageList(maType, stockDataClass.HighPrices, stockDataClass, length);
                List<decimal> wellesWilderLowMovingAvgList = GetMovingAverageList(maType, stockDataClass.LowPrices, stockDataClass, length);

                for (int i = 0; i < typicalPriceZeroLagEmaList.Count; i++)
                {
                    decimal hi = wellesWilderHighMovingAvgList.ElementAtOrDefault(i);
                    decimal lo = wellesWilderLowMovingAvgList.ElementAtOrDefault(i);
                    decimal mi = typicalPriceZeroLagEmaList.ElementAtOrDefault(i);
                    decimal macd = mi > hi ? mi - hi : mi < lo ? mi - lo : 0;

                    decimal ppo = mi > hi && hi != 0 ? macd / hi * 100 : mi < lo && lo != 0 ? macd / lo * 100 : 0;
                    ppoList.Add(ppo);

                    decimal ppoSignalLine = CalculateExponentialMovingAverage(ppo, ppoSignalLineList.LastOrDefault(), signalPeriod);
                    ppoSignalLineList.Add(ppoSignalLine);

                    decimal prevPpoHistogram = ppoHistogramList.LastOrDefault();
                    decimal ppoHistogram = ppo - ppoSignalLine;
                    ppoHistogramList.Add(ppoHistogram);

                    var signal = GetCompareSignal(ppoHistogram, prevPpoHistogram);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (ppoList, ppoSignalLineList, ppoHistogramList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>)
            CalculateMovingAverageConvergenceDivergenceLeader(StockData stockDataClass, string maType, int days = 9)
        {
            // @author LazyBear 
            // List of all my indicators: 
            // https://docs.google.com/document/d/15AGCufJZ8CIUvwFJ9W-IKns88gkWOKBCvByMEvm5MLo/edit?usp=sharing
            //
            //study("MACD Leader [LazyBear]", shorttitle = "MACDL_LB")
            //src = close
            //shortLength = input(12, title = "Fast Length")
            //longLength = input(26, title = "Slow Length")
            //sigLength = input(9, title = "Signal Length")
            //showMACD = input(false)
            //showMACDSignal = input(false)
            //ma(s, l) => ema(s, l)
            //sema = ma(src, shortLength)
            //lema = ma(src, longLength)
            //i1 = sema + ma(src - sema, shortLength)
            //i2 = lema + ma(src - lema, longLength)
            //macdl = i1 - i2
            //macd = sema - lema

            //hline(0)
            //plot(macdl, title = "MACDLeader", color = maroon, linewidth = 2)
            //plot(showMACD ? macd : na, title = "MACD", color = green)
            //plot(showMACDSignal ? sma(macd, sigLength) : na, title = "Signal", color = red)
            List<decimal> macdList = new();
            List<decimal> macdSignalLineList = new();
            List<decimal> macdHistogramList = new();
            List<decimal> diff12List = new();
            List<decimal> diff26List = new();
            List<decimal> diff12EmaList = new();
            List<decimal> diff26EmaList = new();
            List<decimal> i1List = new();
            List<decimal> i2List = new();
            List<Signal> signalsList = new();

            try
            {
                int shortEmaCount = (int)Math.Ceiling(days / 0.75);
                int longEmaCount = (int)Math.Ceiling(days / 0.3462);
                int signalPeriod = days;

                List<decimal> emaList = GetMovingAverageList(maType, null, stockDataClass, shortEmaCount);
                List<decimal> ema26List = GetMovingAverageList(maType, null, stockDataClass, longEmaCount);

                for (int i = 0; i < emaList.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal ema12 = emaList.ElementAtOrDefault(i);
                    decimal ema26 = ema26List.ElementAtOrDefault(i);

                    decimal diff12 = currentValue - ema12;
                    diff12List.Add(diff12);

                    decimal diff26 = currentValue - ema26;
                    diff26List.Add(diff26);
                }

                diff12EmaList = GetMovingAverageList(maType, diff12List, stockDataClass, shortEmaCount);
                diff26EmaList = GetMovingAverageList(maType, diff26List, stockDataClass, longEmaCount);
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal ema12 = emaList.ElementAtOrDefault(j);
                    decimal ema26 = ema26List.ElementAtOrDefault(j);
                    decimal diff12Ema = diff12EmaList.ElementAtOrDefault(j);
                    decimal diff26Ema = diff26EmaList.ElementAtOrDefault(j);

                    decimal i1 = ema12 + diff12Ema;
                    i1List.Add(i1);

                    decimal i2 = ema26 + diff26Ema;
                    i2List.Add(i2);

                    decimal macd = i1 - i2;
                    macdList.Add(macd);
                }

                macdSignalLineList = GetMovingAverageList(maType, macdList, stockDataClass, signalPeriod);
                for (int k = 0; k < stockDataClass.InputValues.Count; k++)
                {
                    decimal macd = macdList.ElementAtOrDefault(k);
                    decimal macdSignalLine = macdSignalLineList.ElementAtOrDefault(k);

                    decimal prevMacdHistogram = macdHistogramList.LastOrDefault();
                    decimal macdHistogram = macd - macdSignalLine;
                    macdHistogramList.Add(macdHistogram);

                    var signal = GetCompareSignal(macdHistogram, prevMacdHistogram);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (diff12EmaList, diff26List, diff26EmaList, i1List, i2List, macdList, macdSignalLineList, macdHistogramList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculatePercentagePriceOscillatorLeader(StockData stockDataClass, string maType, int days = 9)
        {
            // @author LazyBear 
            // List of all my indicators: 
            // https://docs.google.com/document/d/15AGCufJZ8CIUvwFJ9W-IKns88gkWOKBCvByMEvm5MLo/edit?usp=sharing
            //
            //study("MACD Leader [LazyBear]", shorttitle = "MACDL_LB")
            //src = close
            //shortLength = input(12, title = "Fast Length")
            //longLength = input(26, title = "Slow Length")
            //sigLength = input(9, title = "Signal Length")
            //showMACD = input(false)
            //showMACDSignal = input(false)
            //ma(s, l) => ema(s, l)
            //sema = ma(src, shortLength)
            //lema = ma(src, longLength)
            //i1 = sema + ma(src - sema, shortLength)
            //i2 = lema + ma(src - lema, longLength)
            //macdl = i1 - i2
            //macd = sema - lema

            //hline(0)
            //plot(macdl, title = "MACDLeader", color = maroon, linewidth = 2)
            //plot(showMACD ? macd : na, title = "MACD", color = green)
            //plot(showMACDSignal ? sma(macd, sigLength) : na, title = "Signal", color = red)
            List<decimal> ppoList = new();
            List<decimal> ppoSignalLineList = new();
            List<decimal> ppoHistogramList = new();
            List<Signal> signalsList = new();

            try
            {
                var macdLeaderList = CalculateMovingAverageConvergenceDivergenceLeader(stockDataClass, maType, days);
                List<decimal> i1List = macdLeaderList.Item4;
                List<decimal> i2List = macdLeaderList.Item5;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal i1 = i1List.ElementAtOrDefault(i);
                    decimal i2 = i2List.ElementAtOrDefault(i);
                    decimal macd = i1 - i2;

                    decimal ppo = i2 != 0 ? macd / i2 * 100 : 0;
                    ppoList.Add(ppo);
                }

                ppoSignalLineList = GetMovingAverageList(maType, ppoList, stockDataClass, days);
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal ppo = ppoList.ElementAtOrDefault(j);
                    decimal ppoSignalLine = ppoSignalLineList.ElementAtOrDefault(j);

                    decimal prevPpoHistogram = ppoHistogramList.LastOrDefault();
                    decimal ppoHistogram = ppo - ppoSignalLine;
                    ppoHistogramList.Add(ppoHistogram);

                    var signal = GetCompareSignal(ppoHistogram, prevPpoHistogram);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (ppoList, ppoSignalLineList, ppoHistogramList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateMacZIndicator(StockData stockDataClass,
             string maType, int days = 9)
        {
            //
            // @author LazyBear 
            // List of all my indicators: https://www.tradingview.com/v/4IneGo8h/
            //
            //study("MAC-Z Indicator [LazyBear]", shorttitle = "MACZ_LB")
            //fastLength = input(12, minval = 1, title = "MACD Fast MA Length"), 
            //slowLength = input(25, minval = 1, title = "MACD Slow MA Length")
            //signalLength = input(9, title = "MACD Signal Length")
            //lengthz = input(25, title = "ZScore Length")
            //lengthStdev = input(25, title = "Stdev Length")
            //A = input(1.0, minval = -2.0, maxval = 2.0, title = "MACZ constant A")
            //B = input(1.0, minval = -2.0, maxval = 2.0, title = "MACZ constant B")
            //useLag = input(false, type = bool, title = "Apply Laguerre Smoothing")
            //gamma = input(0.02, title = "Laguerre Gamma")

            //source = close
            //calc_wima(src, length) => 
            //    MA_s = (src + nz(MA_s[1] * (length - 1))) / length
            //    MA_s

            //calc_laguerre(s, g) =>
            //    l0 = (1 - g) * s + g * nz(l0[1])
            //    l1 = -g * l0 + nz(l0[1]) + g * nz(l1[1])
            //    l2 = -g * l1 + nz(l1[1]) + g * nz(l2[1])
            //    l3 = -g * l2 + nz(l2[1]) + g * nz(l3[1])
            //    (l0 + 2 * l1 + 2 * l2 + l3) / 6

            //zscore = (source - calc_wima(source, lengthz)) / stdev(source, lengthz)
            //fastMA = sma(source, fastLength)
            //slowMA = sma(source, slowLength)
            //macd = fastMA - slowMA
            //macz_t = zscore * A + macd / stdev(source, lengthStdev) * B
            //macz = useLag ? calc_laguerre(macz_t, gamma) : macz_t
            //signal = sma(macz, signalLength)
            //hist = macz - signal

            //plot(hist, color = red, style = area, title = "Histogram", transp = 85)
            //plot(macz, color = green, title = "MAC-Z", linewidth = 2)
            //plot(signal, color = orange, title = "Signal", linewidth = 2)
            decimal gamma = 0.02m;
            List<decimal> zscoreList = new();
            List<decimal> macztList = new();
            List<decimal> l0List = new();
            List<decimal> l1List = new();
            List<decimal> l2List = new();
            List<decimal> l3List = new();
            List<decimal> maczList = new();
            List<decimal> maczSignalList = new();
            List<decimal> histList = new();
            List<Signal> signalsList = new();

            try
            {
                int fastLength = (int)Math.Ceiling(days / 0.75);
                int slowLength = (int)Math.Ceiling(days / 0.36);
                int signalPeriod = days;

                List<decimal> stdDevList = CalculateStandardDeviationVolatility(null, stockDataClass, slowLength).Item4;
                List<decimal> fastSmaList = GetMovingAverageList(maType, null, stockDataClass, fastLength);
                List<decimal> slowSmaList = GetMovingAverageList(maType, null, stockDataClass, slowLength);
                List<decimal> wilderMovingAvgList = CalculateWellesWilderMovingAverage(stockDataClass, slowLength).Item1;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal stdev = stdDevList.ElementAtOrDefault(i);
                    decimal wima = wilderMovingAvgList.ElementAtOrDefault(i);
                    decimal fastMa = fastSmaList.ElementAtOrDefault(i);
                    decimal slowMa = slowSmaList.ElementAtOrDefault(i);

                    decimal zscore = stdev != 0 ? (currentValue - wima) / stdev : 0;
                    zscoreList.Add(zscore);

                    decimal macd = fastMa - slowMa;
                    decimal maczt = stdev != 0 ? zscore + (macd / stdev) : zscore;
                    macztList.Add(maczt);

                    decimal prevL0 = i >= 1 ? l0List.LastOrDefault() : maczt;
                    decimal l0 = ((1 - gamma) * maczt) + (gamma * prevL0);
                    l0List.Add(l0);

                    decimal prevL1 = i >= 1 ? l1List.LastOrDefault() : maczt;
                    decimal l1 = (-1 * gamma * l0) + prevL0 + (gamma * prevL1);
                    l1List.Add(l1);

                    decimal prevL2 = i >= 1 ? l2List.LastOrDefault() : maczt;
                    decimal l2 = (-1 * gamma * l1) + prevL1 + (gamma * prevL2);
                    l2List.Add(l2);

                    decimal prevL3 = i >= 1 ? l3List.LastOrDefault() : maczt;
                    decimal l3 = (-1 * gamma * l2) + prevL2 + (gamma * prevL3);
                    l3List.Add(l3);

                    decimal macz = (l0 + (2 * l1) + (2 * l2) + l3) / 6;
                    maczList.Add(macz);

                    decimal maczSignal = maczList.TakeLast(signalPeriod).Average();
                    maczSignalList.Add(maczSignal);

                    decimal prevHist = histList.LastOrDefault();
                    decimal hist = macz - maczSignal;
                    histList.Add(hist);

                    var signal = GetCompareSignal(hist, prevHist);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (zscoreList, macztList, l0List, l1List, l2List, l3List, maczList, maczSignalList, histList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateMacZVwapIndicator(
            StockData stockDataClass, string maType, int days = 9)
        {
            //
            // @author LazyBear 
            // List of all my indicators: https://www.tradingview.com/v/4IneGo8h/
            //
            //study("MAC-Z VWAP Indicator [LazyBear]", shorttitle = "MACZVWAP_LB")
            //fastLength = input(12, minval = 1, title = "MACD Fast MA Length")
            //slowLength = input(25, minval = 1, title = "MACD Slow MA Length")
            //signalLength = input(9, title = "MACD Signal Length")
            //lengthz = input(20, title = "Z-VWAP Length")
            //lengthStdev = input(25, title = "Stdev Length")
            //A = input(1.0, minval = -2.0, maxval = 2.0, title = "MACZ constant A")
            //B = input(1.0, minval = -2.0, maxval = 2.0, title = "MACZ constant B")
            //useLag = input(false, type = bool, title = "Apply Laguerre Smoothing")
            //gamma = input(0.02, title = "Laguerre Gamma")
            //source = close

            //calc_laguerre(s, g) =>
            //    l0 = (1 - g) * s + g * nz(l0[1])
            //    l1 = -g * l0 + nz(l0[1]) + g * nz(l1[1])
            //    l2 = -g * l1 + nz(l1[1]) + g * nz(l2[1])
            //    l3 = -g * l2 + nz(l2[1]) + g * nz(l3[1])
            //    (l0 + 2 * l1 + 2 * l2 + l3) / 6

            //calc_zvwap(pds) =>
            //    mean = sum(volume * close, pds) / sum(volume, pds)
            //    vwapsd = sqrt(sma(pow(close - mean, 2), pds))
            //    (close - mean) / vwapsd

            //zscore = calc_zvwap(lengthz)
            //fastMA = sma(source, fastLength)
            //slowMA = sma(source, slowLength)
            //macd = fastMA - slowMA
            //macz_t = zscore * A + macd / stdev(source, lengthStdev) * B
            //macz = useLag ? calc_laguerre(macz_t, gamma) : macz_t
            //signal = sma(macz, signalLength)
            //hist = macz - signal

            //plot(hist, color = red, style = area, title = "Histogram", transp = 85)
            //plot(macz, color = green, title = "MAC-Z", linewidth = 2)
            //plot(signal, color = orange, title = "Signal", linewidth = 2)
            decimal gamma = 0.02m;
            List<decimal> macztList = new();
            List<decimal> l0List = new();
            List<decimal> l1List = new();
            List<decimal> l2List = new();
            List<decimal> l3List = new();
            List<decimal> maczList = new();
            List<decimal> maczSignalList = new();
            List<decimal> histList = new();
            List<Signal> signalsList = new();

            try
            {
                int fastLength = (int)Math.Ceiling(days / 0.75);
                int slowLength = (int)Math.Ceiling(days / 0.36);
                int signalPeriod = days;
                int zLength = (int)Math.Ceiling(days / 0.45);

                var stdDevList = CalculateStandardDeviationVolatility(null, stockDataClass, slowLength).Item4;
                var fastSmaList = GetMovingAverageList(maType, null, stockDataClass, fastLength);
                var slowSmaList = GetMovingAverageList(maType, null, stockDataClass, slowLength);
                var zScoreList = CalculateZDistanceFromVwapIndicator(stockDataClass, zLength).Item4;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal stdev = stdDevList.ElementAtOrDefault(i);
                    decimal fastMa = fastSmaList.ElementAtOrDefault(i);
                    decimal slowMa = slowSmaList.ElementAtOrDefault(i);
                    decimal zscore = zScoreList.ElementAtOrDefault(i);

                    decimal macd = fastMa - slowMa;
                    decimal maczt = stdev != 0 ? zscore + (macd / stdev) : zscore;
                    macztList.Add(maczt);

                    decimal prevL0 = i >= 1 ? l0List.LastOrDefault() : maczt;
                    decimal l0 = ((1 - gamma) * maczt) + (gamma * prevL0);
                    l0List.Add(l0);

                    decimal prevL1 = i >= 1 ? l1List.LastOrDefault() : maczt;
                    decimal l1 = (-1 * gamma * l0) + prevL0 + (gamma * prevL1);
                    l1List.Add(l1);

                    decimal prevL2 = i >= 1 ? l2List.LastOrDefault() : maczt;
                    decimal l2 = (-1 * gamma * l1) + prevL1 + (gamma * prevL2);
                    l2List.Add(l2);

                    decimal prevL3 = i >= 1 ? l3List.LastOrDefault() : maczt;
                    decimal l3 = (-1 * gamma * l2) + prevL2 + (gamma * prevL3);
                    l3List.Add(l3);

                    decimal macz = (l0 + (2 * l1) + (2 * l2) + l3) / 6;
                    maczList.Add(macz);

                    decimal maczSignal = maczList.TakeLast(signalPeriod).Average();
                    maczSignalList.Add(maczSignal);

                    decimal prevHist = histList.LastOrDefault();
                    decimal hist = macz - maczSignal;
                    histList.Add(hist);

                    var signal = GetCompareSignal(hist, prevHist);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (macztList, l0List, l1List, l2List, l3List, maczList, maczSignalList, histList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateZDistanceFromVwapIndicator(StockData stockDataClass, int days = 20)
        {
            //
            // @author LazyBear 
            // List of all my indicators: https://www.tradingview.com/v/4IneGo8h/
            //
            //study("Z distance from VWAP [LazyBear]", shorttitle = "ZVWAP_LB")
            //length = input(20)

            //calc_zvwap(pds) =>
            //    mean = sum(volume * close, pds) / sum(volume, pds)
            //    vwapsd = sqrt(sma(pow(close - mean, 2), pds))
            //    (close - mean) / vwapsd

            //plot(0)
            //upperTop = input(2.5)
            //upperBottom = input(2.0)
            //lowerTop = input(-2.5)
            //lowerBottom = input(-2.0)

            //plot(1, style = 3, color = gray), plot(-1, style = 3, color = gray)
            //ul1 = plot(upperTop, "OB High")
            //ul2 = plot(upperBottom, "OB Low")
            //fill(ul1, ul2, color = red)
            //ll1 = plot(lowerTop, "OS High")
            //ll2 = plot(lowerBottom, "OS Low")
            //fill(ll1, ll2, color = green)
            //plot(calc_zvwap(length), title = "ZVWAP", color = maroon, linewidth = 2)
            List<decimal> meanList = new();
            List<decimal> powList = new();
            List<decimal> powSmaList = new();
            List<decimal> vwapsdList = new();
            List<decimal> volSumList = new();
            List<decimal> volPriceSumList = new();
            List<decimal> tempVolList = new();
            List<decimal> tempVolPriceList = new();
            List<decimal> zscoreList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevZScore1 = i >= 1 ? zscoreList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevZScore2 = i >= 2 ? zscoreList.ElementAtOrDefault(i - 2) : 0;

                    decimal currentVolume = stockDataClass.Volumes.ElementAtOrDefault(i);
                    tempVolList.Add(currentVolume);

                    decimal volPrice = currentVolume * currentValue;
                    tempVolPriceList.Add(volPrice);

                    decimal volPriceSum = tempVolPriceList.TakeLast(days).Sum();
                    volPriceSumList.Add(volPriceSum);

                    decimal volSum = tempVolList.TakeLast(days).Sum();
                    volSumList.Add(volSum);

                    decimal mean = volSum != 0 ? volPriceSum / volSum : 0;
                    meanList.Add(mean);

                    decimal pow = Pow(currentValue - mean, 2);
                    powList.Add(pow);

                    decimal powSma = powList.TakeLast(days).Average();
                    powSmaList.Add(powSma);

                    decimal vwapsd = powSma >= 0 ? (decimal)Sqrt((double)powSma) : 0;
                    vwapsdList.Add(vwapsd);

                    decimal zscore = vwapsd != 0 ? (currentValue - mean) / vwapsd : 0;
                    zscoreList.Add(zscore);

                    var signal = GetRsiSignal(zscore - prevZScore1, prevZScore1 - prevZScore2, zscore, prevZScore1, 2, -2);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (powList, powSmaList, vwapsdList, zscoreList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateFunctionToCandles(StockData stockDataClass, string maType, int days = 12)
        {
            //@version=3
            //study("Function To Candles", shorttitle = "FTC")
            //length = input(14),i = input("Rsi", title = "Indicator", options =["Rsi", "Stochastic", "Roc", "Cog", "Correlation"]),heikin = input(false, title = "Heikin-Ashi Mode")
            //----
            //f(x)=>
            //    st = stoch(x, x, x, length)
            //    f = i == "Rsi" ? rsi(x, length) : i == "Stochastic" ? st : i == "Roc" ? roc(x, length) : i == "Cog" ? cog(x, length) : correlation(x, n, length)
            //----
            //C = f(close)
            //O = f(open)
            //H = f(high)
            //L = f(low)
            //----
            //c = heikin ? (C + O + H + L) / 4 : C
            //o = heikin ? (C[1] + O[1]) / 2 : O
            //h = heikin ? max(max(H, C), O) : H
            //l = heikin ? min(min(L, C), O) : L
            //plotcandle(c, h, l, o, color = c > o ?#2196f3:red,wickcolor=#5d606b)
            List<decimal> rsiCList = new();
            List<decimal> rsiOList = new();
            List<decimal> rsiHList = new();
            List<decimal> rsiLList = new();
            List<decimal> rsiCHeikinList = new();
            List<decimal> rsiOHeikinList = new();
            List<decimal> rsiHHeikinList = new();
            List<decimal> rsiLHeikinList = new();
            List<decimal> rocCList = new();
            List<decimal> rocOList = new();
            List<decimal> rocHList = new();
            List<decimal> rocLList = new();
            List<decimal> rocCHeikinList = new();
            List<decimal> rocOHeikinList = new();
            List<decimal> rocHHeikinList = new();
            List<decimal> rocLHeikinList = new();
            List<decimal> cogCList = new();
            List<decimal> cogOList = new();
            List<decimal> cogHList = new();
            List<decimal> cogLList = new();
            List<decimal> cogCHeikinList = new();
            List<decimal> cogOHeikinList = new();
            List<decimal> cogHHeikinList = new();
            List<decimal> cogLHeikinList = new();
            List<decimal> corrCList = new();
            List<decimal> corrOList = new();
            List<decimal> corrHList = new();
            List<decimal> corrLList = new();
            List<decimal> corrCHeikinList = new();
            List<decimal> corrOHeikinList = new();
            List<decimal> corrHHeikinList = new();
            List<decimal> corrLHeikinList = new();
            List<decimal> stochCList = new();
            List<decimal> stochOList = new();
            List<decimal> stochHList = new();
            List<decimal> stochLList = new();
            List<decimal> stochCHeikinList = new();
            List<decimal> stochOHeikinList = new();
            List<decimal> stochHHeikinList = new();
            List<decimal> stochLHeikinList = new();
            List<decimal> indexList = new();
            List<decimal> tempCloseList = new();
            List<decimal> tempOpenList = new();
            List<decimal> tempHighList = new();
            List<decimal> tempLowList = new();
            List<decimal> tpList = new();
            List<Signal> signalsList = new();

            try
            {
                rsiCList = CalculateRelativeStrengthIndex(stockDataClass.ClosePrices, stockDataClass, maType, days).Item4;
                rsiOList = CalculateRelativeStrengthIndex(stockDataClass.OpenPrices, stockDataClass, maType, days).Item4;
                rsiHList = CalculateRelativeStrengthIndex(stockDataClass.HighPrices, stockDataClass, maType, days).Item4;
                rsiLList = CalculateRelativeStrengthIndex(stockDataClass.LowPrices, stockDataClass, maType, days).Item4;
                rocCList = CalculateRateOfChange(stockDataClass.ClosePrices, stockDataClass, days).Item1;
                rocOList = CalculateRateOfChange(stockDataClass.OpenPrices, stockDataClass, days).Item1;
                rocHList = CalculateRateOfChange(stockDataClass.HighPrices, stockDataClass, days).Item1;
                rocLList = CalculateRateOfChange(stockDataClass.LowPrices, stockDataClass, days).Item1;
                stochCList = CalculateStochasticOscillator(stockDataClass.ClosePrices, stockDataClass, maType, days).Item3;
                stochOList = CalculateStochasticOscillator(stockDataClass.OpenPrices, stockDataClass, maType, days).Item3;
                stochHList = CalculateStochasticOscillator(stockDataClass.HighPrices, stockDataClass, maType, days).Item3;
                stochLList = CalculateStochasticOscillator(stockDataClass.LowPrices, stockDataClass, maType, days).Item3;
                cogCList = CalculateEhlersCenterofGravityOscillator(stockDataClass.ClosePrices, stockDataClass, days).Item5;
                cogOList = CalculateEhlersCenterofGravityOscillator(stockDataClass.OpenPrices, stockDataClass, days).Item5;
                cogHList = CalculateEhlersCenterofGravityOscillator(stockDataClass.HighPrices, stockDataClass, days).Item5;
                cogLList = CalculateEhlersCenterofGravityOscillator(stockDataClass.LowPrices, stockDataClass, days).Item5;

                for (int h = 0; h < stockDataClass.HighPrices.Count; h++)
                {
                    decimal closePrice = stockDataClass.ClosePrices.ElementAtOrDefault(h);
                    tempCloseList.Add(closePrice);

                    decimal openPrice = stockDataClass.OpenPrices.ElementAtOrDefault(h);
                    tempOpenList.Add(openPrice);

                    decimal highPrice = stockDataClass.HighPrices.ElementAtOrDefault(h);
                    tempHighList.Add(highPrice);

                    decimal lowPrice = stockDataClass.LowPrices.ElementAtOrDefault(h);
                    tempLowList.Add(lowPrice);

                    decimal index = h;
                    indexList.Add(index);

                    var lbList = indexList.TakeLast(days).Select(x => (double)x).ToList();
                    var corrC = GoodnessOfFit.R(lbList, tempCloseList.TakeLast(days).Select(x => (double)x));
                    corrC = IsValueNullOrInfinity(corrC) ? 0 : corrC;
                    corrCList.Add((decimal)corrC);

                    var corrO = GoodnessOfFit.R(lbList, tempOpenList.TakeLast(days).Select(x => (double)x));
                    corrO = IsValueNullOrInfinity(corrO) ? 0 : corrO;
                    corrOList.Add((decimal)corrO);

                    var corrH = GoodnessOfFit.R(lbList, tempHighList.TakeLast(days).Select(x => (double)x));
                    corrH = IsValueNullOrInfinity(corrH) ? 0 : corrH;
                    corrHList.Add((decimal)corrH);

                    var corrL = GoodnessOfFit.R(lbList, tempLowList.TakeLast(days).Select(x => (double)x));
                    corrL = IsValueNullOrInfinity(corrL) ? 0 : corrL;
                    corrLList.Add((decimal)corrL);
                }

                for (int i = 0; i < stockDataClass.HighPrices.Count; i++)
                {
                    decimal rsiC = rsiCList.ElementAtOrDefault(i) / 100;
                    decimal rsiO = rsiOList.ElementAtOrDefault(i) / 100;
                    decimal rsiH = rsiHList.ElementAtOrDefault(i) / 100;
                    decimal rsiL = rsiLList.ElementAtOrDefault(i) / 100;
                    decimal rocC = rocCList.ElementAtOrDefault(i) / 100;
                    decimal rocO = rocOList.ElementAtOrDefault(i) / 100;
                    decimal rocH = rocHList.ElementAtOrDefault(i) / 100;
                    decimal rocL = rocLList.ElementAtOrDefault(i) / 100;
                    decimal stochC = stochCList.ElementAtOrDefault(i) / 100;
                    decimal stochO = stochOList.ElementAtOrDefault(i) / 100;
                    decimal stochH = stochHList.ElementAtOrDefault(i) / 100;
                    decimal stochL = stochLList.ElementAtOrDefault(i) / 100;
                    decimal cogC = cogCList.ElementAtOrDefault(i) / 100;
                    decimal cogO = cogOList.ElementAtOrDefault(i) / 100;
                    decimal cogH = cogHList.ElementAtOrDefault(i) / 100;
                    decimal cogL = cogLList.ElementAtOrDefault(i) / 100;
                    decimal corrC = corrCList.ElementAtOrDefault(i);
                    decimal corrO = corrOList.ElementAtOrDefault(i);
                    decimal corrH = corrHList.ElementAtOrDefault(i);
                    decimal corrL = corrLList.ElementAtOrDefault(i);
                    decimal prevRsiC = i >= 1 ? rsiCList.ElementAtOrDefault(i - 1) / 100 : 0;
                    decimal prevRsiO = i >= 1 ? rsiOList.ElementAtOrDefault(i - 1) / 100 : 0;
                    decimal prevRocC = i >= 1 ? rocCList.ElementAtOrDefault(i - 1) / 100 : 0;
                    decimal prevRocO = i >= 1 ? rocOList.ElementAtOrDefault(i - 1) / 100 : 0;
                    decimal prevStochC = i >= 1 ? stochCList.ElementAtOrDefault(i - 1) / 100 : 0;
                    decimal prevStochO = i >= 1 ? stochOList.ElementAtOrDefault(i - 1) / 100 : 0;
                    decimal prevCogC = i >= 1 ? cogCList.ElementAtOrDefault(i - 1) / 100 : 0;
                    decimal prevCogO = i >= 1 ? cogOList.ElementAtOrDefault(i - 1) / 100 : 0;
                    decimal prevCorrC = i >= 1 ? corrCList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevCorrO = i >= 1 ? corrOList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevTp1 = i >= 1 ? tpList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevTp2 = i >= 2 ? tpList.ElementAtOrDefault(i - 2) : 0;

                    decimal rsiCHeikin = (rsiC + rsiO + rsiH + rsiL) / 4;
                    rsiCHeikinList.Add(rsiCHeikin);

                    decimal rsiOHeikin = (prevRsiC + prevRsiO) / 2;
                    rsiOHeikinList.Add(rsiOHeikin);

                    decimal rsiHHeikin = Math.Max(Math.Max(rsiH, rsiC), 0);
                    rsiHHeikinList.Add(rsiHHeikin);

                    decimal rsiLHeikin = Math.Min(Math.Min(rsiL, rsiC), 0);
                    rsiLHeikinList.Add(rsiLHeikin);

                    decimal rocCHeikin = (rocC + rocO + rocH + rocL) / 4;
                    rocCHeikinList.Add(rocCHeikin);

                    decimal rocOHeikin = (prevRocC + prevRocO) / 2;
                    rocOHeikinList.Add(rocOHeikin);

                    decimal rocHHeikin = Math.Max(Math.Max(rocH, rocC), 0);
                    rocHHeikinList.Add(rocHHeikin);

                    decimal rocLHeikin = Math.Min(Math.Min(rocL, rocC), 0);
                    rocLHeikinList.Add(rocLHeikin);

                    decimal stochCHeikin = (stochC + stochO + stochH + stochL) / 4;
                    stochCHeikinList.Add(stochCHeikin);

                    decimal stochOHeikin = (prevStochC + prevStochO) / 2;
                    stochOHeikinList.Add(stochOHeikin);

                    decimal stochHHeikin = Math.Max(Math.Max(stochH, stochC), 0);
                    stochHHeikinList.Add(stochHHeikin);

                    decimal stochLHeikin = Math.Min(Math.Min(stochL, stochC), 0);
                    stochLHeikinList.Add(stochLHeikin);

                    decimal cogCHeikin = (cogC + cogO + cogH + cogL) / 4;
                    cogCHeikinList.Add(cogCHeikin);

                    decimal cogOHeikin = (prevCogC + prevCogO) / 2;
                    cogOHeikinList.Add(cogOHeikin);

                    decimal cogHHeikin = Math.Max(Math.Max(cogH, cogC), 0);
                    cogHHeikinList.Add(cogHHeikin);

                    decimal cogLHeikin = Math.Min(Math.Min(cogL, cogC), 0);
                    cogLHeikinList.Add(cogLHeikin);

                    decimal corrCHeikin = (corrC + corrO + corrH + corrL) / 4;
                    corrCHeikinList.Add(corrCHeikin);

                    decimal corrOHeikin = (prevCorrC + prevCorrO) / 2;
                    corrOHeikinList.Add(corrOHeikin);

                    decimal corrHHeikin = Math.Max(Math.Max(corrH, corrC), 0);
                    corrHHeikinList.Add(corrHHeikin);

                    decimal corrLHeikin = Math.Min(Math.Min(corrL, corrC), 0);
                    corrLHeikinList.Add(corrLHeikin);

                    decimal tp = (rsiC + rsiO + rsiH + rsiL) / 4;
                    tpList.Add(tp);

                    var signal = GetCompareSignal(tp - prevTp1, prevTp1 - prevTp2);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (rsiCList, rsiOList, rsiHList, rsiLList, rsiCHeikinList, rsiOHeikinList, rsiHHeikinList, rsiLHeikinList, rocCList, rocOList, rocHList, rocLList, rocCHeikinList,
                rocOHeikinList, rocHHeikinList, rocLHeikinList, stochCList, stochOList, stochHList, stochLList, stochCHeikinList, stochOHeikinList, stochHHeikinList,
                stochLHeikinList, cogCList, cogOList, cogHList, cogLList, cogCHeikinList, cogOHeikinList, cogHHeikinList, cogLHeikinList, corrCList, corrOList, corrHList,
                corrLList, corrCHeikinList, corrOHeikinList, corrHHeikinList, corrLHeikinList, tpList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateReallySimpleIndicator(StockData stockDataClass, string maType, int days = 10)
        {
            //@version=4

            // Please don't remove this header comment 
            //
            // Webby's RSI (Really Simple Indicator)
            // Plot percentage of the day's low vs 21-day EMA.
            //
            // Webby's RSI was created by Mike Webster
            // @mwebster1971 http://twitter.com/mwebster1971
            //
            // More details on Webby's RSI
            // https://www.investors.com/market-trend/stock-market-update-raging-bull-rests/
            //
            // Pine Script version by John Muchow
            // @JohnMuchow http://twitter.com/JohnMuchow
            // Web: https://PlayTheTrade.com

            //study(title = "Webby's RSI")

            //---------------------------------------------------------
            // Inputs - User configurable values
            //----------------------------------------------------------
            //plotStyle = input(title = "Plot Style", defval = "Histogram", options =["Histogram", "Columns", "Line", "Area"])
            //movingAverageLength = input(title = "Moving Average (5 - 50)", type = input.integer, defval = 10, minval = 5, maxval = 50)

            //---------------------------------------------------------
            // Calculations
            //----------------------------------------------------------
            // 21-day EMA of close
            //_21DayExpMovingAverage = ema(close, 21)

            // Webby's RSI data point - percent of day's low vs 21-day EMA
            //lowVs21DayMovingAverage = (((low - _21DayExpMovingAverage) / close) * 100)

            // Simple moving average of data points 
            //movingAverage = sma(lowVs21DayMovingAverage, movingAverageLength)

            //----------------------------------------------------------
            // Show horizontal lines on graph at specified intervals
            //----------------------------------------------------------
            //hline(0, title = "0 line", color = color.white, linestyle = hline.style_solid, editable = false)
            //hline(.5, title = ".5 line", color = color.green, linestyle = hline.style_solid, editable = false)
            //hline(2, title = "2 line", color = color.green, linestyle = hline.style_solid, editable = false)
            //hline(4, title = "4 line", color = color.yellow, linestyle = hline.style_solid, editable = false)
            //hline(6, title = "6 line", color = color.red, linestyle = hline.style_solid, editable = false)

            //----------------------------------------------------------
            // Plot histogram for Webby's RSI, ignoring negative values
            //----------------------------------------------------------
            //plot(series = lowVs21DayMovingAverage > 0 ? abs(lowVs21DayMovingAverage) : na,
            // title = "Webby's RSI Histogram",
            // color = color.aqua,
            // linewidth = plotStyle == "Histogram" ? 2 : na,
            // style = plotStyle == "Histogram" ? plot.style_histogram : plotStyle == "Line" ? plot.style_line : plotStyle == "Area" ? plot.style_area : plot.style_columns,
            // editable = false)

            //----------------------------------------------------------
            // Show moving average across the plot
            //----------------------------------------------------------
            //plot(series = movingAverage > 0 ? movingAverage : na,
            // title = "Moving Average",
            // color = #C20690, 
            // editable = true)
            List<decimal> rsiList = new();
            List<decimal> rsiMaList = new();
            List<Signal> signalsList = new();

            try
            {
                int smoothLength = days;
                int length = (int)Math.Ceiling(smoothLength / 0.4762);

                var maList = GetMovingAverageList(maType, null, stockDataClass, length);
                var minMaxList = VolumeInputCheck(stockDataClass, 0, false);
                var lowList = minMaxList.Item2;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal currentLow = lowList.ElementAtOrDefault(i);
                    decimal currentMa = maList.ElementAtOrDefault(i);

                    decimal rsi = currentValue != 0 ? (currentLow - currentMa) / currentValue * 100 : 0;
                    rsiList.Add(rsi);
                }

                rsiMaList = GetMovingAverageList(maType, rsiList, stockDataClass, smoothLength);
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal rsi = rsiMaList.ElementAtOrDefault(j);
                    decimal prevRsi1 = j >= 1 ? rsiMaList.ElementAtOrDefault(j - 1) : 0;
                    decimal prevRsi2 = j >= 2 ? rsiMaList.ElementAtOrDefault(j - 2) : 0;

                    var signal = GetCompareSignal(rsi - prevRsi1, prevRsi1 - prevRsi2);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (rsiList, rsiMaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateZScore(StockData stockDataClass, int days = 14)
        {
            //@version=3
            // Copyright (c) 2018-present, Alex Orekhov (everget)
            // Z-Score script may be freely distributed under the MIT license.
            //study("Z-Score", shorttitle = "ZSC")

            //length = input(title = "Length", type = integer, minval = 1, defval = 14)
            //stdevInput = input(title = "Standard Deviation", defval = "Population", options =["Population", "Sample"])
            //src = input(title = "Source", type = source, defval = close)

            //sampleStdev(src, length) =>
            //    dev = src - sma(src, length)
            //    variance = sum(dev * dev, length) / (length - 1)
            //    sqrt(variance)

            //selectedStdev = stdevInput == "Population"
            //     ? stdev(src, length)
            //     : sampleStdev(src, length)

            //zsc = (src - sma(src, length)) / selectedStdev

            //zscColor = zsc > 2 ? #0ebb23 : zsc < -2 ? red : #674ea7

            //plot(zsc, title = "Z-Score", linewidth = 2, color = zscColor, transp = 0)

            //hline(2, title = "Upper Level", linestyle = dotted, color =#e69138)
            //hline(0, title = "Zero Level", linestyle = dotted, color =#989898)
            //hline(-2, title = "Lower Level", linestyle = dotted, color =#e69138)
            List<decimal> zScoreSampleList = new();
            List<decimal> zScorePopulationList = new();
            List<decimal> devSquaredList = new();
            List<decimal> devSquaredSumList = new();
            List<decimal> varianceSampleList = new();
            List<decimal> variancePopulationList = new();
            List<decimal> stdDevPopulationList = new();
            List<decimal> stdDevSampleList = new();
            List<Signal> signalsList = new();

            try
            {
                List<decimal> smaList = CalculateSimpleMovingAverage(stockDataClass, days).Item1;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal sma = smaList.ElementAtOrDefault(i);
                    decimal dev = currentValue - sma;

                    decimal devSquared = dev * dev;
                    devSquaredList.Add(devSquared);

                    decimal devSquaredSum = devSquaredList.TakeLast(days).Sum();
                    devSquaredSumList.Add(devSquaredSum);

                    decimal varianceSample = devSquaredSum / (days - 1);
                    varianceSampleList.Add(varianceSample);

                    decimal stdDevSample = varianceSample >= 0 ? (decimal)Sqrt((double)varianceSample) : 0;
                    stdDevSampleList.Add(stdDevSample);

                    decimal zScoreSample = stdDevSample != 0 ? dev / stdDevSample : 0;
                    zScoreSampleList.Add(zScoreSample);

                    decimal variancePopulation = devSquaredSum / days;
                    variancePopulationList.Add(variancePopulation);

                    decimal stdDevPopulation = variancePopulation >= 0 ? (decimal)Sqrt((double)variancePopulation) : 0;
                    stdDevPopulationList.Add(stdDevPopulation);

                    decimal prevZScorePopulation = zScorePopulationList.LastOrDefault();
                    decimal zScorePopulation = stdDevPopulation != 0 ? dev / stdDevPopulation : 0;
                    zScorePopulationList.Add(zScorePopulation);

                    var signal = GetCompareSignal(zScorePopulation, prevZScorePopulation);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (devSquaredSumList, varianceSampleList, stdDevSampleList, zScoreSampleList, variancePopulationList, stdDevPopulationList, zScorePopulationList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateFastZScore(StockData stockDataClass, string maType, int days = 200)
        {
            //@version=2
            //study("Fast Z-score")
            //length = input(200)
            //
            //src = sma(close, length)
            //gs = (linreg(src, length / 2, 0) - linreg(src, length, 0)) / stdev(src, length) / 2
            //plot(gs, color =#00BFFF,transp=0)
            List<decimal> gsList = new();
            List<decimal> smaStdDevList = new();
            List<decimal> smaLinregList = new();
            List<Signal> signalsList = new();

            try
            {
                int length1 = days;
                int length2 = MinOrMax((int)Math.Ceiling((decimal)days / 2));

                var smaList = GetMovingAverageList(maType, null, stockDataClass, length1);
                smaLinregList = CalculateLinearRegression(smaList, stockDataClass, length1).Item15;
                var linreg2List = CalculateLinearRegression(smaList, stockDataClass, length2).Item15;
                smaStdDevList = CalculateStandardDeviationVolatility(smaList, stockDataClass, length1).Item4;
                var emaList = CalculateExponentialMovingAverage(stockDataClass, length1).Item1;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal ema = emaList.ElementAtOrDefault(i);
                    decimal stdDev = smaStdDevList.ElementAtOrDefault(i);
                    decimal linreg = smaLinregList.ElementAtOrDefault(i);
                    decimal linreg2 = linreg2List.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevEma = i >= 1 ? emaList.ElementAtOrDefault(i - 1) : 0;

                    decimal gs = stdDev != 0 ? (linreg2 - linreg) / stdDev / 2 : 0;
                    gsList.Add(gs);

                    var signal = GetVolatilitySignal(currentValue - ema, prevValue - prevEma, gs, 0);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (smaLinregList, smaStdDevList, gsList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>)
            CalculateEdgePreservingFilter(StockData stockDataClass, string maType, int days = 200)
        {
            //@version=3
            //study("Edge-Preserving Filter", overlay = true)
            //length = input(200),smooth = input(50)
            //----
            //src = close
            //os = src - sma(src, length)
            //p = linreg(abs(os), smooth, 0)
            //h = p / highest(p, length)
            //----
            //cnd = h == 1 and h[1] != 1
            //sign = cnd and os< 0 ? 1 : cnd and os > 0 ? -1 : 0
            //----
            //condition = sign != 0
            //a = 0.
            //b = 0.
            //a := condition ? 1 : nz(a[1], 1) + 1
            //b:= a == 1 ? src : nz(b[1], src) + src
            //c = b / a
            //----
            //plot(c, color =#FE2E64,linewidth=2,transp=0)
            List<decimal> osList = new();
            List<decimal> absOsList = new();
            List<decimal> pList = new();
            List<decimal> highestList = new();
            List<decimal> hList = new();
            List<decimal> aList = new();
            List<decimal> bList = new();
            List<decimal> cList = new();
            List<decimal> cndList = new();
            List<decimal> signList = new();
            List<Signal> signalsList = new();

            try
            {
                int length = MinOrMax((int)Math.Ceiling((decimal)days / 4));

                var smaList = GetMovingAverageList(maType, null, stockDataClass, days);

                for (int h = 0; h < stockDataClass.InputValues.Count; h++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(h);
                    decimal sma = smaList.ElementAtOrDefault(h);

                    decimal os = currentValue - sma;
                    osList.Add(os);

                    decimal absOs = Math.Abs(os);
                    absOsList.Add(absOs);
                }

                pList = CalculateLinearRegression(absOsList, stockDataClass, length).Item15;
                highestList = GetMaxAndMinValuesList(pList, days).Item1;
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal p = pList.ElementAtOrDefault(i);
                    decimal highest = highestList.ElementAtOrDefault(i);
                    decimal os = osList.ElementAtOrDefault(i);

                    decimal prevH = hList.LastOrDefault();
                    decimal h = highest != 0 ? p / highest : 0;
                    hList.Add(h);

                    decimal cnd = h == 1 && prevH != 1 ? 1 : 0;
                    cndList.Add(cnd);

                    decimal sign = cnd == 1 && os < 0 ? 1 : cnd == 1 && os > 0 ? -1 : 0;
                    signList.Add(sign);

                    decimal prevA = i >= 1 ? aList.ElementAtOrDefault(i - 1) : 1;
                    bool condition = sign != 0;
                    decimal a = condition ? 1 : prevA + 1;
                    aList.Add(a);

                    decimal prevB = i >= 1 ? bList.ElementAtOrDefault(i - 1) : currentValue;
                    decimal b = a == 1 ? currentValue : prevB + currentValue;
                    bList.Add(b);

                    decimal prevC = cList.LastOrDefault();
                    decimal c = a != 0 ? b / a : 0;
                    cList.Add(c);

                    var signal = GetCompareSignal(currentValue - c, prevValue - prevC);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (pList, highestList, hList, cndList, signList, aList, bList, cList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>)
            CalculateAbsoluteStrengthMTFIndicator(StockData stockDataClass, string maType, int days = 50)
        {
            //@version=3
            //study("Absolute Strength MTF Indicator")
            //----
            //Length = input(50, title = "Period of Evaluation")
            //Smooth = input(25, title = "Period of Smoothing")
            //----
            //src = input(close, title = "Source")
            //Resolution = input(defval = "1", type = resolution)
            //Mode = input(title = "Indicator Method", defval = "RSI", options =["RSI", "STOCHASTIC", "ADX"])
            //Ma = input(title = "Moving Average Method", defval = "SMA", options =["SMA", "EMA", "LSMA"])
            //----
            //Price = security(tickerid, Resolution, close)
            //f(x, Length) => Ma == "SMA" ? sma(x, Length) : Ma == "EMA" ? ema(x, Length) : linreg(x, Length, 0)
            //----
            //Price1 = f(Price, Length)
            //Price2 = f(Price[1], Length)
            //Bulls0 = 0.5 * (abs(Price1 - Price2) + (Price1 - Price2))
            //Bears0 = 0.5 * (abs(Price1 - Price2) - (Price1 - Price2))
            //----           
            //Bulls1 = Price1 - lowest(Price1, Length)
            //Bears1 = highest(Price1, Length) - Price1
            //Bulls2 = 0.5 * (abs(high - high[1]) + (high - high[1]))
            //Bears2 = 0.5 * (abs(low[1] - low) + (low[1] - low))
            //----
            //Bulls = Mode == "RSI" ? Bulls0 : Mode == "STOCHASTIC" ? Bulls1 : Bulls2
            //Bears = Mode == "RSI" ? Bears0 : Mode == "STOCHASTIC" ? Bears1 : Bears2
            //AvgBulls = f(Bulls, Length)
            //AvgBears = f(Bears, Length)
            //----
            //SmthBulls = f(AvgBulls, Smooth)
            //SmthBears = f(AvgBears, Smooth)
            //trend = SmthBulls > SmthBears ? 1 : -1
            //----
            //A = plot(SmthBulls, color =#0080FF,linewidth=2,transp=0)
            //B = plot(SmthBears, color =#FE2E64,linewidth=2,transp=0)
            //fill(A, B, color = trend == 1 ?#0080FF:#FE2E64,transp=80)
            List<decimal> price2List = new();
            List<decimal> prevValuesList = new();
            List<decimal> bulls0List = new();
            List<decimal> bears0List = new();
            List<decimal> bulls1List = new();
            List<decimal> bears1List = new();
            List<decimal> bulls2List = new();
            List<decimal> bears2List = new();
            List<decimal> avgBulls0List = new();
            List<decimal> avgBears0List = new();
            List<decimal> avgBulls1List = new();
            List<decimal> avgBears1List = new();
            List<decimal> avgBulls2List = new();
            List<decimal> avgBears2List = new();
            List<decimal> smthBulls0List = new();
            List<decimal> smthBears0List = new();
            List<decimal> smthBulls1List = new();
            List<decimal> smthBears1List = new();
            List<decimal> smthBulls2List = new();
            List<decimal> smthBears2List = new();
            List<Signal> signalsList = new();

            try
            {
                int length = MinOrMax((int)Math.Ceiling((decimal)days / 2));

                for (int h = 0; h < stockDataClass.InputValues.Count; h++)
                {
                    decimal prevValue = h >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(h - 1) : 0;
                    prevValuesList.Add(prevValue);
                }

                var price1List = GetMovingAverageList(maType, null, stockDataClass, days);
                price2List = GetMovingAverageList(maType, prevValuesList, stockDataClass, days);
                var minMaxList = VolumeInputCheck(stockDataClass, days, true);
                var highestList = minMaxList.Item1;
                var lowestList = minMaxList.Item2;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal price1 = price1List.ElementAtOrDefault(i);
                    decimal price2 = price2List.ElementAtOrDefault(i);
                    decimal highest = highestList.ElementAtOrDefault(i);
                    decimal lowest = lowestList.ElementAtOrDefault(i);
                    decimal high = stockDataClass.HighPrices.ElementAtOrDefault(i);
                    decimal low = stockDataClass.LowPrices.ElementAtOrDefault(i);
                    decimal prevHigh = i >= 1 ? stockDataClass.HighPrices.ElementAtOrDefault(i - 1) : 0;
                    decimal prevLow = i >= 1 ? stockDataClass.LowPrices.ElementAtOrDefault(i - 1) : 0;

                    decimal bulls0 = 0.5m * (Math.Abs(price1 - price2) + (price1 - price2));
                    bulls0List.Add(bulls0);

                    decimal bears0 = 0.5m * (Math.Abs(price1 - price2) - (price1 - price2));
                    bears0List.Add(bears0);

                    decimal bulls1 = price1 - lowest;
                    bulls1List.Add(bulls1);

                    decimal bears1 = highest - price1;
                    bears1List.Add(bears1);

                    decimal bulls2 = 0.5m * (Math.Abs(high - prevHigh) + (high - prevHigh));
                    bulls2List.Add(bulls2);

                    decimal bears2 = 0.5m * (Math.Abs(prevLow - low) + (prevLow - low));
                    bears2List.Add(bears2);
                }

                avgBulls0List = GetMovingAverageList(maType, bulls0List, stockDataClass, days);
                avgBears0List = GetMovingAverageList(maType, bears0List, stockDataClass, days);
                avgBulls1List = GetMovingAverageList(maType, bulls1List, stockDataClass, days);
                avgBears1List = GetMovingAverageList(maType, bears1List, stockDataClass, days);
                avgBulls2List = GetMovingAverageList(maType, bulls2List, stockDataClass, days);
                avgBears2List = GetMovingAverageList(maType, bears2List, stockDataClass, days);
                smthBulls0List = GetMovingAverageList(maType, avgBulls0List, stockDataClass, length);
                smthBears0List = GetMovingAverageList(maType, avgBears0List, stockDataClass, length);
                smthBulls1List = GetMovingAverageList(maType, avgBulls1List, stockDataClass, length);
                smthBears1List = GetMovingAverageList(maType, avgBears1List, stockDataClass, length);
                smthBulls2List = GetMovingAverageList(maType, avgBulls2List, stockDataClass, length);
                smthBears2List = GetMovingAverageList(maType, avgBears2List, stockDataClass, length);
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal bulls = smthBulls0List.ElementAtOrDefault(j);
                    decimal bears = smthBears0List.ElementAtOrDefault(j);
                    decimal prevBulls = j >= 1 ? smthBulls0List.ElementAtOrDefault(j - 1) : 0;
                    decimal prevBears = j >= 1 ? smthBears0List.ElementAtOrDefault(j - 1) : 0;

                    var signal = GetCompareSignal(bulls - bears, prevBulls - prevBears);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (price2List, bulls0List, bears0List, bulls1List, bears1List, bulls2List, bears2List, avgBulls0List, avgBears0List, avgBulls1List, avgBears1List, avgBulls2List,
                avgBears2List, smthBulls0List, smthBears0List, smthBulls1List, smthBears1List, smthBulls2List, smthBears2List, signalsList);
        }

        public static (List<decimal>, List<Signal>) CalculateTrendStep(StockData stockDataClass, int days = 50)
        {
            //@version=3
            //study("Trend Step", overlay = true)
            //length = input(50)
            //
            //src = close
            //dev = stdev(src, length) * 2
            //a = 0.
            //a := n < length ? src : src > nz(a[1], src) + dev ? src : src < nz(a[1], src) - dev ? src : a[1]
            //css = fixnan(a > a[1] ? #2196f3 : a < a[1] ? #e65100 : na)
            //plot(a, color = css, linewidth = 2, transp = 0)
            List<decimal> aList = new();
            List<Signal> signalsList = new();

            try
            {
                List<decimal> stdDevList = CalculateStandardDeviationVolatility(null, stockDataClass, days).Item4;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal dev = stdDevList.ElementAtOrDefault(i) * 2;

                    decimal prevA = i >= 1 ? aList.ElementAtOrDefault(i - 1) : currentValue;
                    decimal a = i < days ? currentValue : currentValue > prevA + dev ? currentValue : currentValue < prevA - dev ? currentValue : prevA;
                    aList.Add(a);

                    var signal = GetCompareSignal(currentValue - a, prevValue - prevA);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (aList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<decimal>, List<Signal>) CalculateQuasiWhiteNoise(StockData stockDataClass, string maType, int days = 20)
        {
            //@version=3
            // Copyright (c) 2018-present, Alex Orekhov (everget)
            // Quasi White Noise script may be freely distributed under the MIT license.
            //study("Quasi White Noise", shorttitle = "QWN")

            //divisor = input(title = "Divisor", type = float, minval = 1, defval = 40)
            //useMintick = input(title = "Use mintick as divisor ?", type = bool, defval = false)
            //src = input(title = "Source", type = source, defval = close)

            // Connors RSI (by Larry Connors) is used as a model of the white noise
            //            updown(src) =>
            //    ud = 0.0
            //    ud:= src == nz(src[1])
            //        ? 0
            //        : src > nz(src[1])
            //            ? (nz(ud[1]) <= 0
            //                ? 1
            //                : nz(ud[1]) + 1)
            //            : (nz(ud[1]) >= 0
            //                ? -1
            //                : nz(ud[1]) - 1)

            //getCRSI(src, rsiLength, updownLength, rocLength) =>
            //    updownrsi = rsi(updown(src), updownLength)
            //    percentrank = percentrank(roc(src, 1), rocLength)
            //    crsi = avg(rsi(src, rsiLength), updownrsi, percentrank)

            //whiteNoiseLength = 500
            //crsi = getCRSI(src, whiteNoiseLength, whiteNoiseLength, 20)

            //whiteNoise = (crsi - 50) * (useMintick ? syminfo.mintick : 1 / divisor)

            //plot(whiteNoise, title = "Dist", color =#351c75)
            //plot(sma(whiteNoise, whiteNoiseLength), title = "Mean", color =#ff006e)
            //plot(pow(stdev(whiteNoise, whiteNoiseLength), 2), title = "Variance", color =#ff6a00)
            List<decimal> tempList = new();
            List<decimal> pctRankList = new();
            List<decimal> streakList = new();
            List<decimal> rsiStreakList = new();
            List<decimal> connorsRsiList = new();
            List<decimal> whiteNoiseList = new();
            List<decimal> whiteNoiseSmaList = new();
            List<decimal> whiteNoiseStdDevList = new();
            List<decimal> whiteNoiseVarianceList = new();
            List<Signal> signalsList = new();

            try
            {
                int divisor = MinOrMax(days * 2);
                int whiteNoiseLength = MinOrMax((int)Math.Ceiling(days / 0.04));

                var rsiList = CalculateRelativeStrengthIndex(null, stockDataClass, maType, whiteNoiseLength).Item4;
                var rocList = CalculateRateOfChange(null, stockDataClass, 1).Item1;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal roc = rocList.ElementAtOrDefault(i);
                    tempList.Add(roc);

                    var lookBackList = tempList.TakeLast(days).Take(days - 1).ToList();
                    int count = lookBackList.Where(x => x <= roc).Count();
                    decimal pctRank = MinOrMax((decimal)count / days * 100, 100, 0);
                    pctRankList.Add(pctRank);

                    decimal prevStreak = streakList.LastOrDefault();
                    decimal streak = currentValue > prevValue ? prevStreak >= 0 ? prevStreak + 1 : 1 : currentValue < prevValue ? prevStreak <= 0 ? prevStreak - 1 : -1 : 0;
                    streakList.Add(streak);
                }

                rsiStreakList = CalculateRelativeStrengthIndex(streakList, stockDataClass, maType, whiteNoiseLength).Item4;
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal currentRsi = rsiList.ElementAtOrDefault(j);
                    decimal percentRank = pctRankList.ElementAtOrDefault(j);
                    decimal streakRsi = rsiStreakList.ElementAtOrDefault(j);
                    decimal prevConnorsRsi1 = j >= 1 ? connorsRsiList.ElementAtOrDefault(j - 1) : 0;
                    decimal prevConnorsRsi2 = j >= 2 ? connorsRsiList.ElementAtOrDefault(j - 2) : 0;

                    decimal connorsRsi = MinOrMax((currentRsi + percentRank + streakRsi) / 3, 100, 0);
                    connorsRsiList.Add(connorsRsi);

                    decimal whiteNoise = (connorsRsi - 50) * ((decimal)1 / divisor);
                    whiteNoiseList.Add(whiteNoise);

                    var signal = GetRsiSignal(connorsRsi - prevConnorsRsi1, prevConnorsRsi1 - prevConnorsRsi2, connorsRsi, prevConnorsRsi1, 70, 30);
                    signalsList.Add(signal);
                }

                whiteNoiseSmaList = GetMovingAverageList(maType, whiteNoiseList, stockDataClass, whiteNoiseLength);
                whiteNoiseStdDevList = CalculateStandardDeviationVolatility(whiteNoiseList, stockDataClass, whiteNoiseLength).Item4;
                for (int k = 0; k < stockDataClass.InputValues.Count; k++)
                {
                    decimal whiteNoiseStdDev = whiteNoiseStdDevList.ElementAtOrDefault(k);

                    decimal whiteNoiseVariance = Pow(whiteNoiseStdDev, 2);
                    whiteNoiseVarianceList.Add(whiteNoiseVariance);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (pctRankList, rsiStreakList, connorsRsiList, whiteNoiseList, whiteNoiseSmaList, whiteNoiseStdDevList, whiteNoiseVarianceList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateKendallRankCorrelationCoefficient(StockData stockDataClass, int days = 20)
        {
            //@version=3
            // Copyright (c) 2018-present, Alex Orekhov (everget)
            // Kendall Rank Correlation Coefficient script may be freely distributed under the MIT license.
            //study("Kendall Rank Correlation Coefficient", shorttitle = "Kendall Correlation")

            //length = input(title = "Length", type = integer, defval = 20)
            //sym1 = input(title = "1st Symbol", type = symbol, defval = "FX:AUDUSD")
            //sym2 = input(title = "2nd Symbol", type = symbol, defval = "FOREXCOM:XAUUSD")
            //src = input(title = "Source", type = source, defval = close)

            //data1 = security(sym1, period, src)
            //data2 = security(sym2, period, src)

            //getKendall(data1, data2, length) =>
            //    totalPairs = length * (length - 1) / 2
            //    numerator = 0.0

            //    for i = 0 to length - 1
            //        for j = 0 to i
            //            numerator := numerator + sign(data1[i] - data1[j]) * sign(data2[i] - data2[j])

            //    numerator / totalPairs

            //kendallCorr = sym1 == sym2 ? 1 : getKendall(data1, data2, length)
            //pearsonCorr = correlation(data1, data2, length)

            //plot(kendallCorr, title = "Kendall", color = orange, transp = 0)
            //plot(pearsonCorr, title = "Pearson", color = purple, transp = 0)
            List<decimal> tempList = new();
            List<decimal> numeratorList = new();
            List<decimal> tempLinRegList = new();
            List<decimal> pearsonCorrelationList = new();
            List<decimal> kendallCorrelationList = new();
            List<Signal> signalsList = new();

            try
            {
                List<decimal> linRegList = CalculateLinearRegression(null, stockDataClass, days).Item15;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal prevKendall1 = i >= 1 ? kendallCorrelationList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevKendall2 = i >= 2 ? kendallCorrelationList.ElementAtOrDefault(i - 2) : 0;

                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    tempList.Add(currentValue);

                    decimal linReg = linRegList.ElementAtOrDefault(i);
                    tempLinRegList.Add(linReg);

                    var pearsonCorrelation = Correlation.Pearson(tempLinRegList.TakeLast(days).Select(x => (double)x), tempList.TakeLast(days).Select(x => (double)x));
                    pearsonCorrelation = IsValueNullOrInfinity(pearsonCorrelation) ? 0 : pearsonCorrelation;
                    pearsonCorrelationList.Add((decimal)pearsonCorrelation);

                    decimal totalPairs = days * (days - 1) / 2;
                    decimal numerator = 0;
                    for (int j = 0; j <= days - 1; j++)
                    {
                        for (int k = 0; k <= j; k++)
                        {
                            decimal prevValueJ = i >= j ? stockDataClass.InputValues.ElementAtOrDefault(i - j) : 0;
                            decimal prevValueK = i >= k ? stockDataClass.InputValues.ElementAtOrDefault(i - k) : 0;
                            decimal prevLinRegJ = i >= j ? linRegList.ElementAtOrDefault(i - j) : 0;
                            decimal prevLinRegK = i >= k ? linRegList.ElementAtOrDefault(i - k) : 0;

                            numerator += Math.Sign(prevLinRegJ - prevLinRegK) * Math.Sign(prevValueJ - prevValueK);
                        }
                    }
                    numeratorList.Add(numerator);

                    decimal kendallCorrelation = numerator / totalPairs;
                    kendallCorrelationList.Add(kendallCorrelation);

                    var signal = GetCompareSignal(kendallCorrelation - prevKendall1, prevKendall1 - prevKendall2);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (pearsonCorrelationList, numeratorList, kendallCorrelationList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>)
            CalculateVostroIndicator(StockData stockDataClass, string maType, int days = 5)
        {
            //@version=2
            //author:Kıvanç Özbilgiç @fr3762 on twitter
            //study("The Vostro Indicator")
            //period156 = input(100, minval = 1)
            //level = input(8, type = integer)
            //gd120 = sum(hl2, 5)
            //gd128 = gd120 * .2
            //gd121 = sum(high - low, 5)
            //gd136 = gd121 * .2 * .2

            //ibuff116 = (low - gd128) / gd136
            //ibuff112 = (high - gd128) / gd136

            //ibuff108 = iff(ibuff112 > level and high > wma(hl2, period156), 90, iff(ibuff116 < -level and low < wma(hl2, period156), -90, 0))
            //ibuff109 = iff((ibuff112 > level and ibuff112[1] > level) or(ibuff116 < -level and ibuff116[1] < -8),0,ibuff108)
            //plot(ibuff109, color = blue, linewidth = 2)
            //plot(80)
            //plot(-80)
            List<decimal> tempList = new();
            List<decimal> rangeList = new();
            List<decimal> gd120List = new();
            List<decimal> gd128List = new();
            List<decimal> gd121List = new();
            List<decimal> gd136List = new();
            List<decimal> iBuff116List = new();
            List<decimal> iBuff112List = new();
            List<decimal> iBuff108List = new();
            List<decimal> iBuff109List = new();
            List<Signal> signalsList = new();
            decimal level = 8;

            try
            {
                int period156 = MinOrMax(days * 20);

                List<decimal> medianPriceList = CalculateMedianPrice(stockDataClass).Item2;
                List<decimal> wmaList = GetMovingAverageList(maType, medianPriceList, stockDataClass, period156);

                for (int i = 0; i < stockDataClass.HighPrices.Count; i++)
                {
                    decimal currentHigh = stockDataClass.HighPrices.ElementAtOrDefault(i);
                    decimal currentLow = stockDataClass.LowPrices.ElementAtOrDefault(i);
                    decimal wma = wmaList.ElementAtOrDefault(i);
                    decimal prevBuff109_1 = i >= 1 ? iBuff109List.ElementAtOrDefault(i - 1) : 0;
                    decimal prevBuff109_2 = i >= 2 ? iBuff109List.ElementAtOrDefault(i - 2) : 0;

                    decimal medianPrice = medianPriceList.ElementAtOrDefault(i);
                    tempList.Add(medianPrice);

                    decimal range = currentHigh - currentLow;
                    rangeList.Add(range);

                    decimal gd120 = tempList.TakeLast(days).Sum();
                    gd120List.Add(gd120);

                    decimal gd128 = gd120 * 0.2m;
                    gd128List.Add(gd128);

                    decimal gd121 = rangeList.TakeLast(days).Sum();
                    gd121List.Add(gd121);

                    decimal gd136 = gd121 * 0.2m * 0.2m;
                    gd136List.Add(gd136);

                    decimal prevIBuff116 = iBuff116List.LastOrDefault();
                    decimal iBuff116 = gd136 != 0 ? (currentLow - gd128) / gd136 : 0;
                    iBuff116List.Add(iBuff116);

                    decimal prevIBuff112 = iBuff112List.LastOrDefault();
                    decimal iBuff112 = gd136 != 0 ? (currentHigh - gd128) / gd136 : 0;
                    iBuff112List.Add(iBuff112);

                    decimal iBuff108 = iBuff112 > level && currentHigh > wma ? 90 : iBuff116 < -level && currentLow < wma ? -90 : 0;
                    iBuff108List.Add(iBuff108);

                    decimal iBuff109 = (iBuff112 > level && prevIBuff112 > level) || (iBuff116 < -level && prevIBuff116 < -level) ? 0 : iBuff108;
                    iBuff109List.Add(iBuff109);

                    var signal = GetRsiSignal(iBuff109 - prevBuff109_1, prevBuff109_1 - prevBuff109_2, iBuff109, prevBuff109_1, 80, -80);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (gd120List, gd128List, gd121List, gd136List, iBuff116List, iBuff112List, iBuff108List, iBuff109List, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>)
            CalculateLindaRaschke3_10Oscillator(StockData stockDataClass, string maType, int days = 3)
        {
            //study("Linda3/10")
            //fast = 3, slow = 10, smoothing = 16
            //fastMA = sma(close, fast)
            //slowMA = sma(close, slow)
            //macd = fastMA - slowMA
            //hline(0, linestyle = solid)
            //signal = sma(macd, smoothing)
            //plot(macd, color = blue)
            //plot(signal, color = red, linewidth = 2)
            //plot(macd, color = blue, style = histogram)
            // macd line is 12 day ema - 26 day ema
            // macd signal line is 9 day ema of macd
            // Percentage Price Oscillator (PPO): {(12-day EMA - 26-day EMA)/26-day EMA} x 100
            // absolute price oscillator = 12 day ema - 26 day ema
            //Signal Line: 9 - day EMA of PPO
            //PPO Histogram: PPO - Signal Line
            List<decimal> macdList = new();
            List<decimal> macdSignalLineList = new();
            List<decimal> macdHistogramList = new();
            List<decimal> ppoList = new();
            List<decimal> ppoSignalLineList = new();
            List<decimal> ppoHistogramList = new();
            List<Signal> signalsList = new();

            try
            {
                int fast = days;
                int slow = MinOrMax((int)Math.Ceiling(fast / 0.3));
                int smoothing = MinOrMax((int)Math.Ceiling(fast / 0.1875));

                List<decimal> fastSmaList = GetMovingAverageList(maType, null, stockDataClass, fast);
                List<decimal> slowSmaList = GetMovingAverageList(maType, null, stockDataClass, slow);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal sma3 = fastSmaList.ElementAtOrDefault(i);
                    decimal sma10 = slowSmaList.ElementAtOrDefault(i);

                    decimal ppo = sma10 != 0 ? (sma3 - sma10) / sma10 * 100 : 0;
                    ppoList.Add(ppo);

                    decimal macd = sma3 - sma10;
                    macdList.Add(macd);
                }

                macdSignalLineList = GetMovingAverageList(maType, macdList, stockDataClass, smoothing);
                ppoSignalLineList = GetMovingAverageList(maType, ppoList, stockDataClass, smoothing);
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal ppo = ppoList.ElementAtOrDefault(j);
                    decimal ppoSignalLine = ppoSignalLineList.ElementAtOrDefault(j);
                    decimal macd = macdList.ElementAtOrDefault(j);
                    decimal macdSignalLine = macdSignalLineList.ElementAtOrDefault(j);

                    decimal ppoHistogram = ppo - ppoSignalLine;
                    ppoHistogramList.Add(ppoHistogram);

                    decimal prevMacdHistogram = macdHistogramList.LastOrDefault();
                    decimal macdHistogram = macd - macdSignalLine;
                    macdHistogramList.Add(macdHistogram);

                    var signal = GetCompareSignal(macdHistogram, prevMacdHistogram);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (macdList, macdSignalLineList, macdHistogramList, ppoList, ppoSignalLineList, ppoHistogramList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) Calculate4MovingAverageConvergenceDivergence(StockData stockDataClass, string maType, int days = 5)
        {
            // @author LazyBear
            //
            //study(title = "4MACD [LazyBear]", shorttitle = "4MACD_LB")

            //source = close
            //mult_b = input(4.3, title = "Blue multiplier")
            //mult_y = input(1.4, title = "Yellow multiplier")

            //ema5 = ema(close, 5)
            //ema8 = ema(close, 8)
            //ema10 = ema(close, 10)
            //ema17 = ema(source, 17)
            //ema14 = ema(source, 14)
            //ema16 = ema(close, 16)
            //ema17_14 = ema17 - ema14
            //ema17_8 = ema17 - ema8
            //ema10_16 = ema10 - ema16
            //ema5_10 = ema5 - ema10

            //MACDBlue = mult_b * (ema17_14 - ema(ema17_14, 5))
            //MACDRed = ema17_8 - ema(ema17_8, 5)
            //MACDYellow = mult_y * (ema10_16 - ema(ema10_16, 5))
            //MACDGreen = ema5_10 - ema(ema5_10, 5)

            //plot(MACDBlue, style = histogram, color =#0066cc, linewidth=4)
            //plot(MACDRed, style = histogram, color = red, linewidth = 4)
            //plot(MACDYellow, style = histogram, color = yellow, linewidth = 4)
            //plot(MACDGreen, style = histogram, color = green, linewidth = 4)
            decimal multB = 4.3m, multY = 1.4m;
            List<decimal> macd1List = new();
            List<decimal> macd2List = new();
            List<decimal> macd3List = new();
            List<decimal> macd4List = new();
            List<decimal> macd1SignalLineList = new();
            List<decimal> macd2SignalLineList = new();
            List<decimal> macd3SignalLineList = new();
            List<decimal> macd4SignalLineList = new();
            List<decimal> macd1HistogramList = new();
            List<decimal> macd2HistogramList = new();
            List<decimal> macd3HistogramList = new();
            List<decimal> macd4HistogramList = new();
            List<decimal> macdBlueList = new();
            List<decimal> macdYellowList = new();
            List<decimal> macdStochasticList = new();
            List<decimal> maxMacdList = new();
            List<decimal> minMacdList = new();
            List<decimal> currentMacdList = new();
            List<Signal> signalsList = new();

            try
            {
                int ema8Period = MinOrMax((int)Math.Ceiling(days / 0.625));
                int ema10Period = MinOrMax(days * 2);
                int ema17Period = MinOrMax((int)Math.Ceiling(days / 0.2942));
                int ema14Period = MinOrMax((int)Math.Ceiling(days / 0.3572));
                int ema16Period = MinOrMax(ema8Period * 2);

                List<decimal> ema5List = GetMovingAverageList(maType, null, stockDataClass, days);
                List<decimal> ema8List = GetMovingAverageList(maType, null, stockDataClass, ema8Period);
                List<decimal> ema10List = GetMovingAverageList(maType, null, stockDataClass, ema10Period);
                List<decimal> ema17List = GetMovingAverageList(maType, null, stockDataClass, ema17Period);
                List<decimal> ema14List = GetMovingAverageList(maType, null, stockDataClass, ema14Period);
                List<decimal> ema16List = GetMovingAverageList(maType, null, stockDataClass, ema16Period);

                for (int i = 0; i < ema5List.Count; i++)
                {
                    decimal ema5 = ema5List.ElementAtOrDefault(i);
                    decimal ema8 = ema8List.ElementAtOrDefault(i);
                    decimal ema10 = ema10List.ElementAtOrDefault(i);
                    decimal ema14 = ema14List.ElementAtOrDefault(i);
                    decimal ema16 = ema16List.ElementAtOrDefault(i);
                    decimal ema17 = ema17List.ElementAtOrDefault(i);

                    decimal macd1 = ema17 - ema14;
                    macd1List.Add(macd1);

                    decimal macd2 = ema17 - ema8;
                    macd2List.Add(macd2);

                    decimal macd3 = ema10 - ema16;
                    macd3List.Add(macd3);

                    decimal macd4 = ema5 - ema10;
                    macd4List.Add(macd4);
                }

                macd1SignalLineList = GetMovingAverageList(maType, macd1List, stockDataClass, days);
                macd2SignalLineList = GetMovingAverageList(maType, macd2List, stockDataClass, days);
                macd3SignalLineList = GetMovingAverageList(maType, macd3List, stockDataClass, days);
                macd4SignalLineList = GetMovingAverageList(maType, macd4List, stockDataClass, days);
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal macd1 = macd1List.ElementAtOrDefault(j);
                    decimal macd1SignalLine = macd1SignalLineList.ElementAtOrDefault(j);
                    decimal macd2 = macd2List.ElementAtOrDefault(j);
                    decimal macd2SignalLine = macd2SignalLineList.ElementAtOrDefault(j);
                    decimal macd3 = macd3List.ElementAtOrDefault(j);
                    decimal macd3SignalLine = macd3SignalLineList.ElementAtOrDefault(j);
                    decimal macd4 = macd4List.ElementAtOrDefault(j);
                    decimal macd4SignalLine = macd4SignalLineList.ElementAtOrDefault(j);

                    decimal macd1Histogram = macd1 - macd1SignalLine;
                    macd1HistogramList.Add(macd1Histogram);

                    decimal macdBlue = multB * macd1Histogram;
                    macdBlueList.Add(macdBlue);

                    decimal prevMacd2Histogram = macd2HistogramList.LastOrDefault();
                    decimal macd2Histogram = macd2 - macd2SignalLine;
                    macd2HistogramList.Add(macd2Histogram);

                    decimal macd3Histogram = macd3 - macd3SignalLine;
                    macd3HistogramList.Add(macd3Histogram);

                    decimal macdYellow = multY * macd3Histogram;
                    macdYellowList.Add(macdYellow);

                    decimal prevMacd4Histogram = macd4HistogramList.LastOrDefault();
                    decimal macd4Histogram = macd4 - macd4SignalLine;
                    macd4HistogramList.Add(macd4Histogram);

                    decimal maxMacd = Math.Max(macdBlue, Math.Max(macdYellow, Math.Max(macd2Histogram, macd4Histogram)));
                    maxMacdList.Add(maxMacd);

                    decimal minMacd = Math.Min(macdBlue, Math.Min(macdYellow, Math.Min(macd2Histogram, macd4Histogram)));
                    minMacdList.Add(minMacd);

                    decimal currentMacd = (macdBlue + macdYellow + macd2Histogram + macd4Histogram) / 4;
                    currentMacdList.Add(currentMacd);

                    decimal macdStochastic = maxMacd - minMacd != 0 ? MinOrMax((currentMacd - minMacd) / (maxMacd - minMacd) * 100, 100, 0) : 0;
                    macdStochasticList.Add(macdStochastic);

                    var signal = GetCompareSignal(macd4Histogram - macd2Histogram, prevMacd4Histogram - prevMacd2Histogram);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (macd1List, macd2List, macd3List, macd4List, macd1SignalLineList, macd2SignalLineList, macd3SignalLineList, macd4SignalLineList, macd1HistogramList,
                macd2HistogramList, macd3HistogramList, macd4HistogramList, macdBlueList, macdYellowList, maxMacdList, minMacdList, currentMacdList, macdStochasticList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) Calculate4PercentagePriceOscillator(StockData stockDataClass, string maType, int days = 5)
        {
            // @author LazyBear
            //
            //study(title = "4MACD [LazyBear]", shorttitle = "4MACD_LB")

            //source = close
            //mult_b = input(4.3, title = "Blue multiplier")
            //mult_y = input(1.4, title = "Yellow multiplier")

            //ema5 = ema(close, 5)
            //ema8 = ema(close, 8)
            //ema10 = ema(close, 10)
            //ema17 = ema(source, 17)
            //ema14 = ema(source, 14)
            //ema16 = ema(close, 16)
            //ema17_14 = ema17 - ema14
            //ema17_8 = ema17 - ema8
            //ema10_16 = ema10 - ema16
            //ema5_10 = ema5 - ema10

            //MACDBlue = mult_b * (ema17_14 - ema(ema17_14, 5))
            //MACDRed = ema17_8 - ema(ema17_8, 5)
            //MACDYellow = mult_y * (ema10_16 - ema(ema10_16, 5))
            //MACDGreen = ema5_10 - ema(ema5_10, 5)

            //plot(MACDBlue, style = histogram, color =#0066cc, linewidth=4)
            //plot(MACDRed, style = histogram, color = red, linewidth = 4)
            //plot(MACDYellow, style = histogram, color = yellow, linewidth = 4)
            //plot(MACDGreen, style = histogram, color = green, linewidth = 4)
            decimal multB = 4.3m, multY = 1.4m;
            List<decimal> ppoBlueList = new();
            List<decimal> ppoYellowList = new();
            List<decimal> ppoStochasticList = new();
            List<decimal> maxPpoList = new();
            List<decimal> minPpoList = new();
            List<decimal> currentPpoList = new();
            List<decimal> ppo1List = new();
            List<decimal> ppo2List = new();
            List<decimal> ppo3List = new();
            List<decimal> ppo4List = new();
            List<decimal> ppo1SignalLineList = new();
            List<decimal> ppo2SignalLineList = new();
            List<decimal> ppo3SignalLineList = new();
            List<decimal> ppo4SignalLineList = new();
            List<decimal> ppo1HistogramList = new();
            List<decimal> ppo2HistogramList = new();
            List<decimal> ppo3HistogramList = new();
            List<decimal> ppo4HistogramList = new();
            List<Signal> signalsList = new();

            try
            {
                int ema5Period = days;
                int ema8Period = MinOrMax((int)Math.Ceiling(days / 0.625));
                int ema10Period = MinOrMax(ema5Period * 2);
                int ema17Period = MinOrMax((int)Math.Ceiling(days / 0.2942));
                int ema14Period = MinOrMax((int)Math.Ceiling(days / 0.3572));
                int ema16Period = MinOrMax(ema8Period * 2);
                int signalPeriod = ema5Period;

                List<decimal> ema5List = GetMovingAverageList(maType, null, stockDataClass, ema5Period);
                List<decimal> ema8List = GetMovingAverageList(maType, null, stockDataClass, ema8Period);
                List<decimal> ema10List = GetMovingAverageList(maType, null, stockDataClass, ema10Period);
                List<decimal> ema17List = GetMovingAverageList(maType, null, stockDataClass, ema17Period);
                List<decimal> ema14List = GetMovingAverageList(maType, null, stockDataClass, ema14Period);
                List<decimal> ema16List = GetMovingAverageList(maType, null, stockDataClass, ema16Period);

                for (int i = 0; i < ema5List.Count; i++)
                {
                    decimal ema5 = ema5List.ElementAtOrDefault(i);
                    decimal ema8 = ema8List.ElementAtOrDefault(i);
                    decimal ema10 = ema10List.ElementAtOrDefault(i);
                    decimal ema14 = ema14List.ElementAtOrDefault(i);
                    decimal ema16 = ema16List.ElementAtOrDefault(i);
                    decimal ema17 = ema17List.ElementAtOrDefault(i);
                    decimal macd1 = ema17 - ema14;
                    decimal macd2 = ema17 - ema8;
                    decimal macd3 = ema10 - ema16;
                    decimal macd4 = ema5 - ema10;

                    decimal ppo1 = ema14 != 0 ? macd1 / ema14 * 100 : 0;
                    ppo1List.Add(ppo1);

                    decimal ppo2 = ema8 != 0 ? macd2 / ema8 * 100 : 0;
                    ppo2List.Add(ppo2);

                    decimal ppo3 = ema16 != 0 ? macd3 / ema16 * 100 : 0;
                    ppo3List.Add(ppo3);

                    decimal ppo4 = ema10 != 0 ? macd4 / ema10 * 100 : 0;
                    ppo4List.Add(ppo4);
                }

                ppo1SignalLineList = GetMovingAverageList(maType, ppo1List, stockDataClass, signalPeriod);
                ppo2SignalLineList = GetMovingAverageList(maType, ppo2List, stockDataClass, signalPeriod);
                ppo3SignalLineList = GetMovingAverageList(maType, ppo3List, stockDataClass, signalPeriod);
                ppo4SignalLineList = GetMovingAverageList(maType, ppo4List, stockDataClass, signalPeriod);
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal ppo1 = ppo1List.ElementAtOrDefault(j);
                    decimal ppo1SignalLine = ppo1SignalLineList.ElementAtOrDefault(j);
                    decimal ppo2 = ppo2List.ElementAtOrDefault(j);
                    decimal ppo2SignalLine = ppo2SignalLineList.ElementAtOrDefault(j);
                    decimal ppo3 = ppo3List.ElementAtOrDefault(j);
                    decimal ppo3SignalLine = ppo3SignalLineList.ElementAtOrDefault(j);
                    decimal ppo4 = ppo4List.ElementAtOrDefault(j);
                    decimal ppo4SignalLine = ppo4SignalLineList.ElementAtOrDefault(j);

                    decimal ppo1Histogram = ppo1 - ppo1SignalLine;
                    ppo1HistogramList.Add(ppo1Histogram);

                    decimal ppoBlue = multB * ppo1Histogram;
                    ppoBlueList.Add(ppoBlue);

                    decimal prevPpo2Histogram = ppo2HistogramList.LastOrDefault();
                    decimal ppo2Histogram = ppo2 - ppo2SignalLine;
                    ppo2HistogramList.Add(ppo2Histogram);

                    decimal ppo3Histogram = ppo3 - ppo3SignalLine;
                    ppo3HistogramList.Add(ppo3Histogram);

                    decimal ppoYellow = multY * ppo3Histogram;
                    ppoYellowList.Add(ppoYellow);

                    decimal prevPpo4Histogram = ppo4HistogramList.LastOrDefault();
                    decimal ppo4Histogram = ppo4 - ppo4SignalLine;
                    ppo4HistogramList.Add(ppo4Histogram);

                    decimal maxPpo = Math.Max(ppoBlue, Math.Max(ppoYellow, Math.Max(ppo2Histogram, ppo4Histogram)));
                    maxPpoList.Add(maxPpo);

                    decimal minPpo = Math.Min(ppoBlue, Math.Min(ppoYellow, Math.Min(ppo2Histogram, ppo4Histogram)));
                    minPpoList.Add(minPpo);

                    decimal currentPpo = (ppoBlue + ppoYellow + ppo2Histogram + ppo4Histogram) / 4;
                    currentPpoList.Add(currentPpo);

                    decimal ppoStochastic = maxPpo - minPpo != 0 ? MinOrMax((currentPpo - minPpo) / (maxPpo - minPpo) * 100, 100, 0) : 0;
                    ppoStochasticList.Add(ppoStochastic);

                    var signal = GetCompareSignal(ppo4Histogram - ppo2Histogram, prevPpo4Histogram - prevPpo2Histogram);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (ppo1List, ppo2List, ppo3List, ppo4List, ppo1SignalLineList, ppo2SignalLineList, ppo3SignalLineList, ppo4SignalLineList, ppo1HistogramList, ppo2HistogramList,
                ppo3HistogramList, ppo4HistogramList, ppoBlueList, ppoYellowList, maxPpoList, minPpoList, currentPpoList, ppoStochasticList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateErgodicMovingAverageConvergenceDivergence(StockData stockDataClass, string maType, int days = 5)
        {
            //input = price, user defined, default is closing price
            //method = moving average (ma), user defined, default is EMA
            //period1 = user defined, default is 32
            //period2 = user defined, default is 5
            //period3 = user defined, default is 5
            //sig = signal, index = current bar number

            //Plot1: macd = macd(index, period1, period2, input, method);
            //Plot2: sig = ma(method, index, period3, MACD);
            //Signals
            //highSell = macd for last sell signal, reset to max_negative at each  buy signal;
            //lowBuy = macd for last buy signal, reset to max_positive at each sell signal;
            //sell = crossedBelow(MACD, SIG) AND macd moreThan topGuide  AND(macd moreThan highSell);
            //buy = crossedAbove(MACD, SIG) AND macd lessThan bottomGuide AND(macd lessThan lowBuy);
            List<decimal> macdList = new();
            List<decimal> macdSignalLineList = new();
            List<decimal> macdHistogramList = new();
            List<Signal> signalsList = new();

            try
            {
                int period2 = days;
                int period1 = MinOrMax((int)Math.Ceiling(period2 / 0.1563));
                int period3 = period2;

                List<decimal> period1EmaList = GetMovingAverageList(maType, null, stockDataClass, period1);
                List<decimal> period2EmaList = GetMovingAverageList(maType, null, stockDataClass, period2);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal ema1 = period1EmaList.ElementAtOrDefault(i);
                    decimal ema2 = period2EmaList.ElementAtOrDefault(i);

                    decimal macd = ema1 - ema2;
                    macdList.Add(macd);
                }

                macdSignalLineList = GetMovingAverageList(maType, macdList, stockDataClass, period3);
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal macd = macdList.ElementAtOrDefault(j);
                    decimal macdSignalLine = macdSignalLineList.ElementAtOrDefault(j);

                    decimal prevMacdHistogram = macdHistogramList.LastOrDefault();
                    decimal macdHistogram = macd - macdSignalLine;
                    macdHistogramList.Add(macdHistogram);

                    var signal = GetCompareSignal(macdHistogram, prevMacdHistogram);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (macdList, macdSignalLineList, macdHistogramList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateErgodicPercentagePriceOscillator(StockData stockDataClass, string maType, int days = 5)
        {
            //input = price, user defined, default is closing price
            //method = moving average (ma), user defined, default is EMA
            //period1 = user defined, default is 32
            //period2 = user defined, default is 5
            //period3 = user defined, default is 5
            //sig = signal, index = current bar number

            //Plot1: macd = macd(index, period1, period2, input, method);
            //Plot2: sig = ma(method, index, period3, MACD);
            //Signals
            //highSell = macd for last sell signal, reset to max_negative at each  buy signal;
            //lowBuy = macd for last buy signal, reset to max_positive at each sell signal;
            //sell = crossedBelow(MACD, SIG) AND macd moreThan topGuide  AND(macd moreThan highSell);
            //buy = crossedAbove(MACD, SIG) AND macd lessThan bottomGuide AND(macd lessThan lowBuy);
            List<decimal> ppoList = new();
            List<decimal> ppoSignalLineList = new();
            List<decimal> ppoHistogramList = new();
            List<Signal> signalsList = new();

            try
            {
                int period2 = days;
                int period1 = MinOrMax((int)Math.Ceiling(period2 / 0.1563));
                int period3 = period2;

                List<decimal> period1EmaList = GetMovingAverageList(maType, null, stockDataClass, period1);
                List<decimal> period2EmaList = GetMovingAverageList(maType, null, stockDataClass, period2);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal ema1 = period1EmaList.ElementAtOrDefault(i);
                    decimal ema2 = period2EmaList.ElementAtOrDefault(i);
                    decimal macd = ema1 - ema2;

                    decimal ppo = ema2 != 0 ? macd / ema2 * 100 : 0;
                    ppoList.Add(ppo);
                }

                ppoSignalLineList = GetMovingAverageList(maType, ppoList, stockDataClass, period3);
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal ppo = ppoList.ElementAtOrDefault(j);
                    decimal ppoSignalLine = ppoSignalLineList.ElementAtOrDefault(j);

                    decimal prevPpoHistogram = ppoHistogramList.LastOrDefault();
                    decimal ppoHistogram = ppo - ppoSignalLine;
                    ppoHistogramList.Add(ppoHistogram);

                    var signal = GetCompareSignal(ppoHistogram, prevPpoHistogram);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (ppoList, ppoSignalLineList, ppoHistogramList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateReverseMovingAverageConvergenceDivergence(
            StockData stockDataClass, string maType, int days = 9)
        {
            //input = price, user defined, default is close
            //method = moving average, user defined, default is EMA
            //period1 = user defined, default is 12
            //period2 = user defined, default is 26
            //signalPeriod = user defined, default is 9
            //index = current bar number

            //alphaX = 2.0 / (1 + period1);
            //alphaY = 2.0 / (1 + period2);
            //ema1 = ma(method, index, period1, input);
            //ema2 = ma(method, index, period2, input);
            //Plot1: macd = ema1 - ema2;
            //Plot2: macdSignal = ma(method, index, sigPeriod, MACD);
            //Plot3: hist = macd - macdSignal;
            //prevEma1 = ema1[index - 1];
            //prevEma2 = ema2[index - 1];
            //prevMacd = macd[index - 1];
            //substitute 0 for macd
            //macdValue = 0;
            //PlotPriceGraph1: pMacdLevel = (macdValue + ((1 - alphaY) * prevEma2) - ((1 - alphaX) * prevEma1)) / (alphaX - alphaY);
            //substitute previous macd for macd   
            //macdValue = prevMacd;
            //PlotPriceGraph2: pMacdEq = (macdValue + ((1 - alphaY) * prevEma2) - ((1 - alphaX) * prevEma1)) / (alphaX - alphaY);
            //PlotPriceGraph3: signal = ma(method, index, sigPeriod, PMACDEQ);
            List<decimal> pMacdLevelList = new();
            List<decimal> pMacdEqList = new();
            List<decimal> pMacdEqSignalList = new();
            List<decimal> macdList = new();
            List<decimal> histogramList = new();
            List<Signal> signalsList = new();

            try
            {
                int period1 = (int)Math.Ceiling(days / 0.75);
                int period2 = (int)Math.Ceiling(days / 0.3462);
                int sigPeriod = days;
                decimal alphaX = (decimal)2 / (1 + period1);
                decimal alphaY = (decimal)2 / (1 + period2);

                List<decimal> ema1List = GetMovingAverageList(maType, null, stockDataClass, period1);
                List<decimal> ema2List = GetMovingAverageList(maType, null, stockDataClass, period2);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal prevEma1 = i >= 1 ? ema1List.ElementAtOrDefault(i - 1) : 0;
                    decimal prevEma2 = i >= 1 ? ema2List.ElementAtOrDefault(i - 1) : 0;
                    decimal prevMacd = i >= 1 ? macdList.ElementAtOrDefault(i - 1) : 0;
                    decimal ema1 = ema1List.ElementAtOrDefault(i);
                    decimal ema2 = ema2List.ElementAtOrDefault(i);

                    decimal macd = ema1 - ema2;
                    macdList.Add(macd);

                    decimal macdValue = 0;
                    decimal pMacdLevel = (macdValue + ((1 - alphaY) * prevEma2) - ((1 - alphaX) * prevEma1)) / (alphaX - alphaY);
                    pMacdLevelList.Add(pMacdLevel);

                    macdValue = prevMacd;
                    decimal pMacdEq = (macdValue + ((1 - alphaY) * prevEma2) - ((1 - alphaX) * prevEma1)) / (alphaX - alphaY);
                    pMacdEqList.Add(pMacdEq);
                }

                pMacdEqSignalList = GetMovingAverageList(maType, pMacdEqList, stockDataClass, sigPeriod);
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal pMacdEq = pMacdEqList.ElementAtOrDefault(j);
                    decimal pMacdEqSignal = pMacdEqSignalList.ElementAtOrDefault(j);

                    decimal prevMacdHistogram = histogramList.LastOrDefault();
                    decimal macdHistogram = pMacdEq - pMacdEqSignal;
                    histogramList.Add(macdHistogram);

                    var signal = GetCompareSignal(macdHistogram, prevMacdHistogram);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (pMacdLevelList, pMacdEqList, pMacdEqSignalList, histogramList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateSwamiStochastics(StockData stockDataClass, int days = 12)
        {
            //minPeriod = user defined, default is 12
            //maxPeriod = user defined, default is 48
            //MT = more than, LT = less than
            //index = current bar number

            //int count = maxPeriod - minPeriod;
            // Calculate the stochastic
            //decimal pNum[] = (decimal[])series.getValue(index - 1, Values.NUMERATOR);
            //decimal pDenom[] = (decimal[])series.getValue(index - 1, Values.DENOMINATOR);
            //decimal pStoch[] = (decimal[])series.getValue(index - 1, Values.STOCH);
            //decimal num[] = new decimal[count];
            //decimal denom[] = new decimal[count];
            //decimal stoch[] = new decimal[count];

            //for (int i = 0; i LT count; i++) 
            //int period = i + minPeriod;
            //decimal high = series.highest(index, period, Enums.BarInput.HIGH);
            //decimal low = series.lowest(index, period, Enums.BarInput.LOW);

            //if (high == null || low == null) break;

            //num[i] = (series.getClose(index) - low + (pNum == null ? 0 : pNum[i])) / 2;
            //denom[i] = (high - low + (pDenom == null ? 0 : pDenom[i])) / 2;

            //if (denom[i] != 0)
            //stoch[i] = 0.2 * (num[i] / denom[i]) + 0.8 * (pStoch == null ? 0 : pStoch[i]);
            //end

            //int R = 255;
            //int G = 255;

            //if (stoch[i] MT 0.5) R = (int)(255 * (2 - 2 * stoch[i]));
            //else G = (int)(255 * 2 * stoch[i]);
            List<decimal> numList = new();
            List<decimal> denomList = new();
            List<decimal> stochList = new();
            List<decimal> rList = new();
            List<decimal> gList = new();
            List<Signal> signalsList = new();

            try
            {
                var minMaxList = VolumeInputCheck(stockDataClass, days, true);
                List<decimal> highestHighList = minMaxList.Item1;
                List<decimal> lowestLowList = minMaxList.Item2;

                for (int i = 0; i < highestHighList.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal highest = highestHighList.ElementAtOrDefault(i);
                    decimal lowest = lowestLowList.ElementAtOrDefault(i);
                    decimal prevStoch1 = i >= 1 ? stochList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevStoch2 = i >= 2 ? stochList.ElementAtOrDefault(i - 2) : 0;

                    decimal pNum = numList.LastOrDefault();
                    decimal num = (currentValue - lowest + pNum) / 2;
                    numList.Add(num);

                    decimal pDenom = denomList.LastOrDefault();
                    decimal denom = (highest - lowest + pDenom) / 2;
                    denomList.Add(denom);

                    decimal stoch = denom != 0 ? MinOrMax((0.2m * num / denom) + (0.8m * prevStoch1), 1, 0) : 0;
                    stochList.Add(stoch);

                    decimal r = stoch > 0.5m ? 255 * (2 - (2 * stoch)) : 255;
                    rList.Add(r);

                    decimal g = stoch > 0.5m ? 255 : 255 * 2 * stoch;
                    gList.Add(g);

                    var signal = GetRsiSignal(stoch - prevStoch1, prevStoch1 - prevStoch2, stoch, prevStoch1, 0.8m, 0.2m);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (numList, denomList, stochList, rList, gList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateBuffAverage(StockData stockDataClass, int days = 5)
        {
            //input = price (user defined, default is close)
            //fastPeriod = user defined, default = 5
            //slowPeriod = user defined, default = 20
            //num = numerator
            //den = denomator, index = current bar number

            //priceVol = input * volume;
            //num = sum(index, fastPeriod, priceVol);
            //den = sum(index, fastPeriod, volume);
            //Plot1: fastBuff = num / den;
            //num = sum(index, slowPeriod, priceVol);
            //den = sum(index, slowPeriod, volume);
            //Plot2: slowBuff = num / den;
            //Signals
            //buy = crossedAbove(fastBuff, slowBuff);
            //sell = crossedBelow(fastBuff, slowBuff);
            List<decimal> priceVolList = new();
            List<decimal> fastBuffNumList = new();
            List<decimal> fastBuffDenomList = new();
            List<decimal> fastBuffList = new();
            List<decimal> slowBuffNumList = new();
            List<decimal> slowBuffDenomList = new();
            List<decimal> slowBuffList = new();
            List<decimal> tempVolumeList = new();
            List<Signal> signalsList = new();

            try
            {
                int fastPeriod = days;
                int slowPeriod = MinOrMax(fastPeriod * 4);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);

                    decimal currentVolume = stockDataClass.Volumes.ElementAtOrDefault(i);
                    tempVolumeList.Add(currentVolume);

                    decimal priceVol = currentValue * currentVolume;
                    priceVolList.Add(priceVol);

                    decimal fastBuffNum = priceVolList.TakeLast(fastPeriod).Sum();
                    fastBuffNumList.Add(fastBuffNum);

                    decimal fastBuffDenom = tempVolumeList.TakeLast(fastPeriod).Sum();
                    fastBuffDenomList.Add(fastBuffDenom);

                    decimal prevFastBuff = fastBuffList.LastOrDefault();
                    decimal fastBuff = fastBuffDenom != 0 ? fastBuffNum / fastBuffDenom : 0;
                    fastBuffList.Add(fastBuff);

                    decimal slowBuffNum = priceVolList.TakeLast(slowPeriod).Sum();
                    slowBuffNumList.Add(slowBuffNum);

                    decimal slowBuffDenom = tempVolumeList.TakeLast(slowPeriod).Sum();
                    slowBuffDenomList.Add(slowBuffDenom);

                    decimal prevSlowBuff = slowBuffList.LastOrDefault();
                    decimal slowBuff = slowBuffDenom != 0 ? slowBuffNum / slowBuffDenom : 0;
                    slowBuffList.Add(slowBuff);

                    var signal = GetCompareSignal(fastBuff - slowBuff, prevFastBuff - prevSlowBuff);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (fastBuffNumList, fastBuffList, slowBuffNumList, slowBuffDenomList, slowBuffList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateTFSMboIndicator(StockData stockDataClass, string maType, int days = 18)
        {
            ////////////////////////////////////////////////////////////
            //  Copyright by HPotter v1.0 15/08/2018
            // MBO indicator is the third component of TFS trading system. This indicator
            // was developed by Bryan Strain and Mark Whitley.
            // The idea of MBO is similar to moving average convergence/divergence (MACD)
            // indicator. It is calculated by subtracting the 200-day moving average from
            // the 25-day moving average.
            //
            // WARNING:
            //  - This script to change bars colors.
            ////////////////////////////////////////////////////////////
            //study(title = "TFS: MBO Strategy", shorttitle = "TFS: MBO indicator")
            //Fastavg = input(25, minval = 1)
            //Slowavg = input(200, minval = 1)
            //Length = input(18, minval = 1)
            //hline(0, color = blue, linestyle = line)
            //xFastAvg = sma(close, Fastavg)
            //xSlowAvg = sma(close, Slowavg)
            //nMBO = xFastAvg - xSlowAvg
            //xSMAMBO = sma(nMBO, Length)
            //pos = iff(nMBO > xSMAMBO, 1,
            //      iff(nMBO < xSMAMBO, -1, nz(pos[1], 0)))
            //barcolor(pos == -1 ? red : pos == 1 ? green : blue)
            //plot(nMBO, color = red, style = histogram, title = "TFS: MBO indicator")
            //plot(xSMAMBO, color = blue, title = "SMA")
            List<decimal> tfsMobList = new();
            List<decimal> macdSignalLineList = new();
            List<decimal> macdHistogramList = new();
            List<Signal> signalsList = new();

            try
            {
                int fastPeriod = (int)Math.Ceiling(days / 0.72);
                int slowPeriod = fastPeriod * 8;
                int signalPeriod = days;

                List<decimal> mob1List = GetMovingAverageList(maType, null, stockDataClass, fastPeriod);
                List<decimal> mob2List = GetMovingAverageList(maType, null, stockDataClass, slowPeriod);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal mob1 = mob1List.ElementAtOrDefault(i);
                    decimal mob2 = mob2List.ElementAtOrDefault(i);

                    decimal tfsMob = mob1 - mob2;
                    tfsMobList.Add(tfsMob);
                }

                macdSignalLineList = GetMovingAverageList(maType, tfsMobList, stockDataClass, signalPeriod);
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal tfsMob = tfsMobList.ElementAtOrDefault(j);
                    decimal macdSignalLine = macdSignalLineList.ElementAtOrDefault(j);

                    decimal prevMacdHistogram = macdHistogramList.LastOrDefault();
                    decimal macdHistogram = tfsMob - macdSignalLine;
                    macdHistogramList.Add(macdHistogram);

                    var signal = GetCompareSignal(macdHistogram, prevMacdHistogram);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (tfsMobList, macdSignalLineList, macdHistogramList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateTFSMboPercentagePriceOscillator(StockData stockDataClass, string maType, int days = 18)
        {
            ////////////////////////////////////////////////////////////
            //  Copyright by HPotter v1.0 15/08/2018
            // MBO indicator is the third component of TFS trading system. This indicator
            // was developed by Bryan Strain and Mark Whitley.
            // The idea of MBO is similar to moving average convergence/divergence (MACD)
            // indicator. It is calculated by subtracting the 200-day moving average from
            // the 25-day moving average.
            //
            // WARNING:
            //  - This script to change bars colors.
            ////////////////////////////////////////////////////////////
            //study(title = "TFS: MBO Strategy", shorttitle = "TFS: MBO indicator")
            //Fastavg = input(25, minval = 1)
            //Slowavg = input(200, minval = 1)
            //Length = input(18, minval = 1)
            //hline(0, color = blue, linestyle = line)
            //xFastAvg = sma(close, Fastavg)
            //xSlowAvg = sma(close, Slowavg)
            //nMBO = xFastAvg - xSlowAvg
            //xSMAMBO = sma(nMBO, Length)
            //pos = iff(nMBO > xSMAMBO, 1,
            //      iff(nMBO < xSMAMBO, -1, nz(pos[1], 0)))
            //barcolor(pos == -1 ? red : pos == 1 ? green : blue)
            //plot(nMBO, color = red, style = histogram, title = "TFS: MBO indicator")
            //plot(xSMAMBO, color = blue, title = "SMA")
            List<decimal> ppoList = new();
            List<decimal> ppoSignalLineList = new();
            List<decimal> ppoHistogramList = new();
            List<Signal> signalsList = new();

            try
            {
                int fastPeriod = (int)Math.Ceiling(days / 0.72);
                int slowPeriod = fastPeriod * 8;
                int signalPeriod = days;

                List<decimal> mob1List = GetMovingAverageList(maType, null, stockDataClass, fastPeriod);
                List<decimal> mob2List = GetMovingAverageList(maType, null, stockDataClass, slowPeriod);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal mob1 = mob1List.ElementAtOrDefault(i);
                    decimal mob2 = mob2List.ElementAtOrDefault(i);
                    decimal tfsMob = mob1 - mob2;

                    decimal ppo = mob2 != 0 ? tfsMob / mob2 * 100 : 0;
                    ppoList.Add(ppo);
                }

                ppoSignalLineList = GetMovingAverageList(maType, ppoList, stockDataClass, signalPeriod);
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal ppo = ppoList.ElementAtOrDefault(j);
                    decimal ppoSignalLine = ppoSignalLineList.ElementAtOrDefault(j);

                    decimal prevPpoHistogram = ppoHistogramList.LastOrDefault();
                    decimal ppoHistogram = ppo - ppoSignalLine;
                    ppoHistogramList.Add(ppoHistogram);

                    var signal = GetCompareSignal(ppoHistogram, prevPpoHistogram);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (ppoList, ppoSignalLineList, ppoHistogramList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateErgodicMeanDeviationIndicator(StockData stockDataClass, string maType, int days = 5)
        {
            //input = price, user defined, default is close
            //period1 = user input, default is 32
            //period2 = user input, default is 5
            //period3 = user input, default is 5
            //sPeriod = user input, default is 5
            //method1 = moving average (ma), user defined, default is EMA
            //method2 = moving average (ma), user defined, default is EMA
            //sig = signal, index = current bar number

            //ma = ma(method1, index, period1, input);
            //ma1 = price - ma;
            //ma2 = ma(method1, index, period2, ma1);
            //Plot1: emdi = ma(method1, index, period3, ma2);
            //Plot2: sig = series.ma(method2, index, sPeriod, emdi);
            //Signals
            //buy = crossedAbove(EMDI, SIG);
            //sell = crossedBelow(EMDI, SIG);
            List<decimal> emdiList = new();
            List<decimal> emdiSignalList = new();
            List<decimal> ma1EmaList = new();
            List<decimal> ma1List = new();
            List<Signal> signalsList = new();

            try
            {
                int period1 = MinOrMax((int)Math.Ceiling(days / 0.15625));

                List<decimal> emaList = GetMovingAverageList(maType, null, stockDataClass, period1);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal currentEma = emaList.ElementAtOrDefault(i);

                    decimal ma1 = currentValue - currentEma;
                    ma1List.Add(ma1);
                }

                ma1EmaList = GetMovingAverageList(maType, ma1List, stockDataClass, days);
                emdiList = GetMovingAverageList(maType, ma1EmaList, stockDataClass, days);
                emdiSignalList = GetMovingAverageList(maType, emdiList, stockDataClass, days);
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal emdi = emdiList.ElementAtOrDefault(j);
                    decimal emdiSignal = emdiSignalList.ElementAtOrDefault(j);
                    decimal prevEmdi = j >= 1 ? emdiList.ElementAtOrDefault(j - 1) : 0;
                    decimal prevEmdiSignal = j >= 1 ? emdiSignalList.ElementAtOrDefault(j - 1) : 0;

                    var signal = GetCompareSignal(emdi - emdiSignal, prevEmdi - prevEmdiSignal);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (ma1EmaList, emdiList, emdiSignalList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) Calculate3HMA(StockData stockDataClass, string maType, int days = 50)
        {
            //@version=4
            //study("3HMA", overlay = true)
            //length = input(50)
            //----
            //p = length / 2
            //a = wma(wma(close, p / 3) * 3 - wma(close, p / 2) - wma(close, p), p)
            //----
            //plot(a, color =#ff1100,linewidth=2,transp=0)
            List<decimal> aList = new();
            List<decimal> midList = new();
            List<Signal> signalsList = new();

            try
            {
                int p = MinOrMax((int)Math.Ceiling((decimal)days / 2));
                int p1 = MinOrMax((int)Math.Ceiling((decimal)p / 3));
                int p2 = MinOrMax((int)Math.Ceiling((decimal)p / 2));

                var wma1List = GetMovingAverageList(maType, null, stockDataClass, p1);
                var wma2List = GetMovingAverageList(maType, null, stockDataClass, p2);
                var wma3List = GetMovingAverageList(maType, null, stockDataClass, p);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal wma1 = wma1List.ElementAtOrDefault(i);
                    decimal wma2 = wma2List.ElementAtOrDefault(i);
                    decimal wma3 = wma3List.ElementAtOrDefault(i);

                    decimal mid = (wma1 * 3) - wma2 - wma3;
                    midList.Add(mid);
                }

                aList = GetMovingAverageList(maType, midList, stockDataClass, p);
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal a = aList.ElementAtOrDefault(j);
                    decimal prevA = j >= 1 ? aList.ElementAtOrDefault(j - 1) : 0;
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(j);
                    decimal prevValue = j >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(j - 1) : 0;

                    var signal = GetCompareSignal(currentValue - a, prevValue - prevA);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (midList, aList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<decimal>, List<decimal>, List<Signal>) CalculateR2AdaptiveRegression(StockData stockDataClass, int days = 100)
        {
            //@version=2
            //study("R2-Adaptive Regression", shorttitle = "R2AR", overlay = true)
            //length = input(100),src = input(close)
            //----
            //a(x)=> stdev(src, length) * correlation(src, x, length) / stdev(x, length)
            //b(x)=>sma(src, length) - a(x) * sma(x, length)
            //r(x)=>pow(correlation(src, x, length), 2)
            //----
            //x2 = nz(out[1], src)
            //y1 = linreg(src, length, 0)
            //y2 = a(x2) * x2 + b(x2)
            //out = r(y1) * y1 + r(y2) * y2 + (1 - (r(y1) + r(y2))) * x2
            //----
            //plot(out, color = red, linewidth = 2, transp = 0)
            List<decimal> outList = new();
            List<decimal> x2List = new();
            List<decimal> x2AvgList = new();
            List<decimal> x2DevList = new();
            List<decimal> x2PowList = new();
            List<decimal> x2PowAvgList = new();
            List<decimal> x2StdDevList = new();
            List<decimal> y2List = new();
            List<decimal> aList = new();
            List<decimal> bList = new();
            List<decimal> ry1List = new();
            List<decimal> ry2List = new();
            List<decimal> r2x2List = new();
            List<decimal> tempList = new();
            List<decimal> y1List = new();
            List<Signal> signalsList = new();

            try
            {
                var linregList = CalculateLinearRegression(null, stockDataClass, days).Item15;
                var stdDevList = CalculateStandardDeviationVolatility(null, stockDataClass, days).Item4;
                var smaList = CalculateSimpleMovingAverage(stockDataClass, days).Item1;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal prevValue = tempList.LastOrDefault();
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    tempList.Add(currentValue);

                    decimal stdDev = stdDevList.ElementAtOrDefault(i);
                    decimal sma = smaList.ElementAtOrDefault(i);
                    var lbList = tempList.TakeLast(days).Select(x => (double)x).ToList();

                    decimal y1 = linregList.ElementAtOrDefault(i);
                    y1List.Add(y1);

                    decimal x2 = i >= 1 ? outList.ElementAtOrDefault(i - 1) : currentValue;
                    x2List.Add(x2);

                    var x2LbList = x2List.TakeLast(days).Select(x => (double)x).ToList();
                    var r2x2 = GoodnessOfFit.R(x2LbList, lbList);
                    r2x2 = IsValueNullOrInfinity(r2x2) ? 0 : r2x2;
                    r2x2List.Add((decimal)r2x2);

                    decimal x2Avg = (decimal)x2LbList.TakeLast(days).Average();
                    x2AvgList.Add(x2Avg);

                    decimal x2Dev = x2 - x2Avg;
                    x2DevList.Add(x2Dev);

                    decimal x2Pow = Pow(x2Dev, 2);
                    x2PowList.Add(x2Pow);

                    decimal x2PowAvg = x2PowList.TakeLast(days).Average();
                    x2PowAvgList.Add(x2PowAvg);

                    decimal x2StdDev = x2PowAvg >= 0 ? (decimal)Sqrt((double)x2PowAvg) : 0;
                    x2StdDevList.Add(x2StdDev);

                    decimal a = x2StdDev != 0 ? stdDev * (decimal)r2x2 / x2StdDev : 0;
                    aList.Add(a);

                    decimal b = sma - (a * x2Avg);
                    bList.Add(b);

                    decimal y2 = (a * x2) + b;
                    y2List.Add(y2);

                    var ry1 = Math.Pow(GoodnessOfFit.R(y1List.TakeLast(days).Select(x => (double)x), lbList), 2);
                    ry1 = IsValueNullOrInfinity(ry1) ? 0 : ry1;
                    ry1List.Add((decimal)ry1);

                    var ry2 = Math.Pow(GoodnessOfFit.R(y2List.TakeLast(days).Select(x => (double)x), lbList), 2);
                    ry2 = IsValueNullOrInfinity(ry2) ? 0 : ry2;
                    ry2List.Add((decimal)ry2);

                    decimal prevOutVal = outList.LastOrDefault();
                    decimal outval = ((decimal)ry1 * y1) + ((decimal)ry2 * y2) + ((1 - (decimal)(ry1 + ry2)) * x2);
                    outList.Add(outval);

                    var signal = GetCompareSignal(currentValue - outval, prevValue - prevOutVal);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (x2List, r2x2List, x2AvgList, x2DevList, x2PowList, x2PowAvgList, x2StdDevList, aList, bList, y2List, ry1List, ry2List, outList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<decimal>, List<decimal>, List<Signal>) CalculateModularFilter(StockData stockDataClass, int days = 200)
        {
            //@version=4
            //study("Modular Filter", overlay = true)
            //length = input(200),
            //beta = input(0.8, minval = 0, maxval = 1),src = input(close),feedback = input(false),z = input(0.5, title = "Feedback Weighting", minval = 0, maxval = 1)
            //----
            //ts = 0.,b = 0.,c = 0.,os = 0.
            //----
            //alpha = 2 / (length + 1)
            //a = feedback ? z * src + (1 - z) * nz(ts[1], src) : src
            //----
            //b:= a > alpha * a + (1 - alpha) * nz(b[1], a) ? a : alpha * a + (1 - alpha) * nz(b[1], a)
            //c:= a < alpha * a + (1 - alpha) * nz(c[1], a) ? a : alpha * a + (1 - alpha) * nz(c[1], a)
            //os:= a == b ? 1 : a == c ? 0 : os[1]
            //----
            //upper = beta * b + (1 - beta) * c
            //lower = beta * c + (1 - beta) * b
            //ts:= os * upper + (1 - os) * lower
            //----
            //css = os == 1 ? #2196f3 : #FF0000
            //plot(ts, color = css, linewidth = 2, transp = 0)
            List<decimal> aList = new();
            List<decimal> bList = new();
            List<decimal> cList = new();
            List<decimal> osList = new();
            List<decimal> upperList = new();
            List<decimal> lowerList = new();
            List<decimal> tsList = new();
            List<decimal> b2List = new();
            List<decimal> c2List = new();
            List<decimal> os2List = new();
            List<decimal> upper2List = new();
            List<decimal> lower2List = new();
            List<decimal> ts2List = new();
            List<Signal> signalsList = new();
            decimal beta = 0.8m, z = 0.5m;

            try
            {
                decimal alpha = (decimal)2 / (days + 1);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevTs = i >= 1 ? tsList.ElementAtOrDefault(i - 1) : currentValue;
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal a = (z * currentValue) + ((1 - z) * prevTs);
                    aList.Add(a);

                    decimal prevB = i >= 1 ? bList.ElementAtOrDefault(i - 1) : a;
                    decimal b = a > (alpha * a) + ((1 - alpha) * prevB) ? a : (alpha * a) + ((1 - alpha) * prevB);
                    bList.Add(b);

                    decimal prevB2 = i >= 1 ? b2List.ElementAtOrDefault(i - 1) : currentValue;
                    decimal b2 = currentValue > (alpha * currentValue) + ((1 - alpha) * prevB2) ? currentValue : (alpha * currentValue) + ((1 - alpha) * prevB2);
                    b2List.Add(b2);

                    decimal prevC = i >= 1 ? cList.ElementAtOrDefault(i - 1) : a;
                    decimal c = a < (alpha * a) + ((1 - alpha) * prevC) ? a : (alpha * a) + ((1 - alpha) * prevC);
                    cList.Add(c);

                    decimal prevC2 = i >= 1 ? c2List.ElementAtOrDefault(i - 1) : currentValue;
                    decimal c2 = currentValue < (alpha * currentValue) + ((1 - alpha) * prevC2) ? currentValue : (alpha * currentValue) + ((1 - alpha) * prevC2);
                    c2List.Add(c2);

                    decimal prevOs = osList.LastOrDefault();
                    decimal os = a == b ? 1 : a == c ? 0 : prevOs;
                    osList.Add(os);

                    decimal prevOs2 = os2List.LastOrDefault();
                    decimal os2 = currentValue == b2 ? 1 : currentValue == c2 ? 0 : prevOs2;
                    os2List.Add(os2);

                    decimal upper = (beta * b) + ((1 - beta) * c);
                    upperList.Add(upper);

                    decimal upper2 = (beta * b2) + ((1 - beta) * c2);
                    upper2List.Add(upper2);

                    decimal lower = (beta * c) + ((1 - beta) * b);
                    lowerList.Add(lower);

                    decimal lower2 = (beta * c2) + ((1 - beta) * b2);
                    lower2List.Add(lower2);

                    decimal ts = (os * upper) + ((1 - os) * lower);
                    tsList.Add(ts);

                    decimal prevTs2 = ts2List.LastOrDefault();
                    decimal ts2 = (os2 * upper2) + ((1 - os2) * lower2);
                    ts2List.Add(ts2);

                    var signal = GetCompareSignal(currentValue - ts2, prevValue - prevTs2);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (aList, bList, b2List, cList, c2List, osList, os2List, upperList, upper2List, lowerList, lower2List, tsList, ts2List, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateAdaptiveAutonomousRecursiveTrailingStop(StockData stockDataClass, int days = 14)
        {
            //@version=4
            //study("Adaptive Autonomous Recursive Trailing Stop", shorttitle = "A2RTS", overlay = true)
            //length = input(14),gamma = input(3.),src = input(close)
            //----
            //ma = 0.
            //os = 0.
            //----
            //er = abs(change(src, length)) / sum(abs(change(src)), length)
            //ama(x)=>
            //    a = 0.
            //    a := er * x + (1 - er) * nz(a[1], x)
            //----
            //d = cum(abs(src - nz(ma[1], src))) / (cum(1) - 1) * gamma
            //ma:= ama(ama(src > nz(ma[1], src) + d ? src + d : src < nz(ma[1], src) - d ? src - d : nz(ma[1], src)))
            //----
            //upper = ma + d
            //lower = ma - d
            //os:= src > upper[1] ? 1 : src < lower[1] ? 0 : os[1]
            //ts = os * lower + (1 - os) * upper
            //css = os == 1 ? #2196f3 : #ff1100
            //plot(ts, color = css, linewidth = 2, transp = 0)
            List<decimal> tsList = new();
            List<decimal> osList = new();
            List<decimal> upperList = new();
            List<decimal> lowerList = new();
            List<Signal> signalsList = new();

            try
            {
                var aamaList = CalculateAdaptiveAutonomousRecursiveMovingAverage(stockDataClass, days);
                var ma2List = aamaList.Item5;
                var dList = aamaList.Item2;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal ma2 = ma2List.ElementAtOrDefault(i);
                    decimal d = dList.ElementAtOrDefault(i);

                    decimal prevUpper = upperList.LastOrDefault();
                    decimal upper = ma2 + d;
                    upperList.Add(upper);

                    decimal prevLower = lowerList.LastOrDefault();
                    decimal lower = ma2 - d;
                    lowerList.Add(lower);

                    decimal prevOs = osList.LastOrDefault();
                    decimal os = currentValue > prevUpper ? 1 : currentValue < prevLower ? 0 : prevOs;
                    osList.Add(os);

                    decimal prevTs = tsList.LastOrDefault();
                    decimal ts = (os * lower) + ((1 - os) * upper);
                    tsList.Add(ts);

                    var signal = GetCompareSignal(currentValue - ts, prevValue - prevTs);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (upperList, lowerList, osList, tsList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateAdaptiveAutonomousRecursiveMovingAverage(StockData stockDataClass, int days = 14)
        {
            //@version=4
            //study("Adaptive Autonomous Recursive Moving Average", shorttitle = "A2RMA", overlay = true)
            //length = input(14),gamma = input(3.),src = input(close)
            //----
            //er = abs(change(src, length)) / sum(abs(change(src)), length)
            //ama(x)=>
            //    a = 0.
            //    a := er * x + (1 - er) * nz(a[1], x)
            //----
            //ma = 0.
            //d = cum(abs(src - nz(ma[1], src))) / bar_index * gamma
            //ma:= ama(ama(src > nz(ma[1], src) + d ? src + d : src < nz(ma[1], src) - d ? src - d : nz(ma[1], src)))
            //----
            //css = ma > ma[1] ? #2196f3 : ma < ma[1] ? #ff1100 : na
            //plot(ma, color = fixnan(css), linewidth = 2, transp = 0)
            List<decimal> dList = new();
            List<decimal> ma1List = new();
            List<decimal> ma2List = new();
            List<decimal> absDiffList = new();
            List<decimal> cList = new();
            List<Signal> signalsList = new();
            decimal gamma = 3;

            try
            {
                List<decimal> erList = CalculateKaufmanAdaptiveMovingAverage(stockDataClass, days).Item3;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal er = erList.ElementAtOrDefault(i);
                    decimal prevMa2 = i >= 1 ? ma2List.ElementAtOrDefault(i - 1) : currentValue;
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal absDiff = Math.Abs(currentValue - prevMa2);
                    absDiffList.Add(absDiff);

                    decimal d = i != 0 ? absDiffList.Sum() / i * gamma : 0;
                    dList.Add(d);

                    decimal c = currentValue > prevMa2 + d ? currentValue + d : currentValue < prevMa2 - d ? currentValue - d : prevMa2;
                    cList.Add(c);

                    decimal prevMa1 = i >= 1 ? ma1List.ElementAtOrDefault(i - 1) : currentValue;
                    decimal ma1 = (er * c) + ((1 - er) * prevMa1);
                    ma1List.Add(ma1);

                    decimal ma2 = (er * ma1) + ((1 - er) * prevMa2);
                    ma2List.Add(ma2);

                    var signal = GetCompareSignal(currentValue - ma2, prevValue - prevMa2);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (absDiffList, dList, cList, ma1List, ma2List, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateAutonomousRecursiveMovingAverage(StockData stockDataClass, int days = 14)
        {
            //@version=3
            //study("Autonomous Recursive Moving Average", shorttitle = "ARMA", overlay = true)
            //length = input(14),gamma = input(3.),zl = input(false, title = "Zero-Lag")
            //----
            //ma = 0.
            //mad = 0.
            //----
            //src = zl ? close + change(close, length / 2) : close
            //ma:= nz(mad[1], src)
            //d = cum(abs(src[length] - ma)) / n * gamma
            //mad:= sma(sma(src > nz(mad[1], src) + d ? src + d : src < nz(mad[1], src) - d ? src - d : nz(mad[1], src), length), length)
            //----
            //plot(mad, color = red, linewidth = 2, transp = 0)
            List<decimal> dList = new();
            List<decimal> madList = new();
            List<decimal> ma1List = new();
            List<decimal> absDiffList = new();
            List<decimal> cList = new();
            List<Signal> signalsList = new();
            decimal gamma = 3;

            try
            {
                int length = MinOrMax((int)Math.Ceiling((decimal)days / 2));

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal priorValue = i >= length ? stockDataClass.InputValues.ElementAtOrDefault(i - length) : 0;
                    decimal prevMad = i >= 1 ? madList.ElementAtOrDefault(i - 1) : currentValue;

                    decimal absDiff = Math.Abs(priorValue - prevMad);
                    absDiffList.Add(absDiff);

                    decimal d = i != 0 ? absDiffList.Sum() / i * gamma : 0;
                    dList.Add(d);

                    decimal c = currentValue > prevMad + d ? currentValue + d : currentValue < prevMad - d ? currentValue - d : prevMad;
                    cList.Add(c);

                    decimal ma1 = cList.TakeLast(days).Average();
                    ma1List.Add(ma1);

                    decimal mad = ma1List.TakeLast(days).Average();
                    madList.Add(mad);

                    var signal = GetCompareSignal(currentValue - mad, prevValue - prevMad);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (absDiffList, dList, cList, ma1List, madList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateAtrFilteredExponentialMovingAverage(StockData stockDataClass,
            string maType, int days = 5)
        {
            //ema_period = input(title = "EMA Period", defval = 45, type = input.integer)
            //atr_period = input(title = "ATR Period", defval = 20, type = input.integer)
            //atr_mult = input(title = "ATR Multiplier", defval = 1.0, minval = 0.1, type = input.float)
            //atr_filter_type = input(title = "ATR Filter Type", defval = "Away from price", options = ["Away from price", "Closer to price"], type = input.string)
            //atr_stddev_length = input(title = "ATR Filter Standard Deviation Length", defval = 10, minval = 1, type = input.integer)
            //atr_stddev_low_lookback = input(title = "ATR Filter Standard Deviation Low Lookback Period", defval = 20, minval = 1, type = input.integer)
            //use_normalized = input(title = "Use normalized ATR for the ATR Filter?", defval = true, type = input.bool)

            //ema_val = get_afema(close, ema_period, atr_period, atr_stddev_length, atr_filter_type, atr_stddev_low_lookback)
            // ------------------------------------------------------------------------------------
            //    ATR-filtered EMA
            // ------------------------------------------------------------------------------------

            //get_afema(src, len = 45, atr_len = 20, stdev_len = 10, filter_type, low_lookback = 20) =>
            //float result = na
            //float alpha = na
            //float stddev_factor = na

            //tr_val = use_normalized ? tr / close : tr
            //atr_val = sma(tr_val, atr_len)

            //stddev_a = sma(pow(atr_val, 2), stdev_len)
            //stddev_b = pow(sum(atr_val, stdev_len), 2) / pow(stdev_len, 2)
            //stddev = sqrt(stddev_a - stddev_b)
            //stddev_lo = lowest(stddev, low_lookback)

            //if (filter_type == "Away from price")
            //        stddev_factor:= min(stddev_lo / stddev, 5.0)
            //if (filter_type == "Closer to price")
            //        stddev_factor:= min(stddev / stddev_lo, 5.0)

            //alpha:= (2.0 * stddev_factor) / (len + 1.0)

            //if (na(src[1]))
            //        result:= sum(src, len) / len
            //else
            //        result:= alpha * src + (1.0 - alpha) * nz(result[1])

            // Return the result
            //result
            List<decimal> trValList = new();
            List<decimal> atrValList = new();
            List<decimal> atrValSumList = new();
            List<decimal> atrValPowList = new();
            List<decimal> stdDevAList = new();
            List<decimal> stdDevBList = new();
            List<decimal> tempList = new();
            List<decimal> stdDevList = new();
            List<decimal> stdDevLowList = new();
            List<decimal> stdDevFactorAFPList = new();
            List<decimal> stdDevFactorCTPList = new();
            List<decimal> stdDevFactorAFPLowList = new();
            List<decimal> stdDevFactorCTPLowList = new();
            List<decimal> alphaAFPList = new();
            List<decimal> alphaCTPList = new();
            List<decimal> emaAFPList = new();
            List<decimal> emaCTPList = new();
            List<Signal> signalsList = new();

            try
            {
                int stdDevLength = days * 2;
                int atrPeriod = days * 4;
                int emaPeriod = (int)Math.Ceiling(days / 0.223);

                var trList = CalculateVortexIndicator(stockDataClass, atrPeriod).Item5;

                for (int h = 0; h < stockDataClass.InputValues.Count; h++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(h);
                    decimal tr = trList.ElementAtOrDefault(h);

                    decimal trVal = currentValue != 0 ? tr / currentValue : tr;
                    trValList.Add(trVal);
                }

                atrValList = GetMovingAverageList(maType, null, stockDataClass, atrPeriod);
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal atrVal = atrValList.ElementAtOrDefault(i);

                    decimal atrValPow = Pow(atrVal, 2);
                    atrValPowList.Add(atrValPow);
                }

                stdDevAList = GetMovingAverageList(maType, atrValPowList, stockDataClass, stdDevLength);
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal stdDevA = stdDevAList.ElementAtOrDefault(j);
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(j);
                    decimal prevValue = j >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(j - 1) : 0;

                    decimal atrVal = atrValList.ElementAtOrDefault(j);
                    tempList.Add(atrVal);

                    decimal atrValSum = tempList.TakeLast(stdDevLength).Sum();
                    atrValSumList.Add(atrValSum);

                    decimal stdDevB = Pow(atrValSum, 2) / Pow(stdDevLength, 2);
                    stdDevBList.Add(stdDevB);

                    decimal stdDev = stdDevA - stdDevB >= 0 ? (decimal)Sqrt((double)(stdDevA - stdDevB)) : 0;
                    stdDevList.Add(stdDev);

                    decimal stdDevLow = stdDevList.TakeLast(atrPeriod).Min();
                    stdDevLowList.Add(stdDevLow);

                    decimal stdDevFactorAFP = stdDev != 0 ? stdDevLow / stdDev : 0;
                    stdDevFactorAFPList.Add(stdDevFactorAFP);

                    decimal stdDevFactorCTP = stdDevLow != 0 ? stdDev / stdDevLow : 0;
                    stdDevFactorCTPList.Add(stdDevFactorCTP);

                    decimal stdDevFactorAFPLow = stdDevFactorAFPList.TakeLast(days).Min();
                    stdDevFactorAFPLowList.Add(stdDevFactorAFPLow);

                    decimal stdDevFactorCTPLow = stdDevFactorCTPList.TakeLast(days).Min();
                    stdDevFactorCTPLowList.Add(stdDevFactorCTPLow);

                    decimal alphaAfp = (2 * stdDevFactorAFPLow) / (emaPeriod + 1);
                    alphaAFPList.Add(alphaAfp);

                    decimal alphaCtp = (2 * stdDevFactorCTPLow) / (emaPeriod + 1);
                    alphaCTPList.Add(alphaCtp);

                    decimal prevEmaAfp = emaAFPList.LastOrDefault();
                    decimal emaAfp = (alphaAfp * currentValue) + ((1 - alphaAfp) * prevEmaAfp);
                    emaAFPList.Add(emaAfp);

                    decimal emaCtp = (alphaCtp * currentValue) + ((1 - alphaCtp) * emaCTPList.LastOrDefault());
                    emaCTPList.Add(emaCtp);

                    var signal = GetCompareSignal(currentValue - emaAfp, prevValue - prevEmaAfp);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (trValList, atrValList, atrValPowList, stdDevAList, atrValSumList, stdDevBList, stdDevList, stdDevLowList, stdDevFactorAFPList, stdDevFactorCTPList,
                stdDevFactorAFPLowList, stdDevFactorCTPLowList, alphaAFPList, alphaCTPList, emaAFPList, emaCTPList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateMidpointOscillator(StockData stockDataClass,
            int days = 9)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Midpoint Oscillator script may be freely distributed under the MIT license.
            //study(title = "Midpoint Oscillator", shorttitle = "MO", overlay = false)

            //src = input(title = "Source", type = input.source, defval = close)
            //lbLength = input(title = "LookBackLength", type = input.integer, defval = 26, minval = 1)
            //sigLength = input(title = "SignalLength", type = input.integer, defval = 9, minval = 1)

            //hh = highest(lbLength)
            //ll = lowest(lbLength)
            //mo = hh - ll != 0 ? 100 * ((2 * src) - hh - ll) / (hh - ll) : 0
            //sig = ema(mo, sigLength)

            //hline(70, color = color.green, linewidth = 2)
            //hline(0)
            //hline(-70, color = color.red, linewidth = 2)
            //moColor = mo > sig or(mo[1] < -70 and mo > -70) ? color.green : mo < sig or(mo[1] > 70 and mo < 70) ? color.red : color.blue
            //plot(mo, color = moColor, linewidth = 2)
            //plot(sig, color = color.black, linewidth = 1)
            List<decimal> moList = new();
            List<decimal> moEmaList = new();
            List<Signal> signalsList = new();

            try
            {
                int lbLength = (int)Math.Ceiling(days / 0.3462);

                var list = VolumeInputCheck(stockDataClass, lbLength, true);
                var hhList = list.Item1;
                var llList = list.Item2;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal hh = hhList.ElementAtOrDefault(i);
                    decimal ll = llList.ElementAtOrDefault(i);

                    decimal prevMo = moList.LastOrDefault();
                    decimal mo = hh - ll != 0 ? MinOrMax(100 * ((2 * currentValue) - hh - ll) / (hh - ll), 100, -100) : 0;
                    moList.Add(mo);

                    decimal prevMoEma = moEmaList.LastOrDefault();
                    decimal moEma = CalculateExponentialMovingAverage(mo, prevMoEma, days);
                    moEmaList.Add(moEma);

                    var signal = GetRsiSignal(mo - moEma, prevMo - prevMoEma, mo, prevMo, 70, -70);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (moList, moEmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateSimpleCycle(StockData stockDataClass, int days = 50)
        {
            //@version=2
            //study("Simple Cycle")
            //length = input(50)
            //
            //a = 1 / length
            //src = close + nz(c[0])
            //b = nz(c[0]) - ema(nz(c[0]), length)
            //c = a * change(src, length) + (1 - a) * b
            //
            //plot(c, color = orange, transp = 0)
            List<decimal> srcList = new();
            List<decimal> bList = new();
            List<decimal> cEmaList = new();
            List<decimal> cList = new();
            List<Signal> signalsList = new();

            try
            {
                decimal a = (decimal)1 / days;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevC1 = i >= 1 ? cList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevC2 = i >= 2 ? cList.ElementAtOrDefault(i - 2) : 0;
                    decimal prevSrc = i >= days ? srcList.ElementAtOrDefault(i - days) : 0;

                    decimal src = currentValue + prevC1;
                    srcList.Add(src);

                    decimal cEma = CalculateExponentialMovingAverage(prevC1, cEmaList.LastOrDefault(), days);
                    cEmaList.Add(cEma);

                    decimal b = prevC1 - cEma;
                    bList.Add(b);

                    decimal c = (a * (src - prevSrc)) + ((1 - a) * b);
                    cList.Add(c);

                    var signal = GetCompareSignal(c - prevC1, prevC1 - prevC2);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (srcList, cEmaList, bList, cList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateReversalPoints(
            StockData stockDataClass, string maType, int days = 100)
        {
            //@version=3
            //study("Reversal Points")
            //length = input(100, minval = 1)
            //----
            //v = volume
            //c = length + (length / sqrt(length)) / 2
            //----
            //m(x, y, p)=>
            //    a = x - y
            //    b = sum(ema(a, p) / ema(ema(a, p), p), length)
            //a = m(max(v, v[1]), min(v, v[1]), length / 2)
            //----
            //plot(a, color =#2196f3,linewidth=2,transp=0)
            //hline(round(c), color = white, linewidth = 2)
            List<decimal> aList = new();
            List<decimal> aEma2List = new();
            List<decimal> aEma1List = new();
            List<decimal> maxList = new();
            List<decimal> minList = new();
            List<decimal> bList = new();
            List<decimal> bSumList = new();
            List<Signal> signalsList = new();

            try
            {
                decimal c = days + ((decimal)(days / Sqrt((double)days)) / 2);
                int length = MinOrMax((int)Math.Ceiling((decimal)days / 2));

                var emaList = CalculateExponentialMovingAverage(stockDataClass, days).Item1;

                for (int h = 0; h < stockDataClass.InputValues.Count; h++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(h);
                    decimal prevValue = h >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(h - 1) : 0;

                    decimal max = Math.Max(currentValue, prevValue);
                    maxList.Add(max);

                    decimal min = Math.Min(currentValue, prevValue);
                    minList.Add(min);

                    decimal a = max - min;
                    aList.Add(a);
                }

                aEma1List = GetMovingAverageList(maType, aList, stockDataClass, length);
                aEma2List = GetMovingAverageList(maType, aEma1List, stockDataClass, length);
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal aEma1 = aEma1List.ElementAtOrDefault(i);
                    decimal aEma2 = aEma2List.ElementAtOrDefault(i);
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal ema = emaList.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevEma = i >= 1 ? emaList.ElementAtOrDefault(i - 1) : 0;

                    decimal b = aEma2 != 0 ? aEma1 / aEma2 : 0;
                    bList.Add(b);

                    decimal bSum = bList.TakeLast(days).Sum();
                    bSumList.Add(bSum);

                    var signal = GetVolatilitySignal(currentValue - ema, prevValue - prevEma, bSum, c);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (maxList, minList, aList, aEma1List, aEma2List, bList, bSumList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateRecursiveDifferenciator(StockData stockDataClass, string maType, int days = 14)
        {
            //@version=2
            //study("Recursive Differenciator")
            //length = input(14),alpha = input(0.6, minval = 0.5, maxval = 1, step = 0.01)
            //----
            //src = input(close)
            //smo = ema(src, length)
            //----
            //a = rsi(smo, length) / 100
            //b = change(alpha * a + (1 - alpha) * nz(b[1], a), length)
            //----
            //plot(b, color = red, transp = 0)
            List<decimal> rsiList = new();
            List<decimal> aList = new();
            List<decimal> bList = new();
            List<decimal> bChgList = new();
            List<Signal> signalsList = new();
            decimal alpha = 0.6m;

            try
            {
                var emaList = GetMovingAverageList(maType, null, stockDataClass, days);
                rsiList = CalculateRelativeStrengthIndex(emaList, stockDataClass, maType, days).Item4;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal rsi = rsiList.ElementAtOrDefault(i);
                    decimal smo = emaList.ElementAtOrDefault(i);
                    decimal priorB = i >= days ? bList.ElementAtOrDefault(i - days) : 0;

                    decimal a = rsi / 100;
                    aList.Add(a);

                    decimal prevBChg1 = i >= 1 ? bChgList.ElementAtOrDefault(i - 1) : a;
                    decimal prevBChg2 = i >= 2 ? bChgList.ElementAtOrDefault(i - 2) : 0;
                    decimal b = (alpha * a) + ((1 - alpha) * prevBChg1);
                    bList.Add(b);

                    decimal bChg = b - priorB;
                    bChgList.Add(bChg);

                    var signal = GetCompareSignal(bChg - prevBChg1, prevBChg1 - prevBChg2);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (rsiList, aList, bList, bChgList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>)
            CalculateAdaptiveErgodicCandlestickOscillator(StockData stockDataClass, int days = 5)
        {
            //
            // @author LazyBear 
            // 
            // List of my public indicators: http://bit.ly/1LQaPK8 
            // List of my app-store indicators: http://blog.tradingview.com/?p=970 
            //
            //study("Adaptive Ergodic Candlestick Oscillator [LazyBear]", shorttitle = "AECO_LB")
            //length = input(defval = 14, title = "Stoch Scaling Length"),
            //sl = input(defval = 9, title = "Signal Length")
            //ep = input(defval = 5, title = "Smooth Length")
            //vrb = abs(stoch(close, high, low, length) - 50) / 50
            //mep = 2 / (ep + 1), ce = cum(1) <= ((length + ep) * 2)
            //came1 = iff(ce, close - open, nz(came1[1]) + mep * vrb * ((close - open) - nz(came1[1])))
            //came2 = iff(ce, high - low, nz(came2[1]) + mep * vrb * ((high - low) - nz(came2[1])))
            //came11 = iff(ce, came1, nz(came11[1]) + mep * vrb * (came1 - nz(came11[1])))
            //came22 = iff(ce, came2, nz(came22[1]) + mep * vrb * (came2 - nz(came22[1])))
            //eco = came11 / came22 * 100.0
            //se = ema(eco, sl)
            //ebc = input(false, title = "Enable Bar colors")
            //bc_ = eco > 0 ? (eco > eco[1] ? green : orange) : (eco < eco[1] ? red : orange)
            //bc_t = eco > 0 ? (eco > se ? lime : orange) : (eco < se ? red : orange)
            //bc = ebc ? bc_t : na
            //barcolor(bc)
            //plot(0, title = "MidLine")
            //plot(eco, style = histogram, color = bc_, linewidth = 2, title = "ECOHisto_1")
            //plot(eco, color = black, linewidth = 2, title = "AECO")
            List<decimal> vrbList = new();
            List<decimal> came1List = new();
            List<decimal> came2List = new();
            List<decimal> came11List = new();
            List<decimal> came22List = new();
            List<decimal> ecoList = new();
            List<decimal> seList = new();
            List<Signal> signalsList = new();

            try
            {
                int ep = days;
                int length = (int)Math.Ceiling(days / 0.3572);
                int sl = (int)Math.Ceiling(days / 0.5556);
                decimal mep = (decimal)2 / (ep + 1);
                decimal ce = (length + ep) * 2;

                List<decimal> stochasticOscillatorList = CalculateStochasticOscillator(stockDataClass.ClosePrices, stockDataClass, "SimpleMovingAverage", length).Item3;

                for (int i = 0; i < stochasticOscillatorList.Count; i++)
                {
                    decimal stoch = stochasticOscillatorList.ElementAtOrDefault(i);
                    decimal currentHigh = stockDataClass.HighPrices.ElementAtOrDefault(i);
                    decimal currentLow = stockDataClass.LowPrices.ElementAtOrDefault(i);
                    decimal currentOpen = stockDataClass.OpenPrices.ElementAtOrDefault(i);
                    decimal currentClose = stockDataClass.ClosePrices.ElementAtOrDefault(i);

                    decimal vrb = Math.Abs(stoch - 50) / 50;
                    vrbList.Add(vrb);

                    decimal prevCame1 = came1List.LastOrDefault();
                    decimal came1 = i < ce ? currentClose - currentOpen : prevCame1 + (mep * vrb * (currentClose - currentOpen - prevCame1));
                    came1List.Add(came1);

                    decimal prevCame2 = came2List.LastOrDefault();
                    decimal came2 = i < ce ? currentHigh - currentLow : prevCame2 + (mep * vrb * (currentHigh - currentLow - prevCame2));
                    came2List.Add(came2);

                    decimal prevCame11 = came11List.LastOrDefault();
                    decimal came11 = i < ce ? came1 : prevCame11 + (mep * vrb * (came1 - prevCame11));
                    came11List.Add(came11);

                    decimal prevCame22 = came22List.LastOrDefault();
                    decimal came22 = i < ce ? came2 : prevCame22 + (mep * vrb * (came2 - prevCame22));
                    came22List.Add(came22);

                    decimal prevEco = ecoList.LastOrDefault();
                    decimal eco = came22 != 0 ? came11 / came22 * 100 : 0;
                    ecoList.Add(eco);

                    decimal se = CalculateExponentialMovingAverage(eco, seList.LastOrDefault(), sl);
                    seList.Add(se);

                    var signal = GetCompareSignal(eco, prevEco);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (vrbList, came1List, came2List, came11List, came22List, ecoList, seList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateInternalBarStrengthIndicator(StockData stockDataClass, int days = 3)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Internal Bar Strength script may be freely distributed under the MIT license.
            //study(title = "Internal Bar Strength", shorttitle = "IBS", overlay = false)

            //smoothLength = input(title="SmoothLength", type=input.integer, defval=3, minval=1)
            //length = input(title = "Length", type = input.integer, defval = 14, minval = 1)
            //obLevel = input(title = "ObLevel", type = input.integer, defval = 70, minval = 1)
            //osLevel = input(title = "OsLevel", type = input.integer, defval = 30, minval = 1)

            //ibs = high - low != 0 ? (close - low) / (high - low) * 100 : 0
            //ibsi = sma(ibs, smoothLength)
            //sig = ema(ibsi, length)

            //hline(obLevel, color = color.green)
            //hline(50)
            //hline(osLevel, color = color.red)
            //ibsColor = ibsi > sig or(ibsi[1] < osLevel and ibsi > osLevel) ? color.green : ibsi < sig or(ibsi[1] > obLevel and ibsi < obLevel) ? color.red : color.black
            //plot(ibsi, color = ibsColor, title = "Ibs", linewidth = 2)
            //plot(sig, color = color.black, title = "Signal", linewidth = 1)
            List<decimal> ibsList = new();
            List<decimal> ibsiList = new();
            List<decimal> ibsEmaList = new();
            List<Signal> signalsList = new();

            try
            {
                int length = (int)Math.Ceiling(days / 0.2143);

                for (int i = 0; i < stockDataClass.HighPrices.Count; i++)
                {
                    decimal close = stockDataClass.ClosePrices.ElementAtOrDefault(i);
                    decimal open = stockDataClass.OpenPrices.ElementAtOrDefault(i);
                    decimal high = stockDataClass.HighPrices.ElementAtOrDefault(i);
                    decimal low = stockDataClass.LowPrices.ElementAtOrDefault(i);

                    decimal ibs = high - low != 0 ? (close - low) / (high - low) * 100 : 0;
                    ibsList.Add(ibs);

                    decimal prevIbsi = ibsiList.LastOrDefault();
                    decimal ibsi = ibsList.TakeLast(days).Average();
                    ibsiList.Add(ibsi);

                    decimal prevIbsiEma = ibsEmaList.LastOrDefault();
                    decimal ibsiEma = CalculateExponentialMovingAverage(ibsi, prevIbsiEma, length);
                    ibsEmaList.Add(ibsiEma);

                    var signal = GetRsiSignal(ibsi - ibsiEma, prevIbsi - prevIbsiEma, ibsi, prevIbsi, 70, 30);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (ibsList, ibsiList, ibsEmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateRexOscillator(StockData stockDataClass, string maType, int days = 14)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Rex Oscillator script may be freely distributed under the MIT license.
            //study(title = "Rex Oscillator", shorttitle = "RO", overlay = false)

            //length = input(title = "Length", type = input.integer, defval = 14, minval = 1)

            //tvb = (3 * close) - (low + open + high)
            //ro = ema(tvb, length)
            //sig = ema(ro, length)

            //hline(0)
            //roColor = ro > sig ? color.green : ro < sig ? color.red : color.black
            //plot(ro, color = roColor, title = "Ro", linewidth = 2)
            //plot(sig, color = color.black, title = "Signal", linewidth = 1)
            List<decimal> tvbList = new();
            List<decimal> roList = new();
            List<decimal> roEmaList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.HighPrices.Count; i++)
                {
                    decimal close = stockDataClass.ClosePrices.ElementAtOrDefault(i);
                    decimal open = stockDataClass.OpenPrices.ElementAtOrDefault(i);
                    decimal high = stockDataClass.HighPrices.ElementAtOrDefault(i);
                    decimal low = stockDataClass.LowPrices.ElementAtOrDefault(i);

                    decimal tvb = (3 * close) - (low + open + high);
                    tvbList.Add(tvb);
                }

                roList = GetMovingAverageList(maType, tvbList, stockDataClass, days);
                roEmaList = GetMovingAverageList(maType, roList, stockDataClass, days);
                for (int j = 0; j < stockDataClass.HighPrices.Count; j++)
                {
                    decimal ro = roList.ElementAtOrDefault(j);
                    decimal roEma = roEmaList.ElementAtOrDefault(j);
                    decimal prevRo = j >= 1 ? roList.ElementAtOrDefault(j - 1) : 0;
                    decimal prevRoEma = j >= 1 ? roEmaList.ElementAtOrDefault(j - 1) : 0;

                    var signal = GetCompareSignal(ro - roEma, prevRo - prevRoEma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (tvbList, roList, roEmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateBullPowerIndicator(StockData stockDataClass, int days = 14)
        {
            //@version=2
            ////////////////////////////////////////////////////////////
            //  Copyright by HPotter v1.0 27/01/2017
            //  Bull Power Indicator
            //  To get more information please see "Bull And Bear Balance Indicator" 
            //  by Vadim Gimelfarb. 
            ////////////////////////////////////////////////////////////
            //study(title = "Bull Power Strategy")
            //SellLevel = input(40, step = 0.01)
            //BuyLevel = input(3, step = 0.01)
            //hline(SellLevel, color = red, linestyle = line)
            //hline(BuyLevel, color = green, linestyle = line)
            //value = iff (close < open , //then 
            //iff(close[1] < open, max(high - close[1], close - low), max(high - open, close - low)), // else
            //iff(close > open, //then
            //    iff(close[1] > open, high - low, max(open - close[1], high - low)), //else
            //    iff(high - close > close - low, //then
            //        iff(close[1] < open, max(high - close[1], close - low), high - open), //else
            //        iff(high - close < close - low, //then
            //            iff(close[1] > open, high - low, max(open - close, high - low)), //else
            //            iff(close[1] > open, max(high - open, close - low),//else
            //                iff(close[1] < open, max(open - close, high - low), high - low))))))
            //pos = iff(value > SellLevel, -1,
            //         iff(value <= BuyLevel, 1, nz(pos[1], 0)))
            //barcolor(pos == -1 ? red : pos == 1 ? green : blue)
            //plot(value, style = line, linewidth = 2, color = blue)
            List<decimal> bpiList = new();
            List<decimal> bpiEmaList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.HighPrices.Count; i++)
                {
                    decimal close = stockDataClass.ClosePrices.ElementAtOrDefault(i);
                    decimal prevClose = i >= 1 ? stockDataClass.ClosePrices.ElementAtOrDefault(i - 1) : 0;
                    decimal open = stockDataClass.OpenPrices.ElementAtOrDefault(i);
                    decimal high = stockDataClass.HighPrices.ElementAtOrDefault(i);
                    decimal low = stockDataClass.LowPrices.ElementAtOrDefault(i);

                    decimal prevBpi = bpiList.LastOrDefault();
                    decimal bpi = close < open ? Math.Max(high - open, close - low) : prevClose < open ? Math.Max(high - prevClose, close - low) :
                        close > open ? Math.Max(open - prevClose, high - low) : prevClose > open ? high - low :
                        high - close > close - low ? high - open : prevClose < open ? Math.Max(high - prevClose, close - low) :
                        high - close < close - low ? Math.Max(open - close, high - low) : prevClose > open ? high - low :
                        prevClose > open ? Math.Max(high - open, close - low) : prevClose < open ? Math.Max(open - close, high - low) : high - low;
                    bpiList.Add(bpi);

                    decimal prevBpiEma = bpiEmaList.LastOrDefault();
                    decimal bpiEma = CalculateExponentialMovingAverage(bpi, bpiEmaList.LastOrDefault(), days);
                    bpiEmaList.Add(bpiEma);

                    var signal = GetCompareSignal(bpi - bpiEma, prevBpi - prevBpiEma, true);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (bpiList, bpiEmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateBearPowerIndicator(StockData stockDataClass, int days = 14)
        {
            //@verion=2
            ////////////////////////////////////////////////////////////
            //  Copyright by HPotter v1.0 24/01/2017
            //  Bear Power Strategy
            //  To get more information please see "Bull And Bear Balance Indicator" 
            //  by Vadim Gimelfarb. 
            ///////////////////////////////////////////////////////////
            //study(title = "Bear Power Strategy")
            //SellLevel = input(30)
            //BuyLevel = input(3)
            //hline(SellLevel, color = red, linestyle = line)
            //hline(BuyLevel, color = green, linestyle = line)
            //value = iff(close < open, //then 
            //            iff(close[1] > open, max(close - open, high - low), high - low), // else
            //            iff(close > open, //then
            //                iff(close[1] > open, max(close[1] - low, high - close), max(open - low, high - close)), //else
            //                iff(high - close > close - low, //then
            //                    iff(close[1] > open, max(close[1] - open, high - low), high - low), //else
            //                    iff(high - close < close - low, //then
            //                        iff(close > open, max(close - low, high - close), open - low), //else
            //                        iff(close > open, max(close[1] - open, high - close),//else
            //                            iff(close[1] < open, max(open - low, high - close), high - low))))))
            //pos = iff(value > SellLevel, -1,
            //        iff(value <= BuyLevel, 1, nz(pos[1], 0)))
            //barcolor(pos == -1 ? red : pos == 1 ? green : blue)
            //plot(value, style = line, linewidth = 2, color = blue)
            List<decimal> bpiList = new();
            List<decimal> bpiEmaList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.HighPrices.Count; i++)
                {
                    decimal close = stockDataClass.ClosePrices.ElementAtOrDefault(i);
                    decimal prevClose = i >= 1 ? stockDataClass.ClosePrices.ElementAtOrDefault(i - 1) : 0;
                    decimal open = stockDataClass.OpenPrices.ElementAtOrDefault(i);
                    decimal high = stockDataClass.HighPrices.ElementAtOrDefault(i);
                    decimal low = stockDataClass.LowPrices.ElementAtOrDefault(i);

                    decimal prevBpi = bpiList.LastOrDefault();
                    decimal bpi = close < open ? high - low : prevClose > open ? Math.Max(close - open, high - low) :
                        close > open ? Math.Max(open - low, high - close) : prevClose > open ? Math.Max(prevClose - low, high - close) :
                        high - close > close - low ? high - low : prevClose > open ? Math.Max(prevClose - open, high - low) :
                        high - close < close - low ? open - low : close > open ? Math.Max(close - low, high - close) :
                        close > open ? Math.Max(prevClose - open, high - close) : prevClose < open ? Math.Max(open - low, high - close) : high - low;
                    bpiList.Add(bpi);

                    decimal prevBpiEma = bpiEmaList.LastOrDefault();
                    decimal bpiEma = CalculateExponentialMovingAverage(bpi, bpiEmaList.LastOrDefault(), days);
                    bpiEmaList.Add(bpiEma);

                    var signal = GetCompareSignal(bpi - bpiEma, prevBpi - prevBpiEma, true);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (bpiList, bpiEmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateErgodicCandlestickOscillator(StockData stockDataClass, string maType, int days = 4)
        {
            ////////////////////////////////////////////////////////////
            //  Copyright by HPotter v1.0 05/08/2014
            // We call this one the ECO for short, but it will be listed on the indicator list 
            // at W. Blau’s Ergodic Candlestick Oscillator. The ECO is a momentum indicator. 
            // It is based on candlestick bars, and takes into account the size and direction 
            // of the candlestick "body". We have found it to be a very good momentum indicator, 
            // and especially smooth, because it is unaffected by gaps in price, unlike many other 
            // momentum indicators.
            // We like to use this indicator as an additional trend confirmation tool, or as an 
            // alternate trend definition tool, in place of a weekly indicator. The simplest way 
            // of using the indicator is simply to define the trend based on which side of the "0" 
            // line the indicator is located on. If the indicator is above "0", then the trend is up. 
            // If the indicator is below "0" then the trend is down. You can add an additional 
            // qualifier by noting the "slope" of the indicator, and the crossing points of the slow 
            // and fast lines. Some like to use the slope alone to define trend direction. If the 
            // lines are sloping upward, the trend is up. Alternately, if the lines are sloping 
            // downward, the trend is down. In this view, the point where the lines "cross" is the 
            // point where the trend changes.
            // When the ECO is below the "0" line, the trend is down, and we are qualified only to 
            // sell on new short signals from the Hi-Lo Activator. In other words, when the ECO is 
            // above 0, we are not allowed to take short signals, and when the ECO is below 0, we 
            // are not allowed to take long signals. 
            ////////////////////////////////////////////////////////////
            //study(title = "ECO (Blau`s Ergodic Candlestick Oscillator)", shorttitle = "ECO")
            //r = input(32, minval = 1)
            //s = input(12, minval = 1)
            //hline(0, color = purple, linestyle = dashed)
            //xCO = close - open
            //xHL = high - low
            //xEMA = ema(ema(xCO, r), s)
            //xvEMA = ema(ema(xHL, r), s)
            //nRes = 100 * (xEMA / xvEMA)
            //plot(nRes, color = blue, title = "ECO")
            List<decimal> xcoList = new();
            List<decimal> xhlList = new();
            List<decimal> xcoEma1List = new();
            List<decimal> xcoEma2List = new();
            List<decimal> xhlEma1List = new();
            List<decimal> xhlEma2List = new();
            List<decimal> ecoList = new();
            List<decimal> ecoSmaList = new();
            List<Signal> signalsList = new();

            try
            {
                int s = days * 3;
                int r = days * 8;
                int signalPeriod = days;

                for (int i = 0; i < stockDataClass.HighPrices.Count; i++)
                {
                    decimal currentHigh = stockDataClass.HighPrices.ElementAtOrDefault(i);
                    decimal currentLow = stockDataClass.LowPrices.ElementAtOrDefault(i);
                    decimal currentOpen = stockDataClass.OpenPrices.ElementAtOrDefault(i);
                    decimal currentClose = stockDataClass.ClosePrices.ElementAtOrDefault(i);

                    decimal xco = currentClose - currentOpen;
                    xcoList.Add(xco);

                    decimal xhl = currentHigh - currentLow;
                    xhlList.Add(xhl);
                }

                xcoEma1List = GetMovingAverageList(maType, xcoList, stockDataClass, r);
                xcoEma2List = GetMovingAverageList(maType, xcoEma1List, stockDataClass, s);
                xhlEma1List = GetMovingAverageList(maType, xhlList, stockDataClass, r);
                xhlEma2List = GetMovingAverageList(maType, xhlEma1List, stockDataClass, s);
                for (int j = 0; j < stockDataClass.HighPrices.Count; j++)
                {
                    decimal xhlEma2 = xhlEma2List.ElementAtOrDefault(j);
                    decimal xcoEma2 = xcoEma2List.ElementAtOrDefault(j);

                    decimal prevEco = ecoList.LastOrDefault();
                    decimal eco = xhlEma2 != 0 ? 100 * xcoEma2 / xhlEma2 : 0;
                    ecoList.Add(eco);

                    decimal prevEcoSma = ecoSmaList.LastOrDefault();
                    decimal ecoSma = ecoList.TakeLast(signalPeriod).Average();
                    ecoSmaList.Add(ecoSma);

                    var signal = GetCompareSignal(eco - ecoSma, prevEco - prevEcoSma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (xcoEma1List, xcoEma2List, xhlEma1List, xhlEma2List, ecoList, ecoSmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<decimal>, List<Signal>) CalculateErgodicTrueStrengthIndex(StockData stockDataClass, string maType, int days = 3)
        {
            //input = price, user defined, default is close
            //period1 = user input, default is 4
            //period2 = user input, default is 8
            //period3 = user input, default is 6
            //sPeriod = user input, default is 3
            //method = moving average (ma), user defined, default is EMA
            //prev = previous, index = current bar number

            //etsi = 0;
            //prevP = price[index - 1];
            //priceD = price - prevP;
            //absPriceD = Math.abs(price - prevP);
            //ma1 = ma(method, index, period1, priceD);
            //aMa1 = ma(method, index, period1, absPriceD);
            //ma2 = ma(method, index, period2, ma1);
            //aMa2 = ma(method, index, period2, ama1);
            //ma3 = ma(method, index, period3, ma2);
            //aMa3 = ma(method, index, period3, ama2);
            //Plot1: etsi = (100 * ma3) / aMa3;
            //Plot2: sig = ma(method, index, sPeriod, etsi);
            List<decimal> etsiList = new();
            List<decimal> etsiSignalList = new();
            List<decimal> priceDiffList = new();
            List<decimal> absPriceDiffList = new();
            List<decimal> diffEma1List = new();
            List<decimal> absDiffEma1List = new();
            List<decimal> diffEma2List = new();
            List<decimal> absDiffEma2List = new();
            List<decimal> diffEma3List = new();
            List<decimal> absDiffEma3List = new();
            List<Signal> signalsList = new();

            try
            {
                int period1 = (int)Math.Ceiling(days / 0.75);
                int period2 = period1 * 2;
                int period3 = days * 2;
                int sPeriod = days;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal priceDiff = currentValue - prevValue;
                    priceDiffList.Add(priceDiff);

                    decimal absPriceDiff = Math.Abs(priceDiff);
                    absPriceDiffList.Add(absPriceDiff);
                }

                diffEma1List = GetMovingAverageList(maType, priceDiffList, stockDataClass, period1);
                absDiffEma1List = GetMovingAverageList(maType, absPriceDiffList, stockDataClass, period1);
                diffEma2List = GetMovingAverageList(maType, diffEma1List, stockDataClass, period2);
                absDiffEma2List = GetMovingAverageList(maType, absDiffEma1List, stockDataClass, period2);
                diffEma3List = GetMovingAverageList(maType, diffEma2List, stockDataClass, period3);
                absDiffEma3List = GetMovingAverageList(maType, absDiffEma2List, stockDataClass, period3);
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal diffEma3 = diffEma3List.ElementAtOrDefault(j);
                    decimal absDiffEma3 = absDiffEma3List.ElementAtOrDefault(j);

                    decimal etsi = absDiffEma3 != 0 ? MinOrMax(100 * diffEma3 / absDiffEma3, 100, -100) : 0;
                    etsiList.Add(etsi);
                }

                etsiSignalList = GetMovingAverageList(maType, etsiList, stockDataClass, sPeriod);
                for (int k = 0; k < stockDataClass.InputValues.Count; k++)
                {
                    decimal etsi = etsiList.ElementAtOrDefault(k);
                    decimal etsiSignal = etsiSignalList.ElementAtOrDefault(k);
                    decimal prevEtsi = k >= 1 ? etsiList.ElementAtOrDefault(k - 1) : 0;
                    decimal prevEtsiSignal = k >= 1 ? etsiSignalList.ElementAtOrDefault(k - 1) : 0;

                    var signal = GetCompareSignal(etsi - etsiSignal, prevEtsi - prevEtsiSignal);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (diffEma1List, absDiffEma1List, diffEma2List, absDiffEma2List, diffEma3List, absDiffEma3List, etsiList, etsiSignalList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateErgodicTrueStrengthIndex2(StockData stockDataClass, string maType, int days = 2)
        {
            //input = price, user defined, default is close
            //period1 = user input, default is 21
            //period2 = user input, default is 9
            //period3 = user input, default is 9
            //period4 = user input, default is 17
            //period5 = user input, default is 6
            //period6 = user input, default is 2
            //sPeriod = user input, default is 2
            //method = moving average (ma), user defined, default is EMA
            //prev = previous, abs = absolute value
            //index = current bar number

            //etsi = 0;
            //prevP = price[index - 1];
            //priceD = price - prevP;
            //absPriceD = Math.abs(price - prevP);
            //ma1 = ma(method, index, period1, priceD);
            //aMa1 = ma(method, index, period1, absPriceD);
            //ma4 = ma(method, index, period4, priceD);
            //aMa4 = ma(method, index, period4, abdPriceD);
            //ma2 = ma(method, index, period2, ma1);
            //aMa2 = ma(method, index, period2, ama1);
            //ma5 = ma(method, index, period5, ma4);
            //aMa5 = ma(method, index, period5, aMa4);
            //ma3 = ma(method, index, period3, ma2);
            //aMa3 = ma(method, index, period3, ama2);
            //ma6 = ma(method, index, period6, ma5);
            //aMa6 = ma(method, index, period6, aMa5);
            //Plot1: etsi2 = (100 * ma6) / aMa6;
            //Plot2: etsi = (100 * ma3) / aMa3;
            //Plot3: sig = ma(method, index, sPeriod, esti);
            List<decimal> etsi2List = new();
            List<decimal> etsi2SignalList = new();
            List<decimal> priceDiffList = new();
            List<decimal> absPriceDiffList = new();
            List<decimal> diffEma1List = new();
            List<decimal> absDiffEma1List = new();
            List<decimal> diffEma2List = new();
            List<decimal> absDiffEma2List = new();
            List<decimal> diffEma3List = new();
            List<decimal> absDiffEma3List = new();
            List<decimal> diffEma4List = new();
            List<decimal> absDiffEma4List = new();
            List<decimal> diffEma5List = new();
            List<decimal> absDiffEma5List = new();
            List<decimal> diffEma6List = new();
            List<decimal> absDiffEma6List = new();
            List<Signal> signalsList = new();

            try
            {
                int period1 = (int)Math.Ceiling(days / 0.0953);
                int period2 = (int)Math.Ceiling(days / 0.2223);
                int period3 = period2;
                int period4 = (int)Math.Ceiling(days / 0.1177);
                int period5 = days * 3;
                int period6 = days;
                int sPeriod = period6;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal priceDiff = currentValue - prevValue;
                    priceDiffList.Add(priceDiff);

                    decimal absPriceDiff = Math.Abs(currentValue - prevValue);
                    absPriceDiffList.Add(absPriceDiff);
                }

                diffEma1List = GetMovingAverageList(maType, priceDiffList, stockDataClass, period1);
                absDiffEma1List = GetMovingAverageList(maType, absPriceDiffList, stockDataClass, period1);
                diffEma4List = GetMovingAverageList(maType, priceDiffList, stockDataClass, period4);
                absDiffEma4List = GetMovingAverageList(maType, absPriceDiffList, stockDataClass, period4);
                diffEma2List = GetMovingAverageList(maType, diffEma1List, stockDataClass, period2);
                absDiffEma2List = GetMovingAverageList(maType, absDiffEma1List, stockDataClass, period2);
                diffEma5List = GetMovingAverageList(maType, diffEma4List, stockDataClass, period5);
                absDiffEma5List = GetMovingAverageList(maType, absDiffEma4List, stockDataClass, period5);
                diffEma3List = GetMovingAverageList(maType, diffEma2List, stockDataClass, period3);
                absDiffEma3List = GetMovingAverageList(maType, absDiffEma2List, stockDataClass, period3);
                diffEma6List = GetMovingAverageList(maType, diffEma5List, stockDataClass, period6);
                absDiffEma6List = GetMovingAverageList(maType, absDiffEma5List, stockDataClass, period6);
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal diffEma6 = diffEma6List.ElementAtOrDefault(j);
                    decimal absDiffEma6 = absDiffEma6List.ElementAtOrDefault(j);

                    decimal etsi2 = absDiffEma6 != 0 ? MinOrMax(diffEma6 / absDiffEma6 * 100, 100, -100) : 0;
                    etsi2List.Add(etsi2);
                }

                etsi2SignalList = GetMovingAverageList(maType, etsi2List, stockDataClass, sPeriod);
                for (int k = 0; k < stockDataClass.InputValues.Count; k++)
                {
                    decimal etsi2 = etsi2List.ElementAtOrDefault(k);
                    decimal etsi2Signal = etsi2SignalList.ElementAtOrDefault(k);
                    decimal prevEtsi2 = k >= 1 ? etsi2List.ElementAtOrDefault(k - 1) : 0;
                    decimal prevEtsi2Signal = k >= 1 ? etsi2SignalList.ElementAtOrDefault(k - 1) : 0;

                    var signal = GetCompareSignal(etsi2 - etsi2Signal, prevEtsi2 - prevEtsi2Signal);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (diffEma1List, absDiffEma1List, diffEma2List, absDiffEma2List, diffEma3List, absDiffEma3List, diffEma4List, absDiffEma4List, diffEma5List, absDiffEma5List,
                diffEma6List, absDiffEma6List, etsi2List, etsi2SignalList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateDecisionPointPriceMomentumOscillator(StockData stockDataClass, int days = 10)
        {
            //
            // @author LazyBear 
            //
            // List of my public indicators: http://bit.ly/1LQaPK8 
            // List of my app-store indicators: http://blog.tradingview.com/?p=970 
            //
            //study(title = "DecisionPoint Price Momentum Oscillator [LazyBear]", shorttitle = "DPMO_LB")
            //src = input(close, title = "Source")
            //length1 = input(35, title = "First Smoothing")
            //length2 = input(20, title = "Second Smoothing")
            //siglength = input(10, title = "Signal Smoothing")
            //fr = input(true, title = "Fill Region")
            //ehc = input(false, title = "Enable Histo Color")
            //ebc = input(false, title = "Enable Bar Colors")
            //soh = input(false, title = "Show Only Histo")
            //slvl = input(false, title = "Show OB/OS Levels")
            //oblvl = input(2.5, title = "OB Level"), oslvl = input(-2.5, title = "OS Level")
            //calc_csf(src, length) => 
            //    sm = 2.0 / length
            //    csf = (src - nz(csf[1])) * sm + nz(csf[1])

            //i = (src / nz(src[1], src)) * 100
            //pmol2 = calc_csf(i - 100, length1)
            //pmol = calc_csf(10 * pmol2, length2)
            //pmols = ema(pmol, siglength)
            //d = pmol - pmols
            //duml = plot(not soh and fr ? (d > 0 ? pmol : pmols) : na, style = circles, color = gray, linewidth = 0, title = "DummyL")
            //plot(0, title = "MidLine")
            //hc = d > 0 ? d > d[1] ? lime : green : d < d[1] ? red : orange
            //plot(d, style = columns, color = ehc ? hc : gray, transp = 80, title = "Histo")
            //sigl = plot(soh ? na : pmols, title = "PMO Signal", color = gray, linewidth = 2, title = "Signal")
            //mdl = plot(soh ? na : pmol, title = "PMO", color = black, linewidth = 2, title = "PMO")
            //fill(duml, sigl, green, transp = 70, title = "PosFill")
            //fill(duml, mdl, red, transp = 70, title = "NegFill")
            //barcolor(ebc ? hc : na)
            //plot(not soh and slvl ? oblvl : na, title = "OB Level", color = gray, linewidth = 2)
            //plot(not soh and slvl ? oslvl : na, title = "OS Level", color = gray, linewidth = 2)
            List<decimal> pmol2List = new();
            List<decimal> pmolList = new();
            List<decimal> pmolsList = new();
            List<decimal> dList = new();
            List<Signal> signalsList = new();

            try
            {
                int signalLength = days;
                int length1 = MinOrMax((int)Math.Ceiling(signalLength * 3.5));
                int length2 = MinOrMax(signalLength * 2);
                decimal smPmol2 = (decimal)2 / length1;
                decimal smPmol = (decimal)2 / length2;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal ival = prevValue != 0 ? currentValue / prevValue * 100 : 100;
                    decimal prevPmol = pmolList.LastOrDefault();
                    decimal prevPmol2 = pmol2List.LastOrDefault();

                    decimal pmol2 = ((ival - 100 - prevPmol2) * smPmol2) + prevPmol2;
                    pmol2List.Add(pmol2);

                    decimal pmol = (((10 * pmol2) - prevPmol) * smPmol) + prevPmol;
                    pmolList.Add(pmol);

                    decimal pmols = CalculateExponentialMovingAverage(pmol, pmolsList.LastOrDefault(), signalLength);
                    pmolsList.Add(pmols);

                    decimal prevD = dList.LastOrDefault();
                    decimal d = pmol - pmols;
                    dList.Add(d);

                    var signal = GetCompareSignal(d, prevD);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (pmol2List, pmolList, pmolsList, dList, signalsList);
        }

        public static (List<decimal>, List<Signal>) CalculateJsaMovingAverage(StockData stockDataClass, int days = 14)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Jsa Moving Average script may be freely distributed under the MIT license.
            //study("Jsa Moving Average", shorttitle = "JMA", overlay = true)

            //length = input(title = "Length", type = input.integer, defval = 14, minval = 1)
            //src = input(title = "Source", type = input.source, defval = close)

            //jma = (src + src[length]) / 2

            //jmaColor = src > jma ? color.green : src < jma ? color.red : color.black
            //plot(jma, color = jmaColor, linewidth = 2)
            List<decimal> jmaList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal priorValue = i >= days ? stockDataClass.InputValues.ElementAtOrDefault(i - days) : 0;
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal prevJma = jmaList.LastOrDefault();
                    decimal jma = (currentValue + priorValue) / 2;
                    jmaList.Add(jma);

                    var signal = GetCompareSignal(currentValue - jma, prevValue - prevJma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (jmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateZeroLagSmoothedCycle(StockData stockDataClass, int days = 100)
        {
            //@version=3
            //study(title = "Zero-Lag Smoothed Cycle", shorttitle = "ZLSC")
            //length = input(100)
            //
            //filt(x) =>
            //    k = linreg(x, length, 0)
            //a(x) =>
            //    c = x - filt(x)
            //l(x) =>
            //    c = a(x) + (a(x) - filt(a(x)))
            //
            //x = close
            //lco = l(l(l(x)))
            //filter = (-sma(sma(lco, length / 2), length / 2)) * 2
            //
            //plot(filter, color = aqua, transp = 0)
            //plot(lco, color = orange, transp = 0)
            List<decimal> ax1List = new();
            List<decimal> ax1LinregList = new();
            List<decimal> lx1List = new();
            List<decimal> lx1LinregList = new();
            List<decimal> ax2List = new();
            List<decimal> ax2LinregList = new();
            List<decimal> lx2List = new();
            List<decimal> lx2LinregList = new();
            List<decimal> ax3List = new();
            List<decimal> ax3LinregList = new();
            List<decimal> lcoList = new();
            List<decimal> filterList = new();
            List<decimal> lcoSma1List = new();
            List<decimal> lcoSma2List = new();
            List<Signal> signalsList = new();

            try
            {
                int length = MinOrMax((int)Math.Ceiling((decimal)days / 2));

                var linregList = CalculateLinearRegression(null, stockDataClass, days).Item15;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal linreg = linregList.ElementAtOrDefault(i);

                    decimal ax1 = currentValue - linreg;
                    ax1List.Add(ax1);
                }

                ax1LinregList = CalculateLinearRegression(ax1List, stockDataClass, days).Item15;
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal ax1 = ax1List.ElementAtOrDefault(j);
                    decimal ax1Linreg = ax1LinregList.ElementAtOrDefault(j);

                    decimal lx1 = ax1 + (ax1 - ax1Linreg);
                    lx1List.Add(lx1);
                }

                lx1LinregList = CalculateLinearRegression(lx1List, stockDataClass, days).Item15;
                for (int k = 0; k < stockDataClass.InputValues.Count; k++)
                {
                    decimal lx1 = lx1List.ElementAtOrDefault(k);
                    decimal lx1Linreg = lx1LinregList.ElementAtOrDefault(k);

                    decimal ax2 = lx1 - lx1Linreg;
                    ax2List.Add(ax2);
                }

                ax2LinregList = CalculateLinearRegression(ax2List, stockDataClass, days).Item15;
                for (int l = 0; l < stockDataClass.InputValues.Count; l++)
                {
                    decimal ax2 = ax2List.ElementAtOrDefault(l);
                    decimal ax2Linreg = ax2LinregList.ElementAtOrDefault(l);

                    decimal lx2 = ax2 + (ax2 - ax2Linreg);
                    lx2List.Add(lx2);
                }

                lx2LinregList = CalculateLinearRegression(lx2List, stockDataClass, days).Item15;
                for (int m = 0; m < stockDataClass.InputValues.Count; m++)
                {
                    decimal lx2 = lx2List.ElementAtOrDefault(m);
                    decimal lx2Linreg = lx2LinregList.ElementAtOrDefault(m);

                    decimal ax3 = lx2 - lx2Linreg;
                    ax3List.Add(ax3);
                }

                ax3LinregList = CalculateLinearRegression(ax3List, stockDataClass, days).Item15;
                for (int n = 0; n < stockDataClass.InputValues.Count; n++)
                {
                    decimal ax3 = ax3List.ElementAtOrDefault(n);
                    decimal ax3Linreg = ax3LinregList.ElementAtOrDefault(n);

                    decimal prevLco = lcoList.LastOrDefault();
                    decimal lco = ax3 + (ax3 - ax3Linreg);
                    lcoList.Add(lco);

                    decimal lcoSma1 = lcoList.TakeLast(length).Average();
                    lcoSma1List.Add(lcoSma1);

                    decimal lcoSma2 = lcoSma1List.TakeLast(length).Average();
                    lcoSma2List.Add(lcoSma2);

                    decimal prevFilter = filterList.LastOrDefault();
                    decimal filter = -lcoSma2 * 2;
                    filterList.Add(filter);

                    var signal = GetCompareSignal(lco - filter, prevLco - prevFilter);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (ax1List, ax1LinregList, lx1List, lx1LinregList, ax2List, ax2LinregList, lx2List, lx2LinregList, ax3List, ax3LinregList, lcoList, lcoSma1List, lcoSma2List,
                filterList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateDecisionPointBreadthSwenlinTradingOscillator(StockData stockDataClass, string maType, int days = 4)
        {
            //
            // @author LazyBear 
            // 
            // List of my public indicators: http://bit.ly/1LQaPK8 
            // List of my app-store indicators: http://blog.tradingview.com/?p=970 
            //
            //study("DecisionPoint Breadth Swenlin Trading Oscillator [LazyBear]", shorttitle = "DBSTO_LB", overlay = false, precision = 5)
            //mkt = input(defval = 1, minval = 0, maxval = 4, title = "Market (0=>AMEX/NASD/NYSE Combined, 1=NYSE, 2=NASDAQ, 3=AMEX, 4=CUSTOM)")
            //aic = input(defval = "INDEX:ADVS", title = "CUSTOM: Advancing Stocks Symbol", type = symbol)
            //dic = input(defval = "INDEX:DECS", title = "CUSTOM: Declining Stocks Symbol", type = symbol)
            //res = isintraday ? "D" : period // dont go below "D"
            //advn = "INDEX:ADVN", decn = "INDEX:DECN" // NYSE
            //advnq = "INDEX:ADVQ", decnq = "INDEX:DECQ" // NASDAQ
            //advna = "INDEX:ADVA", decna = "INDEX:DECA" // AMEX
            //advc = "(INDEX:ADVN+INDEX:ADVQ+INDEX:ADVA)/3.0", decc = "(INDEX:DECN+INDEX:DECQ+INDEX:DECA)/3.0"
            //adv = security(mkt == 0 ? advc : mkt == 1 ? advn : mkt == 2 ? advnq : mkt == 3 ? advna : aic, res, close)
            //dec = security(mkt == 0 ? decc : mkt == 1 ? decn : mkt == 2 ? decnq : mkt == 3 ? decna : dic, res, close)
            //i = (adv - dec) / (adv + dec)
            //sto = sma(ema(i * 1000, 4), 5)
            //sh = input(true, title = "Show Histo")
            //plot(0, color = gray, title = "MidLine")
            //plot(sh ? sto : na, style = histogram, color = sto > 0 ? sto > sto[1] ? green : orange : sto < sto[1] ? red : orange, title = "Histo")
            //plot(sto, linewidth = 2, color = black, title = "DSTO")
            List<decimal> stoList = new();
            List<decimal> ivalEmaList = new();
            List<decimal> stoEmaList = new();
            List<Signal> signalsList = new();

            try
            {
                int period = days;
                int smaPeriod = MinOrMax((int)Math.Ceiling(period / 0.8));

                List<decimal> ranaList = CalculateMcClellanOscillator(stockDataClass, maType, period).Item5;

                for (int i = 0; i < ranaList.Count; i++)
                {
                    decimal rana = ranaList.ElementAtOrDefault(i);

                    decimal ivalEma = CalculateExponentialMovingAverage(rana, ivalEmaList.LastOrDefault(), period);
                    ivalEmaList.Add(ivalEma);

                    decimal prevSto = stoList.LastOrDefault();
                    decimal sto = ivalEmaList.TakeLast(smaPeriod).Average();
                    stoList.Add(sto);

                    decimal prevStoEma = stoEmaList.LastOrDefault();
                    decimal stoEma = CalculateExponentialMovingAverage(sto, stoEmaList.LastOrDefault(), period);
                    stoEmaList.Add(stoEma);

                    var signal = GetCompareSignal(sto - stoEma, prevSto - prevStoEma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (stoList, stoEmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateForecastOscillator(StockData stockDataClass, int days = 3)
        {
            //
            // @author LazyBear
            // 
            //study(title = "Forecast Oscillator [LazyBear]", shorttitle = "ForecastOsc_LB")
            //pf = 100 * ((close[0] - close[1]) / close[0])
            //plot(pf, color=green)
            //plot(sma(pf, 3), color = orange)
            List<decimal> pfList = new();
            List<decimal> pfSmaList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal pf = currentValue != 0 ? 100 * (currentValue - prevValue) / currentValue : 0;
                    pfList.Add(pf);

                    decimal prevPfSma = pfSmaList.LastOrDefault();
                    decimal pfSma = pfList.TakeLast(days).Average();
                    pfSmaList.Add(pfSma);

                    var signal = GetCompareSignal(pfSma, prevPfSma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (pfList, pfSmaList, signalsList);
        }

        public static (List<decimal>, List<Signal>) CalculateChandeForecastOscillator(StockData stockDataClass, int days = 14)
        {
            //@version=2
            ////////////////////////////////////////////////////////////
            //  Copyright by HPotter v1.0 11/03/2018
            // The Chande Forecast Oscillator developed by Tushar Chande The Forecast 
            // Oscillator plots the percentage difference between the closing price and 
            // the n-period linear regression forecasted price. The oscillator is above 
            // zero when the forecast price is greater than the closing price and less 
            // than zero if it is below.
            ////////////////////////////////////////////////////////////
            //strategy(title = "Chande Forecast Oscillator", shorttitle = "CFO")
            //Length = input(14, minval = 1)
            //Offset = input(0)
            //hline(0, color = black, linestyle = line)
            //xLG = linreg(close, Length, Offset)
            //xCFO = ((close - xLG) * 100) / close
            //plot(xCFO, color = red, title = "CFO")
            List<decimal> pfList = new();
            List<Signal> signalsList = new();

            try
            {
                List<decimal> linRegList = CalculateLinearRegression(null, stockDataClass, days).Item15;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal currentLinReg = linRegList.ElementAtOrDefault(i);

                    decimal prevPf = pfList.LastOrDefault();
                    decimal pf = currentValue != 0 ? (currentValue - currentLinReg) * 100 / currentValue : 0;
                    pfList.Add(pf);

                    var signal = GetCompareSignal(pf, prevPf);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (pfList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateChandeKrollRSquaredIndex(StockData stockDataClass, int days = 14)
        {
            //@version=3
            // Copyright (c) 2018-present, Alex Orekhov (everget)
            // Chande Kroll R-Squared Index script may be freely distributed under the MIT license.
            //study("Chande Kroll R-Squared Index", shorttitle = "R2")

            //length = input(title = "Length", type = integer, defval = 14, minval = 1)
            //applySmoothing = input(title = "Apply Smoothing ?", type = bool, defval = false)
            //smoothingLength = input(title = "Smoothing Length", type = integer, defval = 3, minval = 1)
            //applyNormalization = input(title = "Apply Normalization to [0, 100] values ?", type = bool, defval = false)
            //src = input(title = "Source", type = source, defval = close)

            //r2Raw = pow(correlation(cum(1), src, length), 2)

            //r2 = applyNormalization
            //     ? 100 * r2Raw
            //     : r2Raw

            //r2Smoothed = applySmoothing
            //     ? sma(r2, smoothingLength)
            //     : r2

            //middleLevel = applyNormalization
            //     ? 50
            //     : 0.5

            //r2Color = r2Smoothed > middleLevel
            //     ? green
            //     : red

            //plot(r2Smoothed, title = "R2", linewidth = 2, color = r2Color, transp = 0)
            //plot(middleLevel, title = "ML", style = circles, color =#f6b26b, transp=0)
            List<decimal> r2RawList = new();
            List<decimal> tempValueList = new();
            List<decimal> indexList = new();
            List<decimal> r2SmoothedList = new();
            List<Signal> signalsList = new();

            try
            {
                int r2Length = days;
                int smoothingLength = MinOrMax((int)Math.Ceiling(r2Length / 0.2143));

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal prevR2Sma1 = i >= 1 ? r2SmoothedList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevR2Sma2 = i >= 2 ? r2SmoothedList.ElementAtOrDefault(i - 2) : 0;

                    decimal index = i;
                    indexList.Add(index);

                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    tempValueList.Add(currentValue);

                    var r2 = GoodnessOfFit.RSquared(indexList.TakeLast(r2Length).Select(x => (double)x), tempValueList.TakeLast(r2Length).Select(x => (double)x));
                    r2 = IsValueNullOrInfinity(r2) ? 0 : r2;
                    r2RawList.Add((decimal)r2);

                    decimal r2Sma = r2RawList.TakeLast(smoothingLength).Average();
                    r2SmoothedList.Add(r2Sma);

                    var signal = GetCompareSignal(r2Sma - prevR2Sma1, prevR2Sma1 - prevR2Sma2);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (r2RawList, r2SmoothedList, signalsList);
        }

        public static (List<decimal>, List<Signal>) CalculateRegressionOscillator(StockData stockDataClass, int days = 63)
        {
            //@version=3
            // Copyright (c) 2018-present, Alex Orekhov (everget)
            // Regression Oscillator indicator script may be freely distributed under the MIT license.
            //study("Regression Oscillator", shorttitle = "ROSC")

            //length = input(title = "Length", type = integer, defval = 63, minval = 1)
            //linregOffset = input(title = "Linear Regression Offset", type = integer, defval = 0)
            //src = input(title = "Source", type = source, defval = close)

            //rosc = 100 * (src / linreg(src, length, linregOffset) - 1)

            //roscColor = rosc >= 0.0 ? #0ebb23 : #ff0000

            //plot(rosc, title = "ROSC", linewidth = 2, color = roscColor, transp = 0)

            //hline(0, title = "Zero Level", linestyle = dotted, color =#989898)
            List<decimal> roscList = new();
            List<Signal> signalsList = new();

            try
            {
                List<decimal> linRegList = CalculateLinearRegression(null, stockDataClass, days).Item15;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal currentLinReg = linRegList.ElementAtOrDefault(i);

                    decimal prevRosc = roscList.LastOrDefault();
                    decimal rosc = currentLinReg != 0 ? 100 * ((currentValue / currentLinReg) - 1) : 0;
                    roscList.Add(rosc);

                    var signal = GetCompareSignal(rosc, prevRosc);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (roscList, signalsList);
        }

        public static (List<decimal>, List<Signal>) CalculateSupportAndResistanceOscillator(StockData stockDataClass)
        {
            //input = price, user defined, default is closing price
            //index = current bar number

            //tRange = getTrueRange(index);
            //close = price[index];
            //sro = 0;
            //if (tRange != 0) sro = ((High - open) + (close - Low)) / (2 * tRange);
            //Signals
            //highSell = sro for last sell signal, reset to max_negative at each  buy signal;
            //lowBuy = sro for last buy signal, reset to max_positive at each sell signal;
            //sell = (sro moreThan topGuide) AND(sro moreThan highSell);
            //buy = (sro lessThan bottGuide)  AND(sro lessThan lowBuy);
            List<decimal> sroList = new();
            List<Signal> signalsList = new();

            try
            {
                var trList = CalculateVortexIndicator(stockDataClass).Item5;

                for (int i = 0; i < stockDataClass.HighPrices.Count; i++)
                {
                    decimal currentHigh = stockDataClass.HighPrices.ElementAtOrDefault(i);
                    decimal currentLow = stockDataClass.LowPrices.ElementAtOrDefault(i);
                    decimal currentOpen = stockDataClass.OpenPrices.ElementAtOrDefault(i);
                    decimal currentClose = stockDataClass.ClosePrices.ElementAtOrDefault(i);
                    decimal tr = trList.ElementAtOrDefault(i);
                    decimal prevSro1 = i >= 1 ? sroList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevSro2 = i >= 2 ? sroList.ElementAtOrDefault(i - 2) : 0;

                    decimal sro = tr != 0 ? MinOrMax(((currentHigh - currentOpen) + (currentClose - currentLow)) / (2 * tr), 1, 0) : 0;
                    sroList.Add(sro);

                    var signal = GetRsiSignal(sro - prevSro1, prevSro1 - prevSro2, sro, prevSro1, 0.7m, 0.3m);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (sroList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateTrendAnalysisIndex(StockData stockDataClass, string maType, int days = 5)
        {
            //input = price user defined, default is close
            //avPeriod = user defined, default is 28
            //taiPeriod = user defined, default is 5
            //sma = simple moving average, index = current bar number
            //TopBand = input(0.11, step = 0.01)
            //LowBand = input(0.02, step = 0.01)

            //av1 = sma(index, avPeriod, input);
            //highest = highest(index, taiPeriod, av1);
            //lowest = lowest(index, taiPeriod, av1);
            //Plot: tai = (highest - lowest) * 100 / price;
            List<decimal> taiList = new();
            List<decimal> taiEmaList = new();
            List<Signal> signalsList = new();

            try
            {
                int avPeriod = (int)Math.Ceiling(days / 0.179);

                var smaList = GetMovingAverageList(maType, null, stockDataClass, avPeriod);
                var list = GetMaxAndMinValuesList(smaList, days);
                var highestList = list.Item1;
                var lowestList = list.Item2;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal highest = highestList.ElementAtOrDefault(i);
                    decimal lowest = lowestList.ElementAtOrDefault(i);

                    decimal prevTai = taiList.LastOrDefault();
                    decimal tai = currentValue != 0 ? (highest - lowest) * 100 / currentValue : 0;
                    taiList.Add(tai);

                    decimal prevTaiEma = taiEmaList.LastOrDefault();
                    decimal taiEma = CalculateExponentialMovingAverage(tai, taiEmaList.LastOrDefault(), days);
                    taiEmaList.Add(taiEma);

                    var signal = GetCompareSignal(tai - taiEma, prevTai - prevTaiEma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (taiList, taiEmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateTrendAnalysisIndicator(StockData stockDataClass, string maType, int days = 4)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Trend Analysis Indicator script may be freely distributed under the MIT license.
            //study("Trend Analysis Indicator", shorttitle = "TAI", overlay = false)

            //maLength = input(title = "MovingAvgLength", type = input.integer, defval = 21, minval = 1)
            //lbLength = input(title = "LookbackLength", type = input.integer, defval = 4, minval = 1)
            //src = input(title = "Source", type = input.source, defval = close)

            //ma = sma(src, maLength)
            //tai = stdev(ma, lbLength)
            //fastMa = ema(src, lbLength)
            //slowMa = ema(src, maLength)
            //sig = sma(tai, maLength * 2)

            //bsc = 0
            //bsc:= (tai > tai[1] and fastMa > slowMa) or fastMa > slowMa ? 1 : (tai > tai[1] and fastMa<slowMa) or fastMa<slowMa ? -1 : nz(bsc[1], 0)
            //taiColor = bsc > 0 ? color.green : bsc < 0 ? color.red : color.black
            //plot(tai, color = taiColor, linewidth = 2)
            //plot(sig, color=color.black, linewidth=1)
            List<decimal> taiList = new();
            List<decimal> taiEmaList = new();
            List<decimal> bscList = new();
            List<Signal> signalsList = new();

            try
            {
                int maLength = (int)Math.Ceiling(days / 0.1905);
                int sigLength = maLength * 2;

                var smaList = GetMovingAverageList(maType, null, stockDataClass, maLength);
                taiList = CalculateStandardDeviationVolatility(smaList, stockDataClass, days).Item4;
                taiEmaList = GetMovingAverageList(maType, taiList, stockDataClass, sigLength);
                var fastMaList = CalculateExponentialMovingAverage(stockDataClass, days).Item1;
                var slowMaList = CalculateExponentialMovingAverage(stockDataClass, maLength).Item1;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal tai = taiList.ElementAtOrDefault(i);
                    decimal fastMa = fastMaList.ElementAtOrDefault(i);
                    decimal slowMa = slowMaList.ElementAtOrDefault(i);
                    decimal prevTai = i >= 1 ? taiList.ElementAtOrDefault(i - 1) : 0;

                    decimal prevBsc = bscList.LastOrDefault();
                    decimal bsc = (tai > prevTai && fastMa > slowMa) || fastMa > slowMa ? 1 : (tai > prevTai && fastMa < slowMa) || fastMa < slowMa ? -1 : bscList.LastOrDefault();
                    bscList.Add(bsc);

                    var signal = GetCompareSignal(bsc, prevBsc);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (taiList, taiEmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculatePriceDifference(StockData stockDataClass, int days)
        {
            //prevP = price[index - 1];
            //diff = price - prevP;
            //absDiff = Math.Abs(price - prevP);
            List<decimal> diffList = new();
            List<decimal> absDiffList = new();
            List<decimal> diffEmaList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal prevDiff = diffList.LastOrDefault();
                    decimal diff = currentValue - prevValue;
                    diffList.Add(diff);

                    decimal absDiff = Math.Abs(diff);
                    absDiffList.Add(absDiff);

                    decimal prevDiffEma = diffEmaList.LastOrDefault();
                    decimal diffEma = CalculateExponentialMovingAverage(diff, diffEmaList.LastOrDefault(), days);
                    diffEmaList.Add(diffEma);

                    var signal = GetCompareSignal(diff - diffEma, prevDiff - prevDiffEma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (diffList, absDiffList, diffEmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateWamiOscillator(StockData stockDataClass, string maType, int days = 4)
        {
            ////////////////////////////////////////////////////////////
            //  Copyright by HPotter v1.0 08/07/2014
            // The WAMI-based trading lies in the application and iteration of the 
            // optimization process until the indicated trades on past market data 
            // give consistent, profitable results. It is rather difficult process 
            // based on Fourier analysis. 
            // You can to change Trigger parameter for to get best values of strategy.
            ////////////////////////////////////////////////////////////
            //study(title = "WAMI Strategy", shorttitle = "WAMI Strategy")
            //Length_EMA = input(13, minval = 1)
            //Length_WMA = input(4, minval = 1)
            //Trigger = input(0)
            //hline(Trigger, color = purple, linestyle = line)
            //xWAMI = ema(ema(wma(mom(close, 1), Length_WMA), Length_EMA), Length_EMA)
            //pos = iff(xWAMI > Trigger, 1,
            //      iff(xWAMI < Trigger, -1, nz(pos[1], 0)))
            //barcolor(pos == -1 ? red : pos == 1 ? green : blue)
            //plot(xWAMI, color = blue, title = "WAMI")
            List<decimal> diffList = new();
            List<decimal> wamiList = new();
            List<decimal> wma1List = new();
            List<decimal> ema2List = new();
            List<Signal> signalsList = new();

            try
            {
                int period2 = MinOrMax((int)Math.Ceiling(days / 0.3077));
                int period3 = period2;

                for (int h = 0; h < stockDataClass.InputValues.Count; h++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(h);
                    decimal prevValue = h >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(h - 1) : 0;

                    decimal diff = currentValue - prevValue;
                    diffList.Add(diff);
                }

                wma1List = GetMovingAverageList("WeightedMovingAverage", diffList, stockDataClass, days);
                ema2List = GetMovingAverageList(maType, wma1List, stockDataClass, period2);
                wamiList = GetMovingAverageList(maType, ema2List, stockDataClass, period3);
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal wami = wamiList.ElementAtOrDefault(i);
                    decimal prevWami = i >= 1 ? wamiList.ElementAtOrDefault(i - 1) : 0;

                    var signal = GetCompareSignal(wami, prevWami);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (wma1List, ema2List, wamiList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateTurboStochasticsSlow(StockData stockDataClass, string maType, int days = 20)
        {
            //input = price, user defined, default is closing price
            //kPeriod = user defined, default is 20
            //dPeriod = user defined, default is 20
            //regress = linear regression period = user defined, default is 10
            //turbo = user defined, default is +2
            //stochK = stochastics slow K, sma = simple moving average
            //index = current bar number

            //fastK = stochK(index, kPeriod, input);
            //slowK = sma(index, kPeriod, fastK);  //same as fastD
            //slowD = sma(index, dPeriod, slowK);
            //if (turbo lessThan 0) turbo = Math.max(turbo, -regress);
            //if (turbo moreThan 0) turbo = Math.min(turbo, regress);
            //Plot1: tssK = linRegLine(index, regress, slowK, regress + turbo)[0];
            //Plot2: tssD = linRegLine(index, regress, slowD, regress + turbo)[0];
            //Signals
            //highSell = tssK for last sell signal, reset to max_negative at each  buy signal;
            //lowBuy = tssK for last buy signal, reset to max_positive at each sell signal;
            //sell = crossedBelow(TSSK, TSSD) AND tssK moreThan topGuide AND(tssK moreThan highSell);
            //buy = crossedAbove(TSSK, TSSD) AND tssK lessThan bottGuide AND(tssK lessThan lowBuy);
            int turbo = 2;
            List<decimal> tssDList = new();
            List<decimal> tssKList = new();
            List<Signal> signalsList = new();

            try
            {
                var stochasticList = CalculateStochasticOscillator(null, stockDataClass, maType, days);
                var fastDList = stochasticList.Item4;
                var slowDList = stochasticList.Item5;

                int regress = MinOrMax((int)Math.Ceiling((decimal)days / 2));
                turbo = turbo < 0 ? Math.Max(turbo, regress * -1) : Math.Min(turbo, regress);

                tssDList = CalculateLinearRegression(slowDList, stockDataClass, regress + turbo).Item15;
                tssKList = CalculateLinearRegression(fastDList, stockDataClass, regress + turbo).Item15;
                for (int i = 0; i < tssDList.Count; i++)
                {
                    decimal tssD = tssDList.ElementAtOrDefault(i);
                    decimal tssK = tssKList.ElementAtOrDefault(i);
                    decimal prevTssk = i >= 1 ? tssKList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevTssd = i >= 1 ? tssDList.ElementAtOrDefault(i - 1) : 0;

                    var signal = GetRsiSignal(tssK - tssD, prevTssk - prevTssd, tssK, prevTssk, 70, 30);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (tssDList, tssKList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateTurboStochasticsFast(StockData stockDataClass, string maType, int days = 20)
        {
            //input = price, user defined, default is closing price
            //kPeriod = user defined, default is 20
            //dPeriod = user defined, default is 20
            //regress = linear regression period = user defined, default is 10
            //turbo = user defined, default is +2
            //stochK = stochastics slow K, sma = simple moving average
            //index = current bar number

            //fastK = stochK(index, kPeriod, input);
            //fastD = sma(index, kPeriod, fastK);
            //if (turbo lessThan 0) turbo = Math.max(turbo, -regress);
            //if (turbo moreThan 0) turbo = Math.min(turbo, regress);
            //Plot1: tsfK = linRegLine(index, regress, fastK, regress + turbo)[0];
            //Plot2: tsfD = linRegLine(index, regress, fastD, regress + turbo)[0];
            //Signals
            //highSell = tsfK for last sell signal, reset to max_negative at each  buy signal;
            //lowBuy = tsfK for last buy signal, reset to max_positive at each sell signal;
            //sell = crossedBelow(TSFK, TSFD) AND tsfK moreThan topGuide AND(tsfK moreThan highSell);
            //buy = crossedAbove(TSFK, TSFD) AND tsfK lessThan bottGuide AND(tsfK lessThan lowBuy);
            int turbo = 2;
            List<decimal> tsfDList = new();
            List<decimal> tsfKList = new();
            List<Signal> signalsList = new();

            try
            {
                var stochasticList = CalculateStochasticOscillator(null, stockDataClass, maType, days);
                List<decimal> fastDList = stochasticList.Item4;
                List<decimal> fastKList = stochasticList.Item3;

                int regress = MinOrMax((int)Math.Ceiling((decimal)days / 2));
                turbo = turbo < 0 ? Math.Max(turbo, regress * -1) : Math.Min(turbo, regress);

                tsfDList = CalculateLinearRegression(fastDList, stockDataClass, regress + turbo).Item15;
                tsfKList = CalculateLinearRegression(fastKList, stockDataClass, regress + turbo).Item15;
                for (int i = 0; i < tsfDList.Count; i++)
                {
                    decimal tsfD = tsfDList.ElementAtOrDefault(i);
                    decimal tsfK = tsfKList.ElementAtOrDefault(i);
                    decimal prevTsfk = i >= 1 ? tsfKList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevTsfd = i >= 1 ? tsfDList.ElementAtOrDefault(i - 1) : 0;

                    var signal = GetRsiSignal(tsfK - tsfD, prevTsfk - prevTsfd, tsfK, prevTsfk, 70, 30);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (tsfDList, tsfKList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateBollingerBandsAvgTrueRange(StockData stockDataClass, string maType, int days = 22)
        {
            //input = price user defined, default is close
            //atrPeriod = user defined, default is 22
            //bPeriod = user defined, default is 55
            //noStd = number of standard deviations = user defined, default is 2
            //atr = average true range, bb = bollinger bands
            //top= bb[0], bottom=bb[1]
            //index = current bar number

            //atr = atr(index, artPeriod);
            //bb[] = bollingerBands(index, bPeriod, noStd, noStd, input);
            //bbDiff = bb[0] - bb[1];
            //Plot: artDev = atr / bbDiff;
            List<decimal> bbDiffList = new();
            List<decimal> atrDevList = new();
            List<Signal> signalsList = new();

            try
            {
                int bPeriod = MinOrMax((int)Math.Ceiling(days / 0.4));

                var bollingerBands = CalculateBollingerBands(null, stockDataClass, 2, maType, bPeriod);
                List<decimal> emaList = CalculateExponentialMovingAverage(stockDataClass, days).Item1;
                var atrList = CalculateAverageTrueRange(stockDataClass, maType, days).Item1;

                for (int i = 0; i < atrList.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal currentEma = emaList.ElementAtOrDefault(i);
                    decimal currentAtr = atrList.ElementAtOrDefault(i);
                    decimal upperBand = bollingerBands.Item1.ElementAtOrDefault(i);
                    decimal lowerBand = bollingerBands.Item2.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevEma = i >= 1 ? emaList.ElementAtOrDefault(i - 1) : 0;

                    decimal bbDiff = upperBand - lowerBand;
                    bbDiffList.Add(bbDiff);

                    decimal atrDev = bbDiff != 0 ? currentAtr / bbDiff : 0;
                    atrDevList.Add(atrDev);

                    var signal = GetVolatilitySignal(currentValue - currentEma, prevValue - prevEma, atrDev, 0.5m);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (bbDiffList, atrDevList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateFibonacciRetrace(StockData stockDataClass, int days = 15)
        {
            //input = price, user defined, default is closing price
            //method = moving average (ma), user defined, default is WMA
            //period1 = user defined, default is 15
            //period2 = user defined, default is 50
            //retfac = retrace factor, user defined, default is .382

            //Plot1: ma = ma(method, period1, input);
            //highest = highest(period2, HIGH);
            //lowest = lowest(period2, LOW);
            //retrace = (highest - lowest) * retfac;
            //Plot2: hret = highest - retrace;
            //Plot3: lret = lowest + retrace;
            decimal retfac = 0.382m;
            List<decimal> tempHighList = new();
            List<decimal> tempLowList = new();
            List<decimal> retraceList = new();
            List<decimal> hretList = new();
            List<decimal> lretList = new();
            List<Signal> signalsList = new();

            try
            {
                int period1 = days;
                int period2 = MinOrMax((int)Math.Ceiling(period1 / 0.3));

                var wmaList = CalculateWeightedMovingAverage(stockDataClass, period1).Item3;
                var minMaxList = VolumeInputCheck(stockDataClass, period2, true);
                var highestList = minMaxList.Item1;
                var lowestList = minMaxList.Item2;

                for (int i = 0; i < wmaList.Count; i++)
                {
                    decimal wma = wmaList.ElementAtOrDefault(i);
                    decimal highest = highestList.ElementAtOrDefault(i);
                    decimal lowest = lowestList.ElementAtOrDefault(i);
                    decimal prevWma = i >= 1 ? wmaList.ElementAtOrDefault(i - 1) : 0;

                    decimal retrace = (highest - lowest) * retfac;
                    retraceList.Add(retrace);

                    decimal prevHret = hretList.LastOrDefault();
                    decimal hret = highest - retrace;
                    hretList.Add(hret);

                    decimal prevLret = lretList.LastOrDefault();
                    decimal lret = lowest + retrace;
                    lretList.Add(lret);

                    var signal = GetBullishBearishSignal(wma - hret, prevWma - prevHret, wma - lret, prevWma - prevLret);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (retraceList, hretList, lretList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateConstanceBrownCompositeIndex(StockData stockDataClass, string maType, int days = 3)
        {
            //
            // @author LazyBear
            // Code from book "Breakthroughs in Technical Analysis" pg 95. 
            //
            // If you use this code in its orignal/modified form, do drop me a note. 
            // 
            //study(title = "Constance Brown Composite Index [LazyBear]", shorttitle = "CBIDX_LB")
            //src = close
            //rsi_length = input(14, title = "RSI Length")
            //rsi_mom_length = input(9, title = "RSI Momentum Length")
            //rsi_ma_length = input(3, title = "RSI MA Length")
            //ma_length = input(3, title = "SMA Length")
            //fastLength = input(13)
            //slowLength = input(33)

            //r = rsi(src, rsi_length)
            //rsidelta = mom(r, rsi_mom_length)
            //rsisma = sma(rsi(src, rsi_ma_length), ma_length)
            //s = rsidelta + rsisma

            //plot(s, color = red, linewidth = 2)
            //plot(sma(s, fastLength), color = green)
            //plot(sma(s, slowLength), color = orange)
            List<decimal> rsiDeltaList = new();
            List<decimal> rsiSmaList = new();
            List<decimal> sList = new();
            List<decimal> tempList = new();
            List<decimal> sFastSmaList = new();
            List<decimal> sSlowSmaList = new();
            List<decimal> bullSlopeList = new();
            List<decimal> bearSlopeList = new();
            List<Signal> signalsList = new();

            try
            {
                int rsiLength = (int)Math.Ceiling(days / 0.2143);
                int rsiMaLength = days;
                int maLength = days;
                int rsiMomLength = days * 3;
                int fastLength = (int)Math.Ceiling(days / 0.2308);
                int slowLength = (int)Math.Ceiling(days / 0.091);

                var rsi1List = CalculateRelativeStrengthIndex(null, stockDataClass, maType, rsiLength).Item4;
                var rsi2List = CalculateRelativeStrengthIndex(null, stockDataClass, maType, rsiMaLength).Item4;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal r = rsi1List.ElementAtOrDefault(i);

                    decimal rsiDelta = i >= rsiMomLength ? rsi1List.ElementAtOrDefault(i - rsiMomLength) : 0;
                    rsiDeltaList.Add(rsiDelta);

                    decimal rsi2 = rsi2List.ElementAtOrDefault(i);
                    tempList.Add(rsi2);

                    decimal rsiSma = tempList.TakeLast(maLength).Average();
                    rsiSmaList.Add(rsiSma);

                    decimal s = rsiDelta + rsiSma;
                    sList.Add(s);

                    decimal sFastSma = sList.TakeLast(fastLength).Average();
                    sFastSmaList.Add(sFastSma);

                    decimal sSlowSma = sList.TakeLast(slowLength).Average();
                    sSlowSmaList.Add(sSlowSma);

                    decimal prevBullSlope = bullSlopeList.LastOrDefault();
                    decimal bullSlope = s - Math.Max(sFastSma, sSlowSma);
                    bullSlopeList.Add(bullSlope);

                    decimal prevBearSlope = bearSlopeList.LastOrDefault();
                    decimal bearSlope = s - Math.Min(sFastSma, sSlowSma);
                    bearSlopeList.Add(bearSlope);

                    var signal = GetBullishBearishSignal(bullSlope, prevBullSlope, bearSlope, prevBearSlope);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (rsiDeltaList, rsiSmaList, sList, sFastSmaList, sSlowSmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateConnorsRelativeStrengthIndex(StockData stockDataClass, string maType, int days = 2)
        {
            //@version=3
            // Copyright (c) 2017-present, Alex Orekhov (everget)
            // Stochastic Connors RSI indicator script may be freely distributed under the MIT license.
            //study(title = "Stochastic Connors RSI", shorttitle = "Stoch CRSI")

            //stochLength = input(title = "Stochastic Length", type = integer, defval = 3, minval = 1)
            //smoothK = input(title = "K", type = integer, defval = 3, minval = 1, maxval = 10000)
            //smoothD = input(title = "D", type = integer, defval = 3, minval = 1, maxval = 10000)

            //rsiLength = input(title = "RSI Length", type = integer, defval = 3, minval = 1)
            //updownLength = input(title = "Updown RSI Length", type = integer, defval = 2, minval = 1)
            //rocLength = input(title = "ROC Length", type = integer, defval = 100, minval = 1)
            //src = input(title = "RSI Source", type = source, defval = close)

            //updown = 0
            //updown_calc(s, ud) =>
            //    newupdown = 0
            //    if s > s[1]
            //        newupdown:= nz(ud[1]) >= 0 ? nz(ud[1]) + 1 : 1
            //    else
            //        if s < s[1]
            //            newupdown:= nz(ud[1]) <= 0 ? nz(ud[1]) - 1 : -1
            //        else
            //            newupdown:= 0

            //updown:= updown_calc(src, updown)

            //updownrsi = rsi(updown, updownLength)

            //rsi = rsi(src, rsiLength)

            //percentrank = percentrank(roc(src, 1), rocLength)

            //crsi = avg(rsi, updownrsi, percentrank)

            //stochcalc = stoch(crsi, crsi, crsi, stochLength)

            //band1 = hline(80, color = gray, linestyle = dashed)
            //band2 = hline(20, color = gray, linestyle = dashed)
            //fill(band1, band2, color =#f9cb9c0f)

            //band3 = hline(70, color = gray, linestyle = dashed)
            //band4 = hline(30, color = gray, linestyle = dashed)
            //fill(band3, band4, color =#de9ba6)

            //smaK = sma(stochcalc, smoothK)
            //smaD = sma(smaK, smoothD)

            //plot(smaK, title = "K", color =#0094ff)
            //plot(smaD, title = "D", color =#ff6a00)
            List<decimal> streakList = new();
            List<decimal> tempList = new();
            List<decimal> pctReturnList = new();
            List<decimal> pctRankList = new();
            List<decimal> rsiStreakList = new();
            List<decimal> connorsRsiList = new();
            List<decimal> connorsRsiSignalList = new();
            List<Signal> signalsList = new();

            try
            {
                int rsiUpDownLength = (int)Math.Ceiling(days / 0.6667);
                int rocLength = days * 50;
                int upDownLength = days;
                int length = MinOrMax((int)Math.Ceiling((decimal)days / 2));

                List<decimal> rsiList = CalculateRelativeStrengthIndex(null, stockDataClass, maType, rsiUpDownLength).Item4;
                List<decimal> rocList = CalculateRateOfChange(null, stockDataClass, length).Item1;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal roc = rocList.ElementAtOrDefault(i);
                    tempList.Add(roc);

                    var lookBackList = tempList.TakeLast(rocLength).Take(rocLength - 1).ToList();
                    int count = lookBackList.Where(x => x <= roc).Count();
                    decimal pctRank = MinOrMax((decimal)count / rocLength * 100, 100, 0);
                    pctRankList.Add(pctRank);

                    decimal prevStreak = streakList.LastOrDefault();
                    decimal streak = currentValue > prevValue ? prevStreak >= 0 ? prevStreak + 1 : 1 : currentValue < prevValue ? prevStreak <= 0 ? prevStreak - 1 : -1 : 0;
                    streakList.Add(streak);
                }

                rsiStreakList = CalculateRelativeStrengthIndex(streakList, stockDataClass, maType, upDownLength).Item4;
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal currentRsi = rsiList.ElementAtOrDefault(j);
                    decimal percentRank = pctRankList.ElementAtOrDefault(j);
                    decimal streakRsi = rsiStreakList.ElementAtOrDefault(j);

                    decimal prevConnorsRsi = connorsRsiList.LastOrDefault();
                    decimal connorsRsi = MinOrMax((currentRsi + percentRank + streakRsi) / 3, 100, 0);
                    connorsRsiList.Add(connorsRsi);

                    decimal prevConnorsRsiEma = connorsRsiSignalList.LastOrDefault();
                    decimal connorsRsiEma = CalculateExponentialMovingAverage(connorsRsi, prevConnorsRsiEma, rsiUpDownLength);
                    connorsRsiSignalList.Add(connorsRsiEma);

                    var signal = GetRsiSignal(connorsRsi - connorsRsiEma, prevConnorsRsi - prevConnorsRsiEma, connorsRsi, prevConnorsRsi, 70, 30);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (streakList, pctRankList, rsiStreakList, connorsRsiList, connorsRsiSignalList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateStochasticConnorsRelativeStrengthIndex(StockData stockDataClass, string maType, int days = 3)
        {
            //@version=3
            // Copyright (c) 2017-present, Alex Orekhov (everget)
            // Stochastic Connors RSI indicator script may be freely distributed under the MIT license.
            //study(title = "Stochastic Connors RSI", shorttitle = "Stoch CRSI")

            //stochLength = input(title = "Stochastic Length", type = integer, defval = 3, minval = 1)
            //smoothK = input(title = "K", type = integer, defval = 3, minval = 1, maxval = 10000)
            //smoothD = input(title = "D", type = integer, defval = 3, minval = 1, maxval = 10000)

            //rsiLength = input(title = "RSI Length", type = integer, defval = 3, minval = 1)
            //updownLength = input(title = "Updown RSI Length", type = integer, defval = 2, minval = 1)
            //rocLength = input(title = "ROC Length", type = integer, defval = 100, minval = 1)
            //src = input(title = "RSI Source", type = source, defval = close)

            //updown = 0
            //updown_calc(s, ud) =>
            //    newupdown = 0
            //    if s > s[1]
            //        newupdown:= nz(ud[1]) >= 0 ? nz(ud[1]) + 1 : 1
            //    else
            //        if s < s[1]
            //            newupdown:= nz(ud[1]) <= 0 ? nz(ud[1]) - 1 : -1
            //        else
            //            newupdown:= 0

            //updown:= updown_calc(src, updown)

            //updownrsi = rsi(updown, updownLength)

            //rsi = rsi(src, rsiLength)

            //percentrank = percentrank(roc(src, 1), rocLength)

            //crsi = avg(rsi, updownrsi, percentrank)

            //stochcalc = stoch(crsi, crsi, crsi, stochLength)

            //band1 = hline(80, color = gray, linestyle = dashed)
            //band2 = hline(20, color = gray, linestyle = dashed)
            //fill(band1, band2, color =#f9cb9c0f)

            //band3 = hline(70, color = gray, linestyle = dashed)
            //band4 = hline(30, color = gray, linestyle = dashed)
            //fill(band3, band4, color =#de9ba6)

            //smaK = sma(stochcalc, smoothK)
            //smaD = sma(smaK, smoothD)

            //plot(smaK, title = "K", color =#0094ff)
            //plot(smaD, title = "D", color =#ff6a00)
            List<decimal> highestRsiList = new();
            List<decimal> lowestRsiList = new();
            List<decimal> stochasticList = new();
            List<decimal> smaKList = new();
            List<decimal> smaDList = new();
            List<Signal> signalsList = new();

            try
            {
                var connorsRsiList = CalculateConnorsRelativeStrengthIndex(stockDataClass, maType, days).Item4;
                var minMaxList = GetMaxAndMinValuesList(connorsRsiList, days);
                highestRsiList = minMaxList.Item1;
                lowestRsiList = minMaxList.Item2;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal crsi = connorsRsiList.ElementAtOrDefault(i);
                    decimal highestRsi = highestRsiList.ElementAtOrDefault(i);
                    decimal lowestRsi = lowestRsiList.ElementAtOrDefault(i);

                    decimal stochastic = highestRsi - lowestRsi != 0 ? MinOrMax(100 * (crsi - lowestRsi) / (highestRsi - lowestRsi), 100, 0) : 0;
                    stochasticList.Add(stochastic);

                    decimal prevSmak = smaKList.LastOrDefault();
                    decimal smaK = stochasticList.TakeLast(days).Average();
                    smaKList.Add(smaK);

                    decimal prevSmad = smaDList.LastOrDefault();
                    decimal smaD = smaKList.TakeLast(days).Average();
                    smaDList.Add(smaD);

                    var signal = GetRsiSignal(smaK - smaD, prevSmak - prevSmad, smaK, prevSmak, 70, 30);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (highestRsiList, lowestRsiList, stochasticList, smaKList, smaDList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateTickLineMomentumOscillator(StockData stockDataClass, string maType, int days = 10)
        {
            //@version=3
            // Copyright (c) 2018-present, Alex Orekhov (everget)
            // Tick Line Momentum Oscillator indicator script may be freely distributed under the MIT license.
            //study("Tick Line Momentum Oscillator", shorttitle = "TLMO")

            //cumoMALength = input(title = "Cumo MA Length", type = integer, defval = 10, minval = 1)
            //cumoMAInput = input(title = "Cumo MA", defval = "EMA", options =["EMA", "SMA", "VWMA", "WMA"])
            //rocLength = input(title = "ROC Length", type = integer, defval = 5, minval = 1)
            //smoothingLength = input(title = "Smoothing Length", type = integer, defval = 5, minval = 1)
            //smoothingMAInput = input(title = "Smoothing MA", defval = "EMA", options =["EMA", "SMA", "VWMA", "WMA"])
            //obosLevel = input(title = "Overbought / Oversold Level", type = integer, defval = 5, minval = 1)
            //src = input(title = "Source", type = source, defval = close)

            //cumoMA = iff(cumoMAInput == "EMA", ema(src, cumoMALength),
            //     iff(cumoMAInput == "SMA", sma(src, cumoMALength),
            //     iff(cumoMAInput == "VWMA", vwma(src, cumoMALength),
            //     iff(cumoMAInput == "WMA", wma(src, cumoMALength),
            //     na))))

            //cumoExpression = src > nz(cumoMA[1]) ? 1 : src < nz(cumoMA[1]) ? -1 : 0

            //tlmo = iff(smoothingMAInput == "EMA", ema(roc(cum(cumoExpression), rocLength), smoothingLength),
            //     iff(smoothingMAInput == "SMA", sma(roc(cum(cumoExpression), rocLength), smoothingLength),
            //     iff(smoothingMAInput == "VWMA", vwma(roc(cum(cumoExpression), rocLength), smoothingLength),
            //     iff(smoothingMAInput == "WMA", wma(roc(cum(cumoExpression), rocLength), smoothingLength),
            //     na))))

            //tlmoColor = tlmo > obosLevel ? #0ebb23 : tlmo < -obosLevel ? #ff0000 : #674ea7
            //plot(tlmo, title = "TLMO", linewidth = 2, color = tlmoColor, transp = 0)

            //hline(obosLevel, title = "Overbought", linestyle = dotted, color =#0ebb23)
            //hline(0, title = "Zero Level", linestyle = solid, color =#f6b26b)
            //hline(-1 * obosLevel, title = "Oversold", linestyle = dotted, color =#ff0000)
            List<decimal> cumoList = new();
            List<decimal> cumoSumList = new();
            List<decimal> rocList = new();
            List<decimal> tlmoList = new();
            List<Signal> signalsList = new();

            try
            {
                int rocLength = MinOrMax((int)Math.Ceiling((decimal)days / 2));

                List<decimal> maList = GetMovingAverageList(maType, null, stockDataClass, days);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevMa = i >= 1 ? maList.ElementAtOrDefault(i - 1) : 0;

                    decimal cumo = currentValue > prevMa ? 1 : currentValue < prevMa ? -1 : 0;
                    cumoList.Add(cumo);

                    decimal cumoSum = cumoList.Sum();
                    cumoSumList.Add(cumoSum);
                }

                rocList = CalculateRateOfChange(cumoSumList, stockDataClass, rocLength).Item1;
                tlmoList = GetMovingAverageList(maType, rocList, stockDataClass, rocLength);
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal tlmo = tlmoList.ElementAtOrDefault(j);
                    decimal prevTlmo1 = j >= 1 ? tlmoList.ElementAtOrDefault(j - 1) : 0;
                    decimal prevTlmo2 = j >= 2 ? tlmoList.ElementAtOrDefault(j - 2) : 0;

                    var signal = GetRsiSignal(tlmo - prevTlmo1, prevTlmo1 - prevTlmo2, tlmo, prevTlmo1, 5, -5);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (cumoList, cumoSumList, rocList, tlmoList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateSmoothedRateOfChange(StockData stockDataClass, int days = 13)
        {
            //@version=3
            // Copyright (c) 2018-present, Alex Orekhov (everget)
            // Smoothed Rate of Change script may be freely distributed under the MIT license.
            //study("Smoothed Rate of Change", shorttitle = "SROC")

            //rocLength = input(title = "ROC Length", type = integer, minval = 1, defval = 21)
            //smoothingLength = input(title = "Smoothing Length", type = integer, minval = 1, defval = 13)
            //src = input(title = "Source", type = source, defval = close)

            //ma = ema(src, smoothingLength)
            //mom = change(ma, rocLength)

            //sroc = nz(ma[rocLength]) == 0
            //     ? 100
            //     : mom == 0
            //         ? 0
            //         : 100 * mom / ma[rocLength]

            //srocColor = sroc >= 0 ? #0ebb23 : red

            //plot(sroc, title = "SROC", linewidth = 2, color = srocColor, transp = 0)

            //hline(0, title = "Zero Level", linestyle = dotted, color =#989898)
            List<decimal> momList = new();
            List<decimal> srocList = new();
            List<Signal> signalsList = new();

            try
            {
                int rocLength = (int)Math.Ceiling(days / 0.62);
                int smoothingLength = days;

                List<decimal> maList = CalculateExponentialMovingAverage(stockDataClass, smoothingLength).Item1;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentMa = maList.ElementAtOrDefault(i);
                    decimal prevMa = i >= rocLength ? maList.ElementAtOrDefault(i - rocLength) : 0;

                    decimal mom = currentMa - prevMa;
                    momList.Add(mom);

                    decimal prevSroc = srocList.LastOrDefault();
                    decimal sroc = prevMa != 0 ? 100 * mom / prevMa : 100;
                    srocList.Add(sroc);

                    var signal = GetCompareSignal(sroc, prevSroc);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (momList, srocList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculatePriceMomentumOscillator(StockData stockDataClass, string maType, int days = 10)
        {
            //@version=3
            // Copyright (c) 2018-present, Alex Orekhov (everget)
            // Price Momentum Oscillator script may be freely distributed under the MIT license.
            //study("Price Momentum Oscillator", shorttitle = "PMO")

            //firstLength = input(title = "1st Smoothing Length", type = integer, defval = 35)
            //secondLength = input(title = "2nd Smoothing Length", type = integer, defval = 20)
            //signalLength = input(title = "Signal Length", type = integer, defval = 10)
            //src = input(title = "Source", type = source, defval = close)
            //highlightCrossovers = input(title = "Highlight PMO/Signal Crossovers ?", type = bool, defval = false)
            //highlightZeroCrossovers = input(title = "Highlight Zero Line Crossovers ?", type = bool, defval = false)
            //applyFilling = input(title = "Apply Ribbon Filling ?", type = bool, defval = false)

            //pmo = ema(10 * ema(nz(roc(src, 1)), firstLength), secondLength)
            //signal = ema(pmo, signalLength)

            //trendColor = pmo > signal ? #0ebb23 : red

            //pmoColor = applyFilling ? trendColor : #0094ff
            //signalColor = applyFilling ? trendColor : #ff6a00

            //pmoPlot = plot(pmo, title = "PMO", color = pmoColor, transp = 0)
            //signalPlot = plot(signal, title = "Signal", color = signalColor, transp = 0)
            //hline(0, title = "Zero Line", linestyle = dotted)

            //transparent = color(white, 100)

            //fillColor = applyFilling ? trendColor : transparent
            //fill(pmoPlot, signalPlot, color = fillColor, transp = 70)

            //zeroCrossBgColor = highlightZeroCrossovers ? (pmo > 0 ? green : red) : transparent
            //bgcolor(zeroCrossBgColor, transp = 90)

            //plotshape(crossover(pmo, signal) and highlightCrossovers ? pmo : na, title = "Crossover", location = location.absolute, style = shape.circle, size = size.tiny, color = green, transp = 0)
            //plotshape(crossunder(pmo, signal) and highlightCrossovers ? pmo : na, title = "Crossunder", location = location.absolute, style = shape.circle, size = size.tiny, color = red, transp = 0)
            List<decimal> pmoList = new();
            List<decimal> pmoValueList = new();
            List<decimal> pmoSignalList = new();
            List<Signal> signalsList = new();

            try
            {
                int signalLength = days;
                int secondLength = signalLength * 2;
                int firstLength = (int)Math.Ceiling(signalLength / 0.2858);

                List<decimal> rocList = CalculateRateOfChange(null, stockDataClass, 1).Item1;
                List<decimal> rocEma1List = GetMovingAverageList(maType, rocList, stockDataClass, firstLength);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal rocEma1 = rocEma1List.ElementAtOrDefault(i);

                    decimal pmoValue = rocEma1 * 10;
                    pmoValueList.Add(pmoValue);
                }

                pmoList = GetMovingAverageList(maType, pmoValueList, stockDataClass, secondLength);
                pmoSignalList = GetMovingAverageList(maType, pmoList, stockDataClass, signalLength);
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal pmo = pmoList.ElementAtOrDefault(j);
                    decimal prevPmo = j >= 1 ? pmoList.ElementAtOrDefault(j - 1) : 0;
                    decimal pmoSignal = pmoSignalList.ElementAtOrDefault(j);
                    decimal prevPmoSignal = j >= 1 ? pmoSignalList.ElementAtOrDefault(j - 1) : 0;

                    var signal = GetCompareSignal(pmo - pmoSignal, prevPmo - prevPmoSignal);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (pmoValueList, pmoList, pmoSignalList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<Signal>) CalculateSqueezeMomentumIndicator(StockData stockDataClass, string maType, int days = 20)
        {
            //
            // @author LazyBear
            // List of all my indicators:
            // https://docs.google.com/document/d/15AGCufJZ8CIUvwFJ9W-IKns88gkWOKBCvByMEvm5MLo/edit?usp=sharing
            // v2 - fixed a typo, where BB multipler was always stuck at 1.5. [Thanks @ucsgears]
            //
            //study(shorttitle = "SQZMOM_LB", title = "Squeeze Momentum Indicator [LazyBear]", overlay = false)
            //length = input(20, title = "BB Length")
            //mult = input(2.0, title = "BB MultFactor")
            //lengthKC = input(20, title = "KC Length")
            //multKC = input(1.5, title = "KC MultFactor")
            //useTrueRange = input(true, title = "Use TrueRange (KC)", type = bool)

            // Calculate BB
            //source = close
            //basis = sma(source, length)
            //dev = mult * stdev(source, length)
            //upperBB = basis + dev
            //lowerBB = basis - dev

            // Calculate KC
            //ma = sma(source, lengthKC)
            //range = useTrueRange ? tr : (high - low)
            //rangema = sma(range, lengthKC)
            //upperKC = ma + rangema * multKC
            //lowerKC = ma - rangema * multKC

            //sqzOn = (lowerBB > lowerKC) and(upperBB < upperKC)
            //sqzOff = (lowerBB < lowerKC) and(upperBB > upperKC)
            //noSqz = (sqzOn == false) and(sqzOff == false)

            //val = linreg(source - avg(avg(highest(high, lengthKC), lowest(low, lengthKC)), sma(close, lengthKC)),lengthKC, 0)

            //bcolor = iff(val > 0,
            //iff(val > nz(val[1]), lime, green),
            //iff(val < nz(val[1]), red, maroon))
            //scolor = noSqz ? blue : sqzOn ? black : gray
            //plot(val, color = bcolor, style = histogram, linewidth = 4)
            //plot(0, color = scolor, style = cross, linewidth = 2)
            List<decimal> midpriceSmaAvgList = new();
            List<decimal> diffList = new();
            List<decimal> slopeList = new();
            List<decimal> interceptList = new();
            List<decimal> predictedTodayList = new();
            List<decimal> predictedNextDayList = new();
            List<decimal> stdErrorList = new();
            List<Signal> signalsList = new();

            try
            {
                List<decimal> midpriceList = CalculateMidprice(stockDataClass, days).Item2;
                List<decimal> smaList = GetMovingAverageList(maType, null, stockDataClass, days);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal midprice = midpriceList.ElementAtOrDefault(i);
                    decimal sma = smaList.ElementAtOrDefault(i);

                    decimal midpriceSmaAvg = (midprice + sma) / 2;
                    midpriceSmaAvgList.Add(midpriceSmaAvg);

                    decimal diff = currentValue - midpriceSmaAvg;
                    diffList.Add(diff);
                }

                var linreg = CalculateLinearRegression(diffList, stockDataClass, days);
                slopeList = linreg.Item11;
                interceptList = linreg.Item14;
                predictedTodayList = linreg.Item15;
                predictedNextDayList = linreg.Item16;
                stdErrorList = linreg.Item17;
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(j);
                    decimal predictedToday = predictedTodayList.ElementAtOrDefault(j);
                    decimal prevPredictedToday = j >= 1 ? predictedTodayList.ElementAtOrDefault(j - 1) : 0;
                    decimal predictedNextDay = predictedNextDayList.ElementAtOrDefault(j);

                    var signal = GetCompareSignal(predictedToday, prevPredictedToday);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (midpriceSmaAvgList, diffList, slopeList, interceptList, predictedTodayList, predictedNextDayList, stdErrorList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateWilsonRelativePriceChannel(StockData stockDataClass, string maType, int days = 1)
        {
            //study(title = "Wilson Relative Price Channel", overlay = true)
            //periods = input(34)
            //smoothing = input(1)
            //overbought = input(70)
            //oversold = input(30)
            //upperNeutralZone = input(55)
            //lowerNeutralZone = input(45)
            //RSI = rsi(close, periods)

            //OB = (ema(RSI - overbought, smoothing))
            //OS = (ema(RSI - oversold, smoothing))
            //NZU = (ema(RSI - upperNeutralZone, smoothing))
            //NZL = (ema(RSI - lowerNeutralZone, smoothing))

            //s1 = plot(close - (close * (OS / 100)), color = gray)
            //u1 = plot(close - (close * (OB / 100)), color = gray)
            //u2 = plot(close - (close * (NZU / 100)), color = gray)
            //s2 = plot(close - (close * (NZL / 100)), color = gray)

            //fill(u1, u2, color = lime)
            //fill(s1, s2, color = red)
            List<decimal> rsiOverboughtList = new();
            List<decimal> rsiOversoldList = new();
            List<decimal> rsiUpperNeutralZoneList = new();
            List<decimal> rsiLowerNeutralZoneList = new();
            List<decimal> obList = new();
            List<decimal> osList = new();
            List<decimal> nzuList = new();
            List<decimal> nzlList = new();
            List<decimal> s1List = new();
            List<decimal> s2List = new();
            List<decimal> u1List = new();
            List<decimal> u2List = new();
            List<Signal> signalsList = new();

            try
            {
                int smoothing = days;
                int period = (int)Math.Ceiling(days / 0.0295);
                decimal overbought = 70, oversold = 30, upperNeutralZone = 55, lowerNeutralZone = 45;

                List<decimal> rsiList = CalculateRelativeStrengthIndex(null, stockDataClass, maType, period).Item4;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal rsi = rsiList.ElementAtOrDefault(i);

                    decimal rsiOverbought = rsi - overbought;
                    rsiOverboughtList.Add(rsiOverbought);

                    decimal rsiOversold = rsi - oversold;
                    rsiOversoldList.Add(rsiOversold);

                    decimal rsiUpperNeutralZone = rsi - upperNeutralZone;
                    rsiUpperNeutralZoneList.Add(rsiUpperNeutralZone);

                    decimal rsiLowerNeutralZone = rsi - lowerNeutralZone;
                    rsiLowerNeutralZoneList.Add(rsiLowerNeutralZone);
                }
                obList = GetMovingAverageList(maType, rsiOverboughtList, stockDataClass, smoothing);
                osList = GetMovingAverageList(maType, rsiOversoldList, stockDataClass, smoothing);
                nzuList = GetMovingAverageList(maType, rsiUpperNeutralZoneList, stockDataClass, smoothing);
                nzlList = GetMovingAverageList(maType, rsiLowerNeutralZoneList, stockDataClass, smoothing);

                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(j);
                    decimal ob = obList.ElementAtOrDefault(j);
                    decimal os = osList.ElementAtOrDefault(j);
                    decimal nzu = nzuList.ElementAtOrDefault(j);
                    decimal nzl = nzlList.ElementAtOrDefault(j);
                    decimal prevValue = j >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(j - 1) : 0;

                    decimal prevS1 = s1List.LastOrDefault();
                    decimal s1 = currentValue - (currentValue * os / 100);
                    s1List.Add(s1);

                    decimal prevU1 = u1List.LastOrDefault();
                    decimal u1 = currentValue - (currentValue * ob / 100);
                    u1List.Add(u1);

                    decimal prevU2 = u2List.LastOrDefault();
                    decimal u2 = currentValue - (currentValue * nzu / 100);
                    u2List.Add(u2);

                    decimal prevS2 = s2List.LastOrDefault();
                    decimal s2 = currentValue - (currentValue * nzl / 100);
                    s2List.Add(s2);

                    var signal = GetBullishBearishSignal(currentValue - Math.Min(u1, u2), prevValue - Math.Min(prevU1, prevU2), currentValue - Math.Max(s1, s2), prevValue - Math.Max(prevS1, prevS2));
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (rsiOverboughtList, rsiOversoldList, rsiUpperNeutralZoneList, rsiLowerNeutralZoneList, obList, osList, nzuList, nzlList, s1List, u1List, s2List, u2List, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateChopZone(StockData stockDataClass, string maType, int days = 30)
        {
            //@version=4
            //study(title = "Chop Zone", format = format.price, precision = 0)

            //colorTurquoise = #34dddd
            //colorDarkGreen = #006400
            //colorPaleGreen = #98fb98
            //colorLime = color.lime
            //colorDarkRed = #8B0000
            //colorRed = color.red
            //colorOrange = color.orange
            //colorLightOrange = #ffc04c
            //colorYellow = color.yellow

            //source = close
            //avg = hlc3

            //pi = atan(1) * 4
            //periods = 30
            //highestHigh = highest(periods)
            //lowestLow = lowest(periods)
            //range = 25 / (highestHigh - lowestLow) * lowestLow

            //ema34 = ema(source, 34)
            //x1_ema34 = 0
            //x2_ema34 = 1
            //y1_ema34 = 0
            //y2_ema34 = (ema34[1] - ema34) / avg * range
            //c_ema34 = sqrt((x2_ema34 - x1_ema34) * (x2_ema34 - x1_ema34) + (y2_ema34 - y1_ema34) * (y2_ema34 - y1_ema34))
            //emaAngle_1 = round(180 * acos((x2_ema34 - x1_ema34) / c_ema34) / pi)
            //emaAngle = iff(y2_ema34 > 0, -emaAngle_1, emaAngle_1)

            //chopZoneColor = emaAngle >= 5 ? colorTurquoise : emaAngle < 5 and emaAngle >= 3.57 ? colorDarkGreen : emaAngle < 3.57 and emaAngle >= 2.14 ? colorPaleGreen : emaAngle < 2.14 and emaAngle >= .71 ? colorLime : emaAngle <= -1 * 5 ? colorDarkRed : emaAngle > -1 * 5 and emaAngle <= -1 * 3.57 ? colorRed : emaAngle > -1 * 3.57 and emaAngle <= -1 * 2.14 ? colorOrange : emaAngle > -1 * 2.14 and emaAngle <= -1 * .71 ? colorLightOrange : colorYellow

            //plot(1, color = chopZoneColor, style = plot.style_columns)
            List<decimal> rangeList = new();
            List<decimal> emaAngle1List = new();
            List<decimal> emaAngleList = new();
            List<decimal> yList = new();
            List<decimal> cList = new();
            List<decimal> avgList = new();
            List<Signal> signalsList = new();

            try
            {
                int emaPeriod = (int)Math.Ceiling(days / 0.8824);

                var emaList = GetMovingAverageList(maType, null, stockDataClass, emaPeriod);
                var list = VolumeInputCheck(stockDataClass, days, false);
                var highList = list.Item1;
                var lowList = list.Item2;
                var minMaxList = GetMaxAndMinValuesList(highList, lowList, days);
                var highestList = minMaxList.Item1;
                var lowestList = minMaxList.Item2;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal highest = highestList.ElementAtOrDefault(i);
                    decimal lowest = lowestList.ElementAtOrDefault(i);
                    decimal high = highList.ElementAtOrDefault(i);
                    decimal low = lowList.ElementAtOrDefault(i);
                    decimal ema = emaList.ElementAtOrDefault(i);
                    decimal prevEma = i >= 1 ? emaList.ElementAtOrDefault(i - 1) : 0;

                    decimal range = highest - lowest != 0 ? 25 / (highest - lowest) * lowest : 0;
                    rangeList.Add(range);

                    decimal avg = (currentValue + high + low) / 3;
                    avgList.Add(avg);

                    decimal y = avg != 0 && range != 0 ? (prevEma - ema) / avg * range : 0;
                    yList.Add(y);

                    decimal c = 1 + (y * y);
                    cList.Add(c);

                    decimal emaAngle1 = c != 0 ? (decimal)Math.Round(180 * Math.Acos(1 / (double)c) / Math.PI) : 0;
                    emaAngle1List.Add(emaAngle1);

                    decimal prevEmaAngle = emaAngleList.LastOrDefault();
                    decimal emaAngle = y > 0 ? -emaAngle1 : emaAngle1;
                    emaAngleList.Add(emaAngle);

                    var signal = GetCompareSignal(emaAngle - 5, prevEmaAngle - 5);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (rangeList, avgList, yList, cList, emaAngle1List, emaAngleList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateScalpersChannel(StockData stockDataClass, string maType, int days = 15)
        {
            //
            // @author LazyBear
            // @credits http://freethinkscript.blogspot.com/2009/05/only-scalpers-channel-that-you-will.html
            //
            //study(title = "Scalper's Channel [LazyBear]", shorttitle = "weak_volume_dependency [LB]", overlay = true)
            //length = input(20)
            //factor = input(15)
            //pi = atan(1) * 4
            //Average(x, y) => (sum(x, y) / y)
            //scalper_line = plot(Average(close, factor) - log(pi * (atr(factor))), color = blue, linewidth = 3)
            //hi = plot(highest(length), color = fuchsia)
            //lo = plot(lowest(length), color = fuchsia)
            //add this for strategy
            //short1 = cross(high, hi1)
            //long1 = cross(low, lo1)
            //if (long1)
            //strategy.entry(id = "Long", long = true, when = long1)
            //strategy.exit("Long TP", from_entry = "Long", profit = 250, stop = 250)
            //if (short1)
            //strategy.entry(id = "Short", long = false, when = short1)
            //strategy.exit("Short TP", from_entry = "Short", profit = 250, stop = 250)
            List<decimal> scalperList = new();
            List<decimal> scalperHighList = new();
            List<decimal> scalperLowList = new();
            List<Signal> signalsList = new();

            try
            {
                decimal pi = (decimal)Math.PI;
                int length = MinOrMax((int)Math.Ceiling(days / 0.75));

                List<decimal> smaList = GetMovingAverageList(maType, null, stockDataClass, days);
                var atrList = CalculateAverageTrueRange(stockDataClass, maType, days).Item1;

                for (int i = 0; i < smaList.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal currentSma = smaList.ElementAtOrDefault(i);
                    decimal currentAtr = atrList.ElementAtOrDefault(i);

                    decimal prevScalper = scalperList.LastOrDefault();
                    decimal scalper = pi * currentAtr > 0 ? currentSma - (decimal)Log((double)(pi * currentAtr)) : currentSma;
                    scalperList.Add(scalper);

                    var lbList = scalperList.TakeLast(length).ToList();
                    decimal highestScalper = lbList.Max();
                    scalperHighList.Add(highestScalper);

                    decimal lowestScalper = lbList.Min();
                    scalperLowList.Add(lowestScalper);

                    var signal = GetCompareSignal(currentValue - scalper, prevValue - prevScalper);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (scalperList, scalperHighList, scalperLowList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateTTMScalperIndicator(StockData stockDataClass)
        {
            //@version=2
            ////////////////////////////////////////////////////////////
            //  Copyright by HPotter v2.0 05/01/2017
            // TTM scalper indicator of John Carter’s Scalper Buys and Sells. The methodology 
            // is a close approximation of the one described in his book Mastering the Trade. 
            // The book is highly recommended. Note the squares are not real-time but will 
            // show up once the third bar has confirmed a reversal. 
            //
            // WARNING:
            // - This script to change bars colors.
            ////////////////////////////////////////////////////////////
            //study(title = "TTM scalper indicator", overlay = true)
            //width = input(14, minval = 1)
            //triggerSell = iff(iff(close[1] < close, 1, 0) and(close[2] < close[1] or close[3] < close[1]), 1, 0)
            //triggerBuy = iff(iff(close[1] > close, 1, 0) and(close[2] > close[1] or close[3] > close[1]), 1, 0)
            //buySellSwitch = iff(triggerSell, 1, iff(triggerBuy, 0, nz(buySellSwitch[1])))
            //SBS = iff(triggerSell and buySellSwitch[1] == false, high, iff(triggerBuy and buySellSwitch[1], low, nz(SBS[1])))
            //clr_s = iff(triggerSell and buySellSwitch[1] == false, 1, iff(triggerBuy and buySellSwitch[1], 0, nz(clr_s[1])))
            //clr = iff(clr_s == 0, red, green)
            //pos = iff(clr == green, 1,
            //       iff(clr == red, -1, nz(pos[1], 0)))
            //barcolor(pos == -1 ? red : pos == 1 ? green : blue)
            //plot(SBS, color = clr, title = "TTM", style = circles, linewidth = 2)
            List<decimal> triggerSellList = new();
            List<decimal> triggerBuyList = new();
            List<decimal> buySellSwitchList = new();
            List<decimal> sbsList = new();
            List<decimal> clrsList = new();
            List<Signal> signalsList = new();

            try
            {
                var minMaxList = VolumeInputCheck(stockDataClass, 0, false);
                var highList = minMaxList.Item1;
                var lowList = minMaxList.Item2;

                for (int i = 0; i < stockDataClass.ClosePrices.Count; i++)
                {
                    decimal close = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevClose1 = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevClose2 = i >= 2 ? stockDataClass.InputValues.ElementAtOrDefault(i - 2) : 0;
                    decimal prevClose3 = i >= 3 ? stockDataClass.InputValues.ElementAtOrDefault(i - 3) : 0;
                    decimal high = highList.ElementAtOrDefault(i);
                    decimal low = lowList.ElementAtOrDefault(i);

                    decimal triggerSell = prevClose1 < close && (prevClose2 < prevClose1 || prevClose3 < prevClose1) ? 1 : 0;
                    triggerSellList.Add(triggerSell);

                    decimal triggerBuy = prevClose1 > close && (prevClose2 > prevClose1 || prevClose3 > prevClose1) ? 1 : 0;
                    triggerBuyList.Add(triggerBuy);

                    decimal prevBuySellSwitch = buySellSwitchList.LastOrDefault();
                    decimal buySellSwitch = triggerSell == 1 ? 1 : triggerBuy == 1 ? 0 : prevBuySellSwitch;
                    buySellSwitchList.Add(buySellSwitch);

                    decimal sbs = triggerSell == 1 && prevBuySellSwitch == 0 ? high : triggerBuy == 1 && prevBuySellSwitch == 1 ? low : sbsList.LastOrDefault();
                    sbsList.Add(sbs);

                    decimal prevClrs = clrsList.LastOrDefault();
                    decimal clrs = triggerSell == 1 && prevBuySellSwitch == 0 ? 1 : triggerBuy == 1 && prevBuySellSwitch == 1 ? -1 : clrsList.LastOrDefault();
                    clrsList.Add(clrs);

                    var signal = GetCompareSignal(clrs, prevClrs);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (triggerSellList, triggerBuyList, buySellSwitchList, sbsList, clrsList, signalsList);
        }

        public static (List<decimal>, List<Signal>) CalculateTFSTetherLineIndicator(StockData stockDataClass, int days = 50)
        {
            ////////////////////////////////////////////////////////////
            //  Copyright by HPotter v1.0 16/05/2014
            // Tether line indicator is the first component of TFS trading strategy.
            // It was named this way because stock prices have a tendency to cluster
            // around it. It means that stock prices tend to move away from the midpoint
            // between their 50-day highs and lows, then return to that midpoint at some
            // time in the future. On a chart, it appears as though the stock price is
            // tethered to this line, and hence the name.
            ////////////////////////////////////////////////////////////
            //study(title = "TFS: Tether Line", shorttitle = "Tether Line", overlay = true)
            //Length = input(50, minval = 1)
            //lower = lowest(Length)
            //upper = highest(Length)
            //xTether = avg(upper, lower)
            //plot(xTether, color = green, title = "Tether Line")
            List<decimal> tetherLineList = new();
            List<Signal> signalsList = new();

            try
            {
                var minMaxList = VolumeInputCheck(stockDataClass, days, true);
                List<decimal> highestHighList = minMaxList.Item1;
                List<decimal> lowestLowList = minMaxList.Item2;

                for (int i = 0; i < stockDataClass.HighPrices.Count; i++)
                {
                    decimal highest = highestHighList.ElementAtOrDefault(i);
                    decimal lowest = lowestLowList.ElementAtOrDefault(i);
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal prevTetherLine = tetherLineList.LastOrDefault();
                    decimal tetherLine = (highest + lowest) / 2;
                    tetherLineList.Add(tetherLine);

                    var signal = GetCompareSignal(currentValue - tetherLine, prevValue - prevTetherLine);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (tetherLineList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<decimal>, List<Signal>) CalculateTironeLevels(StockData stockDataClass, int days = 20)
        {
            //
            // @author LazyBear
            // Tirone Levels are dynamic S/R levels
            // 
            //study(title = "Tirone Levels [LazyBear]", shorttitle = "TironeLvl_LB", overlay = true)
            //length = input(20)
            //method_mp = input(false, title = "Midpoint Method?", type = bool)
            //method_mm = input(true, title = "Mean Method?", type = bool)

            //ll = lowest(low, length)
            //hh = highest(high, length)

            // Midpoint method
            //tlh = hh - ((hh - ll) / 3)
            //clh = ll + ((hh - ll) / 2)
            //blh = ll + ((hh - ll) / 3)

            // Mean method
            //am = (hh + ll + close) / 3
            //eh = am + (hh - ll)
            //el = am - (hh - ll)
            //rh = 2 * am - ll
            //rl = 2 * am - hh
            List<decimal> tlhList = new();
            List<decimal> clhList = new();
            List<decimal> blhList = new();
            List<decimal> amList = new();
            List<decimal> ehList = new();
            List<decimal> elList = new();
            List<decimal> rhList = new();
            List<decimal> rlList = new();
            List<Signal> signalsList = new();

            try
            {
                var minMaxList = VolumeInputCheck(stockDataClass, days, true);
                List<decimal> highestHighList = minMaxList.Item1;
                List<decimal> lowestLowList = minMaxList.Item2;

                for (int i = 0; i < highestHighList.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal hh = highestHighList.ElementAtOrDefault(i);
                    decimal ll = lowestLowList.ElementAtOrDefault(i);

                    decimal tlh = hh - ((hh - ll) / 3);
                    tlhList.Add(tlh);

                    decimal clh = ll + ((hh - ll) / 2);
                    clhList.Add(clh);

                    decimal blh = ll + ((hh - ll) / 3);
                    blhList.Add(blh);

                    decimal prevAm = amList.LastOrDefault();
                    decimal am = (hh + ll + currentValue) / 3;
                    amList.Add(am);

                    decimal eh = am + (hh - ll);
                    ehList.Add(eh);

                    decimal el = am - (hh - ll);
                    elList.Add(el);

                    decimal rh = (2 * am) - ll;
                    rhList.Add(rh);

                    decimal rl = (2 * am) - hh;
                    rlList.Add(rl);

                    var signal = GetCompareSignal(currentValue - am, prevValue - prevAm);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (tlhList, clhList, blhList, amList, ehList, elList, rhList, rlList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateDerivativeOscillator(StockData stockDataClass, string maType, int days = 3)
        {
            //
            // @author LazyBear
            // @credits Constance Brown
            // 
            //study(title = "Derivative Oscillator [LazyBear]", shorttitle = "DO_LB")
            //length = input(14, title = "RSI Length")
            //p = input(9, title = "SMA length")
            //ema1 = input(5, title = "EMA1 length")
            //ema2 = input(3, title = "EMA2 length")

            //s1 = ema(ema(rsi(close, length), ema1), ema2)
            //s2 = s1 - sma(s1, p)
            //c_color = s2 < 0 ? (s2 < s2[1] ? red : lime) : (s2 >= 0 ? (s2 > s2[1] ? lime : red) : na)
            //plot(s2, style = histogram, color = c_color)
            List<decimal> s1List = new();
            List<decimal> s2List = new();
            List<decimal> s1SmaList = new();
            List<Signal> signalsList = new();

            try
            {
                int ema1Length = (int)Math.Ceiling(days / 0.6);
                int ema2Length = days;
                int smaLength = days * 3;
                int length = (int)Math.Ceiling(days / 0.2143);

                var rsiList = CalculateRelativeStrengthIndex(null, stockDataClass, maType, length).Item4;
                var rsiEma1List = GetMovingAverageList(maType, rsiList, stockDataClass, ema1Length);
                var rsiEma2List = GetMovingAverageList(maType, rsiEma1List, stockDataClass, ema2Length);

                for (int i = 0; i < rsiList.Count; i++)
                {
                    decimal prevS1 = s1List.LastOrDefault();
                    decimal s1 = rsiEma2List.ElementAtOrDefault(i);
                    s1List.Add(s1);

                    decimal prevS1Sma = s1SmaList.LastOrDefault();
                    decimal s1Sma = s1List.TakeLast(smaLength).Average();
                    s1SmaList.Add(s1Sma);

                    decimal s2 = s1 - s1Sma;
                    s2List.Add(s2);

                    var signal = GetCompareSignal(s1 - s1Sma, prevS1 - prevS1Sma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (s1List, s1SmaList, s2List, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>)
            CalculateUltimateTraderOscillator(StockData stockDataClass, string maType, int days = 2)
        {
            // This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
            // © RedKTrader

            //@version=4
            //study("Ultimate Trader Oscillator - UTO v3", shorttitle = "UTO_v3", precision = 2)
            //length = input(10)
            //savg = input(1, title = "scoring length", minval = 1)
            //VolSprLen = input(10, title = "Vol/Spread Lookback", minval = 5)
            //smooth = input(4)
            //Sentiment = input(4, title = "Sentiment Multiplier", minval = 1)
            //s_level = input(25, title = "Key Level")
            //ss = input(false, title = "Spread Score ?")
            //vw = input(false, title = "Volume Score ?")
            //svsign_opt = input(true, title = "Spread & Volume based on previous close ?")

            // variables we will use
            //p = close
            //body = close - open
            //range = high - low
            //c = change(close)
            //v = volume
            //t = tr(true)
            //svsign = svsign_opt ? sign(c) : sign(body)

            // ========= scoring section ==========================================
            //1. Close vs. Open within Bar Range (Balance of Power)
            //k1 = nz(body / range * 100)

            //2. closing within current bar  
            // * special case when price doesn't move -- range = 0
            //k2 = range == 0 ? 0 : nz(stoch(p, high, low, 1) * 2 - 100)

            //3. closing within 2 bars
            //k3 = c == 0 ? 0 : nz(stoch(p, high, low, 2) * 2 - 100)

            //4. change of close within 2 bars
            //k4 = nz(c / (highest(2) - lowest(2)) * 100)

            // Note: 2 ways to caluclate the score from spread and volume, either based on close vs open or close vs prior bar. 
            // default here is to use close vs prior bar which seems to be better aligned to the visual assessment
            //5. Price Spread vs TR for lookback, apply sign of bar body to score 
            //k5 = ss ? svsign * stoch(t, t, t, VolSprLen) : 0

            //6. Volume compared to volume range for lookback, apply sign of bar body to score
            //k6 = vw ? svsign * stoch(v, v, v, VolSprLen) : 0

            // Calculate avg scores for each category for scoring length 
            //kk1 = wma(k1, savg)
            //kk2 = wma(k2, savg)
            //kk3 = wma(k3, savg)
            //kk4 = wma(k4, savg)
            //kk5 = wma(k5, savg)
            //kk6 = wma(k6, savg)

            // plot(kk1, title="1. Close vs. Open within Bar Range ",color = color.white , linewidth=2)
            // plot(kk2, title="2. closing within current bar",color = color.yellow , linewidth=2)
            // plot(kk3, title="3. closing within 2 bars ",color = color.orange , linewidth=2)
            // plot(kk4, title="4. change of close within 2 bars ",color = color.red , linewidth=2)
            // plot(kk5, title="5. Price Spread vs recent TR ",color = color.green , linewidth=2)
            // plot(kk6, title="6. Volume vs volume range ",color = color.aqua , linewidth=2)

            // // easy way to add only positive values to bulls and negative values to bears
            //bullscore = max(0, kk1) + max(0, kk2) + max(0, kk3) + max(0, kk4) + max(0, kk5) + max(0, kk6)
            //bearscore = -1 * (min(0, kk1) + min(0, kk2) + min(0, kk3) + min(0, kk4) + min(0, kk5) + min(0, kk6))
            // =======================================================================================

            // create directional index and smoothing of final score oscillator
            //dx = bullscore / bearscore
            //dxi = 2 * (100 - 100 / (1 + dx)) - 100
            //dxiavg = wma(dxi, length)
            //dxis = wma(dxiavg, smooth)
            //dxiss = wma(dxis, smooth)

            //red = #ff180b, green = #00aa00
            //long = Sentiment * length
            //longdxi = wma(dxi, long)
            //longdxis = wma(longdxi, smooth)

            // ====== Plot Section  ================================================================
            //hline(0, color = #ffee58aa,  linestyle = hline.style_solid, editable = false)
            //hline(s_level, color = #ffee58aa,  linestyle = hline.style_dotted, editable = false)
            //hline(-s_level, color = #ffee58aa,  linestyle = hline.style_dotted, editable = false)
            //hline(100, color = color.green, linestyle = hline.style_dotted, editable = false)
            //hline(-100, color = color.red, linestyle = hline.style_dotted, editable = false)

            // main plots
            //plot(longdxis, title = "Sentiment", style = plot.style_area, transp = 50, color = longdxis >= 0 ? green : red, linewidth = 4)
            //plot(dxis, title = "UTOs", color = dxis >= 0 ? color.aqua : color.orange, linewidth = 3)
            //plot(dxiss, title = "UTOss", color = color.silver, linewidth = 2, transp = 50)

            // v3 additions
            // new feature: show a stochastic of the directional index for length
            //kx = stoch(dxis, dxis, dxis, length) * 2 - 100
            //plot(kx, title = "Stoch", transp = 50, color = color.yellow, style = plot.style_stepline, display = 0)

            // new feature: show inidvidual bar scores for each bar - this is not averaged or smoothed
            //kscore = (k1 + k2 + k3 + k4 + k5 + k6) / (4 + (ss ? 1 : 0) + (vw ? 1 : 0))
            //plot(kscore, title = "Bar Score", style = plot.style_histogram, transp = 75, color = kscore >= 0 ? green : red, linewidth = 6, display = 0)
            List<decimal> k1List = new();
            List<decimal> k2List = new();
            List<decimal> k3List = new();
            List<decimal> k4List = new();
            List<decimal> k5List = new();
            List<decimal> k6List = new();
            List<decimal> bullScoreList = new();
            List<decimal> bearScoreList = new();
            List<decimal> dxList = new();
            List<decimal> dxiList = new();
            List<decimal> dxiavgList = new();
            List<decimal> dxisList = new();
            List<decimal> dxissList = new();
            List<Signal> signalsList = new();

            try
            {
                int vsprLength = days * 5;
                int smoothLength = days * 2;

                var minMaxList = VolumeInputCheck(stockDataClass, 0, false);
                var highList = minMaxList.Item1;
                var lowList = minMaxList.Item2;
                var minMax2List = GetMaxAndMinValuesList(highList, lowList, days);
                var highestList = minMax2List.Item1;
                var lowestList = minMax2List.Item2;
                var trList = CalculateVortexIndicator(stockDataClass, days).Item5;
                var trStoList = CalculateStochasticOscillator(trList, stockDataClass, maType, vsprLength).Item3;
                var vStoList = CalculateStochasticOscillator(stockDataClass.Volumes, stockDataClass, maType, vsprLength).Item3;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal close = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal body = close - stockDataClass.OpenPrices.ElementAtOrDefault(i);
                    decimal high = highList.ElementAtOrDefault(i);
                    decimal low = lowList.ElementAtOrDefault(i);
                    decimal range = high - low;
                    decimal prevClose = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal c = close - prevClose;
                    decimal v = stockDataClass.Volumes.ElementAtOrDefault(i);
                    decimal tr = trList.ElementAtOrDefault(i);
                    decimal sign = Math.Sign(c);
                    decimal highest = highestList.ElementAtOrDefault(i);
                    decimal lowest = lowestList.ElementAtOrDefault(i);
                    decimal vSto = vStoList.ElementAtOrDefault(i);
                    decimal trSto = trStoList.ElementAtOrDefault(i);

                    decimal k1 = range != 0 ? body / range * 100 : 0;
                    k1List.Add(k1);

                    decimal k2 = range == 0 ? 0 : ((close - low) / range * 100 * 2) - 100;
                    k2List.Add(k2);

                    decimal k3 = c == 0 || highest - lowest == 0 ? 0 : ((close - lowest) / (highest - lowest) * 100 * 2) - 100;
                    k3List.Add(k3);

                    decimal k4 = highest - lowest != 0 ? c / (highest - lowest) * 100 : 0;
                    k4List.Add(k4);

                    decimal k5 = sign * trSto;
                    k5List.Add(k5);

                    decimal k6 = sign * vSto;
                    k6List.Add(k6);

                    decimal bullScore = Math.Max(0, k1) + Math.Max(0, k2) + Math.Max(0, k3) + Math.Max(0, k4) + Math.Max(0, k5) + Math.Max(0, k6);
                    bullScoreList.Add(bullScore);

                    decimal bearScore = -1 * (Math.Min(0, k1) + Math.Min(0, k2) + Math.Min(0, k3) + Math.Min(0, k4) + Math.Min(0, k5) + Math.Min(0, k6));
                    bearScoreList.Add(bearScore);

                    decimal dx = bearScore != 0 ? bullScore / bearScore : 0;
                    dxList.Add(dx);

                    decimal dxi = (2 * (100 - (100 / (1 + dx)))) - 100;
                    dxiList.Add(dxi);
                }

                dxiavgList = GetMovingAverageList(maType, dxiList, stockDataClass, vsprLength);
                dxisList = GetMovingAverageList(maType, dxiavgList, stockDataClass, smoothLength);
                dxissList = GetMovingAverageList(maType, dxisList, stockDataClass, smoothLength);
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal dxis = dxisList.ElementAtOrDefault(j);
                    decimal dxiss = dxissList.ElementAtOrDefault(j);
                    decimal prevDxis = j >= 1 ? dxisList.ElementAtOrDefault(j - 1) : 0;
                    decimal prevDxiss = j >= 1 ? dxissList.ElementAtOrDefault(j - 1) : 0;

                    var signal = GetCompareSignal(dxis - dxiss, prevDxis - prevDxiss);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (k1List, k2List, k3List, k4List, k5List, k6List, bullScoreList, bearScoreList, dxList, dxiList, dxiavgList, dxisList, dxissList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateVolumeWeightedRelativeStrengthIndex(
            StockData stockDataClass, string maType, int days = 3)
        {
            //@version=3
            //study(title = "RedK Relative Strength Index", shorttitle = "RedK_RSI", scale = scale.right, precision = 2)

            //inputs
            //src = close
            //len = input(10, minval = 1, title = "Length")
            //sentiment = input(3, minval = 1, title = "Sentiment Factor")
            //smooth = input(3, minval = 1, title = "Smoothing")
            //vw = input(defval = true, title = "Volume Weighted ?")
            //step = input(title = "Step", defval = 5, maxval = 50, minval = 0, step = 5)

            //Calculations  -- prefer to use wma 
            //v = vw ? volume : 1
            //longlen = sentiment * len

            //up = wma(max(change(src) * v, 0), len)
            //down = wma(-min(change(src) * v, 0), len)
            //rsiraw = down == 0 ? 100 : up == 0 ? 0 : 100 - (100 / (1 + up / down))
            //rsiraw100 = rsiraw * 2 - 100
            //rsi = wma(rsiraw100, smooth)

            //longup = wma(max(change(src) * v, 0), longlen)
            //longdown = wma(-min(change(src) * v, 0), longlen)
            //longrsiraw = longdown == 0 ? 100 : longup == 0 ? 0 : 100 - (100 / (1 + longup / longdown))
            //longrsiraw100 = longrsiraw * 2 - 100
            //longrsi = wma(longrsiraw100, smooth)
            //longrsis = step > 0 ? round(longrsi / step) * step : longrsi

            //Plot
            //Plot levels and sentiment first, so the visual order is correct - doesn't cover the main plot
            //zeroline = hline(0, title = 'Zero Line', color = yellow, linestyle = line)
            //hline(40, title = 'Strong Up Level', color = green, linestyle = dotted)
            //hline(-40, title = 'Strong Down Level', color = red, linestyle = dotted)

            //plot(longrsis, title = 'Sentiment', style = area, transp = 20, color = longrsis >= 0 ? green : red, linewidth = 2)

            //plot(rsiraw100, color = purple)
            //plot(rsi, title = 'K_RSI', style = line, transp = 20, color = rsi >= 0 ? aqua : orange, linewidth = 2)


            //SignalDn = rsi < 0 and rsi[1] >= 0
            //plotshape(SignalDn, title = "Signal Down", style = shape.triangledown, location = location.top, transp = 20, size = size.small, color = red, offset = -1)

            //SignalUp = rsi >= 0 and rsi[1] < 0
            //plotshape(SignalUp, title = "Signal Up", style = shape.triangleup, location = location.bottom, transp = 20, size = size.small, color = green, offset = -1)
            List<decimal> maxList = new();
            List<decimal> minList = new();
            List<decimal> upList = new();
            List<decimal> dnList = new();
            List<decimal> rsiRawList = new();
            List<decimal> rsiScaledList = new();
            List<decimal> rsiList = new();
            List<Signal> signalsList = new();

            try
            {
                int length = (int)Math.Ceiling(days / 0.3);

                for (int i = 0; i < stockDataClass.HighPrices.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal volume = stockDataClass.Volumes.ElementAtOrDefault(i);

                    decimal max = Math.Max((currentValue - prevValue) * volume, 0);
                    maxList.Add(max);

                    decimal min = -Math.Min((currentValue - prevValue) * volume, 0);
                    minList.Add(min);
                }

                upList = GetMovingAverageList(maType, maxList, stockDataClass, length);
                dnList = GetMovingAverageList(maType, minList, stockDataClass, length);
                for (int j = 0; j < stockDataClass.HighPrices.Count; j++)
                {
                    decimal up = upList.ElementAtOrDefault(j);
                    decimal dn = dnList.ElementAtOrDefault(j);

                    decimal rsiRaw = dn == 0 ? 100 : up == 0 ? 0 : 100 - (100 / (1 + (up / dn)));
                    rsiRawList.Add(rsiRaw);

                    decimal rsiScale = (rsiRaw * 2) - 100;
                    rsiScaledList.Add(rsiScale);
                }

                rsiList = GetMovingAverageList(maType, rsiScaledList, stockDataClass, days);
                for (int k = 0; k < stockDataClass.HighPrices.Count; k++)
                {
                    decimal rsi = rsiList.ElementAtOrDefault(k);
                    decimal prevRsi1 = k >= 1 ? rsiList.ElementAtOrDefault(k - 1) : 0;
                    decimal prevRsi2 = k >= 2 ? rsiList.ElementAtOrDefault(k - 2) : 0;

                    var signal = GetCompareSignal(rsi - prevRsi1, prevRsi1 - prevRsi2);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (maxList, minList, upList, dnList, rsiRawList, rsiScaledList, rsiList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateKaseIndicator(StockData stockDataClass, string maType, int days = 10)
        {
            //period = user defined, default is 10
            //av = average
            //sqrt = square root
            //atr = average true range
            //moreT = moreThan, lessT = lessThan
            //index = current bar number

            //priorHigh = high[index - period];
            //priorLow = low[index - period]);
            //avVol = sma(period, index, volume);
            //avTR = atr(period);
            //kUp = kUp[index - 1];
            //if (avTR moreT 0) kUp = (priorHigh / low) / (avVol * sqrt(period));
            //kDown = kDown[index - 1];  //previous Kdown
            //if (avTR moreT 0) kDown = (high / priorLow) / (avVol * sqrt(period));
            //plot1 = null;
            //if (kUp moreT kDown) plot1 = low;
            //plot2 = null;
            //if (kUp lessT kDown) plot2 = high;
            //plot3 = null;
            //if (kUp == kDown) plot3 = (high + low) / 2;
            //Plot1: plot1;
            //Plot2: plot2;
            //Plot3: plot3;
            List<decimal> kUpList = new();
            List<decimal> kDownList = new();
            List<Signal> signalsList = new();

            try
            {
                decimal sqrtPeriod = Sqrt((double)days);

                var volumeSmaList = GetMovingAverageList(maType, null, stockDataClass, days);
                var atrList = CalculateAverageTrueRange(stockDataClass, maType, days).Item1;

                for (int i = 0; i < stockDataClass.HighPrices.Count; i++)
                {
                    decimal currentHigh = stockDataClass.HighPrices.ElementAtOrDefault(i);
                    decimal currentLow = stockDataClass.LowPrices.ElementAtOrDefault(i);
                    decimal avgTrueRange = atrList.ElementAtOrDefault(i);
                    decimal avgVolSma = volumeSmaList.ElementAtOrDefault(i);
                    decimal prevHigh = i >= 1 ? stockDataClass.HighPrices.ElementAtOrDefault(i - 1) : 0;
                    decimal prevLow = i >= 1 ? stockDataClass.LowPrices.ElementAtOrDefault(i - 1) : 0;
                    decimal ratio = avgVolSma * sqrtPeriod;

                    decimal prevKUp = kUpList.LastOrDefault();
                    decimal kUp = avgTrueRange > 0 && ratio != 0 && currentLow != 0 ? prevHigh / currentLow / ratio : prevKUp;
                    kUpList.Add(kUp);

                    decimal prevKDown = kDownList.LastOrDefault();
                    decimal kDown = avgTrueRange > 0 && ratio != 0 && prevLow != 0 ? currentHigh / prevLow / ratio : prevKDown;
                    kDownList.Add(kDown);

                    var signal = GetCompareSignal(kUp - kDown, prevKUp - prevKDown);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (kUpList, kDownList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateKaseConvergenceDivergence(StockData stockDataClass, string maType, int days = 3)
        {
            //kase cd
            //Kcd

            //study(title = "Kcd", shorttitle = "Kcd")
            //length = input(30, title = "Length")
            //rwh = (high - low) / (atr(length) * sqrt(length))
            //rwl = (high - low) / (atr(length) * sqrt(length))
            //pk = wma((rwh - rwl), 3)
            //kcd = (pk - sma(pk, 8))

            //rbars = iff(kcd > kcd, kcd, 0)
            //gbars = iff(kcd > kcd, kcd, 0)
            //plot(rbars, style = histogram, color = red)
            //plot(gbars, style = histogram, color = blue)
            List<decimal> kcdList = new();
            List<decimal> pkSignalList = new();
            List<Signal> signalsList = new();

            try
            {
                int kcdSignalPeriod = (int)Math.Ceiling(days / 0.375);

                var pkList = CalculateKasePeakOscillator(stockDataClass, maType, days).Item4;
                pkSignalList = GetMovingAverageList(maType, pkList, stockDataClass, kcdSignalPeriod);

                for (int i = 0; i < stockDataClass.HighPrices.Count; i++)
                {
                    decimal pk = pkList.ElementAtOrDefault(i);
                    decimal pkSma = pkSignalList.ElementAtOrDefault(i);

                    decimal prevKcd = kcdList.LastOrDefault();
                    decimal kcd = pk - pkSma;
                    kcdList.Add(kcd);

                    var signal = GetCompareSignal(kcd, prevKcd);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (pkSignalList, kcdList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<Signal>) CalculateKasePeakOscillator(StockData stockDataClass, string maType, int days = 3)
        {
            //
            // @author LazyBear
            // If you use this code, in its original or modified form, appreciate if you could
            // drop me a note. Thx. 
            // 
            //study(title = "Kase Peak Oscillator [LazyBear]", shorttitle = "KPO_LB")
            //length = input(30, title = "Length")
            //rwh = (high - low[length]) / (atr(length) * sqrt(length))
            //rwl = (high[length] - low) / (atr(length) * sqrt(length))
            //pk = wma((rwh - rwl), 3)
            //mn = sma(pk, length)
            //sd = stdev(pk, length)
            //v1 = iff(mn + (1.33 * sd) > 2.08, mn + (1.33 * sd), 2.08)
            //v2 = iff(mn - (1.33 * sd) < -1.92, mn - (1.33 * sd), -1.92)
            //ln = iff(pk[1] >= 0 and pk > 0, v1, iff(pk[1] <= 0 and pk < 0, v2, 0))
            //rbars = iff(pk[1] > pk, pk, 0)
            //gbars = iff(pk > pk[1], pk, 0)
            //plot(rbars, style = histogram, color = red)
            //plot(gbars, style = histogram, color = green)
            //plot(ln, color = yellow, linewidth = 1)
            List<decimal> rwhList = new();
            List<decimal> rwlList = new();
            List<decimal> diffList = new();
            List<decimal> pkList = new();
            List<decimal> mnList = new();
            List<decimal> sdList = new();
            List<decimal> v1List = new();
            List<decimal> v2List = new();
            List<decimal> lnList = new();
            List<Signal> signalsList = new();

            try
            {
                int length = days * 10;
                decimal sqrt = Sqrt((double)length);

                var atrList = CalculateAverageTrueRange(stockDataClass, maType, length).Item1;

                for (int i = 0; i < stockDataClass.HighPrices.Count; i++)
                {
                    decimal currentAtr = atrList.ElementAtOrDefault(i);
                    decimal currentHigh = stockDataClass.HighPrices.ElementAtOrDefault(i);
                    decimal currentLow = stockDataClass.LowPrices.ElementAtOrDefault(i);
                    decimal prevLow = i >= length ? stockDataClass.LowPrices.ElementAtOrDefault(i - length) : 0;
                    decimal prevHigh = i >= length ? stockDataClass.HighPrices.ElementAtOrDefault(i - length) : 0;

                    decimal rwh = currentAtr != 0 ? (currentHigh - prevLow) / currentAtr * sqrt : 0;
                    rwhList.Add(rwh);

                    decimal rwl = currentAtr != 0 ? (prevHigh - currentLow) / currentAtr * sqrt : 0;
                    rwlList.Add(rwl);

                    decimal diff = rwh - rwl;
                    diffList.Add(diff);
                }

                pkList = GetMovingAverageList(maType, diffList, stockDataClass, days);
                mnList = GetMovingAverageList(maType, pkList, stockDataClass, length);
                sdList = CalculateStandardDeviationVolatility(pkList, stockDataClass, length).Item4;
                for (int j = 0; j < stockDataClass.HighPrices.Count; j++)
                {
                    decimal pk = pkList.ElementAtOrDefault(j);
                    decimal mn = mnList.ElementAtOrDefault(j);
                    decimal sd = sdList.ElementAtOrDefault(j);
                    decimal prevPk = j >= 1 ? pkList.ElementAtOrDefault(j - 1) : 0;

                    decimal v1 = mn + (1.33m * sd) > 2.08m ? mn + (1.33m * sd) : 2.08m;
                    v1List.Add(v1);

                    decimal v2 = mn - (1.33m * sd) < -1.92m ? mn - (1.33m * sd) : -1.92m;
                    v2List.Add(v2);

                    decimal prevLn = lnList.LastOrDefault();
                    decimal ln = prevPk >= 0 && pk > 0 ? v1 : prevPk <= 0 && pk < 0 ? v2 : 0;
                    lnList.Add(ln);

                    var signal = GetCompareSignal(ln, prevLn);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (rwhList, rwlList, diffList, pkList, mnList, sdList, v1List, v2List, lnList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateKasePeakOscillatorV2(StockData stockDataClass, string maType, int days = 3)
        {
            //PRC_Kase Peak Oscillator V2 | indicator
            //19.07.2017
            //Nicolas @ www.prorealcode.com
            //Sharing ProRealTime knowledge
            //translated from MT4 code

            // --- settings
            //kpoDeviations  = 2.0 // Kase peak oscillator deviations
            //kpoShortCycle  = 8   // Kase peak oscillator short cycle
            //kpoLongCycle   = 65  // Kase peak oscillator long cycle
            //kpoSensitivity = 40
            //allPeaksMode = 0 //1=true ; 0=false
            // --- end of settings

            //if barindex > kpoLongCycle * 2 then
            //ccLog = Log(Close[0] / Close[1])
            //ccDev = std[9](ccLog)
            //avg = average[30](ccDev)

            //if (avg > 0) then
            //max1 = 0
            //maxs = 0

            //for k = kpoShortCycle to kpoLongCycle - 1 do
            //max1 = Max(Log(High[0] / Low[0 + k]) / Sqrt(k), max1)
            //maxs = Max(Log(High[0 + k] / Low[0]) / Sqrt(k), maxs)
            //next
            //x1 = max1 / avg
            //xs = maxs / avg
            //endif

            //xp = kpoSensitivity * (average[3](x1) - average[3](xs))
            //xpAbs = Abs(xp)
            //kpoBuffer = xp
            //kphBuffer = xp
            //tmpVal = average[50](xpAbs) + kpoDeviations * std[50](xpAbs)
            //maxVal = Max(90.0, tmpVal)
            //minVal = Min(90.0, tmpVal)

            //if (kpoBuffer > 0) then
            //kpdBuffer = maxVal
            //kpmBuffer = minVal
            //else
            //kpdBuffer = -maxVal
            //kpmBuffer = -minVal
            //endif

            //kppbuffer = 0
            //if (not allPeaksMode) then
            //if (kpoBuffer[1] > 0 and kpoBuffer[1]> kpoBuffer[0] and kpoBuffer[1]>= kpoBuffer[2] and kpoBuffer[1]>= maxVal) then
            //kppBuffer = kpoBuffer[1]
            //endif
            //if (kpoBuffer[1] < 0 and kpoBuffer[1]< kpoBuffer[0] and kpoBuffer[1]<= kpoBuffer[2] and kpoBuffer[1]<= -maxVal) then
            //kppBuffer = kpoBuffer[1]
            //endif
            //else
            //if (kpoBuffer[1] > 0 and kpoBuffer[1]> kpoBuffer[0] and kpoBuffer[1]>= kpoBuffer[2]) then
            //kppBuffer = kpoBuffer[1]
            //endif
            //if (kpoBuffer[1] < 0 and kpoBuffer[1]< kpoBuffer[0] and kpoBuffer[1]<= kpoBuffer[2]) then
            //kppBuffer = kpoBuffer[1]
            //endif
            //endif
            //endif
            decimal kpoDeviations = 2, kpoSensitivity = 40;
            List<decimal> ccLogList = new();
            List<decimal> ccDevList = new();
            List<decimal> ccDevAvgList = new();
            List<decimal> xpAbsAvgList = new();
            List<decimal> kpoBufferList = new();
            List<decimal> xpAbsStdDevList = new();
            List<decimal> x1List = new();
            List<decimal> x2List = new();
            List<decimal> log1MaxList = new();
            List<decimal> log2MaxList = new();
            List<decimal> xpList = new();
            List<decimal> xpAbsList = new();
            List<decimal> kpdBufferList = new();
            List<decimal> kpmBufferList = new();
            List<decimal> kppBufferList = new();
            List<decimal> tmpValList = new();
            List<decimal> maxValList = new();
            List<decimal> minValList = new();
            List<Signal> signalsList = new();

            try
            {
                int kpoShortCycle = (int)Math.Ceiling(days / 0.375);
                int kpoLongCycle = (int)Math.Ceiling(days / 0.0462);
                int ccStdDevLength = days * 3;
                int ccStdDevAvgLength = days * 10;
                int x1AvgLength = days;
                int xpAbsLength = (int)Math.Ceiling(days / 0.06);

                for (int i = 0; i < stockDataClass.HighPrices.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal temp = prevValue != 0 ? currentValue / prevValue : 0;

                    decimal ccLog = temp > 0 ? (decimal)Log((double)temp) : 0;
                    ccLogList.Add(ccLog);
                }

                ccDevList = CalculateStandardDeviationVolatility(ccLogList, stockDataClass, ccStdDevLength).Item4;
                ccDevAvgList = GetMovingAverageList(maType, ccDevList, stockDataClass, ccStdDevAvgLength);
                for (int j = 0; j < stockDataClass.HighPrices.Count; j++)
                {
                    decimal avg = ccDevAvgList.ElementAtOrDefault(j);
                    decimal currentLow = stockDataClass.LowPrices.ElementAtOrDefault(j);
                    decimal currentHigh = stockDataClass.HighPrices.ElementAtOrDefault(j);

                    decimal max1 = 0, max2 = 0;
                    for (int k = kpoShortCycle; k < kpoLongCycle; k++)
                    {
                        decimal sqrtK = (decimal)Sqrt((double)k);
                        decimal prevLow = j >= k ? stockDataClass.LowPrices.ElementAtOrDefault(j - k) : 0;
                        decimal prevHigh = j >= k ? stockDataClass.HighPrices.ElementAtOrDefault(j - k) : 0;
                        decimal temp1 = prevLow != 0 ? currentHigh / prevLow : 0;
                        decimal log1 = temp1 > 0 ? (decimal)Log((double)temp1) : 0;
                        max1 = Math.Max(log1 / sqrtK, max1);
                        decimal temp2 = currentLow != 0 ? prevHigh / currentLow : 0;
                        decimal log2 = temp2 > 0 ? (decimal)Log((double)temp2) : 0;
                        max2 = Math.Max(log2 / sqrtK, max2);
                    }
                    log1MaxList.Add(max1);
                    log2MaxList.Add(max2);

                    decimal x1 = avg != 0 ? max1 / avg : 0;
                    x1List.Add(x1);

                    decimal x2 = avg != 0 ? max2 / avg : 0;
                    x2List.Add(x2);

                    decimal xp = kpoSensitivity * (x1List.TakeLast(x1AvgLength).Average() - x2List.TakeLast(x1AvgLength).Average());
                    xpList.Add(xp);

                    decimal xpAbs = Math.Abs(xp);
                    xpAbsList.Add(xpAbs);

                    decimal xpAbsAvg = xpAbsList.TakeLast(xpAbsLength).Average();
                    xpAbsAvgList.Add(xpAbsAvg);
                }

                xpAbsStdDevList = CalculateStandardDeviationVolatility(xpAbsList, stockDataClass, xpAbsLength).Item4;
                for (int l = 0; l < stockDataClass.HighPrices.Count; l++)
                {
                    decimal xpAbsAvg = xpAbsAvgList.ElementAtOrDefault(l);
                    decimal xpAbsStdDev = xpAbsStdDevList.ElementAtOrDefault(l);
                    decimal prevKpoBuffer1 = l >= 1 ? kpoBufferList.ElementAtOrDefault(l - 1) : 0;
                    decimal prevKpoBuffer2 = l >= 2 ? kpoBufferList.ElementAtOrDefault(l - 2) : 0;

                    decimal tmpVal = xpAbsAvg + (kpoDeviations * xpAbsStdDev);
                    tmpValList.Add(tmpVal);

                    decimal maxVal = Math.Max(90, tmpVal);
                    maxValList.Add(maxVal);

                    decimal minVal = Math.Min(90, tmpVal);
                    minValList.Add(minVal);

                    decimal prevKpoBuffer = kpoBufferList.LastOrDefault();
                    decimal kpoBuffer = xpList.ElementAtOrDefault(l);
                    kpoBufferList.Add(kpoBuffer);

                    decimal kpdBuffer = kpoBuffer > 0 ? maxVal : maxVal * -1;
                    kpdBufferList.Add(kpdBuffer);

                    decimal kpmBuffer = kpoBuffer > 0 ? minVal : minVal * -1;
                    kpmBufferList.Add(kpmBuffer);

                    decimal kppBuffer = prevKpoBuffer1 > 0 && prevKpoBuffer1 > kpoBuffer && prevKpoBuffer1 >= prevKpoBuffer2 && prevKpoBuffer1 >= maxVal ? prevKpoBuffer1 :
                        prevKpoBuffer1 < 0 && prevKpoBuffer1 < kpoBuffer && prevKpoBuffer1 <= prevKpoBuffer2 && prevKpoBuffer1 <= maxVal * -1 ? prevKpoBuffer1 :
                        prevKpoBuffer1 > 0 && prevKpoBuffer1 > kpoBuffer && prevKpoBuffer1 >= prevKpoBuffer2 ? prevKpoBuffer1 :
                        prevKpoBuffer1 < 0 && prevKpoBuffer1 < kpoBuffer && prevKpoBuffer1 <= prevKpoBuffer2 ? prevKpoBuffer1 : 0;
                    kppBufferList.Add(kppBuffer);

                    var signal = GetCompareSignal(kpoBuffer, prevKpoBuffer);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (ccLogList, ccDevList, ccDevAvgList, log1MaxList, log2MaxList, x1List, x2List, xpList, xpAbsList, xpAbsAvgList, xpAbsStdDevList, tmpValList, maxValList,
                minValList, kpdBufferList, kpmBufferList, kppBufferList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateKaseDevStop(StockData stockDataClass, string maType, int days = 5)
        {
            //pararemeters:
            //n = 20
            //periodFast = 5
            //periodSlow = 21

            //DTR = max(max(High - Low[2], abs(High - Close[2])), max(abs(Low - Close[2]), (abs(Low - Close[2]))))
            //price = typicalprice
            //avg = average[n](DTR)
            //st = std[n](DTR)

            //maFast = average[periodFast](close)
            //maSlow = average[periodSlow](close)

            //if maFast < maSlow then
            //WarningLine = price + avg
            //Dev1 = price + avg + st
            //Dev2 = price + avg + 2.2 * st
            //Dev3 = price + avg + 3.6 * st
            //else
            //WarningLine = price - avg
            //Dev1 = price - avg - st
            //Dev2 = price - avg - 2.2 * st
            //Dev3 = price - avg - 3.6 * st
            //endif
            List<decimal> warningLineList = new();
            List<decimal> dev1List = new();
            List<decimal> dev2List = new();
            List<decimal> dev3List = new();
            List<decimal> dtrList = new();
            List<decimal> dtrStdList = new();
            List<decimal> dtrAvgList = new();
            List<Signal> signalsList = new();

            try
            {
                int periodFast = days;
                int n = MinOrMax(periodFast * 4);
                int periodSlow = MinOrMax((int)Math.Ceiling(periodFast / 0.2381));

                List<decimal> typicalPriceList = CalculateTypicalPrice(stockDataClass).Item1;

                for (int i = 0; i < stockDataClass.HighPrices.Count; i++)
                {
                    decimal currentHigh = stockDataClass.HighPrices.ElementAtOrDefault(i);
                    decimal currentLow = stockDataClass.LowPrices.ElementAtOrDefault(i);
                    decimal prevClose = i >= 2 ? stockDataClass.ClosePrices.ElementAtOrDefault(i - 2) : 0;
                    decimal prevLow = i >= 2 ? stockDataClass.LowPrices.ElementAtOrDefault(i - 2) : 0;

                    decimal dtr = Math.Max(Math.Max(currentHigh - prevLow, Math.Abs(currentHigh - prevClose)), Math.Max(Math.Abs(currentLow - prevClose),
                        Math.Abs(currentLow - prevClose)));
                    dtrList.Add(dtr);

                    decimal dtrAvg = dtrList.TakeLast(n).Average();
                    dtrAvgList.Add(dtrAvg);
                }

                List<decimal> smaSlowList = GetMovingAverageList(maType, null, stockDataClass, periodSlow);
                List<decimal> smaFastList = GetMovingAverageList(maType, null, stockDataClass, periodFast);
                dtrStdList = CalculateStandardDeviationVolatility(dtrList, stockDataClass, n).Item4;
                for (int j = 0; j < stockDataClass.HighPrices.Count; j++)
                {
                    decimal maFast = smaFastList.ElementAtOrDefault(j);
                    decimal maSlow = smaSlowList.ElementAtOrDefault(j);
                    decimal dtrAvg = dtrAvgList.ElementAtOrDefault(j);
                    decimal dtrStd = dtrStdList.ElementAtOrDefault(j);
                    decimal currentTypicalPrice = typicalPriceList.ElementAtOrDefault(j);
                    decimal prevMaFast = j >= 1 ? smaFastList.ElementAtOrDefault(j - 1) : 0;
                    decimal prevMaSlow = j >= 1 ? smaSlowList.ElementAtOrDefault(j - 1) : 0;

                    decimal warningLine = maFast < maSlow ? currentTypicalPrice + dtrAvg : currentTypicalPrice - dtrAvg;
                    warningLineList.Add(warningLine);

                    decimal dev1 = maFast < maSlow ? currentTypicalPrice + dtrAvg + dtrStd : currentTypicalPrice - dtrAvg - dtrStd;
                    dev1List.Add(dev1);

                    decimal dev2 = maFast < maSlow ? currentTypicalPrice + dtrAvg + (2.2m * dtrStd) : currentTypicalPrice - dtrAvg - (2.2m * dtrStd);
                    dev2List.Add(dev2);

                    decimal dev3 = maFast < maSlow ? currentTypicalPrice + dtrAvg + (3.6m * dtrStd) : currentTypicalPrice - dtrAvg - (3.6m * dtrStd);
                    dev3List.Add(dev3);

                    var signal = GetCompareSignal(maFast - maSlow, prevMaFast - prevMaSlow);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (dtrList, dtrAvgList, dtrStdList, warningLineList, dev1List, dev2List, dev3List, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateKaseDevStopV2(StockData stockDataClass, string maType, int days = 10)
        {
            //PRC_KaseDevStop v3 | indicator
            //29.06.2018
            //Nicolas @ www.prorealcode.com
            //Sharing ProRealTime knowledge
            //translated from MT5 code version

            //--- settings 
            //inpDesPeriod = 20          // Dev-stop period
            //inpSlowPeriod = 21          // Dev-stop slow period
            //inpFastPeriod = 10          // Dev-stop fast period
            //inpStdDev1 = 0.0         // Deviation 1
            //inpStdDev2 = 1.0         // Deviation 2
            //inpStdDev3 = 2.2         // Deviation 3
            //inpStdDev4 = 3.6         // Deviation 4
            //--- end of settings 

            //pricc = customclose
            //once price = close * 100
            //average1 = average[inpFastPeriod](pricc)
            //average2 = average[inpSlowPeriod](pricc)
            //if average1 > average2 then
            //trend = 1
            //else
            //trend = -1
            //endif

            //if trend <> trend[1] then
            //if trend = 1 then
            //price = high
            //else
            //price = low
            //endif
            //endif
            //if trend > 0 then
            //price = max(price, high)
            //endif
            //if trend < 0 then
            //price = min(price, low)
            //endif

            //mmax = max(max(high, high[1]), pricc[2])
            //mmin = min(min(low, low[1]), pricc[2])
            //rrange = mmax - mmin
            //avg = rrange
            //for n = 1 to inpDesPeriod - 1 do
            //avg = (avg + rrange[n])
            //next
            //avg = avg / n

            //dev = square(rrange - avg)
            //for n = 1 to inpDesPeriod - 1 do
            //dev = dev + (rrange[n] - avg) * (rrange[n] - avg)
            //next
            //dev = sqrt(dev / n)

            //val = price + (-1) * trend * (avg + (inpStdDev1 * dev))
            //val1 = price + (-1) * trend * (avg + (inpStdDev2 * dev))
            //val2 = price + (-1) * trend * (avg + (inpStdDev3 * dev))
            //val3 = price + (-1) * trend * (avg + (inpStdDev4 * dev))
            decimal inpStdDev1 = 0, inpStdDev2 = 1, inpStdDev3 = 2.2m, inpStdDev4 = 3.6m;
            List<decimal> valList = new();
            List<decimal> val1List = new();
            List<decimal> val2List = new();
            List<decimal> val3List = new();
            List<decimal> trendList = new();
            List<decimal> rrangeList = new();
            List<decimal> devList = new();
            List<decimal> devSquaredList = new();
            List<decimal> divisionOfSumList = new();
            List<decimal> stdDevVolatilityList = new();
            List<decimal> priceList = new();
            List<Signal> signalsList = new();

            try
            {
                int fastPeriod = days;
                int desPeriod = MinOrMax(fastPeriod * 2);
                int slowPeriod = MinOrMax((int)Math.Ceiling(fastPeriod / 0.4762));

                List<decimal> smaFastList = GetMovingAverageList(maType, null, stockDataClass, fastPeriod);
                List<decimal> smaSlowList = GetMovingAverageList(maType, null, stockDataClass, slowPeriod);

                for (int i = 0; i < stockDataClass.HighPrices.Count; i++)
                {
                    decimal currentHigh = stockDataClass.HighPrices.ElementAtOrDefault(i);
                    decimal currentLow = stockDataClass.LowPrices.ElementAtOrDefault(i);
                    decimal currentClose = stockDataClass.ClosePrices.ElementAtOrDefault(i);
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal maFast = smaFastList.ElementAtOrDefault(i);
                    decimal maSlow = smaSlowList.ElementAtOrDefault(i);
                    decimal prevHigh = i >= 1 ? stockDataClass.HighPrices.ElementAtOrDefault(i - 1) : 0;
                    decimal prevLow = i >= 1 ? stockDataClass.LowPrices.ElementAtOrDefault(i - 1) : 0;
                    decimal prevClose = i >= 2 ? stockDataClass.ClosePrices.ElementAtOrDefault(i - 2) : 0;

                    decimal trend = maFast > maSlow ? 1 : -1;
                    trendList.Add(trend);

                    decimal prevPrice = priceList.LastOrDefault();
                    decimal price = trend == 1 ? currentHigh : currentLow;
                    price = trend > 0 ? Math.Max(price, currentHigh) : Math.Min(price, currentLow);
                    priceList.Add(price);

                    decimal mmax = Math.Max(Math.Max(currentHigh, prevHigh), prevClose);
                    decimal mmin = Math.Min(Math.Min(currentLow, prevLow), prevClose);

                    decimal rrange = mmax - mmin;
                    rrangeList.Add(rrange);

                    decimal avg = rrangeList.TakeLast(desPeriod).Average();
                    decimal dev = rrange - avg;
                    devList.Add(dev);

                    decimal devSquared = Pow(dev, 2);
                    devSquaredList.Add(devSquared);

                    decimal divisionOfSum = devSquaredList.TakeLast(desPeriod).Average();
                    divisionOfSumList.Add(divisionOfSum);

                    decimal stdDevVolatility = divisionOfSum >= 0 ? (decimal)Sqrt((double)divisionOfSum) : 0;
                    stdDevVolatilityList.Add(stdDevVolatility);

                    decimal val = (price + ((-1) * trend)) * (avg + (inpStdDev1 * dev));
                    valList.Add(val);

                    decimal val1 = (price + ((-1) * trend)) * (avg + (inpStdDev2 * dev));
                    val1List.Add(val1);

                    decimal val2 = (price + ((-1) * trend)) * (avg + (inpStdDev3 * dev));
                    val2List.Add(val2);

                    decimal prevVal3 = val3List.LastOrDefault();
                    decimal val3 = (price + ((-1) * trend)) * (avg + (inpStdDev4 * dev));
                    val3List.Add(val3);

                    var signal = GetCompareSignal(price - val3, prevPrice - prevVal3);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (trendList, rrangeList, devList, devSquaredList, divisionOfSumList, stdDevVolatilityList, valList, val1List, val2List, val3List, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateKaseSerialDependencyIndex(StockData stockDataClass, int days)
        {
            //sdiUp = ln(H[N-1]/L[0])/V
            //sdiDown = ln(L[N-1]/H[0])/V
            //H[N-1] =   high n bars ago
            //H[0]=   this barís high
            //L[N-1] =   low n bars ago
            //L[0]=   this barís low
            //V=historical volatility over n bars
            //N=a number from n1 to n2 that gives the highest resultant value for the index.

            //Kase Serial Dependency Index
            //Volatility = stddev(ln(P / P[1])[n])
            //KSDI(up) = (ln(H[0] / L[n])) / volatility[n]
            //KSDI(down) = (ln(L[0] / H[n]) / volatility[n]
            List<decimal> ksdiUpList = new();
            List<decimal> ksdiDownList = new();
            List<decimal> tempList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int h = 0; h < stockDataClass.HighPrices.Count; h++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(h);
                    decimal prevValue = h >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(h - 1) : 0;
                    decimal temp = prevValue != 0 ? currentValue / prevValue : 0;

                    decimal tempLog = temp > 0 ? (decimal)Log((double)temp) : 0;
                    tempList.Add(tempLog);
                }

                List<decimal> stdDevList = CalculateStandardDeviationVolatility(tempList, stockDataClass, days).Item4;
                for (int i = 0; i < stockDataClass.HighPrices.Count; i++)
                {
                    decimal currentHigh = stockDataClass.HighPrices.ElementAtOrDefault(i);
                    decimal currentLow = stockDataClass.LowPrices.ElementAtOrDefault(i);
                    decimal volatility = stdDevList.ElementAtOrDefault(i);
                    decimal prevHigh = i >= days ? stockDataClass.HighPrices.ElementAtOrDefault(i - days) : 0;
                    decimal prevLow = i >= days ? stockDataClass.LowPrices.ElementAtOrDefault(i - days) : 0;
                    decimal ksdiUpTemp = prevLow != 0 ? currentHigh / prevLow : 0;
                    decimal ksdiDownTemp = prevHigh != 0 ? currentLow / prevHigh : 0;
                    decimal ksdiUpLog = ksdiUpTemp > 0 ? (decimal)Log((double)ksdiUpTemp) : 0;
                    decimal ksdiDownLog = ksdiDownTemp > 0 ? (decimal)Log((double)ksdiDownTemp) : 0;

                    decimal prevKsdiUp = ksdiUpList.LastOrDefault();
                    decimal ksdiUp = volatility != 0 ? ksdiUpLog / volatility : 0;
                    ksdiUpList.Add(ksdiUp);

                    decimal prevKsdiDown = ksdiDownList.LastOrDefault();
                    decimal ksdiDown = volatility != 0 ? ksdiDownLog / volatility : 0;
                    ksdiDownList.Add(ksdiDown);

                    var signal = GetCompareSignal(ksdiUp - ksdiDown, prevKsdiUp - prevKsdiDown);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (ksdiUpList, ksdiDownList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateKirshenbaumBands(StockData stockDataClass, int days = 20)
        {
            //input = price, user defined, default is closing price
            //method = moving average (ma), user defined, default is EMA
            //period1 = user defined, default is 30
            //period2 = user defined, default is 20
            //noSdDev = number of standard deviations, user defined, default is 1

            //stdErr = standard error, index = current bar number

            //ma = ma(method, index, period1, input);
            //sdErr = stdErr(period2, index, input);
            //topBand = ma + (sdErr * noSdDev);
            //bottBand = ma - (sdErr * noSdDev);
            List<decimal> topList = new();
            List<decimal> bottomList = new();
            List<Signal> signalsList = new();

            try
            {
                decimal currentStdDeviation = 1;
                int period1 = (int)Math.Ceiling(days / 0.6667);
                int period2 = days;

                var emaList = CalculateExponentialMovingAverage(stockDataClass, period1).Item1;
                var stdErrorList = CalculateLinearRegression(null, stockDataClass, period2).Item17;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal currentEma = emaList.ElementAtOrDefault(i);
                    decimal currentStdError = stdErrorList.ElementAtOrDefault(i);
                    decimal ratio = currentStdError * currentStdDeviation;
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal prevTop = topList.LastOrDefault();
                    decimal top = currentEma + ratio;
                    topList.Add(top);

                    decimal prevBottom = bottomList.LastOrDefault();
                    decimal bottom = currentEma - ratio;
                    bottomList.Add(bottom);

                    var signal = GetBullishBearishSignal(currentValue - top, prevValue - prevTop, currentValue - bottom, prevValue - prevBottom);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (topList, bottomList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateMovingAverageSupportResistance(StockData stockDataClass, int days = 10)
        {
            //input = price, user defined, default is closing price
            //method = moving average = ma, user defined, default is SMA
            //period = user defined, default is 10
            //fac = percent factor = user defined, default is 2
            //index = current bar number6

            //masr = ma(method, index, period, input);
            //suppLevel = (1 + (fac / 100));
            //Plot1: top = masr * suppLevel;
            //Plot2: bott = masr / suppLevel;
            decimal fac = 2;
            List<decimal> topList = new();
            List<decimal> bottomList = new();
            List<Signal> signalsList = new();

            try
            {
                decimal supportLevel = 1 + (fac / 100);

                var smaList = CalculateSimpleMovingAverage(stockDataClass, days).Item1;

                for (int i = 0; i < smaList.Count; i++)
                {
                    decimal currentSma = smaList.ElementAtOrDefault(i);
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevSma = i >= 1 ? smaList.ElementAtOrDefault(i - 1) : 0;

                    decimal top = currentSma * supportLevel;
                    topList.Add(top);

                    decimal bottom = supportLevel != 0 ? currentSma / supportLevel : 0;
                    bottomList.Add(bottom);

                    var signal = GetCompareSignal(currentValue - currentSma, prevValue - prevSma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (topList, bottomList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateUltimateVolatilityIndicator(StockData stockDataClass, string maType, int days = 10)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Ultimate Volatility Indicator [CC] script may be freely distributed under the MIT license.
            //study("Ultimate Volatility Indicator [CC]", overlay = false)

            //f_security(_symbol, _res, _src, _repaint) => 
            //    security(_symbol, _res, _src[_repaint ? 0 : barstate.isrealtime ? 1 : 0])[_repaint ? 0 : barstate.isrealtime ? 0 : 1]


            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //length = input(title = "Length", type = input.integer, defval = 14, minval = 1)
            //o = f_security(syminfo.tickerid, res, open, rep)
            //c = f_security(syminfo.tickerid, res, close, rep)
            //threshold = input(title = "Threshold", type = input.integer, defval = 1, minval = 1)

            //uvi = (1 / length) * sum(abs(c - o), length)
            //ema = ema(c, length)

            //hline(threshold)
            //sig = uvi > threshold and c > ema ? 2 : uvi > threshold and c<ema ? -2 : c > ema ? 1 : c < ema ? -1 : 0
            //alertcondition(crossover(sig, 1), "Strong Buy Signal", "Strong Bullish Change Detected")
            //alertcondition(crossunder(sig, -1), "Strong Sell Signal", "Strong Bearish Change Detected")
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //uviColor = sig > 1 ? color.green : sig > 0 ? color.lime : sig < -1 ? color.maroon : sig < 0 ? color.red : color.black
            //barcolor(bar ? uviColor : na)
            //plot(uvi, title = "UVI", linewidth = 2, color = uviColor)
            List<decimal> uviList = new();
            List<decimal> absList = new();
            List<Signal> signalsList = new();

            try
            {
                var maList = GetMovingAverageList(maType, null, stockDataClass, days);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentOpen = stockDataClass.OpenPrices.ElementAtOrDefault(i);
                    decimal currentClose = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal currentMa = maList.ElementAtOrDefault(i);
                    decimal prevClose = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevMa = i >= 1 ? maList.ElementAtOrDefault(i - 1) : 0;

                    decimal abs = Math.Abs(currentClose - currentOpen);
                    absList.Add(abs);

                    decimal uvi = (decimal)1 / days * absList.TakeLast(days).Sum();
                    uviList.Add(uvi);

                    var signal = GetVolatilitySignal(currentClose - currentMa, prevClose - prevMa, uvi, 1);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (absList, uviList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateFoldedRelativeStrengthIndex(StockData stockDataClass, string maType, int days = 14)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Folded Relative Strength Index [CC] script may be freely distributed under the MIT license.
            //study("Folded Relative Strength Index [CC]", overlay = false)

            //inp = input(title = "Source", type = input.source, defval = close)
            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //src = security(syminfo.tickerid, res, inp[rep ? 0 : barstate.isrealtime ? 1 : 0])[rep ? 0 : barstate.isrealtime ? 0 : 1]
            //length = input(title = "Length", type = input.integer, defval = 14, minval = 1)
            //obLevel = input(title = "ObLevel", type = input.integer, defval = 50, minval = 1)
            //osLevel = input(title = "OsLevel", type = input.integer, defval = 10, minval = 1)

            //rsi = rsi(src, length)
            //frsi = (1 / length) * sum(2 * abs(rsi - 50), length)
            //frsiSig = ema(frsi, length)

            //hline(obLevel, color = color.green)
            //hline(osLevel, color = color.red)
            //sig = nz(frsi[1]) < osLevel and frsi > osLevel ? 1 : nz(frsi[1]) > obLevel and frsi<obLevel ? -1 : frsi > frsiSig ? 1 : frsi < frsiSig ? -1 : 0
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //frsiColor = sig > 0 ? color.green : sig < 0 ? color.red : color.black
            //barcolor(bar ? frsiColor : na)
            //plot(frsi, title = "FoldedRSI", color = frsiColor, linewidth = 2)
            //plot(frsiSig, title = "FRSISig", color = color.black, linewidth = 1)
            List<decimal> absRsiList = new();
            List<decimal> frsiList = new();
            List<decimal> frsiMaList = new();
            List<Signal> signalsList = new();

            try
            {
                var rsiList = CalculateRelativeStrengthIndex(null, stockDataClass, maType, days).Item4;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal rsi = rsiList.ElementAtOrDefault(i);

                    decimal absRsi = 2 * Math.Abs(rsi - 50);
                    absRsiList.Add(absRsi);

                    decimal frsi = absRsiList.TakeLast(days).Sum();
                    frsiList.Add(frsi);
                }

                frsiMaList = GetMovingAverageList(maType, frsiList, stockDataClass, days);
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal frsi = frsiList.ElementAtOrDefault(j);
                    decimal frsiMa = frsiMaList.ElementAtOrDefault(j);
                    decimal prevFrsi = j >= 1 ? frsiList.ElementAtOrDefault(j - 1) : 0;
                    decimal prevFrsiMa = j >= 1 ? frsiMaList.ElementAtOrDefault(j - 1) : 0;

                    var signal = GetRsiSignal(frsi - frsiMa, prevFrsi - prevFrsiMa, frsi, prevFrsi, 50, 10);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (absRsiList, frsiList, frsiMaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateTechnicalRatings(StockData stockDataClass, string maType, int days = 2)
        {
            //@version=4
            //study(title = "Technical Ratings", shorttitle = "Technicals", precision = 2)
            //res = input("", title = "Indicator Timeframe", type = input.resolution)
            //ratingSignal = input(defval = "All", title = "Rating is based on", options = ["MAs", "Oscillators", "All"])
            // Awesome Oscillator
            //AO() => 
            //    sma(hl2, 5) - sma(hl2, 34)
            // Stochastic RSI
            //StochRSI() =>
            //    rsi1 = rsi(close, 14)
            //    K = sma(stoch(rsi1, rsi1, rsi1, 14), 3)
            //    D = sma(K, 3)
            //    [K, D]
            // Ultimate Oscillator
            //tl() => close[1] < low ? close[1] : low
            //uo(ShortLen, MiddlLen, LongLen) =>
            //    Value1 = sum(tr, ShortLen)
            //    Value2 = sum(tr, MiddlLen)
            //    Value3 = sum(tr, LongLen)
            //    Value4 = sum(close - tl(), ShortLen)
            //    Value5 = sum(close - tl(), MiddlLen)
            //    Value6 = sum(close - tl(), LongLen)
            //    float UO = na
            //    if Value1 != 0 and Value2 != 0 and Value3 != 0
            //        var0 = LongLen / ShortLen
            //        var1 = LongLen / MiddlLen
            //        Value7 = (Value4 / Value1) * (var0)
            //        Value8 = (Value5 / Value2) * (var1)
            //        Value9 = (Value6 / Value3)
            //        UO:= (Value7 + Value8 + Value9) / (var0 + var1 + 1)
            //    UO
            // Ichimoku Cloud
            //donchian(len) => avg(lowest(len), highest(len))
            //ichimoku_cloud() =>
            //    conversionLine = donchian(9)
            //    baseLine = donchian(26)
            //    leadLine1 = avg(conversionLine, baseLine)
            //    leadLine2 = donchian(52)
            //    [conversionLine, baseLine, leadLine1, leadLine2]

            //calcRatingMA(ma, src) => na(ma) or na(src) ? na: (ma == src ? 0 : (ma < src ? 1 : -1))
            //calcRating(buy, sell) => buy ? 1 : (sell ? -1 : 0)
            //calcRatingAll() =>
            //============== MA =================
            //    SMA10 = sma(close, 10)
            //    SMA20 = sma(close, 20)
            //    SMA30 = sma(close, 30)
            //    SMA50 = sma(close, 50)
            //    SMA100 = sma(close, 100)
            //    SMA200 = sma(close, 200)

            //    EMA10 = ema(close, 10)
            //    EMA20 = ema(close, 20)
            //    EMA30 = ema(close, 30)
            //    EMA50 = ema(close, 50)
            //    EMA100 = ema(close, 100)
            //    EMA200 = ema(close, 200)

            //    HullMA9 = hma(close, 9)

            // Volume Weighted Moving Average (VWMA)
            //        VWMA = vwma(close, 20)

            //[IC_CLine, IC_BLine, IC_Lead1, IC_Lead2] = ichimoku_cloud()

            // ======= Other =============
            // Relative Strength Index, RSI
            //        RSI = rsi(close, 14)

            // Stochastic
            //lengthStoch = 14
            //smoothKStoch = 3
            //smoothDStoch = 3
            //kStoch = sma(stoch(close, high, low, lengthStoch), smoothKStoch)
            //dStoch = sma(kStoch, smoothDStoch)

            // Commodity Channel Index, CCI
            //        CCI = cci(close, 20)

            // Average Directional Index
            //        float adxValue = na, float adxPlus = na, float adxMinus = na
            //[P, M, V] = dmi(14, 14)
            //adxValue:= V
            //adxPlus:= P
            //adxMinus:= M
            // Awesome Oscillator
            //ao = AO()

            // Momentum
            //        Mom = mom(close, 10)
            // Moving Average Convergence/Divergence, MACD
            //[macdMACD, signalMACD, _] = macd(close, 12, 26, 9)
            // Stochastic RSI
            //[Stoch_RSI_K, Stoch_RSI_D] = StochRSI()
            // Williams Percent Range
            //WR = wpr(14)

            // Bull / Bear Power
            //        BullPower = high - ema(close, 13)
            //        BearPower = low - ema(close, 13)
            // Ultimate Oscillator
            //UO = uo(7, 14, 28)
            //if not na(UO)
            //    UO:= UO * 100
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            //PriceAvg = ema(close, 50)
            //DownTrend = close < PriceAvg
            //UpTrend = close > PriceAvg
            // calculate trading recommendation based on SMA/EMA
            //float ratingMA = 0
            //float ratingMAC = 0

            //if not na(SMA10)
            //    ratingMA:= ratingMA + calcRatingMA(SMA10, close)
            //    ratingMAC:= ratingMAC + 1
            //if not na(SMA20)
            //    ratingMA:= ratingMA + calcRatingMA(SMA20, close)
            //    ratingMAC:= ratingMAC + 1
            //if not na(SMA30)
            //    ratingMA:= ratingMA + calcRatingMA(SMA30, close)
            //    ratingMAC:= ratingMAC + 1
            //if not na(SMA50)
            //    ratingMA:= ratingMA + calcRatingMA(SMA50, close)
            //    ratingMAC:= ratingMAC + 1
            //if not na(SMA100)
            //    ratingMA:= ratingMA + calcRatingMA(SMA100, close)
            //    ratingMAC:= ratingMAC + 1
            //if not na(SMA200)
            //    ratingMA:= ratingMA + calcRatingMA(SMA200, close)
            //    ratingMAC:= ratingMAC + 1
            //if not na(EMA10)
            //    ratingMA:= ratingMA + calcRatingMA(EMA10, close)
            //    ratingMAC:= ratingMAC + 1
            //if not na(EMA20)
            //    ratingMA:= ratingMA + calcRatingMA(EMA20, close)
            //    ratingMAC:= ratingMAC + 1
            //if not na(EMA30)
            //    ratingMA:= ratingMA + calcRatingMA(EMA30, close)
            //    ratingMAC:= ratingMAC + 1
            //if not na(EMA50)
            //    ratingMA:= ratingMA + calcRatingMA(EMA50, close)
            //    ratingMAC:= ratingMAC + 1
            //if not na(EMA100)
            //    ratingMA:= ratingMA + calcRatingMA(EMA100, close)
            //    ratingMAC:= ratingMAC + 1
            //if not na(EMA200)
            //    ratingMA:= ratingMA + calcRatingMA(EMA200, close)
            //    ratingMAC:= ratingMAC + 1

            //if not na(HullMA9)
            //    ratingHullMA9 = calcRatingMA(HullMA9, close)
            //    ratingMA:= ratingMA + ratingHullMA9
            //    ratingMAC:= ratingMAC + 1

            //if not na(VWMA)
            //    ratingVWMA = calcRatingMA(VWMA, close)
            //    ratingMA:= ratingMA + ratingVWMA
            //    ratingMAC:= ratingMAC + 1

            //float ratingIC = na
            //if not(na(IC_Lead1) or na(IC_Lead2) or na(close) or na(close[1]) or na(IC_BLine) or na(IC_CLine))
            //    ratingIC:= calcRating(
            //    IC_Lead1 > IC_Lead2 and close > IC_Lead1 and close < IC_BLine and close[1] < IC_CLine and close > IC_CLine,
            //    IC_Lead2 > IC_Lead1 and close < IC_Lead2 and close > IC_BLine and close[1] > IC_CLine and close < IC_CLine)
            //if not na(ratingIC)
            //    ratingMA:= ratingMA + ratingIC
            //    ratingMAC:= ratingMAC + 1

            //ratingMA:= ratingMAC > 0 ? ratingMA / ratingMAC : na

            //float ratingOther = 0
            //float ratingOtherC = 0

            //ratingRSI = RSI
            //if not(na(ratingRSI) or na(ratingRSI[1]))
            //    ratingOtherC:= ratingOtherC + 1
            //    ratingOther:= ratingOther + calcRating(ratingRSI < 30 and ratingRSI[1] < ratingRSI, ratingRSI > 70 and ratingRSI[1] > ratingRSI)

            //if not(na(kStoch) or na(dStoch) or na(kStoch[1]) or na(dStoch[1]))
            //    ratingOtherC:= ratingOtherC + 1
            //    ratingOther:= ratingOther + calcRating(kStoch < 20 and dStoch < 20 and kStoch > dStoch and kStoch[1] < dStoch[1], kStoch > 80 and dStoch > 80 and kStoch < dStoch and kStoch[1] > dStoch[1])

            //ratingCCI = CCI
            //if not(na(ratingCCI) or na(ratingCCI[1]))
            //    ratingOtherC:= ratingOtherC + 1
            //    ratingOther:= ratingOther + calcRating(ratingCCI < -100 and ratingCCI > ratingCCI[1], ratingCCI > 100 and ratingCCI < ratingCCI[1])

            //if not(na(adxValue) or na(adxPlus[1]) or na(adxMinus[1]) or na(adxPlus) or na(adxMinus))
            //    ratingOtherC:= ratingOtherC + 1
            //    ratingOther:= ratingOther + calcRating(adxValue > 20 and adxPlus[1] < adxMinus[1] and adxPlus > adxMinus, adxValue > 20 and adxPlus[1] > adxMinus[1] and adxPlus < adxMinus)

            //if not(na(ao) or na(ao[1]))
            //    ratingOtherC:= ratingOtherC + 1
            //    ratingOther:= ratingOther + calcRating(crossover(ao, 0) or(ao > 0 and ao[1] > 0 and ao > ao[1] and ao[2] > ao[1]), crossunder(ao, 0) or(ao < 0 and ao[1] < 0 and ao < ao[1] and ao[2] < ao[1]))

            //if not(na(Mom) or na(Mom[1]))
            //    ratingOtherC:= ratingOtherC + 1
            //    ratingOther:= ratingOther + calcRating(Mom > Mom[1], Mom < Mom[1])

            //if not(na(macdMACD) or na(signalMACD))
            //    ratingOtherC:= ratingOtherC + 1
            //    ratingOther:= ratingOther + calcRating(macdMACD > signalMACD, macdMACD < signalMACD)

            //float ratingStoch_RSI = na
            //if not(na(DownTrend) or na(UpTrend) or na(Stoch_RSI_K) or na(Stoch_RSI_D) or na(Stoch_RSI_K[1]) or na(Stoch_RSI_D[1]))
            //    ratingStoch_RSI:= calcRating(
            //    DownTrend and Stoch_RSI_K < 20 and Stoch_RSI_D < 20 and Stoch_RSI_K > Stoch_RSI_D and Stoch_RSI_K[1] < Stoch_RSI_D[1],
            //    UpTrend and Stoch_RSI_K > 80 and Stoch_RSI_D > 80 and Stoch_RSI_K < Stoch_RSI_D and Stoch_RSI_K[1] > Stoch_RSI_D[1])
            //if not na(ratingStoch_RSI)
            //    ratingOtherC:= ratingOtherC + 1
            //    ratingOther:= ratingOther + ratingStoch_RSI

            //float ratingWR = na
            //if not(na(WR) or na(WR[1]))
            //    ratingWR:= calcRating(WR < -80 and WR > WR[1], WR > -20 and WR < WR[1])
            //if not na(ratingWR)
            //    ratingOtherC:= ratingOtherC + 1
            //    ratingOther:= ratingOther + ratingWR

            //float ratingBBPower = na
            //if not(na(UpTrend) or na(DownTrend) or na(BearPower) or na(BearPower[1]) or na(BullPower) or na(BullPower[1]))
            //    ratingBBPower:= calcRating(
            //    UpTrend and BearPower < 0 and BearPower > BearPower[1],
            //    DownTrend and BullPower > 0 and BullPower < BullPower[1])
            //if not na(ratingBBPower)
            //    ratingOtherC:= ratingOtherC + 1
            //    ratingOther:= ratingOther + ratingBBPower

            //float ratingUO = na
            //if not(na(UO))
            //    ratingUO:= calcRating(UO > 70, UO < 30)
            //if not na(ratingUO)
            //    ratingOtherC:= ratingOtherC + 1
            //    ratingOther:= ratingOther + ratingUO

            //ratingOther:= ratingOtherC > 0 ? ratingOther / ratingOtherC : na

            //float ratingTotal = 0
            //float ratingTotalC = 0
            //if not na(ratingMA)
            //    ratingTotal:= ratingTotal + ratingMA
            //    ratingTotalC:= ratingTotalC + 1
            //if not na(ratingOther)
            //    ratingTotal:= ratingTotal + ratingOther
            //    ratingTotalC:= ratingTotalC + 1
            //ratingTotal:= ratingTotalC > 0 ? ratingTotal / ratingTotalC : na

            //[ratingTotal, ratingOther, ratingMA, ratingOtherC, ratingMAC]
            //[ratingTotal, ratingOther, ratingMA, ratingOtherC, ratingMAC] = security(syminfo.tickerid, res, calcRatingAll())
            //StrongBound = 0.5
            //WeakBound = 0.1
            //getSignal(ratingTotal, ratingOther, ratingMA) =>
            //    float _res = ratingTotal
            //    if ratingSignal == "MAs"
            //        _res:= ratingMA
            //    if ratingSignal == "Oscillators"
            //        _res:= ratingOther
            //    _res
            //tradeSignal = getSignal(ratingTotal, ratingOther, ratingMA)

            //poscol = input(color.blue, "Buy Color")
            //neutralcolor = input(color.gray, "Neutral Color")
            //negcol = input(color.red, "Sell Color")
            //poscond = tradeSignal > WeakBound
            //negcond = tradeSignal < -WeakBound
            //posseries = poscond ? tradeSignal : 0
            //negseries = negcond ? tradeSignal : 0
            //count_rising(plot) =>
            //    v_plot = plot > 0 ? plot : -plot
            //    var count = 0
            //    if v_plot == 0
            //        count:= 0
            //    else if v_plot >= v_plot[1]
            //        count:= min(5, count + 1)
            //    else if v_plot < v_plot[1]
            //        count:= max(1, count - 1)
            //    count
            //poscount = count_rising(posseries)
            //negcount = count_rising(negseries)
            //_pc = poscond ? poscount : negcond ? negcount : 0
            //colorTransp(col, transp) =>
            //    red = color.r(col)
            //    green = color.g(col)
            //    blue = color.b(col)
            //    color.rgb(red, green, blue, transp)
            //hline(1, color = colorTransp(poscol, 50), linestyle = hline.style_solid)
            //hline(0.5, color = colorTransp(poscol, 50), linestyle = hline.style_dashed)
            //hline(-1, color = colorTransp(negcol, 50), linestyle = hline.style_solid)
            //hline(-0.5, color = colorTransp(negcol, 50), linestyle = hline.style_dashed)
            //getTimeOfNextBar() =>
            //    currentTime = time(timeframe.period)
            //    changeTime = change(currentTime)
            //    minChange = if (not na(changeTime))
            //        var float minChange = changeTime
            //        minChange:= min(minChange, changeTime)
            //    int(currentTime + minChange)
            //drawInfo(txt, value) =>
            //    var info = label.new(0, 0, "", yloc = yloc.price, xloc = xloc.bar_time, textalign = text.align_left, textcolor = color.white)
            //    label.set_x(info, getTimeOfNextBar())
            //    label.set_text(info, txt)
            //    label.set_color(info, poscond ? poscol : negcond ? negcol : color.gray)
            //    label.set_style(info, label.style_label_left)
            //calcRatingStatus(value) =>
            //    if -StrongBound > value
            //        "Strong Sell"
            //    else if value < -WeakBound
            //        "Sell"
            //    else if value > StrongBound
            //        "Strong Buy"
            //    else if value > WeakBound
            //        "Buy"
            //    else
            //                "Neutral"
            //MAText = ratingMAC == 0 ? "" : "MAs:     " + calcRatingStatus(ratingMA) + "\n"
            //OtherText = ratingOtherC == 0 ? "" : "Oscillators: " + calcRatingStatus(ratingOther) + "\n"
            //TotaText = "All:  " + calcRatingStatus(ratingTotal)
            //drawInfo(MAText + OtherText + TotaText, tradeSignal)
            //col_buy = color.from_gradient(tradeSignal, 0.0, 0.2, neutralcolor, poscol)
            //col_sell = color.from_gradient(tradeSignal, -0.2, 0.0, negcol, neutralcolor)
            //col_gradient = color.from_gradient(tradeSignal, -0.2, 0.2, col_sell, col_buy)
            //plot(tradeSignal, title = "Rating", linewidth = 1, style = plot.style_columns, color = colorTransp(col_gradient, 50 - _pc * 10))
            //_cond1 = crossunder(tradeSignal, -WeakBound)
            //alertcondition(_cond1, "Sell", "Ratings changed to Sell")
            //_cond2 = crossover(tradeSignal, WeakBound)
            //alertcondition(_cond2, "Buy", "Ratings changed to Buy")
            //_cond3 = crossunder(tradeSignal, -StrongBound)
            //alertcondition(_cond3, "Strong Sell", "Ratings changed to Strong Sell")
            //_cond4 = crossover(tradeSignal, StrongBound)
            //alertcondition(_cond4, "Strong Buy", "Ratings changed to Strong Buy")
            List<decimal> maRatingList = new();
            List<decimal> oscRatingList = new();
            List<decimal> totalRatingList = new();
            List<Signal> signalsList = new();

            try
            {
                var rsiList = CalculateRelativeStrengthIndex(null, stockDataClass, maType, days).Item4;
                var aoList = CalculateAwesomeOscillator(stockDataClass, maType, days).Item1;
                var stoRsiList = CalculateStochasticOscillator(rsiList, stockDataClass, maType, days);
                var macdList = CalculateMovingAverageConvergenceDivergence(stockDataClass, maType, days);
                var uoList = CalculateUltimateOscillator(stockDataClass, days).Item12;
                var ichiMokuList = CalculateIchimokuCloud(stockDataClass, days);
                var adxList = CalculateAverageDirectionalIndex(stockDataClass, maType, days);
                var cciList = CalculateCommodityChannelIndex(stockDataClass, days).Item4;
                var bullBearPowerList = CalculateElderRayBearandBullPower(stockDataClass, maType, days);
                var hullMaList = CalculateHullMovingAverage(stockDataClass, maType, days).Item2;
                var williamsPctList = CalculateWilliamsR(stockDataClass, days).Item1;
                var vwmaList = CalculateVolumeWeightedMovingAverage(stockDataClass, maType, days).Item3;
                var stoList = CalculateStochasticOscillator(null, stockDataClass, maType, days);
                var ma10List = GetMovingAverageList(maType, null, stockDataClass, days);
                var ma20List = GetMovingAverageList(maType, null, stockDataClass, days * 2);
                var ma30List = GetMovingAverageList(maType, null, stockDataClass, days * 3);
                var ma50List = GetMovingAverageList(maType, null, stockDataClass, days * 5);
                var ma100List = GetMovingAverageList(maType, null, stockDataClass, days * 10);
                var ma200List = GetMovingAverageList(maType, null, stockDataClass, days * 20);
                var momList = CalculateKurtosisIndicator(stockDataClass, maType, days).Item1;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal rsi = rsiList.ElementAtOrDefault(i);
                    decimal prevRsi = i >= 1 ? rsiList.ElementAtOrDefault(i - 1) : 0;
                    decimal ma10 = ma10List.ElementAtOrDefault(i);
                    decimal ma20 = ma20List.ElementAtOrDefault(i);
                    decimal ma30 = ma30List.ElementAtOrDefault(i);
                    decimal ma50 = ma50List.ElementAtOrDefault(i);
                    decimal ma100 = ma100List.ElementAtOrDefault(i);
                    decimal ma200 = ma200List.ElementAtOrDefault(i);
                    decimal hullMa = hullMaList.ElementAtOrDefault(i);
                    decimal vwma = vwmaList.ElementAtOrDefault(i);
                    decimal conLine = ichiMokuList.Item1.ElementAtOrDefault(i);
                    decimal baseLine = ichiMokuList.Item2.ElementAtOrDefault(i);
                    decimal leadLine1 = ichiMokuList.Item3.ElementAtOrDefault(i);
                    decimal leadLine2 = ichiMokuList.Item4.ElementAtOrDefault(i);
                    decimal kSto = stoList.Item4.ElementAtOrDefault(i);
                    decimal prevKSto = i >= 1 ? stoList.Item4.ElementAtOrDefault(i - 1) : 0;
                    decimal dSto = stoList.Item5.ElementAtOrDefault(i);
                    decimal prevDSto = i >= 1 ? stoList.Item5.ElementAtOrDefault(i - 1) : 0;
                    decimal cci = cciList.ElementAtOrDefault(i);
                    decimal prevCci = i >= 1 ? cciList.ElementAtOrDefault(i - 1) : 0;
                    decimal adx = adxList.Item10.ElementAtOrDefault(i);
                    decimal adxPlus = adxList.Item5.ElementAtOrDefault(i);
                    decimal prevAdxPlus = i >= 1 ? adxList.Item5.ElementAtOrDefault(i - 1) : 0;
                    decimal adxMinus = adxList.Item6.ElementAtOrDefault(i);
                    decimal prevAdxMinus = i >= 1 ? adxList.Item6.ElementAtOrDefault(i - 1) : 0;
                    decimal ao = aoList.ElementAtOrDefault(i);
                    decimal prevAo1 = i >= 1 ? aoList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevAo2 = i >= 2 ? aoList.ElementAtOrDefault(i - 2) : 0;
                    decimal mom = momList.ElementAtOrDefault(i);
                    decimal prevMom = i >= 1 ? momList.ElementAtOrDefault(i - 1) : 0;
                    decimal macd = macdList.Item1.ElementAtOrDefault(i);
                    decimal macdSig = macdList.Item2.ElementAtOrDefault(i);
                    decimal kStoRsi = stoRsiList.Item4.ElementAtOrDefault(i);
                    decimal prevKStoRsi = i >= 1 ? stoRsiList.Item4.ElementAtOrDefault(i - 1) : 0;
                    decimal dStoRsi = stoRsiList.Item5.ElementAtOrDefault(i);
                    decimal prevDStoRsi = i >= 1 ? stoRsiList.Item5.ElementAtOrDefault(i - 1) : 0;
                    bool upTrend = currentValue > ma50;
                    bool dnTrend = currentValue < ma50;
                    decimal wr = williamsPctList.ElementAtOrDefault(i);
                    decimal prevWr = i >= 1 ? williamsPctList.ElementAtOrDefault(i - 1) : 0;
                    decimal bullPower = bullBearPowerList.Item1.ElementAtOrDefault(i);
                    decimal prevBullPower = i >= 1 ? bullBearPowerList.Item1.ElementAtOrDefault(i - 1) : 0;
                    decimal bearPower = bullBearPowerList.Item2.ElementAtOrDefault(i);
                    decimal prevBearPower = i >= 1 ? bullBearPowerList.Item2.ElementAtOrDefault(i - 1) : 0;
                    decimal uo = uoList.ElementAtOrDefault(i);

                    decimal maRating = 0;
                    maRating += currentValue > ma10 ? 1 : currentValue < ma10 ? -1 : 0;
                    maRating += currentValue > ma20 ? 1 : currentValue < ma20 ? -1 : 0;
                    maRating += currentValue > ma30 ? 1 : currentValue < ma30 ? -1 : 0;
                    maRating += currentValue > ma50 ? 1 : currentValue < ma50 ? -1 : 0;
                    maRating += currentValue > ma100 ? 1 : currentValue < ma100 ? -1 : 0;
                    maRating += currentValue > ma200 ? 1 : currentValue < ma200 ? -1 : 0;
                    maRating += currentValue > hullMa ? 1 : currentValue < hullMa ? -1 : 0;
                    maRating += currentValue > vwma ? 1 : currentValue < vwma ? -1 : 0;
                    maRating += leadLine1 > leadLine2 && currentValue > leadLine1 && currentValue < baseLine && prevValue < conLine && currentValue > conLine ? 1 : leadLine2 > leadLine1 &&
                        currentValue < leadLine2 && currentValue > baseLine && prevValue > conLine && currentValue < conLine ? -1 : 0;
                    maRating /= 9;
                    maRatingList.Add(maRating);

                    decimal oscRating = 0;
                    oscRating += rsi < 30 && prevRsi < rsi ? 1 : rsi > 70 && prevRsi > rsi ? -1 : 0;
                    oscRating += kSto < 20 && dSto < 20 && kSto > dSto && prevKSto < prevDSto ? 1 : kSto > 80 && dSto > 80 && kSto < dSto && prevKSto > prevDSto ? -1 : 0;
                    oscRating += cci < -100 && cci > prevCci ? 1 : cci > 100 && cci < prevCci ? -1 : 0;
                    oscRating += adx > 20 && prevAdxPlus < prevAdxMinus && adxPlus > adxMinus ? 1 : adx > 20 && prevAdxPlus > prevAdxMinus && adxPlus < adxMinus ? -1 : 0;
                    oscRating += (ao > 0 && prevAo1 < 0) || (ao > 0 && prevAo1 > 0 && ao > prevAo1 && prevAo2 > prevAo1) ? 1 : (ao < 0 && prevAo1 > 0) || (ao < 0 && prevAo1 < 0 && ao < prevAo1 && prevAo2 < prevAo1) ? -1 : 0;
                    oscRating += mom > prevMom ? 1 : mom < prevMom ? -1 : 0;
                    oscRating += macd > macdSig ? 1 : macd < macdSig ? -1 : 0;
                    oscRating += dnTrend && kStoRsi < 20 && dStoRsi < 20 && kStoRsi > dStoRsi && prevKStoRsi < prevDStoRsi ? 1 : upTrend && kStoRsi > 80 && dStoRsi > 80 && kStoRsi < dStoRsi && prevKStoRsi > prevDStoRsi ? -1 : 0;
                    oscRating += wr < -80 && wr > prevWr ? 1 : wr > -20 && wr < prevWr ? -1 : 0;
                    oscRating += upTrend && bearPower < 0 && bearPower > prevBearPower ? 1 : dnTrend && bullPower > 0 && bullPower < prevBullPower ? -1 : 0;
                    oscRating += uo > 70 ? 1 : uo < 30 ? -1 : 0;
                    oscRating /= 11;
                    oscRatingList.Add(oscRating);

                    decimal totalRating = (maRating + oscRating) / 2;
                    totalRatingList.Add(totalRating);

                    var signal = GetConditionSignal(totalRating > 0.1m, totalRating < -0.1m);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (maRatingList, oscRatingList, totalRatingList, signalsList);
        }

        public static (List<decimal>, List<Signal>) CalculateWilliamsR(StockData stockDataClass, int days = 14)
        {
            //period = user defined, default is 14
            //index = current bar number

            // Find the highest high and lowest low over the period
            //highest = highest(index, period, HIGH);
            //lowest = lowest(index, period, LOW);
            //WR = ((high - close) / (high - low)) * (-100);
            // Signals
            //buy = crossedAbove(WR, topGuide);
            //sell = crossedBelow(WR, bottomGuide);
            List<decimal> williamsRList = new();
            List<Signal> signalsList = new();

            try
            {
                var minMaxList = VolumeInputCheck(stockDataClass, days, true);
                var highestList = minMaxList.Item1;
                var lowestList = minMaxList.Item2;

                for (int i = 0; i < stockDataClass.HighPrices.Count; i++)
                {
                    decimal currentClose = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal highestHigh = highestList.ElementAtOrDefault(i);
                    decimal lowestLow = lowestList.ElementAtOrDefault(i);
                    decimal prevWilliamsR1 = i >= 1 ? williamsRList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevWilliamsR2 = i >= 2 ? williamsRList.ElementAtOrDefault(i - 2) : 0;

                    decimal williamsR = highestHigh - lowestLow != 0 ? -100 * (highestHigh - currentClose) / (highestHigh - lowestLow) : -100;
                    williamsRList.Add(williamsR);

                    var signal = GetRsiSignal(williamsR - prevWilliamsR1, prevWilliamsR1 - prevWilliamsR2, williamsR, prevWilliamsR1, -20, -80);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (williamsRList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateRelativeStrengthIndex(
            List<decimal>? customValuesList, StockData stockDataClass, string maType, int days = 14)
        {
            //input = price, user defined, default is closing price
            //method = moving average (ma), user defined, default is SMMA
            //period = user defined, default is 14
            //index = current bar number

            //diff = price - price[index - 1];
            //up = 0, down = 0;
            //if (diff MT 0) up = diff;
            //else down = abs(diff);
            //avgUp = ma(method, index, period, UP);
            //avgDown = ma(method, index, period, DOWN);
            //dSum = avUp + avDn;
            //Plot RSI = (avUp / dSum) * 100;
            //signals
            //buy = crossedAbove(RSI, topGuide);
            //sell = crossedBelow(RSI, bottomGuide);
            List<decimal> rsiList = new();
            List<decimal> rsList = new();
            List<decimal> lossList = new();
            List<decimal> gainList = new();
            List<decimal> avgLossList = new();
            List<decimal> avgGainList = new();
            List<decimal> rsiSignalList = new();
            List<decimal> rsiHistogramList = new();
            List<Signal> signalsList = new();

            try
            {
                if (customValuesList != null)
                {
                    stockDataClass.InputValues = customValuesList;
                }

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal priceChg = currentValue - prevValue;

                    decimal loss = priceChg < 0 ? Math.Abs(priceChg) : 0;
                    lossList.Add(loss);

                    decimal gain = priceChg > 0 ? priceChg : 0;
                    gainList.Add(gain);
                }

                avgGainList = GetMovingAverageList(maType, gainList, stockDataClass, days);
                avgLossList = GetMovingAverageList(maType, lossList, stockDataClass, days);
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal avgGain = avgGainList.ElementAtOrDefault(j);
                    decimal avgLoss = avgLossList.ElementAtOrDefault(j);

                    decimal rs = avgLoss != 0 ? MinOrMax(avgGain / avgLoss, 1, 0) : 0;
                    rsList.Add(rs);

                    decimal prevRsi = rsiList.LastOrDefault();
                    decimal rsi = avgLoss == 0 ? 100 : avgGain == 0 ? 0 : MinOrMax(100 - (100 / (1 + rs)), 100, 0);
                    rsiList.Add(rsi);

                    decimal rsiSignal = CalculateExponentialMovingAverage(rsi, rsiSignalList.LastOrDefault(), days);
                    rsiSignalList.Add(rsiSignal);

                    decimal prevRsiHistogram = rsiHistogramList.LastOrDefault();
                    decimal rsiHistogram = rsi - rsiSignal;
                    rsiHistogramList.Add(rsiHistogram);

                    var signal = GetRsiSignal(rsiHistogram, prevRsiHistogram, rsi, prevRsi, 70, 30);
                    signalsList.Add(signal);
                }

                // reset the input values list
                stockDataClass = LoadCalculations.GetInputValuesList(stockDataClass.InputName, stockDataClass);
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (avgGainList, avgLossList, rsList, rsiList, rsiSignalList, rsiHistogramList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateLiquidRelativeStrengthIndex(StockData stockDataClass, int days = 14)
        {
            //@version=4
            //study("Liquid RSI", "LRSI")
            //length = input(14),src = input(close)
            //----
            //a = change(src)
            //b = change(volume)
            //c = 100 * rma(max(a, 0) * max(b, 0), length) / rma(abs(a) * abs(b), length)
            //----
            //plot(c, color =#009688,linewidth=2,transp=0)
            //hline(80, color = color.blue, linewidth = 2)
            //hline(20, color = color.orange, linewidth = 2)
            List<decimal> numList = new();
            List<decimal> numEmaList = new();
            List<decimal> denList = new();
            List<decimal> denEmaList = new();
            List<decimal> cList = new();
            List<Signal> signalsList = new();

            try
            {
                decimal k = (decimal)1 / days;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal currentVolume = stockDataClass.Volumes.ElementAtOrDefault(i);
                    decimal prevVolume = i >= 1 ? stockDataClass.Volumes.ElementAtOrDefault(i - 1) : 0;
                    decimal a = currentValue - prevValue;
                    decimal b = currentVolume - prevVolume;
                    decimal prevC1 = i >= 1 ? cList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevC2 = i >= 2 ? cList.ElementAtOrDefault(i - 2) : 0;

                    decimal num = Math.Max(a, 0) * Math.Max(b, 0);
                    numList.Add(num);

                    decimal den = Math.Abs(a) * Math.Abs(b);
                    denList.Add(den);

                    decimal prevNumEma = numEmaList.LastOrDefault();
                    decimal numEma = (num * k) + (prevNumEma * (1 - k));
                    numEmaList.Add(numEma);

                    decimal prevDenEma = denEmaList.LastOrDefault();
                    decimal denEma = (den * k) + (prevDenEma * (1 - k));
                    denEmaList.Add(denEma);

                    decimal c = denEma != 0 ? MinOrMax(100 * numEma / denEma, 100, 0) : 0;
                    cList.Add(c);

                    var signal = GetRsiSignal(c - prevC1, prevC1 - prevC2, c, prevC1, 80, 20);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (numList, denList, numEmaList, denEmaList, cList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateRelativeSpreadStrength(StockData stockDataClass, string maType, int days = 5)
        {
            //@version=3
            // Copyright (c) 2018-present, Alex Orekhov (everget)
            // Relative Spread Strength script may be freely distributed under the MIT license.
            //study("Relative Spread Strength", shorttitle = "RSS")

            //rsiLength = input(title = "RSI Length", type = integer, defval = 14, minval = 1)
            //fastLength = input(title = "Fast MA Length", type = integer, defval = 10, minval = 1)
            //slowLength = input(title = "Slow MA Length", type = integer, defval = 40, minval = 1)
            //smoothingLength = input(title = "Smoothing Length", type = integer, defval = 5, minval = 1)
            //smoothingType = input(title = "Smoothing Type", defval = "EMA", options =["EMA", "SMA"])
            //highLevel = input(title = "High Level", type = integer, defval = 80, maxval = 100)
            //lowLevel = input(title = "Low Level", type = integer, defval = 20, minval = 0)
            //highlightBreakouts = input(title = "Highlight Overbought/Oversold Breakouts ?", type = bool, defval = true)
            //src = input(title = "Source", type = source, defval = close)

            //spread = smoothingType == "EMA" ? ema(src, fastLength) - ema(src, slowLength) : sma(src, fastLength) - sma(src, slowLength)

            //rs = rsi(spread, rsiLength)
            //rss = sma(rs, smoothingLength)

            //rssColor = rss > highLevel ? #0ebb23 : rss < lowLevel ? #ff0000 : #f4b77d
            //plot(rss, title = "RSS", linewidth = 2, color = rssColor, transp = 0)

            //transparent = color(white, 100)

            //maxLevelPlot = hline(100, title = "Max Level", linestyle = dotted, color = transparent)
            //highLevelPlot = hline(highLevel, title = "High Level", linestyle = dotted)
            //hline(50, title = "Middle Level", linestyle = dotted)
            //lowLevelPlot = hline(lowLevel, title = "Low Level", linestyle = dotted)
            //minLevelPlot = hline(0, title = "Min Level", linestyle = dotted, color = transparent)

            //fill(highLevelPlot, lowLevelPlot, color = purple, transp = 95)

            //highFillColor = rss > highLevel and highlightBreakouts ? green: transparent
            //lowFillColor = rss < lowLevel and highlightBreakouts ? red: transparent

            //fill(maxLevelPlot, highLevelPlot, color = highFillColor, transp = 90)
            //fill(minLevelPlot, lowLevelPlot, color = lowFillColor, transp = 90)
            List<decimal> spreadList = new();
            List<decimal> rsList = new();
            List<decimal> rssList = new();
            List<Signal> signalsList = new();

            try
            {
                int rsiLength = (int)Math.Ceiling(days / 0.3572);
                int smoothingLength = days;
                int fastLength = days * 2;
                int slowLength = fastLength * 4;

                List<decimal> fastEmaList = GetMovingAverageList(maType, null, stockDataClass, fastLength);
                List<decimal> slowEmaList = GetMovingAverageList(maType, null, stockDataClass, slowLength);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal fastEma = fastEmaList.ElementAtOrDefault(i);
                    decimal slowEma = slowEmaList.ElementAtOrDefault(i);

                    decimal spread = fastEma - slowEma;
                    spreadList.Add(spread);
                }

                rsList = CalculateRelativeStrengthIndex(spreadList, stockDataClass, maType, rsiLength).Item4;
                rssList = GetMovingAverageList(maType, rsList, stockDataClass, smoothingLength);
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal rss = rssList.ElementAtOrDefault(j);
                    decimal prevRss1 = j >= 1 ? rssList.ElementAtOrDefault(j - 1) : 0;
                    decimal prevRss2 = j >= 2 ? rssList.ElementAtOrDefault(j - 2) : 0;

                    var signal = GetRsiSignal(rss - prevRss1, prevRss1 - prevRss2, rss, prevRss1, 80, 20);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (spreadList, rsList, rssList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>)
            CalculateRelativeMomentumIndex(StockData stockDataClass, string maType, int days = 3)
        {
            //@version=3
            // Copyright (c) 2018-present, Alex Orekhov (everget)
            // Relative Momentum Index script may be freely distributed under the MIT license.
            //study("Relative Momentum Index", shorttitle = "RMI")

            //length = input(title = "Length", type = integer, minval = 1, defval = 14)
            //momentumLength = input(title = "Momentum Length", type = integer, minval = 1, defval = 3)
            //highlightBreakouts = input(title = "Highlight Overbought/Oversold Breakouts ?", type = bool, defval = true)
            //src = input(title = "Source", type = source, defval = close)

            //up = rma(max(change(src, momentumLength), 0), length)
            //down = rma(-min(change(src, momentumLength), 0), length)

            //rmi = down == 0 ? 100 : up == 0 ? 0 : 100 - (100 / (1 + up / down))

            //obLevel = 70
            //osLevel = 30

            //rmiColor = rmi > obLevel ? #0ebb23 : rmi < osLevel ? #ff0000 : #f4b77d
            //plot(rmi, title = "RMI", linewidth = 2, color = rmiColor, transp = 0)

            //transparent = color(white, 100)

            //maxLevelPlot = hline(100, title = "Max Level", linestyle = dotted, color = transparent)
            //obLevelPlot = hline(obLevel, title = "Overbought Level", linestyle = dotted)
            //hline(50, title = "Middle Level", linestyle = dotted)
            //osLevelPlot = hline(osLevel, title = "Oversold Level", linestyle = dotted)
            //minLevelPlot = hline(0, title = "Min Level", linestyle = dotted, color = transparent)

            //fill(obLevelPlot, osLevelPlot, color = purple, transp = 95)

            //obFillColor = rmi > obLevel and highlightBreakouts ? green: transparent
            //osFillColor = rmi < osLevel and highlightBreakouts ? red: transparent

            //fill(maxLevelPlot, obLevelPlot, color = obFillColor, transp = 90)
            //fill(minLevelPlot, osLevelPlot, color = osFillColor, transp = 90)
            List<decimal> rsiList = new();
            List<decimal> rsList = new();
            List<decimal> lossList = new();
            List<decimal> gainList = new();
            List<decimal> avgLossList = new();
            List<decimal> avgGainList = new();
            List<decimal> rsiSignalList = new();
            List<decimal> rsiHistogramList = new();
            List<Signal> signalsList = new();

            try
            {
                int rsiLength = (int)Math.Ceiling(days / 0.2143);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= days ? stockDataClass.InputValues.ElementAtOrDefault(i - days) : 0;
                    decimal priceChg = currentValue - prevValue;

                    decimal loss = priceChg < 0 ? Math.Abs(priceChg) : 0;
                    lossList.Add(loss);

                    decimal gain = priceChg > 0 ? priceChg : 0;
                    gainList.Add(gain);
                }

                avgGainList = GetMovingAverageList(maType, gainList, stockDataClass, rsiLength);
                avgLossList = GetMovingAverageList(maType, lossList, stockDataClass, rsiLength);
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal avgGain = avgGainList.ElementAtOrDefault(j);
                    decimal avgLoss = avgLossList.ElementAtOrDefault(j);

                    decimal rs = avgLoss != 0 ? avgGain / avgLoss : 0;
                    rsList.Add(rs);

                    decimal prevRsi = rsiList.LastOrDefault();
                    decimal rsi = avgLoss == 0 ? 100 : avgGain == 0 ? 0 : MinOrMax(100 - (100 / (1 + rs)), 100, 0);
                    rsiList.Add(rsi);

                    decimal rsiSignal = CalculateExponentialMovingAverage(rsi, rsiSignalList.LastOrDefault(), rsiLength);
                    rsiSignalList.Add(rsiSignal);

                    decimal prevRsiHistogram = rsiHistogramList.LastOrDefault();
                    decimal rsiHistogram = rsi - rsiSignal;
                    rsiHistogramList.Add(rsiHistogram);

                    var signal = GetRsiSignal(rsiHistogram, prevRsiHistogram, rsi, prevRsi, 70, 30);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (avgGainList, avgLossList, rsList, rsiList, rsiSignalList, rsiHistogramList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateSectorRotationModel(StockData stockDataClass, StockData marketDataClass, string maType, int days = 25)
        {
            //input = price, user defined, default is closing price
            //rocPeriod = user defined, default is 75
            //instr1 = for financial sector use SP500 XLF
            //instr2 = for consumer discretionary sector use SP500 XLY
            //instr3 = for energy sector use SP500 XLE
            //instr4 = for utilities sector use SP500 XLU
            //instr5 = for consumer staples sector use SP500 XLP
            //index = current bar number

            //bull01 = roc(index, period, input, instr1);
            //bull02 = roc(index, period, input, instr2);
            //bear01 = roc(index, period, input, instr3);
            //bear02 = roc(index, period, input, instr4);
            //bear03 = roc(index, period, input, instr5);
            //bear = (bear01 + bear02 + bear03) / 3;
            //bull = (bull01 + bull02) / 2;
            //Plot: osc = 100 * (bull - bear);
            List<decimal> bearList = new();
            List<decimal> bullList = new();
            List<decimal> oscList = new();
            List<decimal> oscEmaList = new();
            List<Signal> signalsList = new();

            try
            {
                int length1 = days;
                int length2 = days * 3;

                if (stockDataClass.InputValues.Count == marketDataClass.InputValues.Count)
                {
                    var bull1List = CalculateRateOfChange(stockDataClass.InputValues, stockDataClass, length1).Item1;
                    var bull2List = CalculateRateOfChange(stockDataClass.InputValues, stockDataClass, length2).Item1;
                    var bear1List = CalculateRateOfChange(marketDataClass.InputValues, marketDataClass, length1).Item1;
                    var bear2List = CalculateRateOfChange(marketDataClass.InputValues, marketDataClass, length2).Item1;

                    for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                    {
                        decimal bull1 = bull1List.ElementAtOrDefault(i);
                        decimal bull2 = bull2List.ElementAtOrDefault(i);
                        decimal bear1 = bear1List.ElementAtOrDefault(i);
                        decimal bear2 = bear2List.ElementAtOrDefault(i);

                        decimal bull = (bull1 + bull2) / 2;
                        bullList.Add(bull);

                        decimal bear = (bear1 + bear2) / 2;
                        bearList.Add(bear);

                        decimal osc = 100 * (bull - bear);
                        oscList.Add(osc);
                    }

                    oscEmaList = GetMovingAverageList(maType, oscList, stockDataClass, length1);
                    for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                    {
                        decimal oscEma = oscEmaList.ElementAtOrDefault(j);
                        decimal prevOscEma1 = j >= 1 ? oscEmaList.ElementAtOrDefault(j - 1) : 0;
                        decimal prevOscEma2 = j >= 2 ? oscEmaList.ElementAtOrDefault(j - 2) : 0;

                        var signal = GetCompareSignal(oscEma - prevOscEma1, prevOscEma1 - prevOscEma2);
                        signalsList.Add(signal);
                    }
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (bullList, bearList, oscList, oscEmaList, signalsList);
        }

        public static (List<decimal>, List<Signal>) CalculateComparePriceMomentumOscillator(StockData stockDataClass, StockData marketDataClass, string maType, int days = 10)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Compare Price Momentum Oscillator [CC] script may be freely distributed under the MIT license.
            //study("Compare Price Momentum Oscillator [CC]", shorttitle = "CPMO", overlay = false)

            //length1 = input(title = "Length1", type = input.integer, defval = 20, minval = 1)
            //length2 = input(title = "Length2", type = input.integer, defval = 35, minval = 1)
            //spSym = input(title = "S&P 500 Symbol", type = input.symbol, defval = "SPY")
            //inp = input(title = "Source", type = input.source, defval = close)
            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //src = security(syminfo.tickerid, res, inp[rep ? 0 : barstate.isrealtime ? 1 : 0])[rep ? 0 : barstate.isrealtime ? 0 : 1]
            //spSrc = security(spSym, res, inp[rep ? 0 : barstate.isrealtime ? 1 : 0])[rep ? 0 : barstate.isrealtime ? 0 : 1]

            //pmo = ema(10 * ema(nz(roc(src, 1)), length2), length1)
            //spPmo = ema(10 * ema(nz(roc(spSrc, 1)), length2), length1)
            //cpmo = pmo - spPmo

            //sig = cpmo > 0 ? 1 : cpmo < 0 ? -1 : 0
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //cpmoColor = sig > 0 ? color.green : sig < 0 ? color.red : color.black
            //barcolor(bar ? cpmoColor : na)
            //plot(cpmo, title = "CPMO", color = cpmoColor, linewidth = 2)
            List<decimal> cpmoList = new();
            List<Signal> signalsList = new();

            try
            {
                if (stockDataClass.InputValues.Count == marketDataClass.InputValues.Count)
                {
                    var pmoList = CalculatePriceMomentumOscillator(stockDataClass, maType, days).Item2;
                    var spPmoList = CalculatePriceMomentumOscillator(marketDataClass, maType, days).Item2;

                    for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                    {
                        decimal pmo = pmoList.ElementAtOrDefault(i);
                        decimal spPmo = spPmoList.ElementAtOrDefault(i);

                        decimal prevCpmo = cpmoList.LastOrDefault();
                        decimal cpmo = pmo - spPmo;
                        cpmoList.Add(cpmo);

                        var signal = GetCompareSignal(cpmo, prevCpmo);
                        signalsList.Add(signal);
                    }
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (cpmoList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateSpearmanIndicator(StockData stockDataClass, int days = 3)
        {
            //input = price, user defined, default is closing price
            //method = moving average, user defined, default is SMA
            //n = Spearman period, user defined, default is 10
            //sigPeriod = signal period, user defined, default is 3

            //size = series.size();
            //r1[] = new int[n + 1];
            //r22[] = new int[n + 1];
            //r11[] = new decimal[n + 1];
            //r21[] = new decimal[n + 1];
            //temp = 0;
            //coefcorr = 0, sc = 0;
            //changed = 0, found = 0;
            //absum = 0, ab = 0, ab2 = 0;

            //for (int k = n; k lessThan size; k++ )
            //for (int i = n; i moreOrEqual 1; i--)
            //r1[i] = i;
            //r22[i] = i;
            //r11[i] = series.getdecimal((k - n + i), key, 0);
            //r21[i] = series.getdecimal((k - n + i), key, 0);
            //endFor
            //sort r21 descending
            //changed = 1;
            //while (changed moreThan 0)
            //changed = 0;
            //for (int i = 1; i lessOrEqual(n - 1); i++)
            //if (r21[i + 1] lessThan r21[i])
            //temp = r21[i];
            //r21[i] = r21[i + 1];
            //r21[i + 1] = temp;
            //changed = 1;
            //endIf
            //endFor
            //endWhile
            ////
            //for (int i = 1; i lessOrEqual n; i++)
            //found = 0;
            //while (found lessThan 1)
            //for (int j = 1; j lessOrEqual n; j++)
            //if (r21[j] == r11[i])
            //r22[i] = j;
            //found = 1;
            //endIf
            //endFor
            //endWhile
            //endFor
            /////////
            //absum = 0;
            //for (int i = 1; i lessOrEqual; i++)
            //ab = r1[i] - r22[i];
            //ab2 = ab * ab;
            //absum = absum + ab2;
            //endFor
            //coefcorr = 1 - ((6 * absum) / (n * ((n * n) - 1)));
            //Plot: sc = 100 * coefcorr;
            //Plot: sig = ma(method, k, sigPeriod, SC);
            //end
            List<decimal> coefCorrList = new();
            List<decimal> scList = new();
            List<decimal> sigList = new();
            List<decimal> absumList = new();
            List<decimal> tempList = new();
            List<Signal> signalsList = new();

            try
            {
                int n = (int)Math.Ceiling(days / 0.3);
                int sigPeriod = days;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    tempList.Add(currentValue);

                    var enumerableList = tempList.TakeLast(n).Select(x => (double)x).ToList();
                    var orderedList = enumerableList.AsQueryExpr().OrderBy(j => j).Run().ToList();

                    var coefCorr = Correlation.Spearman(enumerableList, orderedList);
                    coefCorr = IsValueNullOrInfinity(coefCorr) ? 0 : coefCorr;
                    coefCorrList.Add((decimal)coefCorr);

                    decimal prevSc = scList.LastOrDefault();
                    decimal sc = 100 * (decimal)coefCorr;
                    scList.Add(sc);

                    decimal prevSig = sigList.LastOrDefault();
                    decimal sig = scList.TakeLast(sigPeriod).Average();
                    sigList.Add(sig);

                    var signal = GetCompareSignal(sc - sig, prevSc - prevSig);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (coefCorrList, scList, sigList, signalsList);
        }

        public static (List<decimal>, List<Signal>) CalculateRelativeDifferenceOfSquaresOscillator(StockData stockDataClass, int days = 20)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Relative Difference Of Squares Oscillator [CC] script may be freely distributed under the MIT license.
            //study("Relative Difference Of Squares Oscillator [CC]", overlay = false)

            //inp = input(title = "Source", type = input.source, defval = close)
            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //src = security(syminfo.tickerid, res, inp[rep ? 0 : barstate.isrealtime ? 1 : 0])[rep ? 0 : barstate.isrealtime ? 0 : 1]
            //length = input(title = "Length", type = input.integer, defval = 20, minval = 1)

            //a = sum(src > nz(src[1]) ? 1 : 0, length)
            //d = sum(src < nz(src[1]) ? 1 : 0, length)
            //n = sum(src == nz(src[1]) ? 1 : 0, length)
            //rdos = a > 0 or d > 0 or n > 0 ? (pow(a, 2) - pow(d, 2)) / pow(a + n + d, 2) : 0

            //sig = rdos > 0 ? 1 : rdos < 0 ? -1 : 0
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //rdosColor = sig > 0 ? color.green : sig < 0 ? color.red : color.black
            //barcolor(bar ? rdosColor : na)
            //plot(rdos, title = "RDOS", color = rdosColor, linewidth = 2)
            List<decimal> rdosList = new();
            List<decimal> aList = new();
            List<decimal> dList = new();
            List<decimal> nList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal a = currentValue > prevValue ? 1 : 0;
                    aList.Add(a);

                    decimal d = currentValue < prevValue ? 1 : 0;
                    dList.Add(d);

                    decimal n = currentValue == prevValue ? 1 : 0;
                    nList.Add(n);

                    decimal prevRdos = rdosList.LastOrDefault();
                    decimal aSum = aList.TakeLast(days).Sum();
                    decimal dSum = dList.TakeLast(days).Sum();
                    decimal nSum = nList.TakeLast(days).Sum();
                    decimal rdos = aSum > 0 || dSum > 0 || nSum > 0 ? (Pow(aSum, 2) - Pow(dSum, 2)) / Pow(aSum + nSum + dSum, 2) : 0;
                    rdosList.Add(rdos);

                    var signal = GetCompareSignal(rdos, prevRdos);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (rdosList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateDemarkReversalPoints(StockData stockDataClass, int days = 4)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Demark Reversal Points [CC] script may be freely distributed under the MIT license.
            //study("Demark Reversal Points [CC]", overlay = true)

            //inp = input(title = "Source", type = input.source, defval = close)
            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //src = security(syminfo.tickerid, res, inp[rep ? 0 : barstate.isrealtime ? 1 : 0])[rep ? 0 : barstate.isrealtime ? 0 : 1]
            //length = input(title = "Length", type = input.integer, defval = 9, minval = 1)
            //lbLength = input(title = "LbLength", type = input.integer, defval = 4, minval = 1)

            //uCount = 0, dCount = 0
            //for i = 0 to length - 1
            //    uCount := uCount + (nz(src[i]) > nz(src[i + lbLength]) ? 1 : 0)
            //    dCount := dCount + (nz(src[i]) < nz(src[i + lbLength]) ? 1 : 0)

            //drp = dCount == length ? 1 : uCount == length ? -1 : 0

            //sig = drp > 0 or uCount > dCount ? 1 : drp < 0 or dCount > uCount ? -1 : 0
            //drpColor = sig > 0 ? color.green : sig < 0 ? color.red : color.black
            //alertcondition(crossover(drp, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(drp, 0), "Sell Signal", "Bearish Change Detected")
            //barcolor(bar ? drpColor : na)
            //plotshape(crossover(drp, 0), "Buy", shape.labelup, location.belowbar, color.green, text = "Buy", textcolor = color.white)
            //plotshape(crossunder(drp, 0), "Sell", shape.labeldown, location.abovebar, color = color.red, text = "Sell", textcolor = color.white)
            List<decimal> uCountList = new();
            List<decimal> dCountList = new();
            List<decimal> drpList = new();
            List<decimal> drpPriceList = new();
            List<Signal> signalsList = new();

            try
            {
                int length = (int)Math.Ceiling(days / 0.444);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);

                    decimal uCount = 0, dCount = 0;
                    for (int j = 0; j <= length - 1; j++)
                    {
                        decimal value = i >= j ? stockDataClass.InputValues.ElementAtOrDefault(i - j) : 0;
                        decimal prevValue = i >= j + days ? stockDataClass.InputValues.ElementAtOrDefault(i - (j + days)) : 0;

                        uCount += value > prevValue ? 1 : 0;
                        dCount += value < prevValue ? 1 : 0;
                    }
                    uCountList.Add(uCount);
                    dCountList.Add(dCount);

                    decimal drp = dCount == length ? 1 : uCount == length ? -1 : 0;
                    drpList.Add(drp);

                    decimal drpPrice = drp != 0 ? currentValue : 0;
                    drpPriceList.Add(drpPrice);

                    var signal = GetConditionSignal(drp > 0 || uCount > dCount, drp < 0 || dCount > uCount);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (uCountList, dCountList, drpList, drpPriceList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateDemarkSetupIndicator(StockData stockDataClass, int days = 4)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Demark Setup Indicator [CC] script may be freely distributed under the MIT license.
            //study("Demark Setup Indicator [CC]", overlay = true)

            //inp = input(title = "Source", type = input.source, defval = close)
            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //src = security(syminfo.tickerid, res, inp[rep ? 0 : barstate.isrealtime ? 1 : 0])[rep ? 0 : barstate.isrealtime ? 0 : 1]
            //length = input(title = "Length", type = input.integer, defval = 4, minval = 1)

            //uCount = 0, dCount = 0
            //for i = 0 to length - 1
            //    uCount := uCount + (nz(src[i]) > nz(src[i + length]) ? 1 : 0)
            //    dCount := dCount + (nz(src[i]) < nz(src[i + length]) ? 1 : 0)

            //dsi = dCount == length ? 1 : uCount == length ? -1 : 0

            //sig = dsi > 0 or uCount > dCount ? 1 : dsi < 0 or dCount > uCount ? -1 : 0
            //dsiColor = sig > 0 ? color.green : sig < 0 ? color.red : color.black
            //alertcondition(crossover(dsi, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(dsi, 0), "Sell Signal", "Bearish Change Detected")
            //barcolor(bar ? dsiColor : na)
            //plotshape(crossover(dsi, 0), "Buy", shape.labelup, location.belowbar, color.green, text = "Buy", textcolor = color.white)
            //plotshape(crossunder(dsi, 0), "Sell", shape.labeldown, location.abovebar, color = color.red, text = "Sell", textcolor = color.white)
            List<decimal> uCountList = new();
            List<decimal> dCountList = new();
            List<decimal> drpList = new();
            List<decimal> drpPriceList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);

                    decimal uCount = 0, dCount = 0;
                    for (int j = 0; j < days; j++)
                    {
                        decimal value = i >= j ? stockDataClass.InputValues.ElementAtOrDefault(i - j) : 0;
                        decimal prevValue = i >= j + days ? stockDataClass.InputValues.ElementAtOrDefault(i - (j + days)) : 0;

                        uCount += value > prevValue ? 1 : 0;
                        dCount += value < prevValue ? 1 : 0;
                    }
                    uCountList.Add(uCount);
                    dCountList.Add(dCount);

                    decimal drp = dCount == days ? 1 : uCount == days ? -1 : 0;
                    drpList.Add(drp);

                    decimal drpPrice = drp != 0 ? currentValue : 0;
                    drpPriceList.Add(drpPrice);

                    var signal = GetConditionSignal(drp > 0 || uCount > dCount, drp < 0 || dCount > uCount);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (uCountList, dCountList, drpList, drpPriceList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateStandardDeviationChannel(StockData stockDataClass, int days = 40)
        {
            //input = price (user defined, default is closing price)
            //noBars = user defined, default is 40
            //noFutureBars = user defined, default is 1;
            //noDev = number of standard deviations user defined, default is 2
            //standDev = standardDeviations
            //index = current bar number

            //endIndex = size() - 1;
            //startIndex = endIndex - noBars;
            //value[] = linRegLine(endIndex, noBars, input);
            //a = value[0];    //a in line equasion y = a + mx
            //m = value[1];   //m in line equasion y = a + mx
            //standDev = std(endIndex, noBars, input);
            //standDev = standDev * noDev;
            //standDev = standDev * .5;  //half above half below
            //y = a + (m * x)
            //startY = a + (m * 0);
            //endY = a + (m * noBars);
            //start = Coordinate(getStartTime(startIndex), startY);
            //end = Coordinate(getStartTime(endIndex), endY);
            //line = Line(start, end);
            //line.setExtendRight(noFutureBars);
            //addFigure(line);
            //top channel
            //startY = a + standDev; // + (m * 0)
            //endY = a + standDev + (m * noBars);
            //start = Coordinate(getStartTime(startIndex), startY);
            //end = Coordinate(getStartTime(endIndex), endY);
            //line = Line(start, end);
            //line.setExtendRight(noFutureBars);
            //addFigure(line);
            //bottom channel
            //startY = a - standDev; // + (m * 0)
            //endY = a - standDev + (m * noBars);
            //start = Coordinate(getStartTime(startIndex), startY);
            //end = Coordinate(getStartTime(endIndex), endY);
            //line = Line(start, end);
            //line.setExtendRight(noFutureBars);
            //addFigure(line);
            decimal noDev = 2;
            List<decimal> startYList = new();
            List<decimal> endYList = new();
            List<decimal> startYTopList = new();
            List<decimal> endYTopList = new();
            List<decimal> startYBottomList = new();
            List<decimal> endYBottomList = new();
            List<Signal> signalsList = new();

            try
            {
                List<decimal> stdDeviationList = CalculateStandardDeviationVolatility(null, stockDataClass, days).Item4;
                var regressionList = CalculateLinearRegression(null, stockDataClass, days);
                List<decimal> mList = regressionList.Item11;
                List<decimal> aList = regressionList.Item14;

                for (int i = 0; i < stdDeviationList.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal standDev = stdDeviationList.ElementAtOrDefault(i);
                    decimal a = aList.ElementAtOrDefault(i);
                    decimal m = mList.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    standDev *= noDev;
                    standDev *= 0.5m;
                    decimal prevA = i >= 1 ? aList.ElementAtOrDefault(i - 1) : 0;

                    decimal startY = a + (m * 0);
                    startYList.Add(startY);

                    decimal endY = a + (m * days);
                    endYList.Add(endY);

                    decimal startYTop = a + standDev;
                    startYTopList.Add(startYTop);

                    decimal prevEndYTop = endYTopList.LastOrDefault();
                    decimal endYTop = a + (standDev + (m * days));
                    endYTopList.Add(endYTop);

                    decimal startYBottom = a - standDev;
                    startYBottomList.Add(startYBottom);

                    decimal prevEndYBottom = endYBottomList.LastOrDefault();
                    decimal endYBottom = a - (standDev + (m * days));
                    endYBottomList.Add(endYBottom);

                    var signal = GetBollingerBandsSignal(currentValue - a, prevValue - prevA, currentValue, prevValue, endYTop, prevEndYTop, endYBottom, prevEndYBottom);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (endYList, startYTopList, endYTopList, startYBottomList, endYBottomList, signalsList);
        }

        public static (List<decimal>, List<Signal>) CalculateStochasticRelativeStrengthIndex(StockData stockDataClass, string maType, int days = 14)
        {
            //input = price, user defined, default is closing price
            //period = user defined, default is 14
            //index = current bar number
            //LT = less than, LOE = less or equal
            //MT = more than, MOE = more or equal

            //Step 1: Calculate the RSI
            //prevPrice = price[index - 1];
            //diff = price - prevPrice;
            //up = 0, down = 0;
            //if (diff moreThan 0) up = diff;
            //else down = diff;
            //down = Math.abs(down);
            //avUp = ma(rsiMethod, index, rsiPeriod, UP);
            //avDn = ma(rsiMethod, index, rsiPeriod, DOWN);
            //dSum = avUp + avDn;
            //rsi = (avUp / dSum) * 100.0;

            //Stochastics calculation  
            //high = highest(index, fastKPeriod, RSI);
            //low = lowest(index, fastKP, Values.RSI);
            //fastK = 0;
            //if (high == low) fastK = 100;
            //else fastK = (rsi - low) / (high - low) * 100;
            //Plot2: slowk = ma(sigMethod, index, slowKPeriod, FASTK);
            //Plot3: sig = ma(sigMethod, index, sigPeriod, SLOWK);

            //Signals
            //prevK = K[index - 1];
            //sell = crossedBelow(SLOWK, SIG) AND slowk moreThan topGuide;
            //buy = crossedAbove(SLOWK, SIG) AND slowk lessThan bottGuide;
            List<decimal> stochRSIList = new();
            List<Signal> signalsList = new();

            try
            {
                List<decimal> rsiList = CalculateRelativeStrengthIndex(null, stockDataClass, maType, days).Item4;
                var minMaxList = GetMaxAndMinValuesList(rsiList, days);
                var highestList = minMaxList.Item1;
                var lowestList = minMaxList.Item2;

                for (int i = 0; i < rsiList.Count; i++)
                {
                    decimal currentRSI = rsiList.ElementAtOrDefault(i);
                    decimal lowestRSI = lowestList.ElementAtOrDefault(i);
                    decimal highestRSI = highestList.ElementAtOrDefault(i);
                    decimal prevStochRsi1 = i >= 1 ? stochRSIList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevStochRsi2 = i >= 2 ? stochRSIList.ElementAtOrDefault(i - 2) : 0;

                    decimal stochRsi = highestRSI - lowestRSI != 0 ? MinOrMax((currentRSI - lowestRSI) / (highestRSI - lowestRSI), 1, 0) : 0;
                    stochRSIList.Add(stochRsi);

                    var signal = GetRsiSignal(stochRsi - prevStochRsi1, prevStochRsi1 - prevStochRsi2, stochRsi, prevStochRsi1, 0.8m, 0.2m);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (stochRSIList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<decimal>, List<Signal>) CalculateCCTStochRSI(StockData stockDataClass, string maType, int days = 3)
        {
            //CCT StochRSI, proposed by Steve Karnish of Cedar Creek Trading, reconfigures classic StochRSI using custom parameters and smoothing.

            //There are 6 types supported.

            //Common formula:
            //(rsi - lowest(rsi, x)) / (highest(rsi, y) - lowest(rsi, z)) * 100

            //Smoothed formula:
            //ema(common formula result, len)

            //Settings(values for x / y / z / len in the above formulae):

            //Type 1: RSILength = 21, x = 8, y = 13, z = 13, len = N / A
            //Type 2: RSILength = 21, x = 21, y = 21, z = 21, len = N / A
            //Type 3: RSILength = 14, x = 14, y = 14, z = 14, len = N / A
            //Type 4: RSILength = 21, x = 13, y = 8, z = 13, len = 8
            //Type 5: RSILength = 5, x = 5, y = 5, z = 5, len = 3
            //Type 6: RSILength = 13, x = 13, y = 13, z = 13, len = 3
            List<decimal> stochRSI1List = new();
            List<decimal> stochRSI2List = new();
            List<decimal> stochRSI3List = new();
            List<decimal> stochRSI4List = new();
            List<decimal> stochRSI5List = new();
            List<decimal> stochRSI6List = new();
            List<decimal> tempRsi21List = new();
            List<decimal> tempRsi14List = new();
            List<decimal> tempRsi13List = new();
            List<decimal> tempRsi5List = new();
            List<decimal> tempRsi8List = new();
            List<decimal> rsiEma4List = new();
            List<decimal> rsiEma5List = new();
            List<decimal> rsiEma6List = new();
            List<decimal> rsiEmaCustomList = new();
            List<decimal> stochRSICustomSignalList = new();
            List<decimal> stochRSICustomList = new();
            List<Signal> signalsList = new();

            try
            {
                int rsi3Length = days;
                int rsi5Length = (int)Math.Ceiling(days / 0.6);
                int rsi8Length = (int)Math.Ceiling(days / 0.375);
                int rsi13Length = (int)Math.Ceiling(days / 0.2308);
                int rsi14Length = (int)Math.Ceiling(days / 0.2143);
                int rsi21Length = days * 7;
                int signalLength = days * 3;

                List<decimal> rsi5List = CalculateRelativeStrengthIndex(null, stockDataClass, maType, rsi5Length).Item4;
                List<decimal> rsi8List = CalculateRelativeStrengthIndex(null, stockDataClass, maType, rsi8Length).Item4;
                List<decimal> rsi13List = CalculateRelativeStrengthIndex(null, stockDataClass, maType, rsi13Length).Item4;
                List<decimal> rsi14List = CalculateRelativeStrengthIndex(null, stockDataClass, maType, rsi14Length).Item4;
                List<decimal> rsi21List = CalculateRelativeStrengthIndex(null, stockDataClass, maType, rsi21Length).Item4;

                for (int i = 0; i < rsi5List.Count; i++)
                {
                    decimal currentRSI5 = rsi5List.ElementAtOrDefault(i);
                    tempRsi5List.Add(currentRSI5);

                    decimal currentRSI8 = rsi8List.ElementAtOrDefault(i);
                    tempRsi8List.Add(currentRSI8);

                    decimal currentRSI13 = rsi13List.ElementAtOrDefault(i);
                    tempRsi13List.Add(currentRSI13);

                    decimal currentRSI14 = rsi14List.ElementAtOrDefault(i);
                    tempRsi14List.Add(currentRSI14);

                    decimal currentRSI21 = rsi21List.ElementAtOrDefault(i);
                    tempRsi21List.Add(currentRSI21);

                    decimal lowestX1 = tempRsi21List.TakeLast(rsi8Length).Min();
                    decimal lowestZ1 = tempRsi21List.TakeLast(rsi13Length).Min();
                    decimal highestY1 = tempRsi21List.TakeLast(rsi13Length).Max();

                    decimal lowestX2 = tempRsi21List.TakeLast(rsi21Length).Min();
                    decimal lowestZ2 = tempRsi21List.TakeLast(rsi21Length).Min();
                    decimal highestY2 = tempRsi21List.TakeLast(rsi21Length).Max();

                    decimal lowestX3 = tempRsi14List.TakeLast(rsi14Length).Min();
                    decimal lowestZ3 = tempRsi14List.TakeLast(rsi14Length).Min();
                    decimal highestY3 = tempRsi14List.TakeLast(rsi14Length).Max();

                    decimal lowestX4 = tempRsi21List.TakeLast(rsi13Length).Min();
                    decimal lowestZ4 = tempRsi21List.TakeLast(rsi13Length).Min();
                    decimal highestY4 = tempRsi21List.TakeLast(rsi8Length).Max();

                    decimal lowestX5 = tempRsi5List.TakeLast(rsi5Length).Min();
                    decimal lowestZ5 = tempRsi5List.TakeLast(rsi5Length).Min();
                    decimal highestY5 = tempRsi5List.TakeLast(rsi5Length).Max();

                    decimal lowestX6 = tempRsi13List.TakeLast(rsi13Length).Min();
                    decimal lowestZ6 = tempRsi13List.TakeLast(rsi13Length).Min();
                    decimal highestY6 = tempRsi13List.TakeLast(rsi13Length).Max();

                    decimal lowestCustom = tempRsi8List.TakeLast(rsi8Length).Min();
                    decimal highestCustom = tempRsi8List.TakeLast(rsi8Length).Max();

                    decimal stochRSI1 = highestY1 - lowestZ1 != 0 ? (currentRSI21 - lowestX1) / (highestY1 - lowestZ1) * 100 : 0;
                    stochRSI1List.Add(stochRSI1);

                    decimal stochRSI2 = highestY2 - lowestZ2 != 0 ? (currentRSI21 - lowestX2) / (highestY2 - lowestZ2) * 100 : 0;
                    stochRSI2List.Add(stochRSI2);

                    decimal stochRSI3 = highestY3 - lowestZ3 != 0 ? (currentRSI14 - lowestX3) / (highestY3 - lowestZ3) * 100 : 0;
                    stochRSI3List.Add(stochRSI3);

                    decimal stochRSI4 = highestY4 - lowestZ4 != 0 ? (currentRSI21 - lowestX4) / (highestY4 - lowestZ4) * 100 : 0;
                    stochRSI4List.Add(stochRSI4);

                    decimal rsiEma4 = CalculateExponentialMovingAverage(stochRSI4, rsiEma4List.LastOrDefault(), rsi8Length);
                    rsiEma4List.Add(rsiEma4);

                    decimal stochRSI5 = highestY5 - lowestZ5 != 0 ? (currentRSI5 - lowestX5) / (highestY5 - lowestZ5) * 100 : 0;
                    stochRSI5List.Add(stochRSI5);

                    decimal rsiEma5 = CalculateExponentialMovingAverage(stochRSI5, rsiEma5List.LastOrDefault(), rsi3Length);
                    rsiEma5List.Add(rsiEma5);

                    decimal stochRSI6 = highestY6 - lowestZ6 != 0 ? (currentRSI13 - lowestX6) / (highestY6 - lowestZ6) * 100 : 0;
                    stochRSI6List.Add(stochRSI6);

                    decimal rsiEma6 = CalculateExponentialMovingAverage(stochRSI6, rsiEma6List.LastOrDefault(), rsi3Length);
                    rsiEma6List.Add(rsiEma6);

                    decimal prevStochCustom = stochRSICustomList.LastOrDefault();
                    decimal stochCustom = highestCustom - lowestCustom != 0 ? (currentRSI8 - lowestCustom) / (highestCustom - lowestCustom) * 100 : 0;
                    stochRSICustomList.Add(stochCustom);

                    decimal rsiEmaCustom = CalculateExponentialMovingAverage(stochCustom, rsiEmaCustomList.LastOrDefault(), rsi3Length);
                    rsiEmaCustomList.Add(rsiEmaCustom);

                    decimal prevRsiEmaCustomSignal = stochRSICustomSignalList.LastOrDefault();
                    decimal rsiEmaCustomSignal = CalculateExponentialMovingAverage(stochCustom, prevRsiEmaCustomSignal, signalLength);
                    stochRSICustomSignalList.Add(rsiEmaCustomSignal);

                    var signal = GetCompareSignal(stochCustom - rsiEmaCustomSignal, prevStochCustom - prevRsiEmaCustomSignal);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (stochRSI1List, stochRSI2List, stochRSI3List, stochRSI4List, stochRSI5List, stochRSI6List, stochRSICustomList, rsiEma4List, rsiEma5List, rsiEma6List,
                rsiEmaCustomList, stochRSICustomSignalList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<decimal>, List<decimal>, List<Signal>) CalculateStochasticMomentumIndex(StockData stockDataClass, string maType, int days = 2)
        {
            //method = moving average (ma), user defined, default is EMA
            //high low Period = hlPeriod = user defined, default is 2
            //maPeriod = user defined, default is 8
            //smoothPeriod = user defined, default is 5
            //signalPeriod = user defined, default is 5
            //index = current bar number

            //HH = highest(index, hlPeriod, HIGH);
            //LL = lowest(index, hlPeriod, LOW);
            //M = (HH + LL) / 2;
            //D = getClose(index) - M;
            //HL = HH - LL;
            //D_MA = ma(method, index, maPeriod, D);
            //HL_MA = ma(method, index, maPeriod, HL);
            //D_SMOOTH = ma(method, index, smoothPeriod, D_MA);
            //HL_SMOOTH = ma(method, index, smoothPeriod, HL_MA);
            //HL2 = HL_SMOOTH / 2;
            //SMI = 0;
            //SMI = 100 * (D_SMOOTH / HL2);
            //SIGNAL = ma(method, index, signalPeriod, SMI);
            //Signals
            //buy = crossedAbove(SMI, SIGNAL);
            //sell = crossedBelow(SMI, SIGNAL);
            List<decimal> dList = new();
            List<decimal> hlList = new();
            List<decimal> mList = new();
            List<decimal> dEmaList = new();
            List<decimal> hlEmaList = new();
            List<decimal> dSmoothEmaList = new();
            List<decimal> hlSmoothEmaList = new();
            List<decimal> hl2List = new();
            List<decimal> smiSignalList = new();
            List<decimal> smiList = new();
            List<Signal> signalsList = new();

            try
            {
                int hlPeriod = days;
                int maPeriod = days * 4;
                int smoothPeriod = (int)Math.Ceiling(days / 0.4);

                var list = VolumeInputCheck(stockDataClass, hlPeriod, true);
                var highList = list.Item1;
                var lowList = list.Item2;

                for (int i = 0; i < stockDataClass.HighPrices.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal highestHigh = highList.ElementAtOrDefault(i);
                    decimal lowestLow = lowList.ElementAtOrDefault(i);

                    decimal median = (highestHigh + lowestLow) / 2;
                    mList.Add(median);

                    decimal diff = currentValue - median;
                    dList.Add(diff);

                    decimal highLow = highestHigh - lowestLow;
                    hlList.Add(highLow);
                }

                dEmaList = GetMovingAverageList(maType, dList, stockDataClass, maPeriod);
                hlEmaList = GetMovingAverageList(maType, hlList, stockDataClass, maPeriod);
                dSmoothEmaList = GetMovingAverageList(maType, dEmaList, stockDataClass, smoothPeriod);
                hlSmoothEmaList = GetMovingAverageList(maType, hlEmaList, stockDataClass, smoothPeriod);
                for (int j = 0; j < stockDataClass.HighPrices.Count; j++)
                {
                    decimal hlSmoothEma = hlSmoothEmaList.ElementAtOrDefault(j);
                    decimal dSmoothEma = dSmoothEmaList.ElementAtOrDefault(j);

                    decimal hl2 = hlSmoothEma / 2;
                    hl2List.Add(hl2);

                    decimal smi = hl2 != 0 ? MinOrMax(100 * dSmoothEma / hl2, 100, -100) : 0;
                    smiList.Add(smi);
                }

                smiSignalList = GetMovingAverageList(maType, smiList, stockDataClass, smoothPeriod);
                for (int k = 0; k < stockDataClass.HighPrices.Count; k++)
                {
                    decimal smi = smiList.ElementAtOrDefault(k);
                    decimal smiSignal = smiSignalList.ElementAtOrDefault(k);
                    decimal prevSmi = k >= 1 ? smiList.ElementAtOrDefault(k - 1) : 0;
                    decimal prevSmiSignal = k >= 1 ? smiSignalList.ElementAtOrDefault(k - 1) : 0;

                    var signal = GetCompareSignal(smi - smiSignal, prevSmi - prevSmiSignal);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (dList, hlList, dEmaList, hlEmaList, dSmoothEmaList, hlSmoothEmaList, hl2List, smiList, smiSignalList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateElasticVolumeWeightedMovingAverage(StockData stockDataClass, string maType, int days = 40)
        {
            //method = moving average (ma) user defined, default is SMA
            //input = price (user defined, default is closing price)
            //mult = user input, default 20
            //period = user input, default 40
            //index = current bar number, avVol = average volume
            //prevE = previousEVWMA

            //avVol = ma(method, index, period, volume);
            //n = avVol * mult;
            //prevE = ifNull(price, EVWMA[index - 1]);
            //Plot: EVWMA = ((n - vol) * prevE + volume * price) / n;
            List<decimal> nList = new();
            List<decimal> evwmaList = new();
            List<Signal> signalsList = new();

            try
            {
                decimal mult = (decimal)days / 2;

                var volumeSmaList = GetMovingAverageList(maType, stockDataClass.Volumes, stockDataClass, days);

                for (int i = 0; i < volumeSmaList.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal currentAvgVolume = volumeSmaList.ElementAtOrDefault(i);
                    decimal currentVolume = stockDataClass.Volumes.ElementAtOrDefault(i);

                    decimal n = currentAvgVolume * mult;
                    nList.Add(n);

                    decimal prevEVWMA = i >= 1 ? evwmaList.LastOrDefault() : currentValue;
                    decimal evwma = evwma = n > 0 ? (((n - currentVolume) * prevEVWMA) + (currentVolume * currentValue)) / n : 0; ;
                    evwmaList.Add(evwma);

                    var signal = GetCompareSignal(currentValue - evwma, prevValue - prevEVWMA);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (nList, evwmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateElasticVolumeWeightedMovingAverageV2(StockData stockDataClass, int days = 14)
        {
            //@version=3
            // Copyright (c) 2018-present, Alex Orekhov (everget)
            // Elastic Volume Weighted Moving Average script may be freely distributed under the MIT license.
            //study("Elastic Volume Weighted Moving Average", shorttitle = "EVWMA", overlay = true)

            //length = input(title = "Length", type = integer, defval = 14)
            //highlightMovements = input(title = "Highlight Movements ?", type = bool, defval = true)
            //src = input(title = "Source", type = source, defval = close)

            //volumeSum = sum(volume, length)

            //evwma = 0.0
            //evwma:= ((volumeSum - volume) * nz(evwma[1]) + volume * src) / volumeSum

            //evwmaColor = highlightMovements ? (evwma > evwma[1] ? green : red) : #6d1e7f
            //plot(evwma, title = "EVWMA", linewidth = 2, color = evwmaColor, transp = 0)
            List<decimal> tempList = new();
            List<decimal> volumeSumList = new();
            List<decimal> evwmaList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal currentVolume = stockDataClass.Volumes.ElementAtOrDefault(i);
                    tempList.Add(currentVolume);

                    decimal volumeSum = tempList.TakeLast(days).Sum();
                    volumeSumList.Add(volumeSum);

                    decimal prevEvwma = evwmaList.LastOrDefault();
                    decimal evwma = volumeSum != 0 ? (((volumeSum - currentVolume) * prevEvwma) + (currentVolume * currentValue)) / volumeSum : 0;
                    evwmaList.Add(evwma);

                    var signal = GetCompareSignal(currentValue - evwma, prevValue - prevEvwma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (volumeSumList, evwmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateHerrickPayoffIndex(StockData stockDataClass)
        {
            //pointValue = user defined, default is 100
            //prev = previous, index = current bar number
            //abs = absolute value
            //LT = less than, MT = more than

            //prevOpen = open[index - 1];
            //prevHigh = high[index - 1];
            //prevLow = low[index - 1];
            //prevClose = close[index - 1];
            //median = (high + low) / 2;
            //prevMedian = (prevHigh + prevLow) / 2;
            //i = abs(close - prevClose);
            //g = min(open, prevOpen);
            //k = (median - prevMedian) * pointValue * volume;
            //temp = 1 + ((i / 2) / g);
            //if (median LT prevMedian) temp = 1 - ((i / 2) / g);
            //k = k * temp;
            //prevK = k[index - 1];
            //PlotHist: hpic = prevK + (k - prevK);
            decimal pointValue = 100;
            List<decimal> kList = new();
            List<decimal> hpicList = new();
            List<decimal> tempList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.HighPrices.Count; i++)
                {
                    decimal currentClose = stockDataClass.ClosePrices.ElementAtOrDefault(i);
                    decimal currentOpen = stockDataClass.OpenPrices.ElementAtOrDefault(i);
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal currentVolume = stockDataClass.Volumes.ElementAtOrDefault(i);
                    decimal prevHigh = i >= 1 ? stockDataClass.HighPrices.ElementAtOrDefault(i - 1) : 0;
                    decimal prevClose = i >= 1 ? stockDataClass.ClosePrices.ElementAtOrDefault(i - 1) : 0;
                    decimal prevLow = i >= 1 ? stockDataClass.LowPrices.ElementAtOrDefault(i - 1) : 0;
                    decimal prevOpen = i >= 1 ? stockDataClass.OpenPrices.ElementAtOrDefault(i - 1) : 0;
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevK = kList.LastOrDefault();
                    decimal absDiff = Math.Abs(currentClose - prevClose);
                    decimal g = Math.Min(currentOpen, prevOpen);
                    decimal k = (currentValue - prevValue) * pointValue * currentVolume;

                    decimal temp = g != 0 ? currentValue < prevValue ? 1 - ((absDiff / 2) / g) : 1 + ((absDiff / 2) / g) : 1;
                    tempList.Add(temp);

                    k *= temp;
                    kList.Add(k);

                    decimal prevHpic = hpicList.LastOrDefault();
                    decimal hpic = prevK + (k - prevK);
                    hpicList.Add(hpic);

                    var signal = GetCompareSignal(hpic, prevHpic);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (tempList, kList, hpicList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateStollerAverageRangeChannels(StockData stockDataClass, string maType, int days = 14)
        {
            //input = price (user defined, default is closing price)
            //method = moving average (user defined, default is SMA)
            //atr = average true range
            //ma = moving average
            //bb = bollinger bands
            //prev = previous, index = current bar number
            //MT = more than, MOE = more or equal
            //LT = less than, LOE = less or equal
            //mult = multiplier factor

            //Plot1: ma = ma(method, index, maPeriod, input);
            //atr = atr(atrPeriod);
            //atr = atr * atrMult;
            //Plot2: upperStarc = ma + atr;
            //Plot3: lowerStarc = ma - atr;
            //bb[] = bollingerBands(bbPeriod, bbMult, bbMult, input);
            //Plot4: bb[0];   //bbTop
            //Plor5: bb[1];  //bbBottom
            //Signals
            //prevMa = ma[index - 1];
            //sell = prevMa MT ma AND high MT bb[0] AND high MT upperStarc AND sellStock;
            //buy = prevMa LT ma AND low LT bb[1] AND low LT lowerStarc AND buyStock;
            //if (sell) sellStock = false; buyStock = true;
            //if (buy) sellStock = true; buyStock = false;
            List<decimal> upperStarcBandList = new();
            List<decimal> lowerStarcBandList = new();
            List<Signal> signalsList = new();
            int atrMult = 2, bbMult = 2;

            try
            {
                List<decimal> smaList = GetMovingAverageList(maType, null, stockDataClass, days);
                var atrList = CalculateAverageTrueRange(stockDataClass, maType, days).Item1;
                var bollingerBandList = CalculateBollingerBands(null, stockDataClass, bbMult, maType, days);
                List<decimal> upperBbList = bollingerBandList.Item1;
                List<decimal> lowerBbList = bollingerBandList.Item2;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevSma = i >= 1 ? smaList.ElementAtOrDefault(i - 1) : 0;
                    decimal currentSma = smaList.ElementAtOrDefault(i);
                    decimal currentAtr = atrList.ElementAtOrDefault(i);
                    decimal currentHigh = stockDataClass.HighPrices.ElementAtOrDefault(i);
                    decimal currentLow = stockDataClass.LowPrices.ElementAtOrDefault(i);
                    decimal currentUpperBBand = upperBbList.ElementAtOrDefault(i);
                    decimal currentLowerBBand = lowerBbList.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal innerLowerStarcBand = currentSma - currentAtr;
                    decimal innerUpperStarcBand = currentSma + currentAtr;

                    decimal prevUpperStarcBand = upperStarcBandList.LastOrDefault();
                    decimal upperStarcBand = currentSma + (currentAtr * atrMult);
                    upperStarcBandList.Add(upperStarcBand);

                    decimal prevLowerStarcBand = lowerStarcBandList.LastOrDefault();
                    decimal lowerStarcBand = currentSma - (currentAtr * atrMult);
                    lowerStarcBandList.Add(lowerStarcBand);

                    var signal = GetBollingerBandsSignal(currentValue - currentSma, prevValue - prevSma, currentValue, prevValue, upperStarcBand, prevUpperStarcBand, lowerStarcBand, prevLowerStarcBand);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (upperStarcBandList, lowerStarcBandList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateLBRPaintBars(StockData stockDataClass, string maType, int days = 9)
        {
            //
            // @author LazyBear 
            // List of all my indicators: 
            // https://docs.google.com/document/d/15AGCufJZ8CIUvwFJ9W-IKns88gkWOKBCvByMEvm5MLo/edit?usp=sharing
            //
            //study("LBR PaintBars [LazyBear]", overlay = true, shorttitle = "LBRBARS_LB")
            //lbperiod = input(16, title = "HL Length")
            //atrperiod = input(9, title = "ATR Length")
            //mult = input(2.5, minval = 0, title = "ATR Multiplier")
            //bcf = input(true, title = "Color LBR Bars?")
            //mnlb = input(false, title = "Color non LBR Bars?")
            //svb = input(false, title = "Show Volatility Bands?")
            //aatr = mult * sma(atr(atrperiod), atrperiod)
            //b1 = lowest(low, lbperiod) + aatr
            //b2 = highest(high, lbperiod) - aatr
            //uvf = (close > b1 and close > b2)
            //lvf = (close < b1 and close<b2 )
            //uv = plot(svb ? b2 : na, style = line, linewidth = 3, color = red, title = "UpperBand")
            //lv = plot(svb ? b1 : na, style = line, linewidth = 3, color = green, title = "LowBand")
            //bc = (bcf ? uvf ? lime : lvf ? maroon : mnlb ? blue : na : (not(uvf or lvf) and mnlb ? blue: na ) )
            //barcolor(bc)
            decimal factor = 2.5m;
            List<decimal> upperBandList = new();
            List<decimal> lowerBandList = new();
            List<decimal> aatrList = new();
            List<Signal> signalsList = new();

            try
            {
                int hlPeriod = MinOrMax((int)Math.Ceiling(days / 0.5625));

                var minMaxList = VolumeInputCheck(stockDataClass, days, true);
                List<decimal> highestHighList = minMaxList.Item1;
                List<decimal> lowestLowList = minMaxList.Item2;
                var atrList = CalculateAverageTrueRange(stockDataClass, maType, days).Item1;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal highest = highestHighList.ElementAtOrDefault(i);
                    decimal lowest = lowestLowList.ElementAtOrDefault(i);
                    decimal currentAtr = atrList.ElementAtOrDefault(i);
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal aatr = factor * currentAtr;
                    aatrList.Add(aatr);

                    decimal prevLowerBand = lowerBandList.LastOrDefault();
                    decimal lowerBand = lowest + aatr;
                    lowerBandList.Add(lowerBand);

                    decimal prevUpperBand = upperBandList.LastOrDefault();
                    decimal upperBand = highest - aatr;
                    upperBandList.Add(upperBand);

                    var signal = GetBullishBearishSignal(currentValue - Math.Max(lowerBand, upperBand), prevValue - Math.Max(prevLowerBand, prevUpperBand),
                        currentValue - Math.Min(lowerBand, upperBand), prevValue - Math.Min(prevLowerBand, prevUpperBand));
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (aatrList, upperBandList, lowerBandList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateDonchianChannels(StockData stockDataClass, int days = 20)
        {
            //Upper Channel Line: 20 - day high
            //Lower Channel Line: 20 - day low
            //Centerline: (20 - day high + 20 - day low)/ 2
            List<decimal> upperChannelList = new();
            List<decimal> lowerChannelList = new();
            List<decimal> middleChannelList = new();
            List<decimal> prevHighPrices = new();
            List<decimal> prevLowPrices = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.HighPrices.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal currentHigh = stockDataClass.HighPrices.ElementAtOrDefault(i);

                    decimal prevHigh = currentValue > currentHigh ? i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0 : i >= 1 ? stockDataClass.HighPrices.ElementAtOrDefault(i - 1) : 0;
                    prevHighPrices.Add(prevHigh);

                    decimal prevLow = currentValue > currentHigh ? i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0 : i >= 1 ? stockDataClass.LowPrices.ElementAtOrDefault(i - 1) : 0;
                    prevLowPrices.Add(prevLow);

                    decimal upperChannel = stockDataClass.HighPrices.TakeLast(days).Max();
                    upperChannelList.Add(upperChannel);

                    decimal lowerChannel = stockDataClass.LowPrices.TakeLast(days).Min();
                    lowerChannelList.Add(lowerChannel);

                    decimal prevMiddleChannel = middleChannelList.LastOrDefault();
                    decimal middleChannel = (upperChannel + lowerChannel) / 2;
                    middleChannelList.Add(middleChannel);

                    var signal = GetCompareSignal(currentValue - middleChannel, prevValue - prevMiddleChannel);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (upperChannelList, middleChannelList, lowerChannelList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateDonchianChannelWidth(StockData stockDataClass,
            int days = 20)
        {
            //@version=2
            ////////////////////////////////////////////////////////////
            //  Copyright by HPotter v1.0 08/02/2018
            // The Donchian Channel was developed by Richard Donchian and it could be compared 
            // to the Bollinger Bands. When it comes to volatility analysis, the Donchian Channel 
            // Width was created in the same way as the Bollinger Bandwidth technical indicator was.
            //
            // As was mentioned above the Donchian Channel Width is used in technical analysis to measure 
            // volatility. Volatility is one of the most important parameters in technical analysis. 
            // A price trend is not just about a price change. It is also about volume traded during this 
            // price change and volatility of a this price change. When a technical analyst focuses his/her 
            // attention solely on price analysis by ignoring volume and volatility, he/she only sees a part 
            // of a complete picture only. This could lead to a situation when a trader may miss something and 
            // lose money. Lets take a look at a simple example how volatility may help a trader:
            //
            //    Most of the price based technical indicators are lagging indicators.
            //    When price moves on low volatility, it takes time for a price trend to change its direction and 
            // it could be ok to have some lag in an indicator.
            //    When price moves on high volatility, a price trend changes its direction faster and stronger. 
            // An indicator's lag acceptable under low volatility could be financially suicidal now - Buy/Sell signals could be generated when it is already too late.
            //
            // Another use of volatility - very popular one - it is to adapt a stop loss strategy to it:
            //    Smaller stop-loss recommended in low volatility periods. If it is not done, a stop-loss could 
            // be generated when it is too late.
            //    Bigger stop-loss recommended in high volatility periods. If it is not done, a stop-loss could 
            // be triggered too often and you may miss good trades.
            //
            // WARNING:
            // - This script to change bars colors.
            ////////////////////////////////////////////////////////////
            //study(title = "Donchian Channel Width Strategy")
            //length = input(20, minval = 1)
            //smoothe = input(22, minval = 1)
            //xUpper = highest(high, length)
            //xLower = lowest(low, length)
            //xDonchianWidth = xUpper - xLower
            //xSmoothed = sma(xDonchianWidth, smoothe)
            //pos = iff(xDonchianWidth > xSmoothed, -1,
            //      iff(xDonchianWidth < xSmoothed, 1, nz(pos[1], 0)))
            //barcolor(pos == -1 ? red : pos == 1 ? green : blue)
            //plot(xDonchianWidth, color = blue, title = "DCW")
            //plot(xSmoothed, color = red, title = "sDCW")
            List<decimal> donchianWidthList = new();
            List<decimal> donchianWidthSmaList = new();
            List<Signal> signalsList = new();

            try
            {
                int smoothLength = (int)Math.Ceiling(days / 0.9091);

                var donchianChannelList = CalculateDonchianChannels(stockDataClass, days);

                for (int i = 0; i < stockDataClass.HighPrices.Count; i++)
                {
                    decimal upper = donchianChannelList.Item1.ElementAtOrDefault(i);
                    decimal lower = donchianChannelList.Item3.ElementAtOrDefault(i);

                    decimal prevDonchianWidth = donchianWidthList.LastOrDefault();
                    decimal donchianWidth = upper - lower;
                    donchianWidthList.Add(donchianWidth);

                    decimal prevDonchianWidthSma = donchianWidthSmaList.LastOrDefault();
                    decimal donchianWidthSma = donchianWidthList.TakeLast(smoothLength).Average();
                    donchianWidthSmaList.Add(donchianWidthSma);

                    var signal = GetCompareSignal(donchianWidth - donchianWidthSma, prevDonchianWidth - prevDonchianWidthSma, true);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (donchianWidthList, donchianWidthSmaList, signalsList);
        }

        public static (List<decimal>, List<Signal>) CalculateAverageTrueRangeTrailingStops(StockData stockDataClass, string maType, int days = 21)
        {
            //position = pos, user defined, default is long
            //input = price, user defined, default is close
            //method = moving average (ma), user defined, default is EMA
            //period1 = maP, user defined, default is 63
            //period2 = artP, user defined, default is 21
            //factor = fac, user defined, default is 3
            //show entrys = showE, user defined, default is false
            //index = current bar number, prev = previous
            //LOE = less or equal, MOE = more or equal
            //shortP = short position, longP = long position
            //index = current bar number

            //longP = pos == "Long";
            //shortP = pos == "Short";
            //atrts = 0, atr = 0;
            //ma = ma(method, maP, input);
            //prevP = price[index - 1];
            //prevA = ifNull(price, atrts[index]); //current atrts is plotted at index+1
            //upTrend = price moreThan ma;
            //dnTrend = price LOE ma;
            //atr = atr(index, atrP);
            //if (upTrend)
            //atrts = price - fac * atr;
            //if (atrts lessThan prevA) atrts = prevA;
            //endIf
            //if (dnTrend)
            //atrts = price + fac * atr;
            //if (atrts moreThan prevA) atrts = prevA;
            //endIf
            //Plot: atrts[index + 1];
            //Signals
            //sell = false, buy = false;
            //if (atrts != 0)
            //if (longP AND upTrend)
            //sell = price lessThan atrts;   //sell to exit
            //buy = prevP lessThan atrts AND price moreThan atrts AND showE;  //buy (enter)
            //endIf
            //if (shortP AND dnTrend)
            //sell = prevP moreThan atrts AND price lessThan atrts  AND showE;   //sell short (enter)
            //buy = price moreThan atrts;  //buy to cover
            //endIf
            //endIf
            decimal factor = 3;
            bool upTrend, dnTrend;
            List<decimal> atrtsList = new();
            List<Signal> signalsList = new();

            try
            {
                int period1 = MinOrMax(days * 3);

                var atrList = CalculateAverageTrueRange(stockDataClass, maType, days).Item1;
                List<decimal> emaList = CalculateExponentialMovingAverage(stockDataClass, period1).Item1;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal currentEma = emaList.ElementAtOrDefault(i);
                    decimal currentAtr = atrList.ElementAtOrDefault(i);
                    decimal prevAtrts = i >= 1 ? atrtsList.LastOrDefault() : currentValue;
                    upTrend = currentValue > currentEma;
                    dnTrend = currentValue <= currentEma;

                    decimal atrts = upTrend ? Math.Max(currentValue - (factor * currentAtr), prevAtrts) : dnTrend ? Math.Min(currentValue + (factor * currentAtr), prevAtrts) :
                        prevAtrts;
                    atrtsList.Add(atrts);

                    var signal = GetCompareSignal(currentValue - atrts, prevValue - prevAtrts);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (atrtsList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateSchaffTrendCycle(StockData stockDataClass, string maType, int days = 10)
        {
            //– Sh: shorter-term Exponential Moving Average with a default period of 23
            //– Lg: longer - term Exponential Moving Average with a default period of 50
            //– Cycle, set at half the cycle length with a default value of 10.

            //The STC is calculated in the following order:

            //First, the 23 - period and the 50 - period EMA and the MACD values are calculated:

            //EMA1 = EMA(Close, Short Length);
            //EMA2 = EMA(Close, Long Length);
            //MACD = EMA1 – EMA2.

            //Second, the 10 - period Stochastic from the MACD values is calculated:

            //% K(MACD) = % KV(MACD, 10);
            //% D(MACD) = % DV(MACD, 10);
            //Schaff = 100 x(MACD – % K(MACD)) / (% D(MACD) – % K(MACD)).
            List<decimal> macdList = new();
            List<decimal> macdKList = new();
            List<decimal> macdDList = new();
            List<decimal> stcList = new();
            List<Signal> signalsList = new();

            try
            {
                int shortLength = MinOrMax((int)Math.Ceiling(days * 2.3));
                int longLength = MinOrMax(days * 5);
                int stochLength = days;

                var ema23List = GetMovingAverageList(maType, null, stockDataClass, shortLength);
                var ema50List = GetMovingAverageList(maType, null, stockDataClass, longLength);

                for (int i = 0; i < ema23List.Count; i++)
                {
                    decimal currentEma23 = ema23List.ElementAtOrDefault(i);
                    decimal currentEma50 = ema50List.ElementAtOrDefault(i);
                    decimal prevStc1 = i >= 1 ? stcList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevStc2 = i >= 2 ? stcList.ElementAtOrDefault(i - 2) : 0;

                    decimal macd = currentEma23 - currentEma50;
                    macdList.Add(macd);

                    decimal lowestMacd = macdList.TakeLast(stochLength).Min();
                    decimal highestMacd = macdList.TakeLast(stochLength).Max();

                    decimal macdK = highestMacd - lowestMacd != 0 ? MinOrMax(100 * ((macd - lowestMacd) / (highestMacd - lowestMacd)), 100, 0) : 0;
                    macdKList.Add(macdK);

                    decimal macdD = macdKList.TakeLast(stochLength).Average();
                    macdDList.Add(macdD);

                    decimal stc = macdD - macdK != 0 ? MinOrMax(100 * ((macd - macdK) / (macdD - macdK)), 100, 0) : 0;
                    stcList.Add(stc);

                    var signal = GetRsiSignal(stc - prevStc1, prevStc1 - prevStc2, stc, prevStc1, 75, 25);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (macdList, macdKList, macdDList, stcList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateAverageTrueRangeChannel(StockData stockDataClass,
            string maType, int days = 14)
        {
            //period = user defined, default is 14
            //shift = user defined, default is 0
            //multiplier = user defined, default is 2.5
            //sma = simple moving average
            //LT = less than

            //Calculate top and middle lines 
            //for (int i = period; i LT size(); i++) 
            //atr = sma(i, period, "TrueRange");
            //close = getClose(i);
            //top = round(close + (atr * mult));
            //bottom = round(close - (atr * mult));
            //Plot1: plot(i + shift, top);
            //Plot2: plot(i + shift, bottom);
            //endFor
            decimal multiplier = 2.5m, innerMultiplier = 1.25m;
            List<decimal> outerTopAtrChannelList = new();
            List<decimal> outerBottomAtrChannelList = new();
            List<decimal> innerTopAtrChannelList = new();
            List<decimal> innerBottomAtrChannelList = new();
            List<Signal> signalsList = new();

            try
            {
                var atrList = CalculateAverageTrueRange(stockDataClass, maType, days).Item1;
                var smaList = CalculateSimpleMovingAverage(stockDataClass, days).Item1;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal atr = atrList.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal sma = smaList.ElementAtOrDefault(i);
                    decimal prevSma = i >= 1 ? smaList.ElementAtOrDefault(i - 1) : 0;

                    decimal topOuter = Math.Round(currentValue + (atr * multiplier));
                    outerTopAtrChannelList.Add(topOuter);

                    decimal bottomOuter = Math.Round(currentValue - (atr * multiplier));
                    outerBottomAtrChannelList.Add(bottomOuter);

                    decimal prevTopInner = innerTopAtrChannelList.LastOrDefault();
                    decimal topInner = Math.Round(currentValue + (atr * innerMultiplier));
                    innerTopAtrChannelList.Add(topInner);

                    decimal prevBottomInner = innerBottomAtrChannelList.LastOrDefault();
                    decimal bottomInner = Math.Round(currentValue - (atr * innerMultiplier));
                    innerBottomAtrChannelList.Add(bottomInner);

                    var signal = GetBollingerBandsSignal(currentValue - sma, prevValue - prevSma, currentValue, prevValue, topInner, prevTopInner, bottomInner, prevBottomInner);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (outerTopAtrChannelList, outerBottomAtrChannelList, innerTopAtrChannelList, innerBottomAtrChannelList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateTrueStrengthIndex(StockData stockDataClass, string maType, int days = 9)
        {
            //
            // @author LazyBear
            // @credits http://en.wikipedia.org/wiki/True_strength_index
            // 
            //study(title = "True Strength Index [LazyBear]", shorttitle = "LB_TSI", overlay = false)
            //r = input(25, title = "Momentum Smoothing 1")
            //s = input(13, title = "Momentum Smoothing 2")
            //src = close
            //m = src - src[1]
            //tsi = 100 * (ema(ema(m, r), s) / ema(ema(abs(m), r), s))
            //ul = hline(25)
            //ll = hline(-25)
            //fill(ul, ll)
            //plot(tsi, color = red)
            List<decimal> pcList = new();
            List<decimal> absPCList = new();
            List<decimal> pcSmooth1List = new();
            List<decimal> absPCSmooth1List = new();
            List<decimal> pcSmooth2List = new();
            List<decimal> absPCSmooth2List = new();
            List<decimal> tsiList = new();
            List<decimal> tsiSignalList = new();
            List<Signal> signalsList = new();

            try
            {
                int r = (int)Math.Ceiling(days / 0.36);
                int s = (int)Math.Ceiling(days / 0.6924);
                int signalPeriod = days;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal pc = currentValue - prevValue;
                    pcList.Add(pc);

                    decimal absPC = Math.Abs(currentValue - prevValue);
                    absPCList.Add(absPC);
                }

                pcSmooth1List = GetMovingAverageList(maType, pcList, stockDataClass, r);
                pcSmooth2List = GetMovingAverageList(maType, pcSmooth1List, stockDataClass, s);
                absPCSmooth1List = GetMovingAverageList(maType, absPCList, stockDataClass, r);
                absPCSmooth2List = GetMovingAverageList(maType, absPCSmooth1List, stockDataClass, s);
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal absSmooth2PC = absPCSmooth2List.ElementAtOrDefault(j);
                    decimal smooth2PC = pcSmooth2List.ElementAtOrDefault(j);

                    decimal tsi = absSmooth2PC != 0 ? MinOrMax(100 * smooth2PC / absSmooth2PC, 100, -100) : 0;
                    tsiList.Add(tsi);
                }

                tsiSignalList = GetMovingAverageList(maType, tsiList, stockDataClass, signalPeriod);
                for (int k = 0; k < stockDataClass.InputValues.Count; k++)
                {
                    decimal tsi = tsiList.ElementAtOrDefault(k);
                    decimal prevTsi1 = k >= 1 ? tsiList.ElementAtOrDefault(k - 1) : 0;
                    decimal prevTsi2 = k >= 2 ? tsiList.ElementAtOrDefault(k - 2) : 0;

                    var signal = GetRsiSignal(tsi - prevTsi1, prevTsi1 - prevTsi2, tsi, prevTsi1, 25, -25);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (pcSmooth1List, absPCSmooth1List, pcSmooth2List, absPCSmooth2List, tsiList, tsiSignalList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateSMIErgodicIndicator(StockData stockDataClass, string maType, int days = 5)
        {
            //price (user defined, default is closing price)
            //method = moving average (user defined, default is EMA)
            //prevP = previousPrice
            //abs = absolute value
            //ma = moving average, index = current bar number
            //MT = moreThan
            //LT = lessThan

            //prevP = price[index - 1];
            //change = price - prevP;
            //absChange = abs(price - prevP);
            //tempChange = ma(method, index, fastPeriod, change);
            //tempAbsC = ma(method, index, fastPeriod, absChange);
            //tempChange = ma(method, index, slowPeriod, tempChange);
            //tempAbsC = ma(method, index, slowPeriod, tempAbsC);
            //Plot1: SMI = tempChange / tempAbsC;
            //Plot2: SIGNAL = ma(method, index, sigPeriod, SMI);
            //Signals
            //highSell = smi for last sell signal, reset to max_negative at each  buy signal;
            //lowBuy = smi for last buy signal, reset to max_positive at each sell signal;
            //sell = crossedBelow(SMI, SIGNAL) AND smi MT topGuide  AND smi MT highSell;
            //buy = crossedAbove(SMI, SIGNAL) AND smi LT bottomGuide AND smi LT lowBuy;
            List<decimal> pcList = new();
            List<decimal> absPCList = new();
            List<decimal> pcSmooth1List = new();
            List<decimal> absPCSmooth1List = new();
            List<decimal> pcSmooth2List = new();
            List<decimal> absPCSmooth2List = new();
            List<decimal> smiList = new();
            List<decimal> smiSignalList = new();
            List<Signal> signalsList = new();

            try
            {
                int fastPeriod = days;
                int slowPeriod = MinOrMax(fastPeriod * 4);
                int signalPeriod = fastPeriod;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal pc = currentValue - prevValue;
                    pcList.Add(pc);

                    decimal absPC = Math.Abs(currentValue - prevValue);
                    absPCList.Add(absPC);
                }

                pcSmooth1List = GetMovingAverageList(maType, pcList, stockDataClass, slowPeriod);
                pcSmooth2List = GetMovingAverageList(maType, pcSmooth1List, stockDataClass, fastPeriod);
                absPCSmooth1List = GetMovingAverageList(maType, absPCList, stockDataClass, slowPeriod);
                absPCSmooth2List = GetMovingAverageList(maType, absPCSmooth1List, stockDataClass, fastPeriod);
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal absSmooth2PC = absPCSmooth2List.ElementAtOrDefault(j);
                    decimal smooth2PC = pcSmooth2List.ElementAtOrDefault(j);

                    decimal smi = absSmooth2PC != 0 ? MinOrMax(100 * smooth2PC / absSmooth2PC, 100, -100) : 0;
                    smiList.Add(smi);
                }

                smiSignalList = GetMovingAverageList(maType, smiList, stockDataClass, signalPeriod);
                for (int k = 0; k < stockDataClass.InputValues.Count; k++)
                {
                    decimal smi = smiList.ElementAtOrDefault(k);
                    decimal smiSignal = smiSignalList.ElementAtOrDefault(k);
                    decimal prevSmi = k >= 1 ? smiList.ElementAtOrDefault(k - 1) : 0;
                    decimal prevSmiSignal = k >= 1 ? smiSignalList.ElementAtOrDefault(k - 1) : 0;

                    var signal = GetRsiSignal(smi - smiSignal, prevSmi - prevSmiSignal, smi, prevSmi, 10, -10);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (pcSmooth1List, absPCSmooth1List, pcSmooth2List, absPCSmooth2List, smiList, smiSignalList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateTrix(StockData stockDataClass, string maType, int days = 9)
        {
            //input = price, user defined, default is close
            //period = user defined, default is 15
            //period2 = user defined, default is 9
            //EMA = exponential moving average
            //ma = moving average, prev = previous
            //index = current bar number, sig = signal

            //ma1 = ma("EMA", index, period, input);
            //ma2 = ma("EMA", index, period, MA1);
            //ma3 = ma("EMA", index, period, MA2);
            //prevMA3 = MA3[index - 1];
            //TRIX = 100 * ((ma3 - prevMA3) / prevMA3);
            //sig = ma("EMA", index, period2, TRIX);
            // Signals
            //buy = crossedAbove(TRIX, SIG);
            //sell = crossedBelow(TRIX, SIG);
            List<decimal> trixList = new();
            List<decimal> trixSignalList = new();
            List<Signal> signalsList = new();

            try
            {
                int period = (int)Math.Ceiling(days / 0.6);
                int period2 = days;

                var ema1List = GetMovingAverageList(maType, null, stockDataClass, period);
                var ema2List = GetMovingAverageList(maType, ema1List, stockDataClass, period);
                var ema3List = GetMovingAverageList(maType, ema2List, stockDataClass, period);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal ema1 = ema1List.ElementAtOrDefault(i);
                    decimal ema2 = ema2List.ElementAtOrDefault(i);
                    decimal ema3 = ema3List.ElementAtOrDefault(i);
                    decimal prevEma3 = i >= 1 ? ema3List.ElementAtOrDefault(i - 1) : 0;

                    decimal trix = prevEma3 != 0 ? 100 * (ema3 - prevEma3) / prevEma3 : 0;
                    trixList.Add(trix);
                }

                trixSignalList = GetMovingAverageList(maType, trixList, stockDataClass, period2);
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal trix = trixList.ElementAtOrDefault(j);
                    decimal trixSignal = trixSignalList.ElementAtOrDefault(j);
                    decimal prevTrix = j >= 1 ? trixList.ElementAtOrDefault(j - 1) : 0;
                    decimal prevTrixSignal = j >= 1 ? trixSignalList.ElementAtOrDefault(j - 1) : 0;

                    var signal = GetCompareSignal(trix - trixSignal, prevTrix - prevTrixSignal);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (trixList, trixSignalList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateUlcerIndex(StockData stockDataClass, int days = 14)
        {
            //@version=3
            // Copyright (c) 2018-present, Alex Orekhov (everget)
            // Ulcer Index script may be freely distributed under the MIT license.
            //study("Ulcer Index")

            //length = input(title = "Length", type = integer, defval = 14)
            //smoothLength = input(title = "Smoothing Length", type = integer, defval = 14)
            //breakout = input(title = "Breakout Level", type = float, step = 0.1, defval = 1.5)
            //signalType = input(title = "Signal Smoothing Type", defval = "SMA", options =["EMA", "SMA"])
            //signalLength = input(title = "Signal Smoothing Length", type = integer, defval = 52)
            //showSignal = input(title = "Show Signal ?", type = bool, defval = true)
            //highlightCrossovers = input(title = "Highlight Crossovers ?", type = bool, defval = true)
            //src = input(title = "Source", type = source, defval = close)

            //highest = highest(src, length)

            //drawdown = 100 * (src - highest) / highest
            //ulcer = sqrt(sma(pow(drawdown, 2), smoothLength))

            //signal = signalType == "SMA" ? sma(ulcer, signalLength) : ema(ulcer, signalLength)

            //ulcerColor = ulcer >= ulcer[1] ? #0ebb23 : red

            //plot(ulcer, title = "Ulcer", linewidth = 2, color = ulcerColor, transp = 0)
            //plot(showSignal ? signal : na, title = "Signal", color =#1155cc, transp=0)
            //plotshape(crossover(ulcer, signal) and highlightCrossovers ? ulcer : na, title = "Crossover", location = location.absolute, style = shape.circle, size = size.small, color = green, transp = 70)
            //plotshape(crossunder(ulcer, signal) and highlightCrossovers ? ulcer : na, title = "Crossunder", location = location.absolute, style = shape.circle, size = size.small, color = red, transp = 70)

            //hline(breakout, title = "Breakout Level", linestyle = dotted)

            //breakoutFillColor = ulcer > breakout ? #ff9800 : color(white, 100)

            //bgcolor(breakoutFillColor, transp = 90)
            List<decimal> ulcerIndexList = new();
            List<decimal> pctDrawdownList = new();
            List<decimal> pctDrawdownSquaredList = new();
            List<decimal> squaredAvgList = new();
            List<decimal> tempList = new();
            List<decimal> ulcerIndexSignalList = new();
            List<Signal> signalsList = new();

            try
            {
                int signalPeriod = MinOrMax((int)Math.Ceiling(days / 0.2692));

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    tempList.Add(currentValue);

                    decimal maxValue = tempList.TakeLast(days).Max();

                    decimal pctDrawdown = maxValue != 0 ? (currentValue - maxValue) / maxValue * 100 : 0;
                    pctDrawdownList.Add(pctDrawdown);

                    decimal pctDrawdownSquared = Pow(pctDrawdown, 2);
                    pctDrawdownSquaredList.Add(pctDrawdownSquared);

                    decimal squaredAvg = pctDrawdownSquaredList.TakeLast(days).Average();
                    squaredAvgList.Add(squaredAvg);

                    decimal prevUlcerIndex = ulcerIndexList.LastOrDefault();
                    decimal ulcerIndex = squaredAvg >= 0 ? (decimal)Sqrt((double)squaredAvg) : 0;
                    ulcerIndexList.Add(ulcerIndex);

                    decimal prevUlcerIndexSignal = ulcerIndexSignalList.LastOrDefault();
                    decimal ulcerIndexSignal = ulcerIndexList.TakeLast(signalPeriod).Average();
                    ulcerIndexSignalList.Add(ulcerIndexSignal);

                    var signal = GetCompareSignal(ulcerIndex - ulcerIndexSignal, prevUlcerIndex - prevUlcerIndexSignal, true);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (pctDrawdownList, pctDrawdownSquaredList, squaredAvgList, ulcerIndexList, ulcerIndexSignalList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<decimal>, List<Signal>) CalculateMartinRatio(StockData stockDataClass, int days = 30)
        {
            //input = price, user defined, default is close
            //period = p1, user defined, default is 30
            //safe = safe return percentage, user defined, default is 2
            //av = average, pow = power
            //sma = simple moving average
            //index = current bar number
            //sqrt = square root

            //safe = safe / 100;  //convert percent to decimal
            //BarSize bar = getBarSize();
            //if (bar.getType() == BarSizeType.LINEAR) barMin = bar.getInterval();
            //else return;
            //minPerYr = 60 * 24 * 30 * 12;
            //barsPerYr = minPerYr / barMin;
            //adjSafe = Math.pow((1 + safe), p1 / barsPerYr) - 1; //safe return per period compounded
            //priorP = price[index - p1];
            //ret = ((100 * (price / priorP) - 1)) - (adjSafe * 100); //safe return subtracted here to reflect Sharpe 1994 revision
            //av = sma(index, p1, ret);
            //ulcer = ulcer(index, p1, ret);
            //Plot: martin = av / ulcer;
            decimal barMin = 60 * 24, bmk = 0.02m;
            List<decimal> martinList = new();
            List<decimal> benchList = new();
            List<decimal> retList = new();
            List<decimal> retSmaList = new();
            List<decimal> pctDrawdownList = new();
            List<decimal> pctDrawdownSquaredList = new();
            List<decimal> squaredAvgList = new();
            List<decimal> ulcerIndexList = new();
            List<Signal> signalsList = new();

            try
            {
                decimal minPerYr = 60 * 24 * 30 * 12;
                decimal barsPerYr = minPerYr / barMin;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= days ? stockDataClass.InputValues.ElementAtOrDefault(i - days) : 0;

                    decimal bench = Pow(1 + bmk, days / (double)barsPerYr) - 1;
                    benchList.Add(bench);

                    decimal ret = prevValue != 0 ? (100 * (currentValue / prevValue)) - 1 - (bench * 100) : 0;
                    retList.Add(ret);

                    decimal retSma = retList.TakeLast(days).Average();
                    retSmaList.Add(retSma);

                    decimal maxValue = retList.TakeLast(days).Max();
                    decimal pctDrawdown = maxValue != 0 ? (ret - maxValue) / maxValue * 100 : 0;
                    pctDrawdownList.Add(pctDrawdown);

                    decimal pctDrawdownSquared = Pow(pctDrawdown, 2);
                    pctDrawdownSquaredList.Add(pctDrawdownSquared);

                    decimal squaredAvg = pctDrawdownSquaredList.TakeLast(days).Average();
                    squaredAvgList.Add(squaredAvg);

                    decimal ulcerIndex = squaredAvg >= 0 ? (decimal)Sqrt((double)squaredAvg) : 0;
                    ulcerIndexList.Add(ulcerIndex);

                    decimal prevMartin = martinList.LastOrDefault();
                    decimal martin = ulcerIndex != 0 ? retSma / ulcerIndex : 0;
                    martinList.Add(martin);

                    var signal = GetCompareSignal(martin - 2, prevMartin - 2);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (benchList, retList, retSmaList, pctDrawdownList, pctDrawdownSquaredList, squaredAvgList, ulcerIndexList, martinList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateMassIndex(StockData stockDataClass, string maType, int days = 9)
        {
            //key = price (user defined, default is closing price)
            //method = moving average (user defined, default is EMA)
            //period1 = user defined, default is 21
            //period2 = user defined, default is 21
            //period3 = user defined, default is 25
            //trendPeriod = user defined, default is 9
            //trendMethod = moving average (user defined, default is EMA)
            //LT = less than, index = current bar number
            //MT = more than

            //Plot1: TREND = ma(trendMethod, index, trendPeriod, key);
            //HL = high - low;
            //firstEma = ma(method, index, period1, HL);
            //secondEma = ma(method, index, period2, firstEma);
            //RATIO = secondEma / firstEma;
            //ALERT = false;
            //Plot2: massIndex = sum(index, period3, RATIO);
            //Signals
            //lastTrend = TREND[index - 1];
            //prevAlert = ALERT[index - 1];
            //upTrend = lastTrend LT TREND;
            //downTernd = lastTrend MT TREND
            //if (massIndex MT topGuide) ALERT = true);
            //if (massIndex MT bottGuide AND prevAlert) ALERT = true);
            //sell = massIndex LT bottomGuide AND prevAlert AND upTrend;
            //buy = massIndex LT bottomGuide AND prevAlert AND downTrend;
            List<decimal> highLowList = new();
            List<decimal> firstEmaList = new();
            List<decimal> secondEmaList = new();
            List<decimal> ratioList = new();
            List<decimal> massIndexList = new();
            List<decimal> massIndexSignalList = new();
            List<Signal> signalsList = new();

            try
            {
                int period1 = MinOrMax((int)Math.Ceiling(days / 0.4286));
                int period3 = MinOrMax((int)Math.Ceiling(days / 0.36));

                for (int i = 0; i < stockDataClass.HighPrices.Count; i++)
                {
                    decimal currentHigh = stockDataClass.HighPrices.ElementAtOrDefault(i);
                    decimal currentLow = stockDataClass.LowPrices.ElementAtOrDefault(i);

                    decimal highLow = currentHigh - currentLow;
                    highLowList.Add(highLow);
                }

                firstEmaList = GetMovingAverageList(maType, highLowList, stockDataClass, period1);
                secondEmaList = GetMovingAverageList(maType, firstEmaList, stockDataClass, period1);
                for (int j = 0; j < stockDataClass.HighPrices.Count; j++)
                {
                    decimal firstEma = firstEmaList.ElementAtOrDefault(j);
                    decimal secondEma = secondEmaList.ElementAtOrDefault(j);

                    decimal ratio = secondEma != 0 ? firstEma / secondEma : 0;
                    ratioList.Add(ratio);

                    decimal massIndex = ratioList.TakeLast(period3).Sum();
                    massIndexList.Add(massIndex);
                }

                massIndexSignalList = GetMovingAverageList(maType, massIndexList, stockDataClass, days);
                for (int k = 0; k < stockDataClass.HighPrices.Count; k++)
                {
                    decimal massIndex = massIndexList.ElementAtOrDefault(k);
                    decimal massIndexEma = massIndexSignalList.ElementAtOrDefault(k);
                    decimal prevMassIndex = k >= 1 ? massIndexList.ElementAtOrDefault(k - 1) : 0;
                    decimal prevMassIndexEma = k >= 1 ? massIndexSignalList.ElementAtOrDefault(k - 1) : 0;

                    var signal = GetCompareSignal(massIndex - massIndexEma, prevMassIndex - prevMassIndexEma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (highLowList, firstEmaList, secondEmaList, ratioList, massIndexList, massIndexSignalList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateForceIndex(StockData stockDataClass, string maType, int days = 2)
        {
            //method = moving average (ma), user defined, default is EMA
            //period1 = p1, user defined, default is 2
            //period2 = p2, user defined, default is 13
            //prev = previous, index = current bar number 
            //prevP = price[index - 1];
            //vol = getVolume(index);
            //rawForce = vol * (price - prevP);
            //Plot1: force = ma(method, index, p1, rawForce);
            //Plot2: ma = ma(method, index, p2, rawForce);
            //Signals
            //prevMa = ma[index - 1];
            //highSell = force for last sell signal, reset to max_negative at each  buy signal;
            //lowBuy = force for last buy signal, reset to max_positive at each sell signal;
            //sell = force moreThan midGuide AND ma lessThan prevMa AND price moreThan highSell;
            //buy = force  lessThan midGuide AND ma moreThan prevMa AND price lessThan lowBuy;
            List<decimal> rawForceList = new();
            List<decimal> forceList = new();
            List<decimal> forceIndexEmaList = new();
            List<Signal> signalsList = new();

            try
            {
                int p2 = MinOrMax((int)Math.Ceiling(days / 0.1538));

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal currentVolume = stockDataClass.Volumes.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal rawForce = (currentValue - prevValue) * currentVolume;
                    rawForceList.Add(rawForce);
                }

                forceList = GetMovingAverageList(maType, rawForceList, stockDataClass, days);
                forceIndexEmaList = GetMovingAverageList(maType, rawForceList, stockDataClass, p2);
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal force = forceList.ElementAtOrDefault(j);
                    decimal prevForce = j >= 1 ? forceList.ElementAtOrDefault(j - 1) : 0;
                    decimal forceIndexEma = forceIndexEmaList.ElementAtOrDefault(j);
                    decimal prevForceIndexEma = j >= 1 ? forceIndexEmaList.ElementAtOrDefault(j - 1) : 0;

                    var signal = GetCompareSignal(force - forceIndexEma, prevForce - prevForceIndexEma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (rawForceList, forceList, forceIndexEmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateEaseOfMovement(StockData stockDataClass, int days = 14)
        {
            ////////////////////////////////////////////////////////////
            //  Copyright by HPotter v1.0 05/06/2014
            // This indicator gauges the magnitude of price and volume movement. 
            // The indicator returns both positive and negative values where a 
            // positive value means the market has moved up from yesterday's value 
            // and a negative value means the market has moved down. A large positive 
            // or large negative value indicates a large move in price and/or lighter 
            // volume. A small positive or small negative value indicates a small move 
            // in price and/or heavier volume.
            // A positive or negative numeric value. A positive value means the market 
            // has moved up from yesterday's value, whereas, a negative value means the 
            // market has moved down. 
            ////////////////////////////////////////////////////////////
            //study(title = "Ease of Movement (EOM)", shorttitle = "EOM")
            //hline(0, color = blue, linestyle = line)
            //xHigh = high
            //xLow = low
            //xVolume = volume
            //xHalfRange = (xHigh - xLow) * 0.5
            //xMidpointMove = mom(xHalfRange, 1)
            //xBoxRatio = iff((xHigh - xLow) != 0, xVolume / (xHigh - xLow), 0)
            //nRes = iff(xBoxRatio != 0, 1000000 * ((xMidpointMove - xMidpointMove[1]) / xBoxRatio), 0)
            //plot(nRes, color = red, title = "EOM", style = histogram, linewidth = 2)
            List<decimal> halfRangeList = new();
            List<decimal> midpointMoveList = new();
            List<decimal> boxRatioList = new();
            List<decimal> emvList = new();
            List<decimal> emvSmaList = new();
            List<decimal> emvSignalList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.HighPrices.Count; i++)
                {
                    decimal currentHigh = stockDataClass.HighPrices.ElementAtOrDefault(i);
                    decimal currentLow = stockDataClass.LowPrices.ElementAtOrDefault(i);
                    decimal currentVolume = stockDataClass.Volumes.ElementAtOrDefault(i);
                    decimal prevHigh = i >= 1 ? stockDataClass.HighPrices.ElementAtOrDefault(i - 1) : 0;
                    decimal prevLow = i >= 1 ? stockDataClass.LowPrices.ElementAtOrDefault(i - 1) : 0;

                    decimal prevHalfRange = halfRangeList.LastOrDefault();
                    decimal halfRange = (currentHigh - currentLow) * 0.5m;
                    halfRangeList.Add(halfRange);

                    decimal prevMidpointMove = midpointMoveList.LastOrDefault();
                    decimal midpointMove = halfRange - prevHalfRange;
                    midpointMoveList.Add(midpointMove);

                    decimal boxRatio = currentHigh - currentLow != 0 ? currentVolume / (currentHigh - currentLow) : 0;
                    boxRatioList.Add(boxRatio);

                    decimal prevEmv = emvList.LastOrDefault();
                    decimal emv = boxRatio != 0 ? 1000000 * ((midpointMove - prevMidpointMove) / boxRatio) : 0;
                    emvList.Add(emv);

                    decimal emvSMA = emvList.TakeLast(days).Average();
                    emvSmaList.Add(emvSMA);

                    decimal prevEmvSignal = emvSignalList.LastOrDefault();
                    decimal emvSignal = emvSmaList.TakeLast(days).Average();
                    emvSignalList.Add(emvSignal);

                    var signal = GetCompareSignal(emv - emvSignal, prevEmv - prevEmvSignal);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (halfRangeList, midpointMoveList, boxRatioList, emvList, emvSmaList, emvSignalList, signalsList);
        }

        public static (List<decimal>, List<Signal>) CalculateDetrendedPriceOscillator(StockData stockDataClass, int days = 20)
        {
            //input = price (user defined, default is closing price)
            //method = moving average (user defined, default is SMA)
            //period user defined, default is 20, adjust to rhythm of stock
            //LT = lessThan
            //MT = moreThan
            //disp = displace, index = current bar number

            //disp = (period / 2) + 1;
            //dispSma = ma(method, index - disp, period, input);
            //Plot: DPO = price - dispSma;
            //Signals
            //prevDpo = DPO[index - 1];
            //highSell = dpo for last sell signal, reset to max_negative at each  buy signal;
            //lowBuy = dpo for last buy signal, reset to max_positive at each sell signal;
            //sell = (dpo MT topGuide) AND(prevDpo MT dpo)  AND(dpo MT highSell);
            //buy = (dpo LT bottGuide AND prevDpo LT dpo)  AND(dpo LT lowBuy);
            List<decimal> dpoList = new();
            List<Signal> signalsList = new();

            try
            {
                int prevPeriods = MinOrMax((int)Math.Ceiling(((decimal)days / 2) + 1));

                List<decimal> smaList = CalculateSimpleMovingAverage(stockDataClass, days).Item1;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentSma = smaList.ElementAtOrDefault(i);
                    decimal prevValue = i >= prevPeriods ? stockDataClass.InputValues.ElementAtOrDefault(i - prevPeriods) : 0;

                    decimal prevDpo = dpoList.LastOrDefault();
                    decimal dpo = prevValue - currentSma;
                    dpoList.Add(dpo);

                    var signal = GetCompareSignal(dpo, prevDpo);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (dpoList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateAverageTrueRange(StockData stockDataClass, string maType, int days = 7)
        {
            //To calculate the ATR, the True Range first needs to be discovered.True Range takes into account
            //the most current period high/ low range as well as the previous period close if necessary.

            //There are three calculation which need to be completed and then compared against each other.

            //The True Range is the largest of the following:

            //The Current Period High minus(-) Current Period Low
            //The Absolute Value(abs) of the Current Period High minus(-) The Previous Period Close
            //The Absolute Value(abs) of the Current Period Low minus(-) The Previous Period Close

            //true range = max[(high - low), abs(high - previous close), abs(low - previous close)]

            //* Absolute Value is used because the ATR does not measure price direction, only volatility. 
            //Therefore there should be no negative numbers.

            //* Once you have the True Range, the Average True Range can be plotted.
            //The ATR is an Exponential Moving Average of the True Range.

            //NATR = ATR(n) / Close * 100
            //Where: ATR(n) = Average True Range over ‘n’ periods.
            List<decimal> atrList = new();
            List<decimal> trList = new();
            List<decimal> natrList = new();
            List<Signal> signalsList = new();

            try
            {
                int signalPeriod = days;
                int length = days * 2;

                IEnumerable<decimal> emaList = CalculateExponentialMovingAverage(stockDataClass, length).Item1;
                var lists = VolumeInputCheck(stockDataClass, length, false);
                var highList = lists.Item1;
                var lowList = lists.Item2;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentHigh = highList.ElementAtOrDefault(i);
                    decimal currentLow = lowList.ElementAtOrDefault(i);
                    decimal prevClose = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal currentTrueRange = Math.Max(currentHigh - currentLow, Math.Max(Math.Abs(currentHigh - prevClose), Math.Abs(currentLow - prevClose)));
                    trList.Add(currentTrueRange);
                }

                atrList = GetMovingAverageList(maType, trList, stockDataClass, length);
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(j);
                    decimal averageTrueRange = atrList.ElementAtOrDefault(j);
                    decimal currentEma = emaList.ElementAtOrDefault(j);
                    decimal prevValue = j >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(j - 1) : 0;
                    decimal prevEma = j >= 1 ? emaList.ElementAtOrDefault(j - 1) : 0;

                    decimal normalizedAvgTrueRange = currentValue != 0 ? averageTrueRange / currentValue * 100 : 0;
                    natrList.Add(normalizedAvgTrueRange);

                    decimal atrSma = atrList.Count > 0 ? atrList.TakeLast(signalPeriod).Average() : 0;
                    var signal = GetVolatilitySignal(currentValue - currentEma, prevValue - prevEma, averageTrueRange, atrSma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (atrList, natrList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateExtendedRecursiveBands(StockData stockDataClass, string maType, int days = 100)
        {
            //@version=4
            //study("Extended Recursive Bands", overlay = true)
            //length = input(100),src = input(close),method = input("Classic", options =["Classic", "Atr", "Stdev", "Ahlr", "Rfv"])
            //----
            //atr = atr(length), stdev = stdev(src, length), ahlr = sma(high - low, length)
            //rfv = 0.,rfv:= rising(src, length) or falling(src, length) ? abs(change(src)) : rfv[1]
            //-----
            //f(a, b, c)=>method == a ? b : c
            //v(x) => f("Atr", atr, f("Stdev", stdev, f("Ahlr", ahlr, f("Rfv", rfv, x))))
            //----
            //sc = 2 / (length + 1)
            //a = 0.,a:= max(nz(a[1], src), src) - sc * v(abs(src - nz(a[1], src)))
            //b = 0.,b:= min(nz(b[1], src), src) + sc * v(abs(src - nz(b[1], src)))
            //----
            //plot(a, color = color.blue, linewidth = 2, transp = 0)
            //plot(b, color = color.orange, linewidth = 2, transp = 0)
            List<decimal> ahlrList = new();
            List<decimal> rfvList = new();
            List<decimal> aClassicList = new();
            List<decimal> bClassicList = new();
            List<decimal> cClassicList = new();
            List<decimal> aAtrList = new();
            List<decimal> bAtrList = new();
            List<decimal> cAtrList = new();
            List<decimal> aStdDevList = new();
            List<decimal> bStdDevList = new();
            List<decimal> cStdDevList = new();
            List<decimal> aAhlrList = new();
            List<decimal> bAhlrList = new();
            List<decimal> cAhlrList = new();
            List<decimal> aRfvList = new();
            List<decimal> bRfvList = new();
            List<decimal> cRfvList = new();
            List<decimal> tempList = new();
            List<Signal> signalsList = new();

            try
            {
                var hlrList = CalculateChaikinVolatility(stockDataClass, days).Item1;
                ahlrList = GetMovingAverageList(maType, hlrList, stockDataClass, days);
                var atrList = CalculateAverageTrueRange(stockDataClass, maType, days).Item1;
                var stdDevList = CalculateStandardDeviationVolatility(null, stockDataClass, days).Item4;

                decimal sc = (decimal)2 / (days + 1);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal ahlr = ahlrList.ElementAtOrDefault(i);
                    decimal atr = atrList.ElementAtOrDefault(i);
                    decimal stdDev = stdDevList.ElementAtOrDefault(i);
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal priorValue = i >= days ? stockDataClass.InputValues.ElementAtOrDefault(i - days) : 0;
                    decimal prevAClassic = i >= 1 ? aClassicList.ElementAtOrDefault(i - 1) : currentValue;
                    decimal prevBClassic = i >= 1 ? bClassicList.ElementAtOrDefault(i - 1) : currentValue;
                    decimal prevAAtr = i >= 1 ? aAtrList.ElementAtOrDefault(i - 1) : currentValue;
                    decimal prevBAtr = i >= 1 ? bAtrList.ElementAtOrDefault(i - 1) : currentValue;
                    decimal prevAStdDev = i >= 1 ? aStdDevList.ElementAtOrDefault(i - 1) : currentValue;
                    decimal prevBStdDev = i >= 1 ? bStdDevList.ElementAtOrDefault(i - 1) : currentValue;
                    decimal prevAAhlr = i >= 1 ? aAhlrList.ElementAtOrDefault(i - 1) : currentValue;
                    decimal prevBAhlr = i >= 1 ? bAhlrList.ElementAtOrDefault(i - 1) : currentValue;
                    decimal prevARfv = i >= 1 ? aRfvList.ElementAtOrDefault(i - 1) : currentValue;
                    decimal prevBRfv = i >= 1 ? bRfvList.ElementAtOrDefault(i - 1) : currentValue;

                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    tempList.Add(prevValue);

                    var lbList = tempList.TakeLast(days).ToList();
                    decimal rfv = currentValue > lbList.Max() || currentValue < lbList.Min() ? Math.Abs(currentValue - prevValue) : rfvList.LastOrDefault();
                    rfvList.Add(rfv);

                    decimal aClassic = Math.Max(prevAClassic, currentValue) - (sc * Math.Abs(currentValue - prevAClassic));
                    aClassicList.Add(aClassic);

                    decimal bClassic = Math.Min(prevBClassic, currentValue) + (sc * Math.Abs(currentValue - prevBClassic));
                    bClassicList.Add(bClassic);

                    decimal prevCClassic = cClassicList.LastOrDefault();
                    decimal cClassic = (aClassic + bClassic) / 2;
                    cClassicList.Add(cClassic);

                    decimal aAtr = Math.Max(prevAAtr, currentValue) - (sc * atr);
                    aAtrList.Add(aAtr);

                    decimal bAtr = Math.Min(prevBAtr, currentValue) + (sc * atr);
                    bAtrList.Add(bAtr);

                    decimal cAtr = (aAtr + bAtr) / 2;
                    cAtrList.Add(cAtr);

                    decimal aStdDev = Math.Max(prevAStdDev, currentValue) - (sc * stdDev);
                    aStdDevList.Add(aStdDev);

                    decimal bStdDev = Math.Min(prevBStdDev, currentValue) + (sc * stdDev);
                    bStdDevList.Add(bStdDev);

                    decimal cStdDev = (aStdDev + bStdDev) / 2;
                    cStdDevList.Add(cStdDev);

                    decimal aAhlr = Math.Max(prevAAhlr, currentValue) - (sc * ahlr);
                    aAhlrList.Add(aAhlr);

                    decimal bAhlr = Math.Min(prevBAhlr, currentValue) + (sc * ahlr);
                    bAhlrList.Add(bAhlr);

                    decimal cAhlr = (aAhlr + bAhlr) / 2;
                    cAhlrList.Add(cAhlr);

                    decimal aRfv = Math.Max(prevARfv, currentValue) - (sc * rfv);
                    aRfvList.Add(aRfv);

                    decimal bRfv = Math.Min(prevBRfv, currentValue) + (sc * rfv);
                    bRfvList.Add(bRfv);

                    decimal cRfv = (aRfv + bRfv) / 2;
                    cRfvList.Add(cRfv);

                    var signal = GetCompareSignal(currentValue - cClassic, prevValue - prevCClassic);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (ahlrList, rfvList, aClassicList, bClassicList, cClassicList, aAtrList, bAtrList, cAtrList, aStdDevList, bStdDevList, cStdDevList, aAhlrList, bAhlrList,
                cAhlrList, aRfvList, bRfvList, cRfvList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>)
            CalculateTrendTraderBands(StockData stockDataClass, string maType, int days = 21)
        {
            //@version=3
            ////////////////////////////////////////////////////////////
            //  Copyright by HPotter v1.0 12/10/2018
            // This is plots the indicator developed by Andrew Abraham 
            // in the Trading the Trend article of TASC September 1998  
            // It was modified, result values wass averages.
            // And draw two bands above and below TT line.
            ////////////////////////////////////////////////////////////
            //study(title = "Trend Trader Bands", overlay = true)
            //Length = input(21, minval = 1),
            //LengthMA = input(21, minval = 1),
            //BandStep = input(20),
            //Multiplier = input(3, minval = 1)
            //avgTR = wma(atr(1), Length)
            //highestC = highest(Length)
            //lowestC = lowest(Length)
            //hiLimit = highestC[1] - (avgTR[1] * Multiplier)
            //loLimit = lowestC[1] + (avgTR[1] * Multiplier)
            //ret = 0.0
            //ret:= iff(close > hiLimit and close > loLimit, hiLimit,
            //      iff(close < loLimit and close < hiLimit, loLimit, nz(ret[1], 0)))
            //nResMA = ema(ret, LengthMA)
            //plot(nResMA, color = blue, title = "Trend Trader AVR")
            //plot(nResMA + BandStep, color = red, title = "Trend Trader UpBand")
            //plot(nResMA - BandStep, color = green, title = "Trend Trader DnBand")
            List<decimal> highLimitList = new();
            List<decimal> lowLimitList = new();
            List<decimal> retList = new();
            List<decimal> retEmaList = new();
            List<decimal> outerUpperBandList = new();
            List<decimal> outerLowerBandList = new();
            List<decimal> innerUpperBandList = new();
            List<decimal> innerLowerBandList = new();
            List<Signal> signalsList = new();
            decimal mult = 3, bandStep = 20;

            try
            {
                var atrList = CalculateAverageTrueRange(stockDataClass, maType, days).Item1;
                var minMaxList = VolumeInputCheck(stockDataClass, days, true);
                List<decimal> highestHighList = minMaxList.Item1;
                List<decimal> lowestLowList = minMaxList.Item2;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal close = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevClose = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevHighest = i >= 1 ? highestHighList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevLowest = i >= 1 ? lowestLowList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevAtr = i >= 1 ? atrList.ElementAtOrDefault(i - 1) : 0;
                    decimal atrMult = prevAtr * mult;

                    decimal highLimit = prevHighest - atrMult;
                    highLimitList.Add(highLimit);

                    decimal lowLimit = prevLowest + atrMult;
                    lowLimitList.Add(lowLimit);

                    decimal ret = close > highLimit && close > lowLimit ? highLimit : close < lowLimit && close < highLimit ? lowLimit : retList.LastOrDefault();
                    retList.Add(ret);

                    decimal prevRetEma = retEmaList.LastOrDefault();
                    decimal retEma = CalculateExponentialMovingAverage(ret, prevRetEma, days);
                    retEmaList.Add(retEma);

                    decimal prevOuterUpperBand = outerUpperBandList.LastOrDefault();
                    decimal outerUpperBand = retEma + bandStep;
                    outerUpperBandList.Add(outerUpperBand);

                    decimal prevOuterLowerBand = outerLowerBandList.LastOrDefault();
                    decimal outerLowerBand = retEma - bandStep;
                    outerLowerBandList.Add(outerLowerBand);

                    decimal innerUpperBand = retEma + (bandStep / 2);
                    innerUpperBandList.Add(innerUpperBand);

                    decimal innerLowerBand = retEma - (bandStep / 2);
                    innerLowerBandList.Add(innerLowerBand);

                    var signal = GetBollingerBandsSignal(close - retEma, prevClose - prevRetEma, close, prevClose, outerUpperBand, prevOuterUpperBand, outerLowerBand, prevOuterLowerBand);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (highLimitList, lowLimitList, retList, retEmaList, outerUpperBandList, outerLowerBandList, innerUpperBandList, innerLowerBandList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateCommoditySelectionIndex(StockData stockDataClass, string maType, int days = 14)
        {
            //@version=3
            ////////////////////////////////////////////////////////////
            //  Copyright by HPotter v1.0 19/03/2019
            // The Commodity Selection Index ("CSI") is a momentum indicator. It was 
            // developed by Welles Wilder and is presented in his book New Concepts in 
            // Technical Trading Systems. The name of the index reflects its primary purpose. 
            // That is, to help select commodities suitable for short-term trading.
            // A high CSI rating indicates that the commodity has strong trending and volatility 
            // characteristics. The trending characteristics are brought out by the Directional 
            // Movement factor in the calculation--the volatility characteristic by the Average 
            // True Range factor.
            // Wilder's approach is to trade commodities with high CSI values (relative to other 
            // commodities). Because these commodities are highly volatile, they have the potential 
            // to make the "most money in the shortest period of time." High CSI values imply 
            // trending characteristics which make it easier to trade the security.
            // The Commodity Selection Index is designed for short-term traders who can handle 
            // the risks associated with highly volatile markets.
            ////////////////////////////////////////////////////////////
            //fADX(Len) =>
            //up = change(high)
            //down = -change(low)
            //trur = rma(tr, Len)
            //plus = fixnan(100 * rma(up > down and up > 0 ? up : 0, Len) / trur)
            //minus = fixnan(100 * rma(down > up and down > 0 ? down : 0, Len) / trur)
            //sum = plus + minus
            //100 * rma(abs(plus - minus) / (sum == 0 ? 1 : sum), Len)

            //study(title = "Commodity Selection Index Strategy", shorttitle = "CSI Strategy")
            //PointValue = input(50)
            //Margin = input(3000)
            //Commission = input(10)
            //Length = input(14)
            //K = 100 * ((PointValue / sqrt(Margin) / (150 + Commission)))
            //xATR = atr(Length)
            //xADX = fADX(Length)
            //nADXR = (xADX + xADX[Length]) * 0.5
            //xCSI = K * xATR * nADXR
            //xMACSI = sma(xCSI, Length)
            //pos = 0.0
            //pos:= iff(xCSI < xMACSI, 1,
            //      iff(xCSI > xMACSI, -1, nz(pos[1], 0)))
            //barcolor(pos == -1 ? red : pos == 1 ? green : blue)
            //plot(xCSI, color = green, title = "CSI")
            //plot(xMACSI, color = red, title = "CSI SMA")
            List<decimal> csiList = new();
            List<decimal> csiSmaList = new();
            List<Signal> signalsList = new();
            decimal pointValue = 50, margin = 3000, commission = 10;

            try
            {
                decimal k = 100 * (pointValue / Sqrt(margin) / (150 + commission));

                var atrList = CalculateAverageTrueRange(stockDataClass, maType, days).Item1;
                var adxList = CalculateAverageDirectionalIndex(stockDataClass, maType, days).Item11;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal atr = atrList.ElementAtOrDefault(i);
                    decimal adxRating = adxList.ElementAtOrDefault(i);

                    decimal prevCsi = csiList.LastOrDefault();
                    decimal csi = k * atr * adxRating;
                    csiList.Add(csi);

                    decimal prevCsiSma = csiSmaList.LastOrDefault();
                    decimal csiSma = csiList.TakeLast(days).Average();
                    csiSmaList.Add(csiSma);

                    var signal = GetCompareSignal(csi - csiSma, prevCsi - prevCsiSma, true);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (csiList, csiSmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateErgodicCommoditySelectionIndex(StockData stockDataClass, string maType, int days = 5)
        {
            ////////////////////////////////////////////////////////////
            //  Copyright by HPotter v1.0 20/06/2018
            // This is one of the techniques described by William Blau in his book 
            // "Momentum, Direction and Divergence" (1995). If you like to learn more, 
            // we advise you to read this book. His book focuses on three key aspects 
            // of trading: momentum, direction and divergence. Blau, who was an electrical 
            // engineer before becoming a trader, thoroughly examines the relationship between 
            // price and momentum in step-by-step examples. From this grounding, he then looks 
            // at the deficiencies in other oscillators and introduces some innovative techniques, 
            // including a fresh twist on Stochastics. On directional issues, he analyzes the 
            // intricacies of ADX and offers a unique approach to help define trending and 
            // non-trending periods.
            // This indicator plots Ergotic CSI and smoothed Ergotic CSI to filter out noise. 
            //
            // WARNING:
            //  - This script to change bars colors.
            ////////////////////////////////////////////////////////////
            //fADX(Len) =>
            //up = change(high)
            //down = -change(low)
            //trur = rma(tr, Len)
            //plus = fixnan(100 * rma(up > down and up > 0 ? up : 0, Len) / trur)
            //minus = fixnan(100 * rma(down > up and down > 0 ? down : 0, Len) / trur)
            //sum = plus + minus
            //100 * rma(abs(plus - minus) / (sum == 0 ? 1 : sum), Len)

            //study(title = "Ergodic CSI Strategy")
            //r = input(32, minval = 1)
            //Length = input(1, minval = 1)
            //BigPointValue = input(1.0, minval = 0.00001)
            //SmthLen = input(5, minval = 1)
            //SellZone = input(0.004, minval = 0.00001)
            //BuyZone = input(0.024, minval = 0.001)
            //hline(BuyZone, color = green, linestyle = line)
            //hline(SellZone, color = red, linestyle = line)
            //source = close
            //K = 100 * (BigPointValue / sqrt(r) / (150 + 5))
            //xTrueRange = atr(1)
            //xADX = fADX(Length)
            //xADXR = (xADX + xADX[1]) * 0.5
            //nRes = iff(Length + xTrueRange > 0, K * xADXR * xTrueRange / Length, 0)
            //xCSI = iff(close > 0, nRes / close, 0)
            //xSMA_CSI = sma(xCSI, SmthLen)
            //pos = iff(xSMA_CSI > BuyZone, 1,
            //      iff(xSMA_CSI <= SellZone, -1, nz(pos[1], 0)))
            //barcolor(pos == -1 ? red : pos == 1 ? green : blue)
            //plot(xCSI, color = green, title = "Ergodic CSI")
            //plot(xSMA_CSI, color = red, title = "SigLin")
            List<decimal> csiList = new();
            List<decimal> ergodicCsiList = new();
            List<decimal> ergodicCsiSmaList = new();
            List<Signal> signalsList = new();

            try
            {
                int length = 1;
                int smoothLength = days;
                int r = (int)Math.Ceiling(smoothLength / 0.15625);
                decimal pointValue = 1, buyZone = 0.024m, sellZone = 0.004m, k = 100 * (pointValue / Sqrt((double)r) / (150 + 5));

                var atrList = CalculateAverageTrueRange(stockDataClass, maType, length).Item1;
                var adxItemsList = CalculateAverageDirectionalIndex(stockDataClass, maType, length);
                var adxList = adxItemsList.Item10;
                var adxRatingList = adxItemsList.Item11;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal atr = atrList.ElementAtOrDefault(i);
                    decimal adx = adxList.ElementAtOrDefault(i);
                    decimal prevAdx = i >= days ? adxList.ElementAtOrDefault(i - days) : 0;
                    decimal adxRating = adxRatingList.ElementAtOrDefault(i);

                    decimal csi = length + atr > 0 ? k * adxRating * atr / length : 0;
                    csiList.Add(csi);

                    decimal ergodicCsi = currentValue > 0 ? csi / currentValue : 0;
                    ergodicCsiList.Add(ergodicCsi);

                    decimal prevErgodicCsiSma = ergodicCsiSmaList.LastOrDefault();
                    decimal ergodicCsiSma = csiList.TakeLast(smoothLength).Average();
                    ergodicCsiSmaList.Add(ergodicCsiSma);

                    var signal = GetBullishBearishSignal(ergodicCsiSma - buyZone, prevErgodicCsiSma - buyZone, ergodicCsiSma - sellZone, prevErgodicCsiSma - sellZone);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (csiList, ergodicCsiList, ergodicCsiSmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateBollingerBandsWithAtrPct(
            StockData stockDataClass, string maType, int days = 14)
        {
            //study(shorttitle = "BB+ATRP", title = "Bollinger Bands with ATR(Percent)", overlay = true)
            //@version=2
            //study("Average Percentage True Range")
            //len = input(14, "ATRP")
            //lh = high - low
            //pc = close[1]
            //hc = abs(high - pc)
            //lc = abs(low - pc)
            //MM = max(max(lh, hc), lc)
            //atrs = iff(MM == hc, hc / (pc + (hc / 2)),
            //       iff(MM == lc, lc / (low + (lc / 2)),
            //       iff(MM == lh, lh / (low + (lh / 2)), 0)))

            //APTR = 100 * atrs * (2 / (len + 1)) + nz(APTR[1]) * (1 - (2 / (len + 1)))
            //plot( APTR,title= "APTR"  ,color=red )

            //length = input(20, "BB", minval = 1)
            //src = input(close, title = "Source")
            //mult = input(2, step = 0.1, minval = 0.001, maxval = 50)
            //basis = sma(src, length)
            //dev = mult * APTR
            //upper = basis + basis * dev / 100
            //lower = basis - basis * dev / 100
            //plot(basis, color = red)
            //p1 = plot(upper, color = blue)
            //p2 = plot(lower, color = blue)
            //fill(p1, p2)
            decimal mult = 2;
            List<decimal> atrsList = new();
            List<decimal> aptrList = new();
            List<decimal> upperList = new();
            List<decimal> innerUpperList = new();
            List<decimal> lowerList = new();
            List<decimal> innerLowerList = new();
            List<decimal> devList = new();
            List<Signal> signalsList = new();

            try
            {
                int aptrLength = days;
                int bbLength = MinOrMax((int)Math.Ceiling(aptrLength / 0.7));
                decimal ratio = (decimal)2 / (aptrLength + 1);

                var smaList = GetMovingAverageList(maType, null, stockDataClass, bbLength);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal basis = smaList.ElementAtOrDefault(i);
                    decimal currentHigh = stockDataClass.HighPrices.ElementAtOrDefault(i);
                    decimal currentLow = stockDataClass.LowPrices.ElementAtOrDefault(i);
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevClose = i >= 1 ? stockDataClass.ClosePrices.ElementAtOrDefault(i - 1) : 0;
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal lh = currentHigh - currentLow;
                    decimal hc = Math.Abs(currentHigh - prevClose);
                    decimal lc = Math.Abs(currentLow - prevClose);
                    decimal mm = Math.Max(Math.Max(lh, hc), lc);
                    decimal prevBasis = i >= 1 ? smaList.ElementAtOrDefault(i - 1) : 0;

                    decimal atrs = mm == hc ? hc / (prevClose + (hc / 2)) : mm == lc ? lc / (currentLow + (lc / 2)) : mm == lh ? lh / (currentLow + (lh / 2)) : 0;
                    atrsList.Add(atrs);

                    decimal prevAptr = aptrList.LastOrDefault();
                    decimal aptr = (100 * atrs * ratio) + (prevAptr * (1 - ratio));
                    aptrList.Add(aptr);

                    decimal dev = mult * aptr;
                    devList.Add(dev);

                    decimal prevUpper = upperList.LastOrDefault();
                    decimal upper = basis + (basis * dev / 100);
                    upperList.Add(upper);

                    decimal innerUpper = basis + (basis * aptr / 100);
                    innerUpperList.Add(innerUpper);

                    decimal prevLower = lowerList.LastOrDefault();
                    decimal lower = basis - (basis * dev / 100);
                    lowerList.Add(lower);

                    decimal innerLower = basis - (basis * aptr / 100);
                    innerLowerList.Add(innerLower);

                    var signal = GetBollingerBandsSignal(currentValue - basis, prevValue - prevBasis, currentValue, prevValue, upper, prevUpper, lower, prevLower);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (atrsList, aptrList, devList, upperList, innerUpperList, lowerList, innerLowerList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateVolatilityBasedMomentum(StockData stockDataClass, string maType, int days = 22)
        {
            //@version=3
            //study("Volatility Based Momentum (VBM)")

            //rocPeriod = input(title = "Periods used to calculate rate of change", type = integer, defval = 22, minval = 1)
            //atrPeriod = input(title = "Periods for ATR used to normalize the rate of change", type = integer, defval = 65, minval = 2)

            //rateOfChange = close[0] - close[rocPeriod]
            //normalizationATR = atr(atrPeriod)[0]
            //volatilityBasedMomentum = rateOfChange / normalizationATR
            //plot(volatilityBasedMomentum)
            List<decimal> vbmList = new();
            List<decimal> vbmEmaList = new();
            List<Signal> signalsList = new();

            try
            {
                int rocPeriod = days;
                int atrPeriod = MinOrMax((int)Math.Ceiling(rocPeriod / 0.3385));
                int signalPeriod = MinOrMax((int)Math.Ceiling(rocPeriod / 0.6));

                var atrList = CalculateAverageTrueRange(stockDataClass, maType, atrPeriod).Item1;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentAtr = atrList.ElementAtOrDefault(i);
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= rocPeriod ? stockDataClass.InputValues.ElementAtOrDefault(i - rocPeriod) : 0;
                    decimal rateOfChange = currentValue - prevValue;

                    decimal prevVbm = vbmList.LastOrDefault();
                    decimal vbm = currentAtr != 0 ? rateOfChange / currentAtr : 0;
                    vbmList.Add(vbm);

                    decimal prevVbmEma = vbmEmaList.LastOrDefault();
                    decimal vbmEma = CalculateExponentialMovingAverage(vbm, vbmEmaList.LastOrDefault(), signalPeriod);
                    vbmEmaList.Add(vbmEma);

                    var signal = GetCompareSignal(vbm - vbmEma, prevVbm - prevVbmEma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (vbmList, vbmEmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateStochasticOscillator(List<decimal>? customValuesList,
            StockData stockDataClass, string maType, int days = 3)
        {
            //method = moving average (ma), user defined, default is EMA
            //kPeriod = user defined, default is 14
            //maPeriod = user defined, default is 3
            //signalPeriod = 3
            //index = current bar number
            //stochasticK=100*(currentClose-lowest)/(highest-lowest); highest and lowest are for kPeriod
            //K = stochasticK(index, kPeriod));
            //pk = ma(method, index, maPeriod, K);
            //signal = ma(method, index, signalPeriod, pk);
            //pd = signal;
            //buy = crossedAbove(pk, pd);
            //sell = crossedBelow(pk, pd);
            List<decimal> fastKList = new();
            List<decimal> fastDList = new();
            List<decimal> slowDList = new();
            List<decimal> lowestLowList = new();
            List<decimal> highestHighList = new();
            List<Signal> signalsList = new();

            try
            {
                int period = (int)Math.Ceiling(days / 0.2143);
                int smaPeriod = days;

                if (customValuesList != null)
                {
                    stockDataClass.InputValues = customValuesList;
                }

                var list = VolumeInputCheck(stockDataClass, period, true);
                var highList = list.Item1;
                var lowList = list.Item2;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);

                    decimal highestHigh = highList.ElementAtOrDefault(i);
                    highestHighList.Add(highestHigh);

                    decimal lowestLow = lowList.ElementAtOrDefault(i);
                    lowestLowList.Add(lowestLow);

                    decimal fastK = highestHigh - lowestLow != 0 ? MinOrMax((currentValue - lowestLow) / (highestHigh - lowestLow) * 100, 100, 0) : 0;
                    fastKList.Add(fastK);
                }

                fastDList = GetMovingAverageList(maType, fastKList, stockDataClass, smaPeriod);
                slowDList = GetMovingAverageList(maType, fastDList, stockDataClass, smaPeriod);
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal slowK = fastDList.ElementAtOrDefault(j);
                    decimal slowD = slowDList.ElementAtOrDefault(j);
                    decimal prevSlowk = j >= 1 ? fastDList.ElementAtOrDefault(j - 1) : 0;
                    decimal prevSlowd = j >= 1 ? slowDList.ElementAtOrDefault(j - 1) : 0;

                    var signal = GetRsiSignal(slowK - slowD, prevSlowk - prevSlowd, slowK, prevSlowk, 80, 20);
                    signalsList.Add(signal);
                }

                // reset the input values list
                stockDataClass = LoadCalculations.GetInputValuesList(stockDataClass.InputName, stockDataClass);
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (highestHighList, lowestLowList, fastKList, fastDList, slowDList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateDynamicMomentumOscillator(StockData stockDataClass, string maType, int days = 10)
        {
            //@version=2
            ////////////////////////////////////////////////////////////
            //  Copyright by HPotter v1.0 07/04/2017
            // In July 1996 Futures magazine, E. Marshall Wall introduces the 
            // Dynamic Momentum Oscillator (Dynamo). Please refer to this article 
            // for interpretation.
            // The Dynamo oscillator is a normalizing function which adjusts the 
            // values of a standard oscillator for trendiness by taking the difference 
            // between the value of the oscillator and a moving average of the oscillator 
            // and then subtracting that value from the oscillator midpoint.
            ////////////////////////////////////////////////////////////
            //study(title = "Dynamo", shorttitle = "Dynamo")
            //OscLen = input(10, minval = 1)
            //MALen = input(20, minval = 1)
            //HiBand = input(77, minval = 1)
            //LowBand = input(23)
            //hline(HiBand, color = red, linestyle = line)
            //hline(LowBand, color = green, linestyle = line)
            //xOscK = stoch(close, high, low, OscLen)
            //xOscAvg = sma(xOscK, OscLen)
            //xMAVal = sma(xOscAvg, MALen)
            //maxNum = 9999999
            //LowestSoFar = iff(xOscAvg < nz(LowestSoFar[1], maxNum), xOscAvg, nz(LowestSoFar[1], maxNum))
            //HighestSoFar = iff(xOscAvg > nz(HighestSoFar[1]), xOscAvg, nz(HighestSoFar[1]))
            //MidPnt = (LowestSoFar + HighestSoFar) / 2
            //nRes = MidPnt - (xMAVal - xOscAvg)
            //pos = iff(nRes > HiBand, 1,
            //      iff(nRes < LowBand, -1, nz(pos[1], 0)))
            //barcolor(pos == -1 ? red : pos == 1 ? green : blue)
            //plot(nRes, color = blue, title = "Dynamo")
            List<decimal> lowestList = new();
            List<decimal> highestList = new();
            List<decimal> midpointList = new();
            List<decimal> dmoList = new();
            List<Signal> signalsList = new();

            try
            {
                int smaLength = MinOrMax(days * 2);

                var stochList = CalculateStochasticOscillator(null, stockDataClass, maType, days).Item3;
                var stochSmaList = GetMovingAverageList(maType, stochList, stockDataClass, days);
                var smaValList = GetMovingAverageList(maType, stochSmaList, stockDataClass, smaLength);
                var minMaxList = GetMaxAndMinValuesList(stochSmaList, days);
                highestList = minMaxList.Item1;
                lowestList = minMaxList.Item2;

                for (int i = 0; i < stockDataClass.HighPrices.Count; i++)
                {
                    decimal smaVal = smaValList.ElementAtOrDefault(i);
                    decimal stochSma = stochSmaList.ElementAtOrDefault(i);
                    decimal highest = highestList.ElementAtOrDefault(i);
                    decimal lowest = lowestList.ElementAtOrDefault(i);
                    decimal prevDmo1 = i >= 1 ? dmoList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevDmo2 = i >= 2 ? dmoList.ElementAtOrDefault(i - 2) : 0;

                    decimal midpoint = MinOrMax((lowest + highest) / 2, 100, 0);
                    midpointList.Add(midpoint);

                    decimal dmo = MinOrMax(midpoint - (smaVal - stochSma), 100, 0);
                    dmoList.Add(dmo);

                    var signal = GetRsiSignal(dmo - prevDmo1, prevDmo1 - prevDmo2, dmo, prevDmo1, 77, 23);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (highestList, lowestList, midpointList, dmoList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateDoubleStochasticOscillator(StockData stockDataClass, string maType, int days = 3)
        {
            //Fast % K = ((Todays Close – Lowest Low in % K Periods) / (Highest High in % K Periods – Lowest Low in % K Periods)) x 100
            //Slowing % K = n - period moving average of Fast % K
            //decimal % K = ((Todays Slowing % K – Lowest Low Slowing % K in % K Periods) / 
            //(Highest High Slowing % K in % K Periods – Lowest Low Slowing % K in % K Periods)) x 100
            //decimal Slowing % K = n - period moving average of decimal % K
            // % D = 3 - period Simple Moving Average of decimal Slowing % K
            List<decimal> slowKList = new();
            List<decimal> decimalKList = new();
            List<decimal> decimalSlowKList = new();
            List<decimal> decimalKSignalList = new();
            List<Signal> signalsList = new();

            try
            {
                int period = (int)Math.Ceiling(days / 0.2143);
                int smaPeriod = days;

                var stochasticList = CalculateStochasticOscillator(null, stockDataClass, maType, period).Item4;

                for (int i = 0; i < stockDataClass.HighPrices.Count; i++)
                {
                    decimal slowK = stochasticList.ElementAtOrDefault(i);
                    slowKList.Add(slowK);

                    decimal highestSlowK = slowKList.TakeLast(period).Max();
                    decimal lowestSlowK = slowKList.TakeLast(period).Min();

                    decimal decimalK = highestSlowK - lowestSlowK != 0 ? MinOrMax((slowK - lowestSlowK) / (highestSlowK - lowestSlowK) * 100, 100, 0) : 0;
                    decimalKList.Add(decimalK);
                }

                decimalSlowKList = GetMovingAverageList(maType, decimalKList, stockDataClass, smaPeriod);
                decimalKSignalList = GetMovingAverageList(maType, decimalSlowKList, stockDataClass, smaPeriod);
                for (int j = 0; j < stockDataClass.HighPrices.Count; j++)
                {
                    decimal decimalSlowK = decimalSlowKList.ElementAtOrDefault(j);
                    decimal decimalKSignal = decimalKSignalList.ElementAtOrDefault(j);
                    decimal prevdecimalslowk = j >= 1 ? decimalSlowKList.ElementAtOrDefault(j - 1) : 0;
                    decimal prevdecimalKSignal = j >= 1 ? decimalKSignalList.ElementAtOrDefault(j - 1) : 0;

                    var signal = GetRsiSignal(decimalSlowK - decimalKSignal, prevdecimalslowk - prevdecimalKSignal, decimalSlowK, prevdecimalslowk, 80, 20);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (decimalKList, decimalSlowKList, decimalKSignalList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateStochasticFastOscillator(StockData stockDataClass, string maType, int days = 3)
        {
            //method = moving average (ma), user defined, default is EMA
            //kPeriod = user defined, default is 14
            //maPeriod = user defined, default is 3
            //signalPeriod = 1
            //index = current bar number

            //stochasticK=100*(currentClose-lowest)/(highest-lowest); highest and lowest are for kPeriod
            //K = stochasticK(index, kPeriod));
            //pk = ma(method, index, maPeriod, K);
            //signal = ma(method, index, signalPeriod, pk);
            //pd = signal;
            //buy = crossedAbove(pk, pd);
            //sell = crossedBelow(pk, pd);
            List<decimal> pkList = new();
            List<decimal> pdList = new();
            List<Signal> signalsList = new();

            try
            {
                int kPeriod = (int)Math.Ceiling(days / 0.2143);
                int smaPeriod = days;
                int signalPeriod = MinOrMax((int)Math.Ceiling((decimal)days / 3));

                var fastKList = CalculateStochasticOscillator(null, stockDataClass, maType, days).Item3;
                pkList = GetMovingAverageList(maType, fastKList, stockDataClass, smaPeriod);
                pdList = GetMovingAverageList(maType, pkList, stockDataClass, signalPeriod);

                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal pkEma = pkList.ElementAtOrDefault(j);
                    decimal pdEma = pdList.ElementAtOrDefault(j);
                    decimal prevPkema = j >= 1 ? pkList.ElementAtOrDefault(j - 1) : 0;
                    decimal prevPdema = j >= 1 ? pdList.ElementAtOrDefault(j - 1) : 0;

                    var signal = GetRsiSignal(pkEma - pdEma, prevPkema - prevPdema, pkEma, prevPkema, 80, 20);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (pkList, pdList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateStochasticCustomOscillator(StockData stockDataClass, string maType, int days = 3)
        {
            //input = price, user defined, default is closing price
            //fkPeriod = user defined, default is 7
            //ckPeriod = user defined, default is 3
            //cdPeriod = user defined, default is 12
            //method = moving average (ma), user defined, default is SMA
            //diff = difference, num = numerator, den = denomator
            //av = average, sma = simple moving average

            //highest = highest(fkPeriod, HIGH);
            //lowest = lowest(fkPeriod, LOW);
            //diff = highest - lowest;
            //num = price - lowest;
            //den = diff;
            //avNum = sma(ckPeriod, NUM);
            //avDen = sma(ckPeriod, DEN);
            //if (diff moreThan 0)
            //if (ckPeriod lessOr = 1) sck = num / den * 100;
            //else sck = avNum / avDen * 100;
            //endIf
            //Plot1: sck;
            //Plot2: scd = ma(method, cdPeriod, SCK);
            //Signals
            //highSell = sck for last sell signal, reset to max_negative at each  buy signal;
            //lowBuy = sck for last buy signal, reset to max_positive at each sell signal;
            //sell = crossedBelow(SCK, SCD)  AND sck moreThan topGuide AND(sck moreThan highSell);
            //buy = crossedAboveSCK, SCD) AND sck lessThan bottGuide AND(sck lessThan lowBuy);
            List<decimal> numList = new();
            List<decimal> numSmaList = new();
            List<decimal> denomSmaList = new();
            List<decimal> denomList = new();
            List<decimal> sckList = new();
            List<decimal> scdList = new();
            List<Signal> signalsList = new();

            try
            {
                int fkPeriod = (int)Math.Ceiling(days / 0.4286);
                int ckPeriod = days;
                int cdPeriod = ckPeriod * 4;

                var list = VolumeInputCheck(stockDataClass, fkPeriod, true);
                var highList = list.Item1;
                var lowList = list.Item2;

                for (int i = 0; i < stockDataClass.HighPrices.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal highestHigh = highList.ElementAtOrDefault(i);
                    decimal lowestLow = lowList.ElementAtOrDefault(i);

                    decimal num = currentValue - lowestLow;
                    numList.Add(num);

                    decimal denom = highestHigh - lowestLow;
                    denomList.Add(denom);
                }

                numSmaList = GetMovingAverageList(maType, numList, stockDataClass, ckPeriod);
                denomSmaList = GetMovingAverageList(maType, denomList, stockDataClass, ckPeriod);
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal numSma = numSmaList.ElementAtOrDefault(j);
                    decimal denomSma = denomSmaList.ElementAtOrDefault(j);

                    decimal sck = denomSma != 0 ? MinOrMax(numSma / denomSma * 100, 100, 0) : 0;
                    sckList.Add(sck);
                }

                scdList = GetMovingAverageList(maType, sckList, stockDataClass, cdPeriod);
                for (int k = 0; k < stockDataClass.InputValues.Count; k++)
                {
                    decimal sck = sckList.ElementAtOrDefault(k);
                    decimal scd = scdList.ElementAtOrDefault(k);
                    decimal prevSck = k >= 1 ? sckList.ElementAtOrDefault(k - 1) : 0;
                    decimal prevScd = k >= 1 ? scdList.ElementAtOrDefault(k - 1) : 0;

                    var signal = GetRsiSignal(sck - scd, prevSck - prevScd, sck, prevSck, 70, 30);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (numSmaList, denomSmaList, sckList, scdList, signalsList);
        }

        public static (List<decimal>, List<Signal>) CalculateStochasticRegular(StockData stockDataClass, string maType, int days = 3)
        {
            //input = price, user defined, default is closing price
            //fkPeriod = user defined, default is 5
            //skPeriod = user defined, default is 3
            //method = moving average (ma), user defined, default is SMA
            //fk = fast k, sk = slow k (or fast d)
            //sma = simple moving average, index = current bar number

            //Plot1: fk = stochK(index, fkPeriod, key);
            //Plot2: sk = ma(method, index, skPeriod, fk);
            //Signals
            //highSell = sk for last sell signal, reset to max_negative at each  buy signal;
            //lowBuy = sk for last buy signal, reset to max_positive at each sell signal;
            //sell = crossedBelow(FK, SK) AND sk moreThan topGuide  AND(sk moreThan highSell);
            //buy = crossedAbove(FK, SK) AND sk lessThan bottGuide AND(sk lessThan lowBuy);
            List<decimal> skList = new();
            List<Signal> signalsList = new();

            try
            {
                int fkPeriod = (int)Math.Ceiling(days / 0.6);
                int skPeriod = days;

                List<decimal> fastKList = CalculateStochasticFastOscillator(stockDataClass, maType, fkPeriod).Item1;
                skList = GetMovingAverageList(maType, fastKList, stockDataClass, skPeriod);

                for (int i = 0; i < stockDataClass.HighPrices.Count; i++)
                {
                    decimal fk = fastKList.ElementAtOrDefault(i);
                    decimal sk = skList.ElementAtOrDefault(i);
                    decimal prevFk = i >= 1 ? fastKList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevSk = i >= 1 ? skList.ElementAtOrDefault(i - 1) : 0;

                    var signal = GetRsiSignal(fk - sk, prevFk - prevSk, fk, prevFk, 70, 30);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (skList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateEhlersCenterofGravityOscillator(
            List<decimal>? customValuesList, StockData stockDataClass, int days = 5)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Ehlers Center Of Gravity Oscillator [CC] script may be freely distributed under the MIT license.
            //study("Ehlers Center Of Gravity Oscillator [CC]", overlay = false)

            //inp = input(title = "Source", type = input.source, defval = hl2)
            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //length = input(title = "Length", type = input.integer, defval = 10, minval = 1)
            //src = security(syminfo.tickerid, res, inp[rep ? 0 : barstate.isrealtime ? 1 : 0])[rep ? 0 : barstate.isrealtime ? 0 : 1]

            //num = 0.0, denom = 0.0
            //for i = 0 to length - 1
            //    num := num + ((1 + i) * nz(src[i]))
            //    denom := denom + nz(src[i])

            //cg = denom != 0 ? (-num / denom) + ((length + 1) / 2) : 0
            //trigger = nz(cg[1])

            //sig = cg > trigger ? 1 : cg < trigger ? -1 : 0
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //cgColor = sig > 0 ? color.green : sig < 0 ? color.red : color.black
            //barcolor(bar ? cgColor : na)
            //plot(cg, title = "CG", color = cgColor, linewidth = 2)
            //plot(trigger, title = "Trigger", color = color.black, linewidth = 1)
            List<decimal> pvList = new();
            List<decimal> pvxList = new();
            List<decimal> numList = new();
            List<decimal> denomList = new();
            List<decimal> cgList = new();
            List<decimal> cgSignalList = new();
            List<Signal> signalsList = new();

            try
            {
                int signalPeriod = days;
                int period = days * 2;

                if (customValuesList != null)
                {
                    stockDataClass.InputValues = customValuesList;
                }

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal num = 0, denom = 0, prevValue = 0, pvx = 0;
                    for (int j = 0; j <= period - 1; j++)
                    {
                        prevValue = i >= j ? stockDataClass.InputValues.ElementAtOrDefault(i - j) : 0;
                        pvx = (1 + j) * prevValue;
                        num += pvx;
                        denom += prevValue;
                    }
                    pvList.Add(prevValue);
                    pvxList.Add(pvx);
                    numList.Add(num);
                    denomList.Add(denom);

                    decimal prevCg = cgList.LastOrDefault();
                    decimal cg = denom != 0 ? (-num / denom) + ((decimal)(period + 1) / 2) : 0;
                    cgList.Add(cg);

                    decimal cgSignal = CalculateExponentialMovingAverage(cg, cgSignalList.LastOrDefault(), signalPeriod);
                    cgSignalList.Add(cgSignal);

                    var signal = GetCompareSignal(cg, prevCg);
                    signalsList.Add(signal);
                }

                // reset the input values list
                stockDataClass = LoadCalculations.GetInputValuesList(stockDataClass.InputName, stockDataClass);
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (pvList, pvxList, numList, denomList, cgList, cgSignalList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateCenterOfLinearity(StockData stockDataClass, int days = 14)
        {
            //@version=4
            //study("Center Of Linearity", "COL")
            //length = input(14),src = input(close)
            //----
            //a = 0.
            //for i = 1 to length
            //    a := a + i * (src[length - i] - src[i - 1])
            //----
            //plot(a, "COG", a > 0 ?#2196f3:#f57f17,style=plot.style_area,transp=0)
            List<decimal> aList = new();
            List<decimal> colList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal priorValue = i >= days ? stockDataClass.InputValues.ElementAtOrDefault(i - days) : 0;

                    decimal a = (i + 1) * (priorValue - prevValue);
                    aList.Add(a);

                    decimal prevCol = colList.LastOrDefault();
                    decimal col = aList.TakeLast(days).Sum();
                    colList.Add(col);

                    var signal = GetCompareSignal(col, prevCol);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (aList, colList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateDampedSineWaveWeightedFilter(StockData stockDataClass,
            int days = 50)
        {
            //@version=4
            //study("Damped Sine Wave Weighted Filter", "DSWF", overlay = true)
            //length = input(50),src = input(close)
            //----
            //sum = 0.,sumw = 0.
            //for i = 1 to length
            //    w = sin(2 * 3.14 * i / length) / i
            //    sumw := sumw + w
            //    sum := sum + w * src[i - 1]
            //----
            //plot(sum / sumw, "Plot",#ff1100,2,transp=0)
            List<decimal> wList = new();
            List<decimal> wvList = new();
            List<decimal> wSumList = new();
            List<decimal> wvSumList = new();
            List<decimal> dswwfList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevVal = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal w = 0, wSum = 0, wv = 0, wvSum = 0;
                    for (int j = 1; j <= days; j++)
                    {
                        decimal prevValue = i >= j - 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - (j - 1)) : 0;

                        w = Sin(MinOrMax(2 * Math.PI * j / days, 0.99, 0.01)) / j;
                        wv = w * prevValue;

                        wvSum += wv;
                        wSum += w;
                    }
                    wList.Add(w);
                    wSumList.Add(wSum);
                    wvList.Add(wv);
                    wvSumList.Add(wvSum);

                    decimal prevDswwf = dswwfList.LastOrDefault();
                    decimal dswwf = wSum != 0 ? wvSum / wSum : 0;
                    dswwfList.Add(dswwf);

                    var signal = GetCompareSignal(currentValue - dswwf, prevVal - prevDswwf);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (wList, wSumList, wvList, wvSumList, dswwfList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>)
            CalculateAverageAbsoluteErrorNormalization(StockData stockDataClass, int days = 14)
        {
            //@version=4
            //study("Average Absolute Error Normalization", "AEN")
            //length = input(14),smo = input(false, "Smoother"),src = close
            //----
            //y = 0.
            //e = sma(abs(src - nz(y[1])), length)
            //a = sma(src - nz(y[1], src), length) / e
            //y:= sma(src + iff(smo, a * e, 0), length) + iff(smo, 0, a * e)
            //----
            //plot(a, "Plot", color.blue, 2, transp = 0)
            //hline(0.8, "", color.orange, linewidth = 2)
            //hline(-0.8, "", color.orange, linewidth = 2)
            List<decimal> yList = new();
            List<decimal> ySmaList = new();
            List<decimal> eList = new();
            List<decimal> eAbsList = new();
            List<decimal> eSmaList = new();
            List<decimal> aList = new();
            List<decimal> eAbsSmaList = new();
            List<decimal> smoList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevY = i >= 1 ? yList.ElementAtOrDefault(i - 1) : currentValue;
                    decimal prevA1 = i >= 1 ? aList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevA2 = i >= 2 ? aList.ElementAtOrDefault(i - 2) : 0;

                    decimal e = currentValue - prevY;
                    eList.Add(e);

                    decimal eAbs = Math.Abs(e);
                    eAbsList.Add(eAbs);

                    decimal eAbsSma = eAbsList.TakeLast(days).Average();
                    eAbsSmaList.Add(eAbsSma);

                    decimal eSma = eList.TakeLast(days).Average();
                    eSmaList.Add(eSma);

                    decimal a = eAbsSma != 0 ? MinOrMax(eSma / eAbsSma, 1, -1) : 0;
                    aList.Add(a);

                    decimal y = currentValue + (a * eAbsSma);
                    yList.Add(y);

                    decimal ySma = yList.TakeLast(days).Average();
                    ySmaList.Add(ySma);

                    decimal smo = ySma + (a * eAbsSma);
                    smoList.Add(smo);

                    var signal = GetRsiSignal(a - prevA1, prevA1 - prevA2, a, prevA1, 0.8m, -0.8m);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (eList, eAbsList, eAbsSmaList, eSmaList, aList, yList, ySmaList, smoList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateConfluenceIndicator(StockData stockDataClass, string maType, int days = 10)
        {
            //@version=2
            ////////////////////////////////////////////////////////////
            //  Copyright by HPotter v1.0 13/03/2017
            // This is modified version of Dale Legan's "Confluence" indicator written by Gary Fritz.
            // ================================================================
            // Here is Gary`s commentary:
            // Since the Confluence indicator returned several "states" (bull, bear, grey, and zero), 
            // he modified the return value a bit:
            // -9 to -1 = Bearish
            // -0.9 to 0.9 = "grey" (and zero)
            // 1 to 9 = Bullish
            // The "grey" range corresponds to the "grey" values plotted by Dale's indicator, but 
            // they're divided by 10.
            ////////////////////////////////////////////////////////////

            //study(title = "Confluence", shorttitle = "Confluence")
            //Harmonic = input(10, minval = 1)
            //BuyBand = input(9)
            //SellBand = input(-9)
            //hline(SellBand, color = red, linestyle = line)
            //hline(BuyBand, color = green, linestyle = line)

            //Price = close

            //STL = round((Harmonic * 2) - 1 - 0.5)
            //ITL = round((STL * 2) - 1 - 0.5)
            //LTL = round((ITL * 2) - 1 - 0.5)
            //HOFF = round(Harmonic / 2 - 0.5)
            //SOFF = round(STL / 2 - 0.5)
            //IOFF = round(ITL / 2 - 0.5)

            //xHavg = sma(Price, Harmonic)
            //xSavg = sma(Price, STL)
            //xIavg = sma(Price, ITL)
            //xLavg = sma(Price, LTL)

            //xvalue2 = xSavg - xHavg[HOFF]
            //xvalue3 = xIavg - xSavg[SOFF]
            //xvalue12 = xLavg - xIavg[IOFF]

            //xmomsig = xvalue2 + xvalue3 + xvalue12

            //xLavgOHLC = sma(ohlc4, LTL - 1)

            //xH2 = sma(Price, Harmonic - 1)
            //xS2 = sma(Price, STL - 1)
            //xI2 = sma(Price, ITL - 1)
            //xL2 = sma(Price, LTL - 1)

            //DerivH = (xHavg * 2) - xHavg[1]
            //DerivS = (xSavg * 2) - xSavg[1]
            //DerivI = (xIavg * 2) - xIavg[1]
            //DerivL = (xLavg * 2) - xLavg[1]
            //SumDH = Harmonic * DerivH
            //SumDS = STL * DerivS
            //SumDI = ITL * DerivI
            //SumDL = LTL * DerivL

            //LengH = Harmonic - 1
            //LengS = STL - 1
            //LengI = ITL - 1
            //LengL = LTL - 1

            //N1H = xH2 * LengH
            //N1S = xS2 * LengS
            //N1I = xI2 * LengI
            //N1L = xL2 * LengL

            //DRH = SumDH - N1H
            //DRS = SumDS - N1S
            //DRI = SumDI - N1I
            //DRL = SumDL - N1L

            //SumH = xH2 * (Harmonic - 1)
            //SumS = xS2 * (STL - 1)
            //SumI = xI2 * (ITL - 1)
            //SumL = xLavgOHLC * (LTL - 1)

            //xvalue5 = (SumH + DRH) / Harmonic
            //xvalue6 = (SumS + DRS) / STL
            //xvalue7 = (SumI + DRI) / ITL
            //xvalue13 = (SumL + DRL) / LTL

            //value9 = xvalue6 - xvalue5[HOFF]
            //value10 = xvalue7 - xvalue6[SOFF]
            //value14 = xvalue13 - xvalue7[IOFF]
            //xmom = value9 + value10 + value14

            //HT = sin(xvalue5 * 2 * 3.14 / 360) + cos(xvalue5 * 2 * 3.14 / 360)
            //HTA = sin(xHavg * 2 * 3.14 / 360) + cos(xHavg * 2 * 3.14 / 360)
            //ST = sin(xvalue6 * 2 * 3.14 / 360) + cos(xvalue6 * 2 * 3.14 / 360)
            //STA = sin(xSavg * 2 * 3.14 / 360) + cos(xSavg * 2 * 3.14 / 360)
            //IT = sin(xvalue7 * 2 * 3.14 / 360) + cos(xvalue7 * 2 * 3.14 / 360)
            //ITA = sin(xIavg * 2 * 3.14 / 360) + cos(xIavg * 2 * 3.14 / 360)

            //xSum = HT + ST + IT
            //xErr = HTA + STA + ITA

            //Condition2 = (((xSum > xSum[SOFF]) and(xHavg < xHavg[SOFF])) or((xSum < xSum[SOFF]) and(xHavg > xHavg[SOFF])))
            //Phase = iff(Condition2, -1, 1)
            //xErrSum = (xSum - xErr) * Phase
            //xErrSig = sma(xErrSum, SOFF)

            //xvalue70 = xvalue5 - xvalue13
            //xvalue71 = sma(xvalue70, Harmonic)

            //ErrNum = iff(xErrSum > 0 and xErrSum < xErrSum[1] and xErrSum < xErrSig, 1,
            //          iff(xErrSum > 0 and xErrSum < xErrSum[1] and xErrSum > xErrSig, 2,
            //           iff(xErrSum > 0 and xErrSum > xErrSum[1] and xErrSum < xErrSig, 2,
            //             iff(xErrSum > 0 and xErrSum > xErrSum[1] and xErrSum > xErrSig, 3,
            //              iff(xErrSum < 0 and xErrSum > xErrSum[1] and xErrSum > xErrSig, -1,
            //               iff(xErrSum < 0 and xErrSum < xErrSum[1] and xErrSum > xErrSig, -2,
            //                 iff(xErrSum < 0 and xErrSum > xErrSum[1] and xErrSum < xErrSig, -2,
            //                  iff(xErrSum < 0 and xErrSum < xErrSum[1] and xErrSum < xErrSig, -3, 0))))))))

            //momNum = iff(xmom > 0 and xmom < xmom[1] and xmom < xmomsig, 1,
            //          iff(xmom > 0 and xmom < xmom[1] and xmom > xmomsig, 2,
            //           iff(xmom > 0 and xmom > xmom[1] and xmom < xmomsig, 2,
            //             iff(xmom > 0 and xmom > xmom[1] and xmom > xmomsig, 3,
            //              iff(xmom < 0 and xmom > xmom[1] and xmom > xmomsig, -1,
            //               iff(xmom < 0 and xmom < xmom[1] and xmom > xmomsig, -2,
            //                 iff(xmom < 0 and xmom > xmom[1] and xmom < xmomsig, -2,
            //                  iff(xmom < 0 and xmom < xmom[1] and xmom < xmomsig, -3, 0))))))))

            //TCNum = iff(xvalue70 > 0 and xvalue70 < xvalue70[1] and xvalue70 < xvalue71, 1,
            //          iff(xvalue70 > 0 and xvalue70 < xvalue70[1] and xvalue70 > xvalue71, 2,
            //           iff(xvalue70 > 0 and xvalue70 > xvalue70[1] and xvalue70 < xvalue71, 2,
            //             iff(xvalue70 > 0 and xvalue70 > xvalue70[1] and xvalue70 > xvalue71, 3,
            //              iff(xvalue70 < 0 and xvalue70 > xvalue70[1] and xvalue70 > xvalue71, -1,
            //               iff(xvalue70 < 0 and xvalue70 < xvalue70[1] and xvalue70 > xvalue71, -2,
            //                 iff(xvalue70 < 0 and xvalue70 > xvalue70[1] and xvalue70 < xvalue71, -2,
            //                  iff(xvalue70 < 0 and xvalue70 < xvalue70[1] and xvalue70 < xvalue71, -3, 0))))))))

            //value42 = ErrNum + momNum + TCNum
            //Confluence = iff(value42 > 0 and xvalue70 > 0, value42,
            //              iff(value42 < 0 and xvalue70 < 0, value42,
            //               iff((value42 > 0 and xvalue70 < 0) or(value42 < 0 and xvalue70 > 0), value42 / 10, 0)))
            //Res1 = iff(Confluence >= 1, Confluence, 0)
            //Res2 = iff(Confluence <= -1, Confluence, 0)
            //Res3 = iff(Confluence == 0, 0, iff(Confluence > -1 and Confluence < 1, 10 * Confluence, 0))
            //pos = iff(Res2 >= SellBand and Res2 != 0, -1,
            //         iff(Res1 <= BuyBand and Res1 != 0, 1,
            //           iff(Res3 != 0, 2, nz(pos[1], 0))))
            //barcolor(pos == -1 ? red : pos == 1 ? green : blue)
            //plot(Res1, color = green, title = "Confluence", linewidth = 3, style = histogram)
            //plot(Res2, color = red, title = "Confluence", linewidth = 3, style = histogram)
            //plot(Res3, color = gray, title = "Confluence", linewidth = 3, style = histogram)
            List<decimal> value2List = new();
            List<decimal> value3List = new();
            List<decimal> value12List = new();
            List<decimal> momSigList = new();
            List<decimal> derivSList = new();
            List<decimal> derivHList = new();
            List<decimal> derivIList = new();
            List<decimal> derivLList = new();
            List<decimal> sumDSList = new();
            List<decimal> sumDHList = new();
            List<decimal> sumDIList = new();
            List<decimal> sumDLList = new();
            List<decimal> n1sList = new();
            List<decimal> n1hList = new();
            List<decimal> n1iList = new();
            List<decimal> n1lList = new();
            List<decimal> drsList = new();
            List<decimal> drhList = new();
            List<decimal> driList = new();
            List<decimal> drlList = new();
            List<decimal> sSumList = new();
            List<decimal> hSumList = new();
            List<decimal> iSumList = new();
            List<decimal> lSumList = new();
            List<decimal> value5List = new();
            List<decimal> value6List = new();
            List<decimal> value7List = new();
            List<decimal> value13List = new();
            List<decimal> value9List = new();
            List<decimal> value10List = new();
            List<decimal> value14List = new();
            List<decimal> momList = new();
            List<decimal> htList = new();
            List<decimal> htaList = new();
            List<decimal> stList = new();
            List<decimal> staList = new();
            List<decimal> itList = new();
            List<decimal> itaList = new();
            List<decimal> sumList = new();
            List<decimal> errList = new();
            List<decimal> cond2List = new();
            List<decimal> phaseList = new();
            List<decimal> errSumList = new();
            List<decimal> errSigList = new();
            List<decimal> value70List = new();
            List<decimal> value71List = new();
            List<decimal> errNumList = new();
            List<decimal> momNumList = new();
            List<decimal> tcNumList = new();
            List<decimal> value42List = new();
            List<decimal> confluenceList = new();
            List<decimal> res1List = new();
            List<decimal> res2List = new();
            List<decimal> res3List = new();
            List<Signal> signalsList = new();

            try
            {
                int stl = (int)Math.Ceiling((days * 2) - 1 - 0.5);
                int itl = (int)Math.Ceiling((stl * 2) - 1 - 0.5);
                int ltl = (int)Math.Ceiling((itl * 2) - 1 - 0.5);
                int hoff = (int)Math.Ceiling(((decimal)days / 2) - 0.5m);
                int soff = (int)Math.Ceiling(((decimal)stl / 2) - 0.5m);
                int ioff = (int)Math.Ceiling(((decimal)itl / 2) - 0.5m);
                int hLength = MinOrMax(days - 1);
                int sLength = stl - 1;
                int iLength = itl - 1;
                int lLength = ltl - 1;

                var hAvgList = GetMovingAverageList(maType, null, stockDataClass, days);
                var sAvgList = GetMovingAverageList(maType, null, stockDataClass, stl);
                var iAvgList = GetMovingAverageList(maType, null, stockDataClass, itl);
                var lAvgList = GetMovingAverageList(maType, null, stockDataClass, ltl);
                var h2AvgList = GetMovingAverageList(maType, null, stockDataClass, hLength);
                var s2AvgList = GetMovingAverageList(maType, null, stockDataClass, sLength);
                var i2AvgList = GetMovingAverageList(maType, null, stockDataClass, iLength);
                var l2AvgList = GetMovingAverageList(maType, null, stockDataClass, lLength);
                var ftpList = CalculateFullTypicalPrice(stockDataClass).Item1;
                var ftpAvgList = GetMovingAverageList(maType, ftpList, stockDataClass, lLength);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal sAvg = sAvgList.ElementAtOrDefault(i);
                    decimal priorSAvg = i >= soff ? sAvgList.ElementAtOrDefault(i - soff) : 0;
                    decimal priorHAvg = i >= hoff ? hAvgList.ElementAtOrDefault(i - hoff) : 0;
                    decimal iAvg = iAvgList.ElementAtOrDefault(i);
                    decimal priorIAvg = i >= ioff ? iAvgList.ElementAtOrDefault(i - ioff) : 0;
                    decimal lAvg = lAvgList.ElementAtOrDefault(i);
                    decimal hAvg = hAvgList.ElementAtOrDefault(i);
                    decimal prevSAvg = i >= 1 ? sAvgList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevHAvg = i >= 1 ? hAvgList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevIAvg = i >= 1 ? iAvgList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevLAvg = i >= 1 ? lAvgList.ElementAtOrDefault(i - 1) : 0;
                    decimal h2 = h2AvgList.ElementAtOrDefault(i);
                    decimal s2 = s2AvgList.ElementAtOrDefault(i);
                    decimal i2 = i2AvgList.ElementAtOrDefault(i);
                    decimal l2 = l2AvgList.ElementAtOrDefault(i);
                    decimal ftpAvg = ftpAvgList.ElementAtOrDefault(i);
                    decimal priorValue5 = i >= hoff ? value5List.ElementAtOrDefault(i - hoff) : 0;
                    decimal priorValue6 = i >= soff ? value6List.ElementAtOrDefault(i - soff) : 0;
                    decimal priorValue7 = i >= ioff ? value7List.ElementAtOrDefault(i - ioff) : 0;
                    decimal priorSum = i >= soff ? sumList.ElementAtOrDefault(i - soff) : 0;
                    decimal priorHAvg2 = i >= soff ? hAvgList.ElementAtOrDefault(i - soff) : 0;
                    decimal prevErrSum = i >= 1 ? errSumList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevMom = i >= 1 ? momList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevValue70 = i >= 1 ? value70List.ElementAtOrDefault(i - 1) : 0;
                    decimal prevConfluence1 = i >= 1 ? confluenceList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevConfluence2 = i >= 2 ? confluenceList.ElementAtOrDefault(i - 2) : 0;

                    decimal value2 = sAvg - priorHAvg;
                    value2List.Add(value2);

                    decimal value3 = iAvg - priorSAvg;
                    value3List.Add(value3);

                    decimal value12 = lAvg - priorIAvg;
                    value12List.Add(value12);

                    decimal momSig = value2 + value3 + value12;
                    momSigList.Add(momSig);

                    decimal derivH = (hAvg * 2) - prevHAvg;
                    derivHList.Add(derivH);

                    decimal derivS = (sAvg * 2) - prevSAvg;
                    derivSList.Add(derivS);

                    decimal derivI = (iAvg * 2) - prevIAvg;
                    derivIList.Add(derivI);

                    decimal derivL = (lAvg * 2) - prevLAvg;
                    derivLList.Add(derivL);

                    decimal sumDH = days * derivH;
                    sumDHList.Add(sumDH);

                    decimal sumDS = stl * derivS;
                    sumDSList.Add(sumDS);

                    decimal sumDI = itl * derivI;
                    sumDIList.Add(sumDI);

                    decimal sumDL = ltl * derivL;
                    sumDLList.Add(sumDL);

                    decimal n1h = h2 * hLength;
                    n1hList.Add(n1h);

                    decimal n1s = s2 * sLength;
                    n1sList.Add(n1s);

                    decimal n1i = i2 * iLength;
                    n1iList.Add(n1i);

                    decimal n1l = l2 * lLength;
                    n1lList.Add(n1l);

                    decimal drh = sumDH - n1h;
                    drhList.Add(drh);

                    decimal drs = sumDS - n1s;
                    drsList.Add(drs);

                    decimal dri = sumDI - n1i;
                    driList.Add(dri);

                    decimal drl = sumDL - n1l;
                    drlList.Add(drl);

                    decimal hSum = h2 * (days - 1);
                    hSumList.Add(hSum);

                    decimal sSum = s2 * (stl - 1);
                    sSumList.Add(sSum);

                    decimal iSum = i2 * (itl - 1);
                    iSumList.Add(iSum);

                    decimal lSum = ftpAvg * (ltl - 1);
                    lSumList.Add(lSum);

                    decimal value5 = (hSum + drh) / days;
                    value5List.Add(value5);

                    decimal value6 = (sSum + drs) / stl;
                    value6List.Add(value6);

                    decimal value7 = (iSum + dri) / itl;
                    value7List.Add(value7);

                    decimal value13 = (lSum + drl) / ltl;
                    value13List.Add(value13);

                    decimal value9 = value6 - priorValue5;
                    value9List.Add(value9);

                    decimal value10 = value7 - priorValue6;
                    value10List.Add(value10);

                    decimal value14 = value13 - priorValue7;
                    value14List.Add(value14);

                    decimal mom = value9 + value10 + value14;
                    momList.Add(mom);

                    decimal ht = (decimal)(Sin((double)value5 * 2 * Math.PI / 360) + Cos((double)value5 * 2 * Math.PI / 360));
                    htList.Add(ht);

                    decimal hta = (decimal)(Sin((double)hAvg * 2 * Math.PI / 360) + Cos((double)hAvg * 2 * Math.PI / 360));
                    htaList.Add(hta);

                    decimal st = (decimal)(Sin((double)value6 * 2 * Math.PI / 360) + Cos((double)value6 * 2 * Math.PI / 360));
                    stList.Add(st);

                    decimal sta = (decimal)(Sin((double)sAvg * 2 * Math.PI / 360) + Cos((double)sAvg * 2 * Math.PI / 360));
                    staList.Add(sta);

                    decimal it = (decimal)(Sin((double)value7 * 2 * Math.PI / 360) + Cos((double)value7 * 2 * Math.PI / 360));
                    itList.Add(it);

                    decimal ita = (decimal)(Sin((double)iAvg * 2 * Math.PI / 360) + Cos((double)iAvg * 2 * Math.PI / 360));
                    itaList.Add(ita);

                    decimal sum = ht + st + it;
                    sumList.Add(sum);

                    decimal err = hta + sta + ita;
                    errList.Add(err);

                    decimal cond2 = (sum > priorSum && hAvg < priorHAvg2) || (sum < priorSum && hAvg > priorHAvg2) ? 1 : 0;
                    cond2List.Add(cond2);

                    decimal phase = cond2 == 1 ? -1 : 1;
                    phaseList.Add(phase);

                    decimal errSum = (sum - err) * phase;
                    errSumList.Add(errSum);

                    decimal errSig = errSumList.TakeLast(soff).Average();
                    errSigList.Add(errSig);

                    decimal value70 = value5 - value13;
                    value70List.Add(value70);

                    decimal value71 = value70List.TakeLast(days).Average();
                    value71List.Add(value71);

                    decimal errNum = errSum > 0 && errSum < prevErrSum && errSum < errSig ? 1 : errSum > 0 && errSum < prevErrSum && errSum > errSig ? 2 :
                        errSum > 0 && errSum > prevErrSum && errSum < errSig ? 2 : errSum > 0 && errSum > prevErrSum && errSum > errSig ? 3 :
                        errSum < 0 && errSum > prevErrSum && errSum > errSig ? -1 : errSum < 0 && errSum < prevErrSum && errSum > errSig ? -2 :
                        errSum < 0 && errSum > prevErrSum && errSum < errSig ? -2 : errSum < 0 && errSum < prevErrSum && errSum < errSig ? -3 : 0;
                    errNumList.Add(errNum);

                    decimal momNum = mom > 0 && mom < prevMom && mom < momSig ? 1 : mom > 0 && mom < prevMom && mom > momSig ? 2 :
                        mom > 0 && mom > prevMom && mom < momSig ? 2 : mom > 0 && mom > prevMom && mom > momSig ? 3 :
                        mom < 0 && mom > prevMom && mom > momSig ? -1 : mom < 0 && mom < prevMom && mom > momSig ? -2 :
                        mom < 0 && mom > prevMom && mom < momSig ? -2 : mom < 0 && mom < prevMom && mom < momSig ? -3 : 0;
                    momNumList.Add(momNum);

                    decimal tcNum = value70 > 0 && value70 < prevValue70 && value70 < value71 ? 1 : value70 > 0 && value70 < prevValue70 && value70 > value71 ? 2 :
                        value70 > 0 && value70 > prevValue70 && value70 < value71 ? 2 : value70 > 0 && value70 > prevValue70 && value70 > value71 ? 3 :
                        value70 < 0 && value70 > prevValue70 && value70 > value71 ? -1 : value70 < 0 && value70 < prevValue70 && value70 > value71 ? -2 :
                        value70 < 0 && value70 > prevValue70 && value70 < value71 ? -2 : value70 < 0 && value70 < prevValue70 && value70 < value71 ? -3 : 0;
                    tcNumList.Add(tcNum);

                    decimal value42 = errNum + momNum + tcNum;
                    value42List.Add(value42);

                    decimal confluence = value42 > 0 && value70 > 0 ? value42 : value42 < 0 && value70 < 0 ? value42 :
                        (value42 > 0 && value70 < 0) || (value42 < 0 && value70 > 0) ? value42 / 10 : 0;
                    confluenceList.Add(confluence);

                    decimal res1 = confluence >= 1 ? confluence : 0;
                    res1List.Add(res1);

                    decimal res2 = confluence <= -1 ? confluence : 0;
                    res2List.Add(res2);

                    decimal res3 = confluence == 0 ? 0 : confluence > -1 && confluence < 1 ? 10 * confluence : 0;
                    res3List.Add(res3);

                    var signal = GetCompareSignal(confluence - prevConfluence1, prevConfluence1 - prevConfluence2);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (value2List, value3List, value12List, momSigList, derivHList, derivSList, derivIList, derivLList, sumDHList, sumDSList, sumDIList, sumDLList, n1hList, n1sList,
                n1iList, n1lList, drhList, drsList, driList, drlList, hSumList, sSumList, iSumList, lSumList, value5List, value6List, value7List, value13List, value9List,
                value10List, value14List, momList, htList, htaList, stList, staList, itList, itaList, sumList, errList, cond2List, phaseList, errSumList, errSigList, value70List,
                value71List, errNumList, momNumList, tcNumList, value42List, confluenceList, res1List, res2List, res3List, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateEhlersAdaptiveCenterOfGravityOscillator(StockData stockDataClass, int days = 5)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Ehlers Adaptive Center Of Gravity [CC] script may be freely distributed under the MIT license.
            //study("Ehlers Adaptive Center Of Gravity [CC]", overlay = false)

            //inp = input(title = "Source", type = input.source, defval = hl2)
            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //src = security(syminfo.tickerid, res, inp[rep ? 0 : barstate.isrealtime ? 1 : 0])[rep ? 0 : barstate.isrealtime ? 0 : 1]
            //alpha = input(title = "Alpha", type = input.float, defval = 0.07, minval = 0.01, step = 0.01)
            //length = input(title = "Length", type = input.integer, defval = 5, minval = 1)

            //instPeriod = 0.0
            //smooth = (src + (2 * nz(src[1])) + (2 * nz(src[2])) + nz(src[3])) / 6
            //cycle = 0.0
            //cycle:= bar_index < 7 ? (src - (2 * nz(src[1])) + nz(src[2])) / 4 : (pow(1 - (0.5 * alpha), 2) * (smooth - (2 * nz(smooth[1])) + nz(smooth[2]))) +
            //        (2 * (1 - alpha) * nz(cycle[1])) - (pow(1 - alpha, 2) * nz(cycle[2]))

            //q1 = ((0.0962 * cycle) + (0.5769 * nz(cycle[2])) - (0.5769 * nz(cycle[4])) - (0.0962 * nz(cycle[6]))) * (0.5 + (0.08 * nz(instPeriod[1])))
            //i1 = nz(cycle[3])

            //deltaPhase = q1 != 0 and nz(q1[1]) != 0 ? ((i1 / q1) - (nz(i1[1]) / nz(q1[1]))) / (1 + ((i1 * nz(i1[1]) / (q1 * nz(q1[1]))))) : 0
            //deltaPhase:= min(max(deltaPhase, 0.1), 1.1)
            //medianDelta = percentile_nearest_rank(deltaPhase, length, 50)

            //dc = medianDelta != 0 ? (6.28318 / medianDelta) + 0.5 : 15
            //instPeriod:= (0.33 * dc) + (0.67 * nz(instPeriod[1]))

            //period = 0.0
            //period:= (0.15 * instPeriod) + (0.85 * nz(period[1]))

            //intPeriod = ceil(period / 2)
            //num = 0.0, denom = 0.0
            //for i = 0 to intPeriod - 1
            //    num := num + ((1 + i) * nz(src[i]))
            //    denom := denom + nz(src[i])

            //acg = denom != 0 ? (-num / denom) + ((intPeriod + 1) / 2) : 0
            //trigger = nz(acg[1])

            //sig = acg > trigger ? 1 : acg < trigger ? -1 : 0
            //acgColor = sig > 0 ? color.green : sig < 0 ? color.red : color.black
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //barcolor(bar ? acgColor : na)
            //plot(acg, title = "ACG", color = acgColor, linewidth = 2)
            List<decimal> numList = new();
            List<decimal> denomList = new();
            List<decimal> cgList = new();
            List<decimal> cgSignalList = new();
            List<Signal> signalsList = new();

            try
            {
                int signalPeriod = days;
                int period = days * 2;

                List<decimal> ehlersAdaptiveCyberCyclePList = CalculateEhlersAdaptiveCyberCycle(stockDataClass, period).Item10;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal p = ehlersAdaptiveCyberCyclePList.ElementAtOrDefault(i);
                    int intPeriod = (int)Math.Ceiling(p / 2);
                    decimal prevCg1 = i >= 1 ? cgList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevCg2 = i >= 2 ? cgList.ElementAtOrDefault(i - 2) : 0;

                    decimal num = 0, denom = 0;
                    for (int j = 0; j <= intPeriod - 1; j++)
                    {
                        decimal prevPrice = i >= j ? stockDataClass.InputValues.ElementAtOrDefault(i - j) : 0;
                        num += (1 + j) * prevPrice;
                        denom += prevPrice;
                    }
                    numList.Add(num);
                    denomList.Add(denom);

                    decimal cg = denom != 0 ? (-num / denom) + ((intPeriod + 1) / 2) : 0;
                    cgList.Add(cg);

                    decimal cgSignal = CalculateExponentialMovingAverage(cg, cgSignalList.LastOrDefault(), signalPeriod);
                    cgSignalList.Add(cgSignal);

                    var signal = GetCompareSignal(cg - prevCg1, prevCg1 - prevCg2);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (numList, denomList, cgList, cgSignalList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateEhlersSmoothedAdaptiveMomentum(StockData stockDataClass, string maType, int days = 5)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Ehlers Smoothed Adaptive Momentum [CC] script may be freely distributed under the MIT license.
            //study("Ehlers Smoothed Adaptive Momentum [CC]", overlay = false)

            //inp = input(title = "Source", type = input.source, defval = hl2)
            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //src = security(syminfo.tickerid, res, inp[rep ? 0 : barstate.isrealtime ? 1 : 0])[rep ? 0 : barstate.isrealtime ? 0 : 1]
            //alpha = input(title = "Alpha", type = input.float, defval = 0.07, minval = 0.01, step = 0.01)
            //length = input(title = "Length", type = input.integer, defval = 5, minval = 1)
            //hpLength = input(title = "HPLength", type = input.integer, defval = 8, minval = 1)

            //pi = 2 * asin(1)
            //a1 = exp(-pi / hpLength)
            //b1 = 2 * a1 * cos(1.738 * pi / hpLength)
            //c1 = a1 * a1
            //coef2 = b1 + c1
            //coef3 = -(c1 + (b1 * c1))
            //coef4 = c1 * c1
            //coef1 = 1 - coef2 - coef3 - coef4

            //instPeriod = 0.0
            //smooth = (src + (2 * nz(src[1])) + (2 * nz(src[2])) + nz(src[3])) / 6
            //cycle = 0.0
            //cycle:= bar_index < 7 ? (src - (2 * nz(src[1])) + nz(src[2])) / 4 : (pow(1 - (0.5 * alpha), 2) * (smooth - (2 * nz(smooth[1])) + nz(smooth[2]))) +
            //        (2 * (1 - alpha) * nz(cycle[1])) - (pow(1 - alpha, 2) * nz(cycle[2]))

            //q1 = ((0.0962 * cycle) + (0.5769 * nz(cycle[2])) - (0.5769 * nz(cycle[4])) - (0.0962 * nz(cycle[6]))) * (0.5 + (0.08 * nz(instPeriod[1])))
            //i1 = nz(cycle[3])

            //deltaPhase = q1 != 0 and nz(q1[1]) != 0 ? ((i1 / q1) - (nz(i1[1]) / nz(q1[1]))) / (1 + ((i1 * nz(i1[1]) / (q1 * nz(q1[1]))))) : 0
            //deltaPhase:= min(max(deltaPhase, 0.1), 1.1)
            //medianDelta = percentile_nearest_rank(deltaPhase, length, 50)

            //dc = medianDelta != 0 ? (6.28318 / medianDelta) + 0.5 : 15
            //instPeriod:= (0.33 * dc) + (0.67 * nz(instPeriod[1]))

            //period = 0.0
            //period:= (0.15 * instPeriod) + (0.85 * nz(period[1]))

            //v1 = src - nz(src[ceil(period - 1)])
            //sam = 0.0
            //sam:= bar_index < 4 ? v1 : (coef1 * v1) + (coef2 * nz(sam[1])) + (coef3 * nz(sam[2])) + (coef4 * nz(sam[3]))
            //trigger = ema(sam, hpLength)

            //slo = sam - nz(sam[1])
            //sig = sam > trigger ? slo > nz(slo[1]) ? 2 : 1 : sam < trigger ? slo < nz(slo[1]) ? -2 : -1 : 0
            //alertcondition(crossover(sig, 1), "Strong Buy Signal", "Strong Bullish Change Detected")
            //alertcondition(crossunder(sig, -1), "Strong Sell Signal", "Strong Bearish Change Detected")
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //samColor = sig > 1 ? color.green : sig > 0 ? color.lime : sig < -1 ? color.maroon : sig < 0 ? color.red : color.black
            //barcolor(bar ? samColor : na)
            //plot(sam, title = "SAM", color = samColor, linewidth = 2)
            //plot(trigger, title = "Trigger", color = color.black, linewidth = 1)
            List<decimal> ipList = new();
            List<decimal> pList = new();
            List<decimal> dcList = new();
            List<decimal> f3List = new();
            List<decimal> v1List = new();
            List<decimal> f3EmaList = new();
            List<Signal> signalsList = new();

            try
            {
                int length = days;
                int hpLength = (int)Math.Ceiling(days / 0.625);
                decimal dtr = (decimal)Math.PI / 180;
                decimal rtd = 1 / dtr;
                decimal a1 = Exp(-1 * Math.PI / hpLength);
                decimal b1 = 2 * a1 * Cos(1.738m * 180 / hpLength * dtr);
                decimal c1 = a1 * a1;
                decimal coef2 = b1 + c1;
                decimal coef3 = -1 * (c1 + (b1 * c1));
                decimal coef4 = c1 * c1;
                decimal coef1 = 1 - coef2 - coef3 - coef4;

                List<decimal> ehlersAdaptiveCyberCycleMdList = CalculateEhlersAdaptiveCyberCycle(stockDataClass, length).Item6;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevIp = ipList.LastOrDefault();
                    decimal prevP = pList.LastOrDefault();
                    decimal md = ehlersAdaptiveCyberCycleMdList.ElementAtOrDefault(i);
                    decimal prevF3_1 = i >= 1 ? f3List.ElementAtOrDefault(i - 1) : 0;
                    decimal prevF3_2 = i >= 2 ? f3List.ElementAtOrDefault(i - 2) : 0;
                    decimal prevF3_3 = i >= 3 ? f3List.ElementAtOrDefault(i - 3) : 0;

                    decimal dc = md == 0 ? 15 : (2 * (decimal)Math.PI / md) + 0.5m;
                    dcList.Add(dc);

                    decimal ip = (0.33m * dc) + (0.67m * prevIp);
                    ipList.Add(ip);

                    decimal p = (0.15m * ip) + (0.85m * prevP);
                    pList.Add(p);

                    int pr = (int)Math.Ceiling(Math.Abs(p - 1));
                    decimal prevValue = i >= pr ? stockDataClass.InputValues.ElementAtOrDefault(i - pr) : 0;

                    decimal v1 = currentValue - prevValue;
                    v1List.Add(v1);

                    decimal f3 = (coef1 * v1) + (coef2 * prevF3_1) + (coef3 * prevF3_2) + (coef4 * prevF3_3);
                    f3List.Add(f3);
                }

                f3EmaList = GetMovingAverageList(maType, f3List, stockDataClass, hpLength);
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal f3 = f3List.ElementAtOrDefault(j);
                    decimal f3Ema = f3EmaList.ElementAtOrDefault(j);
                    decimal prevF3 = j >= 1 ? f3List.ElementAtOrDefault(j - 1) : 0;
                    decimal prevF3Ema = j >= 1 ? f3EmaList.ElementAtOrDefault(j - 1) : 0;

                    var signal = GetCompareSignal(f3 - f3Ema, prevF3 - prevF3Ema);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (dcList, ipList, pList, v1List, f3List, f3EmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateEhlersStochasticCenterofGravityOscillator(StockData stockDataClass, int days = 8)
        {
            //
            // @author LazyBear 
            // 
            // List of my public indicators: http://bit.ly/1LQaPK8 
            // List of my app-store indicators: http://blog.tradingview.com/?p=970 
            //
            //study("Ehlers Stochastic CG Oscillator [LazyBear]", shorttitle = "ESCGO_LB", overlay = false, precision = 3)
            //src = input(hl2, title = "Source")
            //length = input(8, title = "Length", minval = 1, maxval = 100)
            //lvls = input(0.8, title = "OB/OS Level")
            //fr = input(true, title = "Fill Osc/Trigger region")
            //cg = iff(dm != 0, -nm / dm + (length + 1) / 2.0, 0)
            //maxc = highest(cg, length)
            //minc = lowest(cg, length)
            //v1 = iff(maxc != minc, (cg - minc) / (maxc - minc), 0)
            //v2_ = (4 * v1 + 3 * v1[1] + 2 * v1[2] + v1[3]) / 10.0
            //v2 = 2 * (v2_ - 0.5)
            //t = (0.96 * ((v2[1]) + 0.02))
            //duml = plot(fr ? (v2 > t ? v2 : t) : na, style = circles, linewidth = 0, color = gray, title = "Dummy")
            //cmil = plot(v2, title = "StochCGOsc", color = red)
            //tl = plot(t, title = "Trigger", color = green)
            //plot(0, title = "ZeroLine", color = gray)
            //u1 = abs(lvls),l1 = abs(lvls) * -1.0
            //plot(u1, title = "Level+", color = gray)
            //plot(l1, title = "Level-", color = gray)
            //fill(cmil, duml, color = red, transp = 50, title = "NegativeFill")
            //fill(tl, duml, color = lime, transp = 50, title = "PositiveFill")
            //ebc = input(false, title = "Color bars?")
            //bc = ebc ? (v2 > v2[1] ? (v2 > 0 ? lime : green) : v2 < v2[1] ? (v2 > 0 ? orange : red) : (v2 > u1 ? lime : v2 < l1 ? red : gray)) : na
            //barcolor(bc)
            List<decimal> tempList = new();
            List<decimal> v1List = new();
            List<decimal> v2_List = new();
            List<decimal> v2List = new();
            List<decimal> tList = new();
            List<Signal> signalsList = new();

            try
            {
                List<decimal> ehlersCGOscillatorList = CalculateEhlersCenterofGravityOscillator(null, stockDataClass, days).Item5;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal cg = ehlersCGOscillatorList.ElementAtOrDefault(i);
                    tempList.Add(cg);

                    decimal maxc = tempList.TakeLast(days).Max();
                    decimal minc = tempList.TakeLast(days).Min();
                    decimal prevV1_1 = i >= 1 ? v1List.ElementAtOrDefault(i - 1) : 0;
                    decimal prevV1_2 = i >= 2 ? v1List.ElementAtOrDefault(i - 2) : 0;
                    decimal prevV1_3 = i >= 3 ? v1List.ElementAtOrDefault(i - 3) : 0;
                    decimal prevV2_1 = i >= 1 ? v2List.ElementAtOrDefault(i - 1) : 0;
                    decimal prevT1 = i >= 1 ? tList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevT2 = i >= 2 ? tList.ElementAtOrDefault(i - 2) : 0;

                    decimal v1 = maxc - minc != 0 ? (cg - minc) / (maxc - minc) : 0;
                    v1List.Add(v1);

                    decimal v2_ = ((4 * v1) + (3 * prevV1_1) + (2 * prevV1_2) + prevV1_3) / 10;
                    v2_List.Add(v2_);

                    decimal v2 = 2 * (v2_ - 0.5m);
                    v2List.Add(v2);

                    decimal t = MinOrMax(0.96m * (prevV2_1 + 0.02m), 1, 0);
                    tList.Add(t);

                    var signal = GetRsiSignal(t - prevT1, prevT1 - prevT2, t, prevT1, 0.8m, 0.2m);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (v1List, v2_List, v2List, tList, signalsList);
        }

        public static (List<decimal>, List<Signal>) CalculateEhlersSimpleCycleIndicator(StockData stockDataClass)
        {
            //
            // @author LazyBear 
            // 
            // List of my public indicators: http://bit.ly/1LQaPK8 
            // List of my app-store indicators: http://blog.tradingview.com/?p=970 
            //
            //study("Ehlers  Simple Cycle Indicator [LazyBear]", shorttitle = "ESCI_LB")
            //src = input(hl2, title = "Source")
            //alpha = input(.07, title = "Alpha")
            //Smooth = (src + 2 * src[1] + 2 * src[2] + src[3]) / 6.0
            //cycle_ = (1 - .5 * alpha) * (1 - .5 * alpha) * (Smooth - 2 * Smooth[1] + Smooth[2]) + 2 * (1 - alpha) * cycle[1] - (1 - alpha) * (1 - alpha) * cycle[2]
            //cycle = iff(n < 7, (src - 2 * src[1] + src[2]) / 4.0, cycle_)
            //t = cycle[1]
            //plot(0, title = "ZeroLine", color = gray)
            //fr = input(true, title = "Fill Osc/Trigger region")
            //duml = plot(fr ? (cycle > t ? cycle : t) : na, style = circles, linewidth = 0, color = gray, title = "Dummy")
            //cmil = plot(cycle, title = "SimpleCycleIndicator", color = blue)
            //tl = plot(t, title = "Trigger", color = green)
            //fill(cmil, duml, color = red, transp = 50, title = "NegativeFill")
            //fill(tl, duml, color = lime, transp = 50, title = "PositiveFill")
            //ebc = input(false, title = "Color bars?")
            //bc = ebc ? (cycle > 0 ? (cycle > t ? lime : (cycle == t ? gray : green)) : (cycle < t ? red : orange)) : na
            //barcolor(bc)
            decimal alpha = 0.07m;
            List<decimal> smoothList = new();
            List<decimal> cycleList = new();
            List<decimal> cycle_List = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentMedianPrice = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevMedianPrice1 = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevMedianPrice2 = i >= 2 ? stockDataClass.InputValues.ElementAtOrDefault(i - 2) : 0;
                    decimal prevMedianPrice3 = i >= 3 ? stockDataClass.InputValues.ElementAtOrDefault(i - 3) : 0;
                    decimal prevSmooth1 = smoothList.LastOrDefault();
                    decimal prevCycle1 = cycle_List.LastOrDefault();
                    decimal prevSmooth2 = i >= 2 ? smoothList.ElementAtOrDefault(i - 2) : 0;
                    decimal prevCycle2 = i >= 2 ? cycle_List.ElementAtOrDefault(i - 2) : 0;
                    decimal prevCyc1 = i >= 1 ? cycleList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevCyc2 = i >= 2 ? cycleList.ElementAtOrDefault(i - 2) : 0;

                    decimal smooth = (currentMedianPrice + (2 * prevMedianPrice1) + (2 * prevMedianPrice2) + prevMedianPrice3) / 6;
                    smoothList.Add(smooth);

                    decimal cycle_ = ((1 - (0.5m * alpha)) * (1 - (0.5m * alpha)) * (smooth - (2 * prevSmooth1) + prevSmooth2)) + (2 * (1 - alpha) * prevCycle1) -
                        ((1 - alpha) * (1 - alpha) * prevCycle2);
                    cycle_List.Add(cycle_);

                    decimal cycle = i < 7 ? (currentMedianPrice - (2 * prevMedianPrice1) + prevMedianPrice2) / 4 : cycle_;
                    cycleList.Add(cycle);

                    var signal = GetCompareSignal(cycle - prevCyc1, prevCyc1 - prevCyc2);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (cycleList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateEhlersSimpleDecycler(StockData stockDataClass, int days = 125)
        {
            //@version=3
            // Copyright (c) 2019-present, Alex Orekhov (everget)
            // Ehlers Simple Decycler script may be freely distributed under the MIT license.
            //study("Ehlers Simple Decycler", shorttitle = "Decycler", overlay = true)

            //highpassLength = input(title = "Highpass Period", type = integer, defval = 125)
            //upperPercent = input(title = "Upper Band % Shift", type = float, minval = 0, step = 0.1, defval = 0.5)
            //lowerPercent = input(title = "Lower Band % Shift", type = float, minval = 0, step = 0.1, defval = 0.5)
            //src = input(title = "Source", type = source, defval = close)
            //highlightMovements = input(title = "Highlight Decycler Movements ?", type = bool, defval = true)

            //PI = 2 * asin(1)

            // High-pass Filter
            //alphaArg = 2 * PI / (highpassLength * sqrt(2))

            //alpha = 0.0
            //alpha:= cos(alphaArg) != 0
            //    ? (cos(alphaArg) + sin(alphaArg) - 1) / cos(alphaArg)
            //    : nz(alpha[1])

            //hp = 0.0
            //hp:= pow(1 - (alpha / 2), 2) * (src - 2 * nz(src[1]) + nz(src[2])) + 2 * (1 - alpha) * nz(hp[1]) - pow(1 - alpha, 2) * nz(hp[2])

            //decycler = src - hp

            //decyclerColor = highlightMovements ? (decycler >= decycler[1] ? green : red) : #741b47
            //plot(decycler, title = "Decycler", linewidth = 2, color = decyclerColor, transp = 0)

            //upperBand = (1 + upperPercent / 100) * decycler
            //lowerBand = (1 - lowerPercent / 100) * decycler

            //bandColor = #138484
            //upperBandPlot = plot(upperBand, title = "Upper", color = bandColor)
            //lowerBandPlot = plot(lowerBand, title = "Lower", color = bandColor)
            //fill(upperBandPlot, lowerBandPlot, title = "Background", color = color(#ffd966, 84))
            decimal upperPercent = 0.5m, lowerPoercent = 0.5m;
            List<decimal> decyclerList = new();
            List<decimal> upperBandList = new();
            List<decimal> lowerBandList = new();
            List<Signal> signalsList = new();

            try
            {
                List<decimal> hpList = CalculateEhlersHighPassFilter(null, stockDataClass, days, 1).Item1;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal hp = hpList.ElementAtOrDefault(i);

                    decimal prevDecycler = decyclerList.LastOrDefault();
                    decimal decycler = currentValue - hp;
                    decyclerList.Add(decycler);

                    decimal upperBand = (1 + (upperPercent / 100)) * decycler;
                    upperBandList.Add(upperBand);

                    decimal lowerBand = (1 - (lowerPoercent / 100)) * decycler;
                    lowerBandList.Add(lowerBand);

                    var signal = GetCompareSignal(currentValue - decycler, prevValue - prevDecycler);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (decyclerList, upperBandList, lowerBandList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateEhlersDecyclerOscillator(StockData stockDataClass, int days = 100)
        {
            //@version=3
            // Copyright (c) 2019-present, Alex Orekhov (everget)
            // Ehlers Decycler Oscillator script may be freely distributed under the MIT license.
            //study("Ehlers Decycler Oscillator", shorttitle = "Decycler Oscillator")

            //hpPeriod = input(title = "High-pass Filter Period", type = integer, defval = 125)
            //k = input(title = "K Multiplier", type = float, step = 0.1, defval = 1)
            //hpPeriod2 = input(title = "High-pass Filter Period 2", type = integer, defval = 100)
            //k2 = input(title = "K Multiplier 2", type = float, step = 0.1, defval = 1.2)
            //src = input(title = "Source", type = source, defval = close)
            //highlightCrossovers = input(title = "Highlight Crossovers ?", type = bool, defval = true)
            //highlightZeroCrossovers = input(title = "Highlight Zero Line Crossovers ?", type = bool, defval = false)
            //applyFilling = input(title = "Apply Ribbon Filling ?", type = bool, defval = false)

            //PI = 2 * asin(1)

            // High-pass Filter
            //            _hp(src, hpPeriod, mult) =>
            //    alphaArg = 2 * PI / (mult * hpPeriod * sqrt(2))

            //    alpha = 0.0
            //    alpha:= cos(alphaArg) != 0
            //        ? (cos(alphaArg) + sin(alphaArg) - 1) / cos(alphaArg)
            //        : nz(alpha[1])

            //    hp = 0.0
            //    hp:= pow(1 - (alpha / 2), 2) * (src - 2 * nz(src[1]) + nz(src[2])) + 2 * (1 - alpha) * nz(hp[1]) - pow(1 - alpha, 2) * nz(hp[2])
            //    hp

            //hp = _hp(src, hpPeriod, 1)
            //decycler = src - hp
            //decosc = 100 * k * _hp(decycler, hpPeriod, 0.5) / src

            //hp2 = _hp(src, hpPeriod2, 1)
            //decycler2 = src - hp2
            //decosc2 = 100 * k2 * _hp(decycler2, hpPeriod2, 0.5) / src

            //trendColor = decosc2 > decosc ? #0ebb23 : red

            //decoscColor = applyFilling ? trendColor : #ff5048
            //decosc2Color = applyFilling ? trendColor : #f5c75e

            //decoscPlot = plot(decosc, title = "1", linewidth = 2, color = decoscColor, transp = 0)
            //decosc2Plot = plot(decosc2, title = "2", linewidth = 2, color = decosc2Color, transp = 0)
            //hline(0, title = "Zero Level", linestyle = dotted)

            //transparent = color(white, 100)

            //fillColor = applyFilling ? trendColor : transparent
            //fill(decoscPlot, decosc2Plot, color = fillColor, transp = 70)

            //zeroCrossBgColor = highlightZeroCrossovers ? (decosc > 0 or decosc2 > 0 ? green : red) : transparent
            //bgcolor(zeroCrossBgColor, transp = 85)

            //plotshape(highlightCrossovers and crossover(decosc, decosc2) ? avg(decosc, decosc[1]) : na, title = "Crossover", location = location.absolute, style = shape.circle, size = size.tiny, color = green, transp = 0)
            //plotshape(highlightCrossovers and crossunder(decosc, decosc2) ? avg(decosc, decosc[1]) : na, title = "Crossunder", location = location.absolute, style = shape.circle, size = size.tiny, color = red, transp = 0)
            decimal k = 1, k2 = 1.2m;
            List<decimal> decycler1FilteredList = new();
            List<decimal> decycler2FilteredList = new();
            List<decimal> decycler1OscillatorList = new();
            List<decimal> decycler2OscillatorList = new();
            List<Signal> signalsList = new();

            try
            {
                int hpPeriod1 = (int)Math.Ceiling(days / 0.8);
                int hpPeriod2 = days;

                List<decimal> decycler1List = CalculateEhlersSimpleDecycler(stockDataClass, hpPeriod1).Item1;
                List<decimal> decycler2List = CalculateEhlersSimpleDecycler(stockDataClass, hpPeriod2).Item1;
                decycler1FilteredList = CalculateEhlersHighPassFilter(decycler1List, stockDataClass, hpPeriod1, 0.5m).Item1;
                decycler2FilteredList = CalculateEhlersHighPassFilter(decycler2List, stockDataClass, hpPeriod2, 0.5m).Item1;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal decycler1Filtered = decycler1FilteredList.ElementAtOrDefault(i);
                    decimal decycler2Filtered = decycler2FilteredList.ElementAtOrDefault(i);

                    decimal prevDecyclerOsc1 = decycler1OscillatorList.LastOrDefault();
                    decimal decyclerOscillator1 = currentValue != 0 ? 100 * k * decycler1Filtered / currentValue : 0;
                    decycler1OscillatorList.Add(decyclerOscillator1);

                    decimal prevDecyclerOsc2 = decycler2OscillatorList.LastOrDefault();
                    decimal decyclerOscillator2 = currentValue != 0 ? 100 * k2 * decycler2Filtered / currentValue : 0;
                    decycler2OscillatorList.Add(decyclerOscillator2);

                    var signal = GetCompareSignal(decyclerOscillator2 - decyclerOscillator1, prevDecyclerOsc2 - prevDecyclerOsc1);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (decycler1FilteredList, decycler1OscillatorList, decycler2FilteredList, decycler2OscillatorList, signalsList);
        }

        public static (List<decimal>, List<Signal>) CalculateEhlersDecyclerOscillatorV2(StockData stockDataClass, int days = 10)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Ehlers Decycler Oscillator [CC] script may be freely distributed under the MIT license.
            //study("Ehlers Decycler Oscillator [CC]", overlay = false)

            //inp = input(title = "Source", type = input.source, defval = close)
            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //src = security(syminfo.tickerid, res, inp[rep ? 0 : barstate.isrealtime ? 1 : 0])[rep ? 0 : barstate.isrealtime ? 0 : 1]
            //length1 = input(title = "Length1", type = input.integer, defval = 10, minval = 1)
            //length2 = input(title = "Length2", type = input.integer, defval = 20, minval = 1)

            //pi = 2 * asin(1)

            //hp_filter(src, length) =>
            //    twoPiPrd = 0.707 * 2 * pi / length
            //    a = (cos(twoPiPrd) + sin(twoPiPrd) - 1) / cos(twoPiPrd)

            //    hp = 0.0
            //    hp:= (pow(1 - (a / 2), 2) * (src - (2 * nz(src[1])) + nz(src[2]))) + (2 * (1 - a) * nz(hp[1])) - (pow(1 - a, 2) * nz(hp[2]))

            //hp1 = hp_filter(src, length1)
            //hp2 = hp_filter(src, length2)
            //dec = hp2 - hp1

            //sig = dec > 0 ? 1 : dec < 0 ? -1 : 0
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //decColor = sig > 0 ? color.green : sig < 0 ? color.red : color.black
            //barcolor(bar ? decColor : na)
            //plot(dec, title = "DEC", color = decColor, linewidth = 2)
            List<decimal> decList = new();
            List<Signal> signalsList = new();

            try
            {
                int length = days * 2;

                var hp1List = CalculateEhlersHighPassFilter(null, stockDataClass, days).Item1;
                var hp2List = CalculateEhlersHighPassFilter(null, stockDataClass, length).Item1;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal hp1 = hp1List.ElementAtOrDefault(i);
                    decimal hp2 = hp2List.ElementAtOrDefault(i);

                    decimal prevDec = decList.LastOrDefault();
                    decimal dec = hp2 - hp1;
                    decList.Add(dec);

                    var signal = GetCompareSignal(dec, prevDec);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (decList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateEhlersFilter(StockData stockDataClass, int days = 5)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Ehlers NonLinear Filter [CC] script may be freely distributed under the MIT license.
            //study("Ehlers NonLinear Filter [CC]", overlay = true)

            //inp = input(title = "Source", type = input.source, defval = hl2)
            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //length = input(title = "Length", type = input.integer, defval = 15, minval = 1)
            //momLength = input(title = "MomentumLength", type = input.integer, defval = 5, minval = 1)
            //src = security(syminfo.tickerid, res, inp[rep ? 0 : barstate.isrealtime ? 1 : 0])[rep ? 0 : barstate.isrealtime ? 0 : 1]

            //num = 0.0, coefSum = 0.0
            //for i = 0 to length - 1
            //    coef = abs(nz(src[i]) - nz(src[i + momLength]))
            //    num := num + (coef * nz(src[i]))
            //    coefSum := coefSum + coef

            //filt = coefSum != 0 ? num / coefSum : 0

            //sig = src > filt ? 1 : src < filt ? -1 : 0
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //filtColor = sig > 0 ? color.green : sig < 0 ? color.red : color.black
            //barcolor(bar ? filtColor : na)
            //plot(filt, title = "Filter", color = filtColor, linewidth = 2)
            List<decimal> filterList = new();
            List<decimal> numList = new();
            List<decimal> sumCList = new();
            List<Signal> signalsList = new();

            try
            {
                int length = days * 3;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal num = 0, sumC = 0;
                    for (int j = 0; j <= length - 1; j++)
                    {
                        decimal currentPrice = i >= j ? stockDataClass.InputValues.ElementAtOrDefault(i - j) : 0;
                        decimal prevPrice = i >= j + days ? stockDataClass.InputValues.ElementAtOrDefault(i - (j + days)) : 0;
                        decimal priceDiff = Math.Abs(currentPrice - prevPrice);

                        num += priceDiff * currentPrice;
                        sumC += priceDiff;
                    }
                    numList.Add(num);
                    sumCList.Add(sumC);

                    decimal prevEhlersFilter = filterList.LastOrDefault();
                    decimal ehlersFilter = sumC != 0 ? num / sumC : 0;
                    filterList.Add(ehlersFilter);

                    var signal = GetCompareSignal(currentValue - ehlersFilter, prevValue - prevEhlersFilter);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (numList, sumCList, filterList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateEhlersDistanceCoefficientFilter(StockData stockDataClass, int days = 14)
        {
            //@version=3
            // Copyright (c) 2018-present, Alex Orekhov (everget)
            // Ehlers Distance Coefficient Filter script may be freely distributed under the MIT license.
            //study("Ehlers Distance Coefficient Filter", shorttitle = "EDCF", overlay = true)
            //length = input(title = "Length", type = integer, defval = 14)
            //src = input(title = "Source", type = source, defval = hl2)

            //srcSum = 0.0
            //coefSum = 0.0
            //for count = 0 to length - 1

            //    distance = 0.0
            //    for lookback = 1 to length - 1
            //        distance := distance + pow(src[count] - src[count + lookback], 2)

            //    srcSum := srcSum + distance * src[count]
            //    coefSum := coefSum + distance

            //dcf = coefSum != 0 ? srcSum / coefSum : 0.0

            //plot(dcf, title = "EDCF", linewidth = 2, color =#6d1e7f, transp=0)
            List<decimal> filterList = new();
            List<decimal> srcSumList = new();
            List<decimal> coefSumList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal srcSum = 0, coefSum = 0;
                    for (int count = 0; count <= days - 1; count++)
                    {
                        decimal prevCount = i >= count ? stockDataClass.InputValues.ElementAtOrDefault(i - count) : 0;

                        decimal distance = 0;
                        for (int lookBack = 1; lookBack <= days - 1; lookBack++)
                        {
                            decimal prevCountLookBack = i >= count + lookBack ? stockDataClass.InputValues.ElementAtOrDefault(i - (count + lookBack)) : 0;
                            distance += Pow(prevCount - prevCountLookBack, 2);
                        }

                        srcSum += distance * prevCount;
                        coefSum += distance;
                    }
                    srcSumList.Add(srcSum);
                    coefSumList.Add(coefSum);

                    decimal prevFilter = filterList.LastOrDefault();
                    decimal filter = coefSum != 0 ? srcSum / coefSum : 0;
                    filterList.Add(filter);

                    var signal = GetCompareSignal(currentValue - filter, prevValue - prevFilter);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (srcSumList, coefSumList, filterList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateEhlersRoofingFilter(StockData stockDataClass, int days = 10)
        {
            //EhlersRoofingFilter
            //{ Roofing filter © 2013  John F. Ehlers } 

            //Vars: alpha1(0), HP(0), a1(0), b1(0), c1(0), c2(0), c3(0), Filt(0), Filt2(0);   
            //Highpass filter cyclic components whose periods are shorter than 48 bars 
            //alpha1 = (Cosine(.707*360 / 48) + Sine (.707*360 / 48) - 1) / Cosine(.707*360 / 48); 
            //HP = (1 - alpha1  / 2)*(1 - alpha1 / 2)*(Close - 2*Close[1] + Close[2]) + 2*(1 - alpha1)*HP[1] - (1 - alpha1)*(1 - alpha1)*HP[2]; 

            //a1 = expvalue(-1.414*3.14159 / 10);
            //b1 = 2*a1*Cosine(1.414*180 / 10);
            //c2 = b1;
            //c3 = -a1*a1;
            //c1 = 1 -c2 -c3;
            //Filt = c1*(HP + HP[1]) / 2 + c2*Filt[1] + c3*Filt[2];
            //Smooth with a Super Smoother Filter  
            //a1 = expvalue(-1.414*3.14159 / 10); 
            //b1 = 2 * a1 * Cosine(1.414 * 180 / 10); 
            //c2 = b1; 
            //c3 = -a1 * a1; 
            //c1 = 1 - c2 - c3; 
            //Filt = c1 * (HP + HP[1]) / 2 + c2 * Filt[1] + c3 * Filt[2];
            List<decimal> highPassList = new();
            List<decimal> roofingFilterList = new();
            List<Signal> signalsList = new();

            try
            {
                int lowerPeriod = days;
                int upperPeriod = (int)Math.Ceiling(lowerPeriod / 0.2084);
                decimal alphaArg = Math.Min((decimal)(0.707 * 2 * Math.PI) / upperPeriod, 0.99m);
                decimal alphaCos = Cos(alphaArg);
                decimal alpha1 = alphaCos != 0 ? (alphaCos + Sin(alphaArg) - 1) / alphaCos : 0;
                decimal a1 = Exp(-1.414m * 3.14159m / lowerPeriod);
                decimal b1 = 2 * a1 * Cos(Math.Min(ToRadians(1.414m * 180 / lowerPeriod), 0.99m));
                decimal c2 = b1;
                decimal c3 = -1 * a1 * a1;
                decimal c1 = 1 - c2 - c3;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue1 = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevValue2 = i >= 2 ? stockDataClass.InputValues.ElementAtOrDefault(i - 2) : 0;
                    decimal prevFilter1 = i >= 1 ? roofingFilterList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevFilter2 = i >= 2 ? roofingFilterList.ElementAtOrDefault(i - 2) : 0;
                    decimal prevHp1 = i >= 1 ? highPassList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevHp2 = i >= 2 ? highPassList.ElementAtOrDefault(i - 2) : 0;
                    decimal test1 = Pow((1 - alpha1) / 2, 2);
                    decimal test2 = currentValue - (2 * prevValue1) + prevValue2;
                    decimal v1 = test1 * test2;
                    decimal v2 = 2 * (1 - alpha1) * prevHp1;
                    decimal v3 = Pow(1 - alpha1, 2) * prevHp2;

                    decimal highPass = v1 + v2 - v3;
                    highPassList.Add(highPass);

                    decimal prevRoofingFilter1 = i >= 1 ? roofingFilterList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevRoofingFilter2 = i >= 2 ? roofingFilterList.ElementAtOrDefault(i - 2) : 0;
                    decimal roofingFilter = (c1 * ((highPass + prevHp1) / 2)) + (c2 * prevFilter1) + (c3 * prevFilter2);
                    roofingFilterList.Add(roofingFilter);

                    var signal = GetCompareSignal(roofingFilter - prevRoofingFilter1, prevRoofingFilter1 - prevRoofingFilter2);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (highPassList, roofingFilterList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateEhlersModifiedStochasticIndicator(StockData stockDataClass, int days = 10)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Ehlers Modified Stochastic Indicator [CC] script may be freely distributed under the MIT license.
            //study("Ehlers Modified Stochastic Indicator [CC]", overlay = false)

            //inp = input(title = "Source", type = input.source, defval = close)
            //res = input(title = "Resolution", type = input.resolution, defval = "D")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //src = security(syminfo.tickerid, res, inp[rep ? 0 : barstate.isrealtime ? 1 : 0])[rep ? 0 : barstate.isrealtime ? 0 : 1]
            //hpLength = input(title = "HPLength", type = input.integer, defval = 48, minval = 1)
            //ssfLength = input(title = "SSFLength", type = input.integer, defval = 10, minval = 1)
            //length = input(title = "Length", type = input.integer, defval = 20, minval = 1)
            //obLevel = input(title = "ObLevel", type = input.integer, defval = 70, minval = 1)
            //osLevel = input(title = "OsLevel", type = input.integer, defval = 30, minval = 1)

            //pi = 2 * asin(1)
            //twoPiPrd = 0.707 * 2 * pi / hpLength
            //a1 = (cos(twoPiPrd) + sin(twoPiPrd) - 1) / cos(twoPiPrd)
            //a2 = exp(-1.414 * pi / ssfLength)
            //beta = 2 * a2 * cos(1.414 * pi / ssfLength)
            //c2 = beta
            //c3 = -a2 * a2
            //c1 = 1 - c2 - c3

            //hp = 0.0
            //hp:= ((1 - (a1 / 2)) * (1 - (a1 / 2)) * (src - (2 * nz(src[1])) + nz(src[2]))) + (2 * (1 - a1) * nz(hp[1])) - ((1 - a1) * (1 - a1) * nz(hp[2]))

            //rfilt = 0.0
            //rfilt:= (c1 * ((hp + nz(hp[1])) / 2)) + (c2 * nz(rfilt[1])) + (c3 * nz(rfilt[2]))

            //highestC = highest(rfilt, length)
            //lowestC = lowest(rfilt, length)
            //stoc = highestC - lowestC != 0 ? (rfilt - lowestC) / (highestC - lowestC) * 100 : 0
            //modStoc = 0.0
            //modStoc:= (c1 * ((stoc + nz(stoc[1])) / 2)) + (c2 * nz(modStoc[1])) + (c3 * nz(modStoc[2]))

            //hline(obLevel, color = color.green)
            //hline(osLevel, color = color.red)
            //sig = stoc > modStoc or(stoc[1] < osLevel and stoc > osLevel) ? 1 : stoc < modStoc or(stoc[1] > obLevel and stoc < obLevel) ? -1 : 0
            //stocColor = sig > 0 ? color.green : sig < 0 ? color.red : color.black
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //barcolor(bar ? stocColor : na)
            //plot(stoc, title = "Stochastic", color = stocColor, linewidth = 2)
            //plot(modStoc, title = "ModifiedStochastic", color = color.black, linewidth = 1)
            List<decimal> highestList = new();
            List<decimal> lowestList = new();
            List<decimal> stocList = new();
            List<decimal> modStocList = new();
            List<Signal> signalsList = new();

            try
            {
                int lowerPeriod = days;
                int length = days * 2;
                decimal a1 = Exp(-1.414 * 3.14159 / lowerPeriod);
                decimal b1 = 2 * a1 * Cos(Math.Min(ToRadians(1.414 * 180 / lowerPeriod), 0.99m));
                decimal c2 = b1;
                decimal c3 = -1 * a1 * a1;
                decimal c1 = 1 - c2 - c3;

                var roofingFilterList = CalculateEhlersRoofingFilter(stockDataClass, days).Item2;
                var minMaxList = GetMaxAndMinValuesList(roofingFilterList, length);
                highestList = minMaxList.Item1;
                lowestList = minMaxList.Item2;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal highest = highestList.ElementAtOrDefault(i);
                    decimal lowest = lowestList.ElementAtOrDefault(i);
                    decimal roofingFilter = roofingFilterList.ElementAtOrDefault(i);
                    decimal prevModStoc1 = i >= 1 ? modStocList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevModStoc2 = i >= 2 ? modStocList.ElementAtOrDefault(i - 2) : 0;

                    decimal prevStoc = stocList.LastOrDefault();
                    decimal stoc = highest - lowest != 0 ? (roofingFilter - lowest) / (highest - lowest) * 100 : 0;
                    stocList.Add(stoc);

                    decimal modStoc = (c1 * ((stoc + prevStoc) / 2)) + (c2 * prevModStoc1) + (c3 * prevModStoc2);
                    modStocList.Add(modStoc);

                    var signal = GetRsiSignal(modStoc - prevModStoc1, prevModStoc1 - prevModStoc2, modStoc, prevModStoc1, 70, 30);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (highestList, lowestList, stocList, modStocList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateEhlersModifiedRelativeStrengthIndex(StockData stockDataClass, int days = 10)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Ehlers Modified Relative Strength Index [CC] script may be freely distributed under the MIT license.
            //study("Ehlers Modified Relative Strength Index [CC]", overlay = false)

            //inp = input(title = "Source", type = input.source, defval = close)
            //res = input(title = "Resolution", type = input.resolution, defval = "D")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //src = security(syminfo.tickerid, res, inp[rep ? 0 : barstate.isrealtime ? 1 : 0])[rep ? 0 : barstate.isrealtime ? 0 : 1]
            //hpLength = input(title = "HPLength", type = input.integer, defval = 48, minval = 1)
            //ssfLength = input(title = "SSFLength", type = input.integer, defval = 10, minval = 1)
            //length = input(title = "Length", type = input.integer, defval = 10, minval = 1)
            //obLevel = input(title = "ObLevel", type = input.float, defval = 0.7, minval = 1)
            //osLevel = input(title = "OsLevel", type = input.float, defval = 0.3, minval = 1)

            //pi = 2 * asin(1)
            //twoPiPrd = 0.707 * 2 * pi / hpLength
            //a1 = (cos(twoPiPrd) + sin(twoPiPrd) - 1) / cos(twoPiPrd)
            //a2 = exp(-1.414 * pi / ssfLength)
            //beta = 2 * a2 * cos(1.414 * pi / ssfLength)
            //c2 = beta
            //c3 = -a2 * a2
            //c1 = 1 - c2 - c3

            //hp = 0.0
            //hp:= ((1 - (a1 / 2)) * (1 - (a1 / 2)) * (src - (2 * nz(src[1])) + nz(src[2]))) + (2 * (1 - a1) * nz(hp[1])) - ((1 - a1) * (1 - a1) * nz(hp[2]))

            //rfilt = 0.0
            //rfilt:= (c1 * ((hp + nz(hp[1])) / 2)) + (c2 * nz(rfilt[1])) + (c3 * nz(rfilt[2]))

            //upChg = 0.0, dnChg = 0.0
            //for i = 0 to length - 1
            //    price = nz(rfilt[i])
            //    prevPrice = nz(rfilt[i + 1])
            //    upChg := price > prevPrice ? upChg + (price - prevPrice) : upChg
            //    dnChg := price < prevPrice ? dnChg + (prevPrice - price) : dnChg

            //denom = upChg + dnChg
            //mrsi = 0.0
            //mrsi := denom != 0 and nz(denom[1]) != 0 ? (c1 * (((upChg / denom) + (upChg[1] / denom[1])) / 2)) + (c2 * nz(mrsi[1])) + (c3 * nz(mrsi[2])) : 0
            //mrsiSig = 0.0
            //mrsiSig := (c1 * ((mrsi + nz(mrsi[1])) / 2)) + (c2 * nz(mrsiSig[1])) + (c3 * nz(mrsiSig[2]))

            //hline(obLevel, color = color.green)
            //hline(osLevel, color = color.red)
            //sig = mrsi > mrsiSig or(mrsi[1] < osLevel and mrsi > osLevel) ? 1 : mrsi < mrsiSig or(mrsi[1] > obLevel and mrsi < obLevel) ? -1 : 0
            //mrsiColor = sig > 0 ? color.green : sig < 0 ? color.red : color.black
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //barcolor(bar ? mrsiColor : na)
            //plot(mrsi, title = "ModifiedRSI", color = mrsiColor, linewidth = 2)
            //plot(mrsiSig, title = "ModifiedRSISignal", color = color.black, linewidth = 1)
            List<decimal> upChgList = new();
            List<decimal> dnChgList = new();
            List<decimal> upChgSumList = new();
            List<decimal> dnChgSumList = new();
            List<decimal> denomList = new();
            List<decimal> mrsiList = new();
            List<decimal> mrsiSigList = new();
            List<Signal> signalsList = new();

            try
            {
                decimal a1 = Exp(-1.414 * 3.14159 / days);
                decimal b1 = 2 * a1 * Cos(Math.Min(ToRadians(1.414 * 180 / days), 0.99m));
                decimal c2 = b1;
                decimal c3 = -1 * a1 * a1;
                decimal c1 = 1 - c2 - c3;

                var roofingFilterList = CalculateEhlersRoofingFilter(stockDataClass, days).Item2;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal roofingFilter = roofingFilterList.ElementAtOrDefault(i);
                    decimal prevRoofingFilter = i >= 1 ? roofingFilterList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevMrsi1 = i >= 1 ? mrsiList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevMrsi2 = i >= 2 ? mrsiList.ElementAtOrDefault(i - 2) : 0;
                    decimal prevMrsiSig1 = i >= 1 ? mrsiSigList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevMrsiSig2 = i >= 2 ? mrsiSigList.ElementAtOrDefault(i - 2) : 0;

                    decimal upChg = roofingFilter > prevRoofingFilter ? roofingFilter - prevRoofingFilter : 0;
                    upChgList.Add(upChg);

                    decimal dnChg = roofingFilter < prevRoofingFilter ? prevRoofingFilter - roofingFilter : 0;
                    dnChgList.Add(dnChg);

                    decimal prevUpChgSum = upChgSumList.LastOrDefault();
                    decimal upChgSum = upChgList.TakeLast(days).Sum();
                    upChgSumList.Add(upChgSum);

                    decimal dnChgSum = dnChgList.TakeLast(days).Sum();
                    dnChgSumList.Add(dnChgSum);

                    decimal prevDenom = denomList.LastOrDefault();
                    decimal denom = upChg + dnChg;
                    denomList.Add(denom);

                    decimal mrsi = denom != 0 && prevDenom != 0 ? (c1 * (((upChgSum / denom) + (prevUpChgSum / prevDenom)) / 2)) + (c2 * prevMrsi1) + (c3 * prevMrsi2) : 0;
                    mrsiList.Add(mrsi);

                    decimal mrsiSig = (c1 * ((mrsi + prevMrsi1) / 2)) + (c2 * prevMrsiSig1) + (c3 * prevMrsiSig2);
                    mrsiSigList.Add(mrsiSig);

                    var signal = GetRsiSignal(mrsi - mrsiSig, prevMrsi1 - prevMrsiSig1, mrsi, prevMrsi1, 0.7m, 0.3m);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (upChgList, dnChgList, upChgSumList, dnChgSumList, denomList, mrsiList, mrsiSigList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateEhlersHpLpRoofingFilter(StockData stockDataClass, int days = 10)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Ehlers HighPass-LowPass Roofing Filter [CC] script may be freely distributed under the MIT license.
            //study("Ehlers HighPass-LowPass Roofing Filter [CC]", overlay = false)

            //inp = input(title = "Source", type = input.source, defval = close)
            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //src = security(syminfo.tickerid, res, inp[rep ? 0 : barstate.isrealtime ? 1 : 0])[rep ? 0 : barstate.isrealtime ? 0 : 1]
            //hpLength = input(title = "HPLength", type = input.integer, defval = 48, minval = 1)
            //ssfLength = input(title = "SSFLength", type = input.integer, defval = 10, minval = 1)

            //pi = 2 * asin(1)
            //twoPiPrd = 2 * pi / hpLength
            //alpha1 = (cos(twoPiPrd) + sin(twoPiPrd) - 1) / cos(twoPiPrd)
            //alpha2 = exp(-1.414 * pi / ssfLength)
            //beta = 2 * alpha2 * cos(1.414 * pi / ssfLength)
            //c2 = beta
            //c3 = -alpha2 * alpha2
            //c1 = 1 - c2 - c3

            //hp = 0.0
            //hp:= ((1 - (alpha1 / 2)) * (src - nz(src[1]))) + ((1 - alpha1) * nz(hp[1]))

            //rfilt = 0.0
            //rfilt:= (c1 * ((hp + nz(hp[1])) / 2)) + (c2 * nz(rfilt[1])) + (c3 * nz(rfilt[2]))

            //sig = rfilt > 0 ? 1 : rfilt < 0 ? -1 : 0
            //rfiltColor = sig > 0 ? color.green : sig < 0 ? color.red : color.black
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //barcolor(bar ? rfiltColor : na)
            //plot(rfilt, title = "RoofingFilter", color = rfiltColor, linewidth = 2)
            List<decimal> highPassList = new();
            List<decimal> roofingFilterList = new();
            List<Signal> signalsList = new();

            try
            {
                int lowerPeriod = days;
                int upperPeriod = (int)Math.Ceiling(lowerPeriod / 0.2084);
                decimal alphaArg = Math.Min(ToRadians((double)360 / upperPeriod), 0.99m);
                decimal alphaCos = Cos(alphaArg);
                decimal alpha1 = alphaCos != 0 ? (alphaCos + Sin(alphaArg) - 1) / alphaCos : 0;
                decimal a1 = (decimal)Exp(-1.414 * 3.14159 / lowerPeriod);
                decimal b1 = 2 * a1 * Cos(Math.Min(ToRadians(1.414 * 180 / lowerPeriod), 0.99m));
                decimal c2 = b1;
                decimal c3 = -1 * a1 * a1;
                decimal c1 = 1 - c2 - c3;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue1 = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevValue2 = i >= 2 ? stockDataClass.InputValues.ElementAtOrDefault(i - 2) : 0;
                    decimal prevFilter1 = i >= 1 ? roofingFilterList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevFilter2 = i >= 2 ? roofingFilterList.ElementAtOrDefault(i - 2) : 0;
                    decimal prevHp1 = i >= 1 ? highPassList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevHp2 = i >= 2 ? highPassList.ElementAtOrDefault(i - 2) : 0;

                    decimal hp = ((1 - (alpha1 / 2)) * (currentValue - prevValue1)) + ((1 - alpha1) * prevHp1);
                    highPassList.Add(hp);

                    decimal filter = (c1 * ((hp + prevHp1) / 2)) + (c2 * prevFilter1) + (c3 * prevFilter2);
                    roofingFilterList.Add(filter);

                    var signal = GetCompareSignal(filter - prevFilter1, prevFilter1 - prevFilter2);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (highPassList, roofingFilterList, signalsList);
        }

        public static (List<decimal>, List<Signal>) CalculateEhlersDecycler(StockData stockDataClass, int days = 60)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Ehlers Decycler [CC] script may be freely distributed under the MIT license.
            //study("Ehlers Decycler [CC]", overlay = true)

            //inp = input(title = "Source", type = input.source, defval = close)
            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //src = security(syminfo.tickerid, res, inp[rep ? 0 : barstate.isrealtime ? 1 : 0])[rep ? 0 : barstate.isrealtime ? 0 : 1]
            //length = input(title = "Length", type = input.integer, defval = 60, minval = 1)

            //pi = 2 * asin(1)
            //twoPiPrd = 2 * pi / length
            //alpha = (cos(twoPiPrd) + sin(twoPiPrd) - 1) / cos(twoPiPrd)

            //dec = 0.0
            //dec:= ((alpha / 2) * (src + nz(src[1]))) + ((1 - alpha) * nz(dec[1]))

            //sig = src > dec ? 1 : src < dec ? -1 : 0
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //decColor = sig > 0 ? color.green : sig < 0 ? color.red : color.black
            //barcolor(bar ? decColor : na)
            //plot(dec, title = "DEC", color = decColor, linewidth = 2)
            List<decimal> decList = new();
            List<Signal> signalsList = new();

            try
            {
                decimal alphaArg = Math.Min(ToRadians((double)360 / days), 0.99m);
                decimal alphaCos = (decimal)Cos(alphaArg);
                decimal alpha1 = alphaCos != 0 ? (alphaCos + (decimal)Sin(alphaArg) - 1) / alphaCos : 0;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue1 = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal prevDec = decList.LastOrDefault();
                    decimal dec = (alpha1 / 2 * (currentValue + prevValue1)) + ((1 - alpha1) * prevDec);
                    decList.Add(dec);

                    var signal = GetCompareSignal(currentValue - dec, prevValue1 - prevDec);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (decList, signalsList);
        }

        public static (List<decimal>, List<Signal>) CalculateEhlersZeroMeanRoofingFilter(StockData stockDataClass, int days = 10)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Ehlers Zero Mean Roofing Filter [CC] script may be freely distributed under the MIT license.
            //study("Ehlers Zero Mean Roofing Filter [CC]", overlay = false)

            //inp = input(title = "Source", type = input.source, defval = close)
            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //src = security(syminfo.tickerid, res, inp[rep ? 0 : barstate.isrealtime ? 1 : 0])[rep ? 0 : barstate.isrealtime ? 0 : 1]
            //hpLength = input(title = "HPLength", type = input.integer, defval = 48, minval = 1)
            //ssfLength = input(title = "SSFLength", type = input.integer, defval = 10, minval = 1)

            //pi = 2 * asin(1)
            //twoPiPrd = 2 * pi / hpLength
            //alpha1 = (cos(twoPiPrd) + sin(twoPiPrd) - 1) / cos(twoPiPrd)
            //alpha2 = exp(-1.414 * pi / ssfLength)
            //beta = 2 * alpha2 * cos(1.414 * pi / ssfLength)
            //c2 = beta
            //c3 = -alpha2 * alpha2
            //c1 = 1 - c2 - c3

            //hp = 0.0
            //hp:= ((1 - (alpha1 / 2)) * (src - nz(src[1]))) + ((1 - alpha1) * nz(hp[1]))

            //rfilt = 0.0
            //rfilt:= (c1 * ((hp + nz(hp[1])) / 2)) + (c2 * nz(rfilt[1])) + (c3 * nz(rfilt[2]))

            //zmrfilt = 0.0
            //zmrfilt:= ((1 - (alpha1 / 2)) * (rfilt - nz(rfilt[1]))) + ((1 - alpha1) * nz(zmrfilt[1]))

            //sig = zmrfilt > 0 ? 1 : zmrfilt < 0 ? -1 : 0
            //zmrfiltColor = sig > 0 ? color.green : sig < 0 ? color.red : color.black
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //barcolor(bar ? zmrfiltColor : na)
            //plot(zmrfilt, title = "ZeroMeanRoofingFilter", color = zmrfiltColor, linewidth = 2)
            //plot(rfilt, title = "RoofingFilter", color = color.black, linewidth = 1)
            List<decimal> zmrFilterList = new();
            List<Signal> signalsList = new();

            try
            {
                int lowerPeriod = days;
                int upperPeriod = (int)Math.Ceiling(lowerPeriod / 0.2084);
                decimal alphaArg = Math.Min(ToRadians((double)360 / upperPeriod), 0.99m);
                decimal alphaCos = Cos(alphaArg);
                decimal alpha1 = alphaCos != 0 ? (alphaCos + Sin(alphaArg) - 1) / alphaCos : 0;

                var roofingFilterList = CalculateEhlersHpLpRoofingFilter(stockDataClass, days).Item2;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentRf = roofingFilterList.ElementAtOrDefault(i);
                    decimal prevRf = i >= 1 ? roofingFilterList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevZmrFilt1 = i >= 1 ? zmrFilterList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevZmrFilt2 = i >= 2 ? zmrFilterList.ElementAtOrDefault(i - 2) : 0;

                    decimal zmrFilt = ((1 - (alpha1 / 2)) * (currentRf - prevRf)) + ((1 - alpha1) * prevZmrFilt1);
                    zmrFilterList.Add(zmrFilt);

                    var signal = GetCompareSignal(zmrFilt - prevZmrFilt1, prevZmrFilt1 - prevZmrFilt2);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (zmrFilterList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateEhlersRoofingFilterIndicator(StockData stockDataClass, int days = 40)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Ehlers Roofing Filter [CC] script may be freely distributed under the MIT license.
            //study("Ehlers Roofing Filter [CC]", overlay = false)

            //inp = input(title = "Source", type = input.source, defval = close)
            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //src = security(syminfo.tickerid, res, inp[rep ? 0 : barstate.isrealtime ? 1 : 0])[rep ? 0 : barstate.isrealtime ? 0 : 1]
            //hpLength = input(title = "HPLength", type = input.integer, defval = 80, minval = 1)
            //lpLength = input(title = "LPLength", type = input.integer, defval = 40, minval = 1)

            //pi = 2 * asin(1)
            //twoPiPrd = 0.707 * 2 * pi / hpLength
            //a1 = (cos(twoPiPrd) + sin(twoPiPrd) - 1) / cos(twoPiPrd)
            //a2 = exp(-1.414 * pi / lpLength)
            //beta = 2 * a2 * cos(1.414 * pi / lpLength)
            //c2 = beta
            //c3 = -a2 * a2
            //c1 = 1 - c2 - c3

            //hp = 0.0
            //hp:= (pow(1 - (a1 / 2), 2) * (src - (2 * nz(src[1])) + nz(src[2]))) + (2 * (1 - a1) * nz(hp[1])) - (pow(1 - a1, 2) * nz(hp[2]))

            //rfilt = 0.0
            //rfilt:= (c1 * ((hp + nz(hp[1])) / 2)) + (c2 * nz(rfilt[1])) + (c3 * nz(rfilt[2]))
            //trigger = nz(rfilt[2])

            //sig = rfilt > 0 ? 1 : rfilt < 0 ? -1 : 0
            //rfiltColor = sig > 0 ? color.green : sig < 0 ? color.red : color.black
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //barcolor(bar ? rfiltColor : na)
            //plot(rfilt, title = "RoofingFilter", color = rfiltColor, linewidth = 2)
            //plot(trigger, title = "Trigger", color = color.black, linewidth = 1)
            List<decimal> highPassList = new();
            List<decimal> roofingFilterList = new();
            List<Signal> signalsList = new();

            try
            {
                int lowerPeriod = days;
                int upperPeriod = days * 2;
                decimal alphaArg = Math.Min(ToRadians(0.707 * 360 / upperPeriod), 0.99m);
                decimal alphaCos = Cos(alphaArg);
                decimal alpha1 = alphaCos != 0 ? (alphaCos + Sin(alphaArg) - 1) / alphaCos : 0;
                decimal a1 = Exp(-1.414 * 3.14159 / lowerPeriod);
                decimal b1 = 2 * a1 * Cos(Math.Min(ToRadians(1.414 * 180 / lowerPeriod), 0.99m));
                decimal c2 = b1;
                decimal c3 = -1 * a1 * a1;
                decimal c1 = 1 - c2 - c3;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue1 = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevValue2 = i >= 2 ? stockDataClass.InputValues.ElementAtOrDefault(i - 2) : 0;
                    decimal prevFilter1 = i >= 1 ? roofingFilterList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevFilter2 = i >= 2 ? roofingFilterList.ElementAtOrDefault(i - 2) : 0;
                    decimal prevHp1 = i >= 1 ? highPassList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevHp2 = i >= 2 ? highPassList.ElementAtOrDefault(i - 2) : 0;

                    decimal hp = (Pow(1 - (a1 / 2), 2) * (currentValue - (2 * prevValue1) + prevValue2)) + (2 * (1 - a1) * prevHp1) - (Pow(1 - a1, 2) * prevHp2);
                    highPassList.Add(hp);

                    decimal filter = (c1 * ((hp + prevHp1) / 2)) + (c2 * prevFilter1) + (c3 * prevFilter2);
                    roofingFilterList.Add(filter);

                    var signal = GetCompareSignal(filter - prevFilter1, prevFilter1 - prevFilter2);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (highPassList, roofingFilterList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateEhlersHurstCoefficient(StockData stockDataClass, int days = 20)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Ehlers Hurst Coefficient [CC] script may be freely distributed under the MIT license.
            //study("Ehlers Hurst Coefficient [CC]", overlay = false)

            //inp = input(title = "Source", type = input.source, defval = close)
            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //src = security(syminfo.tickerid, res, inp[rep ? 0 : barstate.isrealtime ? 1 : 0])[rep ? 0 : barstate.isrealtime ? 0 : 1]
            //length = input(title = "Length", type = input.integer, defval = 30, minval = 1)
            //ssfLength = input(title = "SSFLength", type = input.integer, defval = 20, minval = 1)

            //pi = 2 * asin(1)
            //alpha = exp(-1.414 * pi / ssfLength)
            //beta = 2 * alpha * cos(1.414 * pi / ssfLength)
            //c2 = beta
            //c3 = -alpha * alpha
            //c1 = 1 - c2 - c3
            //hLength = ceil(length / 2)

            //n3 = (highest(src, length) - lowest(src, length)) / length
            //hh = src, ll = src
            //for i = 0 to hLength - 1
            //    price = nz(src[i])
            //    hh := price > hh ? price : hh
            //    ll := price < ll ? price : ll

            //n1 = (hh - ll) / hLength
            //hh := nz(src[hLength])
            //ll := nz(src[hLength])
            //for i = hLength to length - 1
            //    price = nz(src[i])
            //    hh := price > hh ? price : hh
            //    ll := price < ll ? price : ll

            //n2 = (hh - ll) / hLength
            //dimen = 0.0
            //dimen := n1 > 0 and n2 > 0 and n3 > 0 ? 0.5 * (((log(n1 + n2) - log(n3)) / log(2)) + dimen[1]) : 0
            //hurst = 2 - dimen

            //smoothHurst = 0.0
            //smoothHurst := (c1 * ((hurst + nz(hurst[1])) / 2)) + (c2 * nz(smoothHurst[1])) + (c3 * nz(smoothHurst[2]))

            //sig = smoothHurst > 0.5 ? 1 : smoothHurst < 0.5 ? -1 : 0
            //hurstColor = sig > 0 ? color.green : sig < 0 ? color.red : color.black
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //barcolor(bar ? hurstColor : na)
            //plot(smoothHurst, title = "Hurst", color = hurstColor, linewidth = 2)
            List<decimal> n1List = new();
            List<decimal> n2List = new();
            List<decimal> n3List = new();
            List<decimal> dimenList = new();
            List<decimal> hurstList = new();
            List<decimal> smoothHurstList = new();
            List<Signal> signalsList = new();

            try
            {
                int lowerPeriod = days;
                int upperPeriod = (int)Math.Ceiling(days / 0.667);
                int hLength = (int)Math.Ceiling((decimal)upperPeriod / 2);
                decimal a1 = Exp(-1.414 * Math.PI / lowerPeriod);
                decimal b1 = 2 * a1 * Cos(Math.Min(ToRadians(1.414 * 180 / lowerPeriod), 0.99m));
                decimal c2 = b1;
                decimal c3 = -1 * a1 * a1;
                decimal c1 = 1 - c2 - c3;

                var minMax3List = GetMaxAndMinValuesList(stockDataClass.InputValues, upperPeriod);
                var hh3List = minMax3List.Item1;
                var ll3List = minMax3List.Item2;
                var minMax1List = GetMaxAndMinValuesList(stockDataClass.InputValues, hLength);
                var hh1List = minMax1List.Item1;
                var ll1List = minMax1List.Item2;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal hh3 = hh3List.ElementAtOrDefault(i);
                    decimal ll3 = ll3List.ElementAtOrDefault(i);
                    decimal hh1 = hh1List.ElementAtOrDefault(i);
                    decimal ll1 = ll1List.ElementAtOrDefault(i);
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal priorValue = i >= hLength ? stockDataClass.InputValues.ElementAtOrDefault(i - hLength) : currentValue;
                    decimal prevSmoothHurst1 = i >= 1 ? smoothHurstList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevSmoothHurst2 = i >= 2 ? smoothHurstList.ElementAtOrDefault(i - 2) : 0;

                    decimal n3 = (hh3 - ll3) / upperPeriod;
                    n3List.Add(n3);

                    decimal n1 = (hh1 - ll1) / hLength;
                    n1List.Add(n1);

                    decimal hh2 = i >= hLength ? priorValue : currentValue;
                    decimal ll2 = i >= hLength ? priorValue : currentValue;
                    for (int j = hLength; j < upperPeriod; j++)
                    {
                        decimal price = i >= j ? stockDataClass.InputValues.ElementAtOrDefault(i - j) : 0;
                        hh2 = price > hh2 ? price : hh2;
                        ll2 = price < ll2 ? price : ll2;
                    }

                    decimal n2 = (hh2 - ll2) / hLength;
                    n2List.Add(n2);

                    decimal prevDimen = dimenList.LastOrDefault();
                    decimal dimen = n1 > 0 && n2 > 0 && n3 > 0 ? 0.5m * (((Log(n1 + n2) - Log(n3)) / Log((double)2)) + prevDimen) : 0;
                    dimenList.Add(dimen);

                    decimal prevHurst = hurstList.LastOrDefault();
                    decimal hurst = 2 - dimen;
                    hurstList.Add(hurst);

                    decimal smoothHurst = (c1 * ((hurst + prevHurst) / 2)) + (c2 * prevSmoothHurst1) + (c3 * prevSmoothHurst2);
                    smoothHurstList.Add(smoothHurst);

                    var signal = GetCompareSignal(smoothHurst - prevSmoothHurst1, prevSmoothHurst1 - prevSmoothHurst2);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (n1List, n2List, n3List, dimenList, hurstList, smoothHurstList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateEhlersReflexIndicator(StockData stockDataClass, int days = 20)
        {
            //{
            //Reflex Indicator
            //(C) 2019 John F. Ehlers
            //}
            //Inputs:
            //Length(20);
            //Vars:
            //Slope(0),sum(0),count(0),a1(0), b1(0), c1(0), c2(0), c3(0), Filt(0),MS(0),Reflex(0);
            //Gently smooth the data in a SuperSmoother
            //a1 = expvalue(-1.414 * 3.14159 / (.5 * Length));
            //b1 = 2 * a1 * Cosine(1.414 * 180 / (.5 * Length));
            //c2 = b1;
            //c3 = -a1 * a1;
            //c1 = 1 - c2 - c3;
            //Filt = c1 * (Close + Close[1]) / 2 + c2 * Filt[1] + c3 * Filt[2];
            //Length is assumed cycle period
            //Slope = (Filt[Length] - Filt) / Length;
            //Sum the differences
            //Sum = 0;
            //For count = 1 to Length Begin
            //Sum = Sum + (Filt + count * Slope) - Filt[count];
            //End;
            //Sum = Sum / Length;
            //Normalize in terms of Standard Deviations
            //MS = .04 * Sum * Sum + .96 * MS[1];
            //If MS<> 0 Then Reflex = Sum / SquareRoot(MS);
            //Plot1(Reflex);
            //Plot2(0);
            List<Signal> signalsList = new();
            List<decimal> filterList = new();
            List<decimal> slopeList = new();
            List<decimal> sumList = new();
            List<decimal> msList = new();
            List<decimal> reflexList = new();
            List<decimal> reflexSignalList = new();

            try
            {
                int signalPeriod = MinOrMax((int)Math.Ceiling((decimal)days / 2));
                decimal a1 = Exp(-1.414 * Math.PI / (0.5 * days));
                decimal b1 = 2 * a1 * Cos(1.414 * Math.PI / (0.5 * days));
                decimal c2 = b1;
                decimal c3 = -a1 * a1;
                decimal c1 = 1 - c2 - c3;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevFilter1 = filterList.LastOrDefault();
                    decimal prevFilter2 = i >= 2 ? filterList.ElementAtOrDefault(i - 2) : 0;
                    decimal priorFilter = i >= days ? filterList.ElementAtOrDefault(i - days) : 0;

                    decimal filter = (c1 * ((currentValue + prevValue) / 2)) + (c2 * prevFilter1) + (c3 * prevFilter2);
                    filterList.Add(filter);

                    decimal slope = days != 0 ? (priorFilter - filter) / days : 0;
                    slopeList.Add(slope);

                    decimal sum = 0;
                    for (int j = 1; j <= days; j++)
                    {
                        decimal prevFilterCount = i >= j ? filterList.ElementAtOrDefault(i - j) : 0;
                        sum += filter + (j * slope) - prevFilterCount;
                    }
                    sum /= days;
                    sumList.Add(sum);

                    decimal prevMs = msList.LastOrDefault();
                    decimal ms = (0.04m * sum * sum) + (0.96m * prevMs);
                    msList.Add(ms);

                    decimal prevReflex = reflexList.LastOrDefault();
                    decimal reflex = ms > 0 ? sum / Sqrt(ms) : 0;
                    reflexList.Add(reflex);

                    decimal prevReflexSignal = reflexSignalList.LastOrDefault();
                    decimal reflexSignal = reflexList.TakeLast(signalPeriod).Average();
                    reflexSignalList.Add(reflexSignal);

                    var signal = GetCompareSignal(reflex - reflexSignal, prevReflex - prevReflexSignal);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (filterList, slopeList, sumList, msList, reflexList, reflexSignalList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<decimal>, List<Signal>) CalculateEhlersSpectrumDerivedFilterBank(StockData stockDataClass, int days = 8)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Ehlers Spectrum Derived Filter Bank script may be freely distributed under the MIT license.
            //study("Ehlers Spectrum Derived Filter Bank", shorttitle = "SDFB", overlay = false)

            //minPeriod = input(title = "MinPeriod", type = input.integer, defval = 8, minval = 1)
            //maxPeriod = input(title = "MaxPeriod", type = input.integer, defval = 50, minval = 1)
            //hpPeriod = input(title = "HpPeriod", type = input.integer, defval = 40, minval = 1)
            //medianPeriod = input(title = "MedianPeriod", type = input.integer, defval = 10, minval = 1)

            //src = input(title = "Source", type = input.source, defval = hl2)

            //pi = 2 * asin(1)
            //alpha1 = (1 - sin(2 * pi / hpPeriod)) / cos(2 * pi / hpPeriod)
            //hp = 0.0
            //hp:= bar_index < 7 ? src : (0.5 * (1 + alpha1) * (src - src[1])) + (alpha1 * hp[1])
            //smoothHp = bar_index < 7 ? src - src[1] : (hp + (2 * hp[1]) + (3 * hp[2]) + (3 * hp[3]) + (2 * hp[4]) + hp[5]) / 12
            //delta = (-0.015 * bar_index) + 0.5
            //delta:= delta < 0.15 ? 0.15 : delta

            //ampl = 0.0, num = 0.0, denom = 0.0, dc = 0.0, real = 0.0, imag = 0.0, db = 0.0, q1 = 0.0, maxAmpl = ampl[10]
            //for n = minPeriod to maxPeriod
            //    beta = cos(2 * pi / n)
            //    gamma = 1 / cos(4 * pi * delta / n)
            //    alpha = gamma - sqrt((gamma * gamma) - 1)
            //    q1 := (n / 6.283185) * (smoothHp - smoothHp[1])
            //    real := (0.5 * (1 - alpha) * (smoothHp - nz(smoothHp[n]))) + (beta * (1 + alpha) * nz(real[n])) - (alpha * nz(real[n + n]))
            //    imag := (0.5 * (1 - alpha) * (q1 - nz(q1[n]))) + (beta * (1 + alpha) * nz(imag[n])) - (alpha * nz(imag[n + n]))
            //    ampl := (real * real) + (imag * imag)
            //    maxAmpl := ampl > maxAmpl ? ampl : maxAmpl
            //    db := maxAmpl != 0 and ampl / maxAmpl > 0 ? -10 * log(0.01 / (1 - ((0.99 * ampl) / maxAmpl))) / log(10) : 0
            //    db := db > 20 ? 20 : db

            //    if db <= 3
            //        num:= num + (n * (20 - db))
            //        denom:= denom + (20 - db)
            //    dc:= num / denom
            //domCyc = percentile_nearest_rank(dc, medianPeriod, 50)

            //plot(domCyc, title = "DC", color = color.blue, linewidth = 2)
            //hpColor = smoothHp > 0 ? color.green : smoothHp < 0 ? color.red : color.black
            //plot(smoothHp, title = "Hp", color = hpColor, linewidth = 2)
            List<decimal> dbList = new();
            List<decimal> numList = new();
            List<decimal> denomList = new();
            List<decimal> dcList = new();
            List<decimal> domCycList = new();
            List<decimal> realList = new();
            List<decimal> imagList = new();
            List<decimal> amplList = new();
            List<decimal> maxAmplList = new();
            List<decimal> q1List = new();
            List<decimal> hpList = new();
            List<decimal> smoothHpList = new();
            List<Signal> signalsList = new();

            try
            {
                int medianPeriod = (int)Math.Ceiling(days / 0.8);
                int maxDbPeriod = medianPeriod * 2;
                int maxPeriod = medianPeriod * 5;
                int hpPeriod = medianPeriod * 4;
                double twoPiPer = MinOrMax(2 * Math.PI / hpPeriod, 0.99, 0.01);
                decimal alpha1 = (1 - Sin(twoPiPer)) / Cos(twoPiPer);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal delta = (-0.015m * i) + 0.5m;
                    delta = delta < 0.15m ? 0.15m : delta;
                    decimal prevHp1 = i >= 1 ? hpList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevHp2 = i >= 2 ? hpList.ElementAtOrDefault(i - 2) : 0;
                    decimal prevHp3 = i >= 3 ? hpList.ElementAtOrDefault(i - 3) : 0;
                    decimal prevHp4 = i >= 4 ? hpList.ElementAtOrDefault(i - 4) : 0;
                    decimal prevHp5 = i >= 5 ? hpList.ElementAtOrDefault(i - 5) : 0;

                    decimal hp = i < 7 ? currentValue : (0.5m * (1 + alpha1) * (currentValue - prevValue)) + (alpha1 * prevHp1);
                    hpList.Add(hp);

                    decimal prevSmoothHp = smoothHpList.LastOrDefault();
                    decimal smoothHp = i < 7 ? currentValue - prevValue : (hp + (2 * prevHp1) + (3 * prevHp2) + (3 * prevHp3) + (2 * prevHp4) + prevHp5) / 12;
                    smoothHpList.Add(smoothHp);

                    decimal ampl = 0, num = 0, denom = 0, dc = 0, real = 0, imag = 0, db = 0, q1 = 0, maxAmpl = 0;
                    for (int j = days; j <= maxPeriod; j++)
                    {
                        decimal beta = Cos(MinOrMax(2 * Math.PI / j, 0.99, 0.01));
                        decimal gamma = 1 / Cos(MinOrMax(4 * Math.PI * (double)delta / j, 0.99, 0.01));
                        decimal alpha = gamma - Sqrt((gamma * gamma) - 1);
                        decimal priorSmoothHp = i >= j ? smoothHpList.ElementAtOrDefault(i - j) : 0;
                        decimal prevReal = i >= j ? realList.ElementAtOrDefault(i - j) : 0;
                        decimal priorReal = i >= j * 2 ? realList.ElementAtOrDefault(i - (j * 2)) : 0;
                        decimal prevImag = i >= j ? imagList.ElementAtOrDefault(i - j) : 0;
                        decimal priorImag = i >= j * 2 ? imagList.ElementAtOrDefault(i - (j * 2)) : 0;
                        decimal prevQ1 = i >= j ? q1List.ElementAtOrDefault(i - j) : 0;

                        q1 = (j / 6.283185m) * (smoothHp - prevSmoothHp);
                        real = (0.5m * (1 - alpha) * (smoothHp - priorSmoothHp)) + (beta * (1 + alpha) * prevReal) - (alpha * priorReal);
                        imag = (0.5m * (1 - alpha) * (q1 - prevQ1)) + (beta * (1 + alpha) * prevImag) - (alpha * priorImag);
                        ampl = (real * real) + (imag * imag);
                        maxAmpl = ampl > maxAmpl ? ampl : maxAmpl;
                        db = maxAmpl != 0 && ampl / maxAmpl > 0 ? -medianPeriod * Log(0.01m / (1 - (0.99m * ampl / maxAmpl))) / Log((double)medianPeriod) : 0;
                        db = db > maxDbPeriod ? maxDbPeriod : db;
                        num += db <= 3 ? j * (maxDbPeriod - db) : 0;
                        denom += db <= 3 ? maxDbPeriod - db : 0;
                        dc = denom != 0 ? num / denom : 0;
                    }
                    q1List.Add(q1);
                    realList.Add(real);
                    imagList.Add(imag);
                    amplList.Add(ampl);
                    maxAmplList.Add(maxAmpl);
                    dbList.Add(db);
                    numList.Add(num);
                    denomList.Add(denom);
                    dcList.Add(dc);

                    decimal domCyc = Median(dcList.TakeLast(medianPeriod));
                    domCyc = domCyc < days ? maxDbPeriod : domCyc;
                    domCycList.Add(domCyc);

                    var signal = GetCompareSignal(smoothHp, prevSmoothHp);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (hpList, smoothHpList, q1List, realList, imagList, amplList, maxAmplList, dbList, numList, denomList, dcList, domCycList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateEhlersDominantCycleTunedBypassFilter(StockData stockDataClass, int days = 8)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Ehlers Dominant Cycle Tuned Bypass Filter script may be freely distributed under the MIT license.
            //study("Ehlers Dominant Cycle Tuned Bypass Filter", shorttitle = "DCTBF", overlay = false)

            //minPeriod = input(title = "MinPeriod", type = input.integer, defval = 8, minval = 1)
            //maxPeriod = input(title = "MaxPeriod", type = input.integer, defval = 50, minval = 1)
            //hpPeriod = input(title = "HpPeriod", type = input.integer, defval = 40, minval = 1)
            //medianPeriod = input(title = "MedianPeriod", type = input.integer, defval = 10, minval = 1)

            //src = input(title = "Source", type = input.source, defval = hl2)

            //pi = 2 * asin(1)
            //alpha1 = (1 - sin(2 * pi / hpPeriod)) / cos(2 * pi / hpPeriod)
            //hp = 0.0
            //hp:= bar_index < 7 ? src : (0.5 * (1 + alpha1) * (src - src[1])) + (alpha1 * hp[1])
            //smoothHp = bar_index < 7 ? src - src[1] : (hp + (2 * hp[1]) + (3 * hp[2]) + (3 * hp[3]) + (2 * hp[4]) + hp[5]) / 12
            //delta = (-0.015 * bar_index) + 0.5
            //delta:= delta < 0.15 ? 0.15 : delta

            //ampl = 0.0, real = 0.0, imag = 0.0, db = 0.0, q1 = 0.0, num = 0.0, denom = 0.0, dc = 0.0, maxAmpl = ampl[10]
            //for n = minPeriod to maxPeriod
            //    beta = cos(2 * pi / n)
            //    gamma = 1 / cos(4 * pi * delta / n)
            //    alpha = gamma - sqrt((gamma * gamma) - 1)
            //    q1 := (n / 6.283185) * (smoothHp - nz(smoothHp[1]))
            //    real := (0.5 * (1 - alpha) * (smoothHp - nz(smoothHp[n]))) + (beta * (1 + alpha) * nz(real[n])) - (alpha * nz(real[n + n]))
            //    imag := (0.5 * (1 - alpha) * (q1 - nz(q1[n]))) + (beta * (1 + alpha) * nz(imag[n])) - (alpha * nz(imag[n + n]))
            //    ampl := (real * real) + (imag * imag)
            //    maxAmpl := ampl > maxAmpl ? ampl : maxAmpl
            //    db := maxAmpl != 0 and ampl / maxAmpl > 0 ? -10 * log(0.01 / (1 - ((0.99 * ampl) / maxAmpl))) / log(10) : 0
            //    db := db > 20 ? 20 : db


            //    if db <= 3
            //        num:= num + (n * (20 - db))
            //        denom:= denom + (20 - db)
            //    dc:= num / denom
            //domCyc = percentile_nearest_rank(dc, medianPeriod, 50)
            //domCyc:= domCyc < 8 ? 20 : domCyc

            //beta = cos(2 * pi / domCyc)
            //gamma = 1 / cos(4 * pi * delta / domCyc)
            //alpha = gamma - sqrt((gamma * gamma) - 1)
            //v1 = 0.0
            //v1:= (0.5 * (1 - alpha) * (smoothHp - nz(smoothHp[1]))) + (beta * (1 + alpha) * nz(v1[1])) - (alpha * nz(v1[2]))
            //v2 = (domCyc / 6.28) * (v1 - nz(v1[1]))

            //plot(v1, title = "V1", color = color.red, linewidth = 2)
            //plot(v2, title = "V2", color = color.blue, linewidth = 2)
            List<decimal> v1List = new();
            List<decimal> v2List = new();
            List<Signal> signalsList = new();

            try
            {
                var list = CalculateEhlersSpectrumDerivedFilterBank(stockDataClass, days);
                var smoothHpList = list.Item2;
                var domCycList = list.Item12;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal domCyc = domCycList.ElementAtOrDefault(i);
                    decimal beta = Cos(MinOrMax(2 * Math.PI / (double)domCyc, 0.99, 0.01));
                    decimal delta = (-0.015m * i) + 0.5m;
                    delta = delta < 0.15m ? 0.15m : delta;
                    decimal gamma = 1 / Cos(MinOrMax(4 * Math.PI * (double)(delta / domCyc), 0.99, 0.01));
                    decimal alpha = gamma - Sqrt((gamma * gamma) - 1);
                    decimal smoothHp = smoothHpList.ElementAtOrDefault(i);
                    decimal prevSmoothHp = i >= 1 ? smoothHpList.ElementAtOrDefault(i - 1) : 0;

                    decimal prevV1 = i >= 1 ? v1List.ElementAtOrDefault(i - 1) : 0;
                    decimal prevV1_2 = i >= 2 ? v1List.ElementAtOrDefault(i - 2) : 0;
                    decimal v1 = (0.5m * (1 - alpha) * (smoothHp - prevSmoothHp)) + (beta * (1 + alpha) * prevV1) - (alpha * prevV1_2);
                    v1List.Add(v1);

                    decimal v2 = (domCyc / 6.28m) * (v1 - prevV1);
                    v2List.Add(v2);

                    var signal = GetConditionSignal(v2 > v1 && v2 >= 0, v2 < v1 || v2 < 0);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (v1List, v2List, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateEhlersRestoringPullIndicator(StockData stockDataClass, int days = 8)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Ehlers Restoring Pull Indicator script may be freely distributed under the MIT license.
            //study("Ehlers Restoring Pull Indicator", shorttitle = "RPI", overlay = false)

            //minPeriod = input(title = "MinPeriod", type = input.integer, defval = 8, minval = 1)
            //maxPeriod = input(title = "MaxPeriod", type = input.integer, defval = 50, minval = 1)
            //hpPeriod = input(title = "HpPeriod", type = input.integer, defval = 40, minval = 1)
            //medianPeriod = input(title = "MedianPeriod", type = input.integer, defval = 10, minval = 1)

            //src = input(title = "Source", type = input.source, defval = hl2)

            //pi = 2 * asin(1)
            //alpha1 = (1 - sin(2 * pi / hpPeriod)) / cos(2 * pi / hpPeriod)
            //hp = 0.0
            //hp:= bar_index < 7 ? src : (0.5 * (1 + alpha1) * (src - src[1])) + (alpha1 * hp[1])
            //smoothHp = bar_index < 7 ? src - src[1] : (hp + (2 * hp[1]) + (3 * hp[2]) + (3 * hp[3]) + (2 * hp[4]) + hp[5]) / 12
            //delta = (-0.015 * bar_index) + 0.5
            //delta:= delta < 0.15 ? 0.15 : delta

            //ampl = 0.0, num = 0.0, denom = 0.0, dc = 0.0, real = 0.0, imag = 0.0, db = 0.0, q1 = 0.0, maxAmpl = ampl[medianPeriod]
            //for n = minPeriod to maxPeriod
            //    beta = cos(2 * pi / n)
            //    gamma = 1 / cos(4 * pi * delta / n)
            //    alpha = gamma - sqrt((gamma * gamma) - 1)
            //    q1 := (n / 6.283185) * (smoothHp - smoothHp[1])
            //    real := (0.5 * (1 - alpha) * (smoothHp - nz(smoothHp[n]))) + (beta * (1 + alpha) * nz(real[n])) - (alpha * nz(real[n + n]))
            //    imag := (0.5 * (1 - alpha) * (q1 - nz(q1[n]))) + (beta * (1 + alpha) * nz(imag[n])) - (alpha * nz(imag[n + n]))
            //    ampl := (real * real) + (imag * imag)
            //    maxAmpl := ampl > maxAmpl ? ampl : maxAmpl
            //    db := maxAmpl != 0 and ampl / maxAmpl > 0 ? -10 * log(0.01 / (1 - ((0.99 * ampl) / maxAmpl))) / log(10) : 0
            //    db := db > 20 ? 20 : db

            //    if db <= 3
            //        num:= num + (n * (20 - db))
            //        denom:= denom + (20 - db)
            //    dc:= num / denom

            //domCyc = percentile_nearest_rank(dc, medianPeriod, 50)
            //rpi = volume * pow(2 * pi / domCyc, 2)
            //sig = ema(rpi, minPeriod)

            //rpiColor = rpi < sig ? color.green : rpi > sig ? color.red : color.black
            //plot(rpi, title = "RPI", color = rpiColor, linewidth = 2)
            //plot(sig, title = "Signal", color = color.black, linewidth = 1)
            List<decimal> rpiList = new();
            List<decimal> rpiEmaList = new();
            List<Signal> signalsList = new();

            try
            {
                var domCycList = CalculateEhlersSpectrumDerivedFilterBank(stockDataClass, days).Item12;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal domCyc = domCycList.ElementAtOrDefault(i);
                    decimal volume = stockDataClass.Volumes.ElementAtOrDefault(i);

                    decimal prevRpi = rpiList.LastOrDefault();
                    decimal rpi = volume * Pow(MinOrMax(2 * (decimal)Math.PI / domCyc, 0.99m, 0.01m), 2);
                    rpiList.Add(rpi);

                    decimal prevRpiEma = rpiEmaList.LastOrDefault();
                    decimal rpiEma = CalculateExponentialMovingAverage(rpi, rpiEmaList.LastOrDefault(), days);
                    rpiEmaList.Add(rpiEma);

                    var signal = GetCompareSignal(rpi - rpiEma, prevRpi - prevRpiEma, true);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (rpiList, rpiEmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateEhlersTrendflexIndicator(StockData stockDataClass, int days = 20)
        {
            //{
            //Trendflex Indicator
            //(C) 2019 John F. Ehlers
            //}
            //Inputs:
            //Length(20);
            //Vars:
            //sum(0),count(0),a1(0), b1(0), c1(0), c2(0), c3(0), Filt(0),MS(0),Trendflex(0);
            //Gently smooth the data in a SuperSmoother
            //a1 = expvalue(-1.414 * 3.14159 / (.5 * Length));
            //b1 = 2 * a1 * Cosine(1.414 * 180 / (.5 * Length));
            //c2 = b1;
            //c3 = -a1 * a1;
            //c1 = 1 - c2 - c3;
            //Filt = c1 * (Close + Close[1]) / 2 + c2 * Filt[1] + c3 * Filt[2];
            //Sum the differences
            //Sum = 0;
            //For count = 1 to Length Begin
            //Sum = Sum + Filt - Filt[count];
            //End;
            //Sum = Sum / Length;
            //Normalize in terms of Standard Deviations
            //MS = .04 * Sum * Sum + .96 * MS[1];
            //If MS<> 0 Then Trendflex = Sum / SquareRoot(MS);
            //Plot1(Trendflex);
            //Plot2(0);
            List<Signal> signalsList = new();
            List<decimal> sumList = new();
            List<decimal> msList = new();
            List<decimal> trendflexList = new();

            try
            {
                var filterList = CalculateEhlersReflexIndicator(stockDataClass, days).Item1;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal filter = filterList.ElementAtOrDefault(i);

                    decimal sum = 0;
                    for (int j = 1; j <= days; j++)
                    {
                        decimal prevFilterCount = i >= j ? filterList.ElementAtOrDefault(i - j) : 0;
                        sum += filter - prevFilterCount;
                    }
                    sum /= days;
                    sumList.Add(sum);

                    decimal prevMs = msList.LastOrDefault();
                    decimal ms = (0.04m * sum * sum) + (0.96m * prevMs);
                    msList.Add(ms);

                    decimal prevTrendflex = trendflexList.LastOrDefault();
                    decimal trendflex = ms > 0 ? sum / Sqrt(ms) : 0;
                    trendflexList.Add(trendflex);

                    var signal = GetCompareSignal(trendflex, prevTrendflex);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (sumList, msList, trendflexList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<Signal>) CalculateEhlersCorrelationCycleIndicator(StockData stockDataClass, int days = 20)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Ehlers Correlation Angle Indicator script may be freely distributed under the MIT license.
            //study("Ehlers Correlation Angle Indicator", shorttitle = "ECAI", overlay = false)

            //indicator = input("Correlation Cycle", "Select Indicator", input.string, options =["Correlation Cycle", "Correlation Angle", "Market State"])
            //length = input(title = "Length", type = input.integer, defval = 20, minval = 1)
            //src = input(title = "Source", type = input.source, defval = close)
            //var showcc = indicator == "Correlation Cycle"
            //var showca = indicator == "Correlation Angle"
            //var showms = indicator == "Market State"

            //pi = 2 * asin(1)
            //sx = 0.0, sy = 0.0, sxx = 0.0, syy = 0.0, sxy = 0.0, nsy = 0.0, nsyy = 0.0, nsxy = 0.0
            //for i = 1 to length
            //    x = nz(src[i - 1])
            //    y = cos(2 * pi * (i - 1) / length)
            //    ny = -sin(2 * pi * (i - 1) / length)

            //    sx := sx + x
            //    sy := sy + y
            //    nsy := nsy + ny
            //    sxx := sxx + (x * x)
            //    syy := syy + (y * y)
            //    nsyy := nsyy + (ny * ny)
            //    sxy := sxy + (x * y)
            //    nsxy := nsxy + (x * ny)
            //real = (length * sxx) - (sx * sx) > 0 and(length * syy) - (sy * sy) > 0 ? ((length * sxy) - (sx * sy)) /
            //     sqrt(((length * sxx) - (sx * sx)) * ((length * syy) - (sy * sy))) : 0
            //imag = (length * sxx) - (sx * sx) > 0 and(length * nsyy) - (nsy * nsy) > 0 ? ((length * nsxy) - (sx * nsy)) /
            //     sqrt(((length * sxx) - (sx * sx)) * ((length * nsyy) - (nsy * nsy))) : 0

            //angle = 0.0
            //angle := imag != 0 ? 90 + (180 / pi * atan(real / imag)) : 90
            //angle := imag > 0 ? angle - 180 : angle
            //angle := angle[1] - angle < 270 and angle < angle[1] ? angle[1] : angle
            //state = abs(angle - angle[1]) < 9 and angle < 0 ? -1 : abs(angle - angle[1]) < 9 and angle >= 0 ? 1 : 0

            //angleColor = angle > 0 ? color.green : angle < 0 ? color.red : color.black
            //plot(showca ? angle : na, title = "ANGL", linewidth = 2, color = angleColor)
            //riColor = real > imag ? color.green : real < imag ? color.red : color.black
            //plot(showcc ? real : na, title = "REAL", linewidth = 2, color = riColor)
            //plot(showcc ? imag : na, title = "IMAG", linewidth = 1, color = color.black)
            //stateColor = state > 0 ? color.green : state < 0 ? color.red : color.black
            //plot(showms ? state : na, title = "MS", linewidth = 2, color = stateColor)
            List<decimal> sxList = new();
            List<decimal> syList = new();
            List<decimal> sxxList = new();
            List<decimal> syyList = new();
            List<decimal> sxyList = new();
            List<decimal> nsyList = new();
            List<decimal> nsyyList = new();
            List<decimal> nsxyList = new();
            List<decimal> yList = new();
            List<decimal> nyList = new();
            List<decimal> realList = new();
            List<decimal> imagList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal y = 0, ny = 0, sx = 0, sy = 0, nsy = 0, sxx = 0, syy = 0, nsyy = 0, sxy = 0, nsxy = 0;
                    for (int j = 1; j <= days; j++)
                    {
                        decimal x = i >= j - 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - (j - 1)) : 0;
                        decimal v = (decimal)MinOrMax(2 * Math.PI * (j - 1) / days, 0.99, 0.01);

                        y = Cos(v);
                        ny = -Sin(v);
                        sx += x;
                        sy += y;
                        nsy += ny;
                        sxx += x * x;
                        syy += y * y;
                        nsyy += ny * ny;
                        sxy += x * y;
                        nsxy += x * ny;
                    }
                    yList.Add(y);
                    nyList.Add(ny);
                    sxList.Add(sx);
                    syList.Add(sy);
                    nsyList.Add(nsy);
                    sxxList.Add(sxx);
                    syyList.Add(syy);
                    nsyyList.Add(nsyy);
                    sxyList.Add(sxy);
                    nsxyList.Add(nsxy);

                    decimal prevReal = realList.LastOrDefault();
                    decimal real = (days * sxx) - (sx * sx) > 0 && (days * syy) - (sy * sy) > 0 ? ((days * sxy) - (sx * sy)) /
                           Sqrt(((days * sxx) - (sx * sx)) * ((days * syy) - (sy * sy))) : 0;
                    realList.Add(real);

                    decimal prevImag = imagList.LastOrDefault();
                    decimal imag = (days * sxx) - (sx * sx) > 0 && (days * nsyy) - (nsy * nsy) > 0 ? ((days * nsxy) - (sx * nsy)) /
                           Sqrt(((days * sxx) - (sx * sx)) * ((days * nsyy) - (nsy * nsy))) : 0;
                    imagList.Add(imag);

                    var signal = GetCompareSignal(real - imag, prevReal - prevImag);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (yList, nyList, syList, nsyList, sxxList, syyList, nsyyList, sxyList, nsxyList, realList, imagList, signalsList);
        }

        public static (List<decimal>, List<Signal>) CalculateEhlersCorrelationAngleIndicator(StockData stockDataClass, int days = 20)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Ehlers Correlation Angle Indicator script may be freely distributed under the MIT license.
            //study("Ehlers Correlation Angle Indicator", shorttitle = "ECAI", overlay = false)

            //indicator = input("Correlation Cycle", "Select Indicator", input.string, options =["Correlation Cycle", "Correlation Angle", "Market State"])
            //length = input(title = "Length", type = input.integer, defval = 20, minval = 1)
            //src = input(title = "Source", type = input.source, defval = close)
            //var showcc = indicator == "Correlation Cycle"
            //var showca = indicator == "Correlation Angle"
            //var showms = indicator == "Market State"

            //pi = 2 * asin(1)
            //sx = 0.0, sy = 0.0, sxx = 0.0, syy = 0.0, sxy = 0.0, nsy = 0.0, nsyy = 0.0, nsxy = 0.0
            //for i = 1 to length
            //    x = nz(src[i - 1])
            //    y = cos(2 * pi * (i - 1) / length)
            //    ny = -sin(2 * pi * (i - 1) / length)

            //    sx := sx + x
            //    sy := sy + y
            //    nsy := nsy + ny
            //    sxx := sxx + (x * x)
            //    syy := syy + (y * y)
            //    nsyy := nsyy + (ny * ny)
            //    sxy := sxy + (x * y)
            //    nsxy := nsxy + (x * ny)
            //real = (length * sxx) - (sx * sx) > 0 and(length * syy) - (sy * sy) > 0 ? ((length * sxy) - (sx * sy)) /
            //     sqrt(((length * sxx) - (sx * sx)) * ((length * syy) - (sy * sy))) : 0
            //imag = (length * sxx) - (sx * sx) > 0 and(length * nsyy) - (nsy * nsy) > 0 ? ((length * nsxy) - (sx * nsy)) /
            //     sqrt(((length * sxx) - (sx * sx)) * ((length * nsyy) - (nsy * nsy))) : 0

            //angle = 0.0
            //angle := imag != 0 ? 90 + (180 / pi * atan(real / imag)) : 90
            //angle := imag > 0 ? angle - 180 : angle
            //angle := angle[1] - angle < 270 and angle < angle[1] ? angle[1] : angle
            //state = abs(angle - angle[1]) < 9 and angle < 0 ? -1 : abs(angle - angle[1]) < 9 and angle >= 0 ? 1 : 0

            //angleColor = angle > 0 ? color.green : angle < 0 ? color.red : color.black
            //plot(showca ? angle : na, title = "ANGL", linewidth = 2, color = angleColor)
            //riColor = real > imag ? color.green : real < imag ? color.red : color.black
            //plot(showcc ? real : na, title = "REAL", linewidth = 2, color = riColor)
            //plot(showcc ? imag : na, title = "IMAG", linewidth = 1, color = color.black)
            //stateColor = state > 0 ? color.green : state < 0 ? color.red : color.black
            //plot(showms ? state : na, title = "MS", linewidth = 2, color = stateColor)
            List<decimal> angleList = new();
            List<Signal> signalsList = new();

            try
            {
                var list = CalculateEhlersCorrelationCycleIndicator(stockDataClass, days);
                var realList = list.Item10;
                var imagList = list.Item11;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal real = realList.ElementAtOrDefault(i);
                    decimal imag = imagList.ElementAtOrDefault(i);

                    decimal prevAngle = i >= 1 ? angleList.ElementAtOrDefault(i - 1) : 0;
                    decimal angle = imag != 0 ? 90 + (180 / (decimal)Math.PI * Atan(real / imag)) : 90;
                    angle = imag > 0 ? angle - 180 : angle;
                    angle = prevAngle - angle < 270 && angle < prevAngle ? prevAngle : angle;
                    angleList.Add(angle);

                    var signal = GetCompareSignal(angle, prevAngle);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (angleList, signalsList);
        }

        public static (List<decimal>, List<Signal>) CalculateEhlersMarketStateIndicator(StockData stockDataClass, int days = 20)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Ehlers Correlation Angle Indicator script may be freely distributed under the MIT license.
            //study("Ehlers Correlation Angle Indicator", shorttitle = "ECAI", overlay = false)

            //indicator = input("Correlation Cycle", "Select Indicator", input.string, options =["Correlation Cycle", "Correlation Angle", "Market State"])
            //length = input(title = "Length", type = input.integer, defval = 20, minval = 1)
            //src = input(title = "Source", type = input.source, defval = close)
            //var showcc = indicator == "Correlation Cycle"
            //var showca = indicator == "Correlation Angle"
            //var showms = indicator == "Market State"

            //pi = 2 * asin(1)
            //sx = 0.0, sy = 0.0, sxx = 0.0, syy = 0.0, sxy = 0.0, nsy = 0.0, nsyy = 0.0, nsxy = 0.0
            //for i = 1 to length
            //    x = nz(src[i - 1])
            //    y = cos(2 * pi * (i - 1) / length)
            //    ny = -sin(2 * pi * (i - 1) / length)

            //    sx := sx + x
            //    sy := sy + y
            //    nsy := nsy + ny
            //    sxx := sxx + (x * x)
            //    syy := syy + (y * y)
            //    nsyy := nsyy + (ny * ny)
            //    sxy := sxy + (x * y)
            //    nsxy := nsxy + (x * ny)
            //real = (length * sxx) - (sx * sx) > 0 and(length * syy) - (sy * sy) > 0 ? ((length * sxy) - (sx * sy)) /
            //     sqrt(((length * sxx) - (sx * sx)) * ((length * syy) - (sy * sy))) : 0
            //imag = (length * sxx) - (sx * sx) > 0 and(length * nsyy) - (nsy * nsy) > 0 ? ((length * nsxy) - (sx * nsy)) /
            //     sqrt(((length * sxx) - (sx * sx)) * ((length * nsyy) - (nsy * nsy))) : 0

            //angle = 0.0
            //angle := imag != 0 ? 90 + (180 / pi * atan(real / imag)) : 90
            //angle := imag > 0 ? angle - 180 : angle
            //angle := angle[1] - angle < 270 and angle < angle[1] ? angle[1] : angle
            //state = abs(angle - angle[1]) < 9 and angle < 0 ? -1 : abs(angle - angle[1]) < 9 and angle >= 0 ? 1 : 0

            //angleColor = angle > 0 ? color.green : angle < 0 ? color.red : color.black
            //plot(showca ? angle : na, title = "ANGL", linewidth = 2, color = angleColor)
            //riColor = real > imag ? color.green : real < imag ? color.red : color.black
            //plot(showcc ? real : na, title = "REAL", linewidth = 2, color = riColor)
            //plot(showcc ? imag : na, title = "IMAG", linewidth = 1, color = color.black)
            //stateColor = state > 0 ? color.green : state < 0 ? color.red : color.black
            //plot(showms ? state : na, title = "MS", linewidth = 2, color = stateColor)
            List<decimal> stateList = new();
            List<Signal> signalsList = new();

            try
            {
                var angleList = CalculateEhlersCorrelationAngleIndicator(stockDataClass, days).Item1;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal angle = angleList.ElementAtOrDefault(i);
                    decimal prevAngle = i >= 1 ? angleList.ElementAtOrDefault(i - 1) : 0;

                    decimal prevState = stateList.LastOrDefault();
                    decimal state = Math.Abs(angle - prevAngle) < 9 && angle < 0 ? -1 : Math.Abs(angle - prevAngle) < 9 && angle >= 0 ? 1 : 0;
                    stateList.Add(state);

                    var signal = GetCompareSignal(state, prevState);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (stateList, signalsList);
        }

        public static (List<decimal>, List<Signal>) CalculateEhlersTrendExtraction(StockData stockDataClass, int days = 20)
        {
            //Inputs:
            //Price((H + L) / 2),
            //Period(20),
            //Delta(.1);
            //Vars:
            //gamma(0),alpha(0),beta(0),BP(0),Trend(0);
            //beta = Cosine(360 / Period);
            //gamma = 1 / Cosine(720 * delta / Period);
            //alpha = gamma - SquareRoot(gamma * gamma - 1);
            //BP = .5 * (1 - alpha) * (Price - Price[2]) + beta * (1 + alpha) * BP[1] - alpha * BP[2];
            //Trend = Average(BP, 2 * Period);
            //Plot1(Trend);
            //Plot2(0);
            List<decimal> trendList = new();
            List<decimal> bpList = new();
            List<Signal> signalsList = new();
            decimal delta = 0.1m;

            try
            {
                decimal beta = Math.Max(Cos(2 * Math.PI / days), 0.99m);
                decimal gamma = 1 / Cos(4 * Math.PI * (double)delta / days);
                decimal alpha = Math.Max(gamma - Sqrt((gamma * gamma) - 1), 0.99m);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue2 = i >= 2 ? stockDataClass.InputValues.ElementAtOrDefault(i - 2) : 0;
                    decimal prevBp1 = i >= 1 ? bpList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevBp2 = i >= 2 ? bpList.ElementAtOrDefault(i - 2) : 0;

                    decimal bp = (0.5m * (1 - alpha) * (currentValue - prevValue2)) + (beta * (1 + alpha) * prevBp1) - (alpha * prevBp2);
                    bpList.Add(bp);

                    decimal prevTrend = trendList.LastOrDefault();
                    decimal trend = bpList.TakeLast(days * 2).Average();
                    trendList.Add(trend);

                    var signal = GetCompareSignal(trend, prevTrend);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (trendList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateEhlersEmpiricalModeDecomposition(
            StockData stockDataClass, int days = 20)
        {
            //@version=2
            ////////////////////////////////////////////////////////////
            //  Copyright by HPotter v1.0 15/10/2014
            // The related article is copyrighted material from Stocks & Commodities Mar 2010
            // You can use in the xPrice any series: Open, High, Low, Close, HL2, HLC3, OHLC4 and ect...
            ////////////////////////////////////////////////////////////
            //study(title = "Empirical Mode Decomposition")
            //Length = input(20, minval = 1)
            //Delta = input(0.5)
            //Fraction = input(0.1)
            //xPrice = hl2
            //beta = cos(3.1415 * (360 / Length) / 180)
            //gamma = 1 / cos(3.1415 * (720 * Delta / Length) / 180)
            //alpha = gamma - sqrt(gamma * gamma - 1)
            //xBandpassFilter = 0.5 * (1 - alpha) * (xPrice - xPrice[2]) + beta * (1 + alpha) * nz(xBandpassFilter[1]) - alpha * nz(xBandpassFilter[2])
            //xMean = sma(xBandpassFilter, 2 * Length)
            //xPeak = iff(xBandpassFilter[1] > xBandpassFilter and xBandpassFilter[1] > xBandpassFilter[2], xBandpassFilter[1], nz(xPeak[1]))
            //xValley = iff(xBandpassFilter[1] < xBandpassFilter and xBandpassFilter[1] < xBandpassFilter[2], xBandpassFilter[1], nz(xValley[1]))
            //xAvrPeak = sma(xPeak, 50)
            //xAvrValley = sma(xValley, 50)
            //nAvrPeak = Fraction * xAvrPeak
            //nAvrValley = Fraction * xAvrValley
            //pos = iff(xMean > nAvrPeak and xMean > nAvrValley, 1,
            //         iff(xMean < nAvrPeak and xMean < nAvrValley, -1, nz(pos[1], 0)))
            //barcolor(pos == -1 ? red : pos == 1 ? green : blue)
            //plot(xMean, color = red, title = "Mean")
            //plot(nAvrPeak, color = blue, title = "Peak")
            //plot(nAvrValley, color = blue, title = "Valley")
            List<Signal> signalsList = new();
            List<decimal> trendList = new();
            List<decimal> bpList = new();
            List<decimal> peakList = new();
            List<decimal> valleyList = new();
            List<decimal> peakAvgList = new();
            List<decimal> valleyAvgList = new();
            List<decimal> peakAvgFracList = new();
            List<decimal> valleyAvgFracList = new();
            decimal delta = 0.5m, fraction = 0.1m;

            try
            {
                decimal beta = MinOrMax(Cos(2 * Math.PI / days), 0.99m, 0.01m);
                decimal gamma = 1 / Cos(4 * (decimal)Math.PI * delta / days);
                decimal alpha = alpha = MinOrMax(gamma - Sqrt((gamma * gamma) - 1), 0.99m, 0.01m);
                int smaLength = (int)Math.Ceiling(days / 0.4);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue2 = i >= 2 ? stockDataClass.InputValues.ElementAtOrDefault(i - 2) : 0;
                    decimal prevBp1 = i >= 1 ? bpList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevBp2 = i >= 2 ? bpList.ElementAtOrDefault(i - 2) : 0;
                    decimal prevPeak = peakList.LastOrDefault();
                    decimal prevValley = valleyList.LastOrDefault();

                    decimal bp = (0.5m * (1 - alpha) * (currentValue - prevValue2)) + (beta * (1 + alpha) * prevBp1) - (alpha * prevBp2);
                    bpList.Add(bp);

                    decimal prevTrend = trendList.LastOrDefault();
                    decimal trend = bpList.TakeLast(days * 2).Average();
                    trendList.Add(trend);

                    decimal peak = prevBp1 > bp && prevBp1 > prevBp2 ? prevBp1 : prevPeak;
                    peakList.Add(peak);

                    decimal valley = prevBp1 < bp && prevBp1 < prevBp2 ? prevBp1 : prevValley;
                    valleyList.Add(valley);

                    decimal peakAvg = peakList.TakeLast(smaLength).Average();
                    peakAvgList.Add(peakAvg);

                    decimal valleyAvg = valleyList.TakeLast(smaLength).Average();
                    valleyAvgList.Add(valleyAvg);

                    decimal prevPeakAvgFrac = peakAvgFracList.LastOrDefault();
                    decimal peakAvgFrac = fraction * peakAvg;
                    peakAvgFracList.Add(peakAvgFrac);

                    decimal prevValleyAvgFrac = valleyAvgFracList.LastOrDefault();
                    decimal valleyAvgFrac = fraction * valleyAvg;
                    valleyAvgFracList.Add(valleyAvgFrac);

                    var signal = GetBullishBearishSignal(trend - Math.Max(peakAvgFrac, valleyAvgFrac), prevTrend - Math.Max(prevPeakAvgFrac, prevValleyAvgFrac),
                        trend - Math.Min(peakAvgFrac, valleyAvgFrac), prevTrend - Math.Min(prevPeakAvgFrac, prevValleyAvgFrac));
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (bpList, trendList, peakList, valleyList, peakAvgList, valleyAvgList, peakAvgFracList, valleyAvgFracList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateEhlersRoofingFilterV2(StockData stockDataClass, string maType, int days = 10)
        {
            //highpassLength = input(title = "High-Pass Filter Length", type = integer, defval = 48)
            //ssfLength = input(title = "Super Smoother Filter Length", type = integer, defval = 10)
            //numberOfPoles = input(title = "Super Smoother Filter Poles", type = integer, defval = 2, options =[2, 3])

            //PI = 2 * asin(1)
            //_rf(src, highpassLength, ssfLength, numberOfPoles) =>
            //alphaArg = 2 * PI / (highpassLength * sqrt(2))

            //alpha = 0.0
            //alpha:= cos(alphaArg) != 0
            //    ? (cos(alphaArg) + sin(alphaArg) - 1) / cos(alphaArg)
            //    : nz(alpha[1])

            //highpass = 0.0
            //highpass:= pow(1 - (alpha / 2), 2) * (src - 2 * nz(src[1]) + nz(src[2])) + 2 * (1 - alpha) * nz(highpass[1]) - pow(1 - alpha, 2) * nz(highpass[2])
            //arg = (highpass + nz(highpass[1])) / 2

            //numberOfPoles == 2
            //     ? _ssf2(arg, ssfLength)
            //     : _ssf3(arg, ssfLength)
            List<decimal> hpFilterList = new();
            List<decimal> argList = new();
            List<decimal> roofingFilter2PoleList = new();
            List<Signal> signalsList = new();

            try
            {
                int highPassLength = (int)Math.Ceiling(days / 0.2084);

                hpFilterList = CalculateEhlersHighPassFilter(null, stockDataClass, highPassLength, 1).Item1;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal highPass = hpFilterList.ElementAtOrDefault(i);
                    decimal prevHp1 = i >= 1 ? hpFilterList.ElementAtOrDefault(i - 1) : 0;

                    decimal arg = (highPass + prevHp1) / 2;
                    argList.Add(arg);
                }

                roofingFilter2PoleList = GetMovingAverageList(maType, argList, stockDataClass, days);
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal roofingFilter = roofingFilter2PoleList.ElementAtOrDefault(j);
                    decimal prevRoofingFilter = j >= 1 ? roofingFilter2PoleList.ElementAtOrDefault(j - 1) : 0;

                    var signal = GetCompareSignal(roofingFilter, prevRoofingFilter);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (hpFilterList, argList, roofingFilter2PoleList, signalsList);
        }

        public static (List<decimal>, List<Signal>) CalculateEhlersHighPassFilter(List<decimal>? customValuesList, StockData stockDataClass, int days = 125, decimal mult = 1)
        {
            //PI = 2 * asin(1)

            // High-pass Filter
            //            _hp(src, hpPeriod, mult) =>
            //    alphaArg = 2 * PI / (mult * hpPeriod * sqrt(2))

            //    alpha = 0.0
            //    alpha:= cos(alphaArg) != 0
            //        ? (cos(alphaArg) + sin(alphaArg) - 1) / cos(alphaArg)
            //        : nz(alpha[1])

            //    hp = 0.0
            //    hp:= pow(1 - (alpha / 2), 2) * (src - 2 * nz(src[1]) + nz(src[2])) + 2 * (1 - alpha) * nz(hp[1]) - pow(1 - alpha, 2) * nz(hp[2])
            //    hp
            List<decimal> highPassList = new();
            List<Signal> signalsList = new();

            try
            {
                decimal alphaArg = MinOrMax(2 * (decimal)Math.PI / (mult * days * Sqrt((double)2)), 0.99m, 0.01m);
                decimal alphaCos = Cos(alphaArg);
                decimal alpha = alphaCos != 0 ? (alphaCos + Sin(alphaArg) - 1) / alphaCos : 0;

                if (customValuesList != null)
                {
                    stockDataClass.InputValues = customValuesList;
                }

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue1 = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevValue2 = i >= 2 ? stockDataClass.InputValues.ElementAtOrDefault(i - 2) : 0;
                    decimal prevHp1 = i >= 1 ? highPassList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevHp2 = i >= 2 ? highPassList.ElementAtOrDefault(i - 2) : 0;
                    decimal pow1 = Pow(1 - (alpha / 2), 2);
                    decimal pow2 = Pow(1 - alpha, 2);

                    decimal highPass = (pow1 * (currentValue - (2 * prevValue1) + prevValue2)) + (2 * (1 - alpha) * prevHp1) - (pow2 * prevHp2);
                    highPassList.Add(highPass);

                    var signal = GetCompareSignal(highPass, prevHp1);
                    signalsList.Add(signal);
                }

                // reset the input values list
                stockDataClass = LoadCalculations.GetInputValuesList(stockDataClass.InputName, stockDataClass);
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (highPassList, signalsList);
        }

        public static (List<decimal>, List<Signal>) CalculateEhlersSuperSmootherFilter(List<decimal>? customValuesList, StockData stockDataClass, int days = 10)
        {
            //EhlersSuperSmootherFilter
            //a1 = expvalue(-1.414*3.14159 / 10);
            //b1 = 2*a1*Cosine(1.414*180 / 10);
            //c2 = b1;
            //c3 = -a1*a1;
            //c1 = 1 -c2 -c3;
            //Filt = c1*(HP + HP[1]) / 2 + c2*Filt[1] + c3*Filt[2];
            List<decimal> filtList = new();
            List<Signal> signalsList = new();

            try
            {
                decimal a1 = Exp(MinOrMax(-1.414 * Math.PI / days, -0.01, -0.99));
                decimal b1 = 2 * a1 * Cos(MinOrMax(1.414 * Math.PI / days, 0.99, 0.01));
                decimal coeff2 = b1;
                decimal coeff3 = (-1 * a1) * a1;
                decimal coeff1 = 1 - coeff2 - coeff3;

                if (customValuesList != null)
                {
                    stockDataClass.InputValues = customValuesList;
                }

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevFilter1 = i >= 1 ? filtList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevFilter2 = i >= 2 ? filtList.ElementAtOrDefault(i - 2) : 0;

                    decimal prevFilt = filtList.LastOrDefault();
                    decimal filt = (coeff1 * ((currentValue + prevValue) / 2)) + (coeff2 * prevFilter1) + (coeff3 * prevFilter2);
                    filtList.Add(filt);

                    var signal = GetCompareSignal(currentValue - filt, prevValue - prevFilt);
                    signalsList.Add(signal);
                }

                // reset the input values list
                stockDataClass = LoadCalculations.GetInputValuesList(stockDataClass.InputName, stockDataClass);
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (filtList, signalsList);
        }

        public static (List<decimal>, List<Signal>) CalculateEhlers2PoleSuperSmootherFilter(StockData stockDataClass, int days = 15)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Ehlers 2 Pole Super Smoother Filter V1 [CC] script may be freely distributed under the MIT license.
            //study("Ehlers 2 Pole Super Smoother Filter V1 [CC]", overlay = true)

            //inp = input(title = "Source", type = input.source, defval = hl2)
            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //src = security(syminfo.tickerid, res, inp[rep ? 0 : barstate.isrealtime ? 1 : 0])[rep ? 0 : barstate.isrealtime ? 0 : 1]
            //length = input(title = "Length", type = input.integer, defval = 15, minval = 1)

            //pi = 2 * asin(1)
            //a1 = exp(-1.414 * pi / length)
            //b1 = 2 * a1 * cos(1.414 * pi / length)
            //coef2 = b1
            //coef3 = -a1 * a1
            //coef1 = 1 - coef2 - coef3

            //ssf = 0.0
            //ssf:= bar_index < 3 ? src : (coef1 * src) + (coef2 * nz(ssf[1])) + (coef3 * nz(ssf[2]))

            //sig = src > ssf ? 1 : src < ssf ? -1 : 0
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //ssfColor = sig > 0 ? color.green : sig < 0 ? color.red : color.black
            //barcolor(bar ? ssfColor : na)
            //plot(ssf, title = "SSF", color = ssfColor, linewidth = 2)
            List<decimal> filtList = new();
            List<Signal> signalsList = new();

            try
            {
                decimal a1 = Exp(MinOrMax(-1.414 * Math.PI / days, -0.01, -0.99));
                decimal b1 = 2 * a1 * Cos(MinOrMax(1.414 * Math.PI / days, 0.99, 0.01));
                decimal coef2 = b1;
                decimal coef3 = -a1 * a1;
                decimal coef1 = 1 - coef2 - coef3;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevFilter1 = i >= 1 ? filtList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevFilter2 = i >= 2 ? filtList.ElementAtOrDefault(i - 2) : 0;
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal filt = i < 3 ? currentValue : (coef1 * currentValue) + (coef2 * prevFilter1) + (coef3 * prevFilter2);
                    filtList.Add(filt);

                    var signal = GetCompareSignal(currentValue - filt, prevValue - prevFilter1);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (filtList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateEhlersAverageErrorFilter(StockData stockDataClass, int days = 27)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Ehlers Average Error Filter [CC] script may be freely distributed under the MIT license.
            //study("Ehlers Average Error Filter [CC]", overlay = true)

            //inp = input(title = "Source", type = input.source, defval = close)
            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //src = security(syminfo.tickerid, res, inp[rep ? 0 : barstate.isrealtime ? 1 : 0])[rep ? 0 : barstate.isrealtime ? 0 : 1]
            //length = input(title = "Length", type = input.integer, defval = 27, minval = 1)

            //a1 = exp(-1.414 * math.pi / length)
            //b1 = 2 * a1 * cos(1.414 * math.pi / length)
            //c2 = b1
            //c3 = -a1 * a1
            //c1 = 1 - c2 - c3

            //ssf = 0.0
            //ssf:= bar_index < 3 ? src : (0.5 * c1 * (src + nz(src[1]))) + (c2 * nz(ssf[1])) + (c3 * nz(ssf[2]))

            //e1 = 0.0
            //e1:= bar_index < 3 ? 0 : (c1 * (src - ssf)) + (c2 * nz(e1[1])) + (c3 * nz(e1[2]))
            //aef = ssf + e1

            //slo = src - nz(aef[1])
            //sig = slo > 0 ? slo > nz(slo[1]) ? 2 : 1 : slo < 0 ? slo < nz(slo[1]) ? -2 : -1 : 0
            //alertcondition(crossover(sig, 1), "Strong Buy Signal", "Strong Bullish Change Detected")
            //alertcondition(crossunder(sig, -1), "Strong Sell Signal", "Strong Bearish Change Detected")
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //aefColor = sig > 1 ? color.green : sig > 0 ? color.lime : sig < -1 ? color.maroon : sig < 0 ? color.red : color.black
            //barcolor(bar ? aefColor : na)
            //plot(aef, title = "Filter", color = aefColor, linewidth = 2)
            List<decimal> filtList = new();
            List<decimal> ssfList = new();
            List<decimal> e1List = new();
            List<Signal> signalsList = new();

            try
            {
                decimal a1 = Exp(MinOrMax(-1.414 * Math.PI / days, -0.01, -0.99));
                decimal b1 = 2 * a1 * Cos(MinOrMax(1.414 * Math.PI / days, 0.99, 0.01));
                decimal c2 = b1;
                decimal c3 = (-1 * a1) * a1;
                decimal c1 = 1 - c2 - c3;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevE11 = i >= 1 ? e1List.ElementAtOrDefault(i - 1) : 0;
                    decimal prevE12 = i >= 2 ? e1List.ElementAtOrDefault(i - 2) : 0;
                    decimal prevSsf1 = i >= 1 ? ssfList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevSsf2 = i >= 2 ? ssfList.ElementAtOrDefault(i - 2) : 0;

                    decimal ssf = i < 3 ? currentValue : (0.5m * c1 * (currentValue + prevValue)) + (c2 * prevSsf1) + (c3 * prevSsf2);
                    ssfList.Add(ssf);

                    decimal e1 = i < 3 ? 0 : (c1 * (currentValue - ssf)) + (c2 * prevE11) + (c3 * prevE12);
                    e1List.Add(e1);

                    decimal prevFilt = filtList.LastOrDefault();
                    decimal filt = ssf + e1;
                    filtList.Add(filt);

                    var signal = GetCompareSignal(currentValue - filt, prevValue - prevFilt);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (e1List, filtList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>)
            CalculateEhlersDeviationScaledSuperSmoother(StockData stockDataClass, int days = 12)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Ehlers Deviation Scaled Super Smoother [CC] script may be freely distributed under the MIT license.
            //study("Ehlers Deviation Scaled Super Smoother [CC]", overlay = true)

            //inp = input(title = "Source", type = input.source, defval = close)
            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //src = security(syminfo.tickerid, res, inp[rep ? 0 : barstate.isrealtime ? 1 : 0])[rep ? 0 : barstate.isrealtime ? 0 : 1]
            //length = input(title = "Length", type = input.integer, defval = 12, minval = 1)
            //rmsLength = input(title = "RMSLength", type = input.integer, defval = 50, minval = 1)

            //mom = src - nz(src[length])
            //hannLength = ceil(length / 1.4)
            //filt = 0.0, coef = 0.0
            //for i = 1 to hannLength
            //    cos = 1 - cos(2 * math.pi * i / (hannLength + 1))
            //    filt := filt + (cos * nz(mom[i - 1]))
            //    coef := coef + cos
            //hFilt = coef != 0 ? filt / coef : 0

            //filtMa = sum(pow(hFilt, 2), rmsLength) / rmsLength
            //rms = filtMa > 0 ? sqrt(filtMa) : 0
            //scaledFilt = rms != 0 ? hFilt / rms : 0

            //a1 = exp(-1.414 * math.pi * abs(scaledFilt) / length)
            //b1 = 2 * a1 * cos(1.414 * math.pi * abs(scaledFilt) / length)
            //c2 = b1
            //c3 = -a1 * a1
            //c1 = 1 - c2 - c3

            //dsss = 0.0
            //dsss := (c1 * ((src + nz(src[1])) / 2)) + (c2 * nz(dsss[1])) + (c3 * nz(dsss[2]))

            //slo = src - dsss
            //sig = slo > 0 ? slo > nz(slo[1]) ? 2 : 1 : slo < 0 ? slo < nz(slo[1]) ? -2 : -1 : 0
            //alertcondition(crossover(sig, 1), "Strong Buy Signal", "Strong Bullish Change Detected")
            //alertcondition(crossunder(sig, -1), "Strong Sell Signal", "Strong Bearish Change Detected")
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //dsssColor = sig > 1 ? color.green : sig > 0 ? color.lime : sig < -1 ? color.maroon : sig < 0 ? color.red : color.black
            //barcolor(bar ? dsssColor : na)
            //plot(dsss, title = "Filter", color = dsssColor, linewidth = 2)
            List<decimal> cosList = new();
            List<decimal> momList = new();
            List<decimal> dsssList = new();
            List<decimal> filtSumList = new();
            List<decimal> coefSumList = new();
            List<decimal> filtList = new();
            List<decimal> filtPowList = new();
            List<decimal> rmsList = new();
            List<decimal> scaledFiltList = new();
            List<decimal> filtPowMaList = new();
            List<Signal> signalsList = new();

            try
            {
                int length = days;
                int rmsLength = (int)Math.Ceiling(days / 0.24);
                int hannLength = MinOrMax((int)Math.Ceiling(days / 1.4));

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal priorValue = i >= days ? stockDataClass.InputValues.ElementAtOrDefault(i - days) : 0;
                    decimal prevDsss1 = i >= 1 ? dsssList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevDsss2 = i >= 2 ? dsssList.ElementAtOrDefault(i - 2) : 0;

                    decimal mom = currentValue - priorValue;
                    momList.Add(mom);

                    decimal filtSum = 0, coefSum = 0, cos = 0;
                    for (int j = 1; j <= hannLength; j++)
                    {
                        decimal prevMom = i >= j - 1 ? momList.ElementAtOrDefault(i - (j - 1)) : 0;
                        cos = 1 - Cos(ToRadians((double)360 * j / (hannLength + 1)));
                        filtSum += cos * prevMom;
                        coefSum += cos;
                    }
                    cosList.Add(cos);
                    filtSumList.Add(filtSum);
                    coefSumList.Add(coefSum);

                    decimal filt = coefSum != 0 ? filtSum / coefSum : 0;
                    filtList.Add(filt);

                    decimal filtPow = Pow(filt, 2);
                    filtPowList.Add(filtPow);

                    decimal filtPowMa = filtPowList.TakeLast(rmsLength).Average();
                    filtPowMaList.Add(filtPowMa);

                    decimal rms = filtPowMa > 0 ? Sqrt(filtPowMa) : 0;
                    rmsList.Add(rms);

                    decimal scaledFilt = rms != 0 ? filt / rms : 0;
                    scaledFiltList.Add(scaledFilt);

                    decimal a1 = Exp(-1.414 * Math.PI * (double)Math.Abs(scaledFilt) / days);
                    decimal b1 = 2 * a1 * Cos(1.414 * Math.PI * (double)Math.Abs(scaledFilt) / days);
                    decimal c2 = b1;
                    decimal c3 = -a1 * a1;
                    decimal c1 = 1 - c2 - c3;

                    decimal dsss = (c1 * ((currentValue + prevValue) / 2)) + (c2 * prevDsss1) + (c3 * prevDsss2);
                    dsssList.Add(dsss);

                    var signal = GetCompareSignal(currentValue - dsss, prevValue - prevDsss1);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (filtSumList, filtList, filtPowList, filtPowMaList, rmsList, scaledFiltList, dsssList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>)
            CalculateEhlersSnakeUniversalTradingFilter(StockData stockDataClass, int days = 23)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Ehlers Snake Universal Trading Filter [CC] script may be freely distributed under the MIT license.
            //study("Ehlers Snake Universal Trading Filter [CC]", overlay = false)

            //inp = input(title = "Source", type = input.source, defval = close)
            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //src = security(syminfo.tickerid, res, inp[rep ? 0 : barstate.isrealtime ? 1 : 0])[rep ? 0 : barstate.isrealtime ? 0 : 1]
            //length = input(title = "Length", type = input.integer, defval = 23, minval = 1)
            //rmsLength = input(title = "RMSLength", type = input.integer, defval = 50, minval = 1)
            //bw = input(title = "Bandwidth", type = input.float, defval = 1.4, minval = 0.01, step = 0.01)

            //l1 = cos(2 * math.pi / (2 * length))
            //g1 = cos(bw * 2 * math.pi / (2 * length))
            //s1 = (1 / g1) - sqrt(1 / pow(g1, 2) - 1)

            //bp = 0.0
            //bp:= bar_index < 3 ? 0 : (0.5 * (1 - s1) * (src - nz(src[2]))) + (l1 * (1 + s1) * nz(bp[1])) - (s1 * nz(bp[2]))

            //filt = 0.0, coef = 0.0
            //for i = 1 to length
            //    cos = 1 - cos(2 * math.pi * i / (length + 1))
            //    filt := filt + (cos * nz(bp[i - 1]))
            //    coef := coef + cos
            //hFilt = coef != 0 ? filt / coef : 0

            //filtMa = sum(pow(hFilt, 2), rmsLength) / rmsLength
            //rms = filtMa > 0 ? sqrt(filtMa) : 0

            //slo = hFilt - nz(hFilt[1])
            //sig = slo > 0 ? slo > nz(slo[1]) ? 2 : 1 : slo < 0 ? slo < nz(slo[1]) ? -2 : -1 : 0
            //alertcondition(crossover(sig, 1), "Strong Buy Signal", "Strong Bullish Change Detected")
            //alertcondition(crossunder(sig, -1), "Strong Sell Signal", "Strong Bearish Change Detected")
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //sutfColor = sig > 1 ? color.green : sig > 0 ? color.lime : sig < -1 ? color.maroon : sig < 0 ? color.red : color.black
            //barcolor(bar ? sutfColor : na)
            //hline(0)
            //plot(hFilt, title = "Filter", color = color.yellow, linewidth = 1)
            //plot(rms, title = "RMS", color = sutfColor, linewidth = 2)
            //plot(-rms, title = "-RMS", color = sutfColor, linewidth = 2)
            List<decimal> cosList = new();
            List<decimal> bpList = new();
            List<decimal> negRmsList = new();
            List<decimal> filtSumList = new();
            List<decimal> coefSumList = new();
            List<decimal> filtList = new();
            List<decimal> filtPowList = new();
            List<decimal> rmsList = new();
            List<decimal> filtPowMaList = new();
            List<Signal> signalsList = new();

            try
            {
                int length = days;
                int rmsLength = (int)Math.Ceiling(days / 0.46);
                int hannLength = MinOrMax((int)Math.Ceiling(days / 1.4));
                int bpLength = days * 2;
                decimal bw = 1.4m;
                decimal l1 = Cos(MinOrMax(2 * Math.PI / bpLength, 0.99, 0.01));
                decimal g1 = Cos(MinOrMax(bw * 2 * (decimal)Math.PI / bpLength, 0.99m, 0.01m));
                decimal s1 = (1 / g1) - Sqrt(1 / Pow(g1, 2) - 1);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue1 = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevValue2 = i >= 2 ? stockDataClass.InputValues.ElementAtOrDefault(i - 2) : 0;
                    decimal prevBp1 = i >= 1 ? bpList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevBp2 = i >= 2 ? bpList.ElementAtOrDefault(i - 2) : 0;
                    decimal prevFilt1 = i >= 1 ? filtList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevFilt2 = i >= 2 ? filtList.ElementAtOrDefault(i - 2) : 0;

                    decimal bp = i < 3 ? 0 : (0.5m * (1 - s1) * (currentValue - prevValue2)) + (l1 * (1 + s1) * prevBp1) - (s1 * prevBp2);
                    bpList.Add(bp);

                    decimal filtSum = 0, coefSum = 0, cos = 0;
                    for (int j = 1; j <= hannLength; j++)
                    {
                        decimal prevBp = i >= j - 1 ? bpList.ElementAtOrDefault(i - (j - 1)) : 0;
                        cos = 1 - (decimal)Cos(ToRadians((double)360 * j / (hannLength + 1)));
                        filtSum += cos * prevBp;
                        coefSum += cos;
                    }
                    cosList.Add(cos);
                    filtSumList.Add(filtSum);
                    coefSumList.Add(coefSum);

                    decimal filt = coefSum != 0 ? filtSum / coefSum : 0;
                    filtList.Add(filt);

                    decimal filtPow = Pow(filt, 2);
                    filtPowList.Add(filtPow);

                    decimal filtPowMa = filtPowList.TakeLast(rmsLength).Average();
                    filtPowMaList.Add(filtPowMa);

                    decimal rms = filtPowMa > 0 ? (decimal)Sqrt((double)filtPowMa) : 0;
                    rmsList.Add(rms);

                    decimal negRms = -rms;
                    negRmsList.Add(negRms);

                    var signal = GetCompareSignal(filt - prevFilt1, prevFilt1 - prevFilt2);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (filtSumList, filtList, filtPowList, filtPowMaList, rmsList, negRmsList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateEhlersImpulseResponse(StockData stockDataClass, int days = 20)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Ehlers Impulse Response [CC] script may be freely distributed under the MIT license.
            //study("Ehlers Impulse Response [CC]", overlay = false)

            //inp = input(title = "Source", type = input.source, defval = close)
            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //src = security(syminfo.tickerid, res, inp[rep ? 0 : barstate.isrealtime ? 1 : 0])[rep ? 0 : barstate.isrealtime ? 0 : 1]
            //length = input(title = "Length", type = input.integer, defval = 20, minval = 1)
            //bw = input(title = "BW", type = input.float, defval = 1.0, minval = 0.01)

            //l1 = cos(2 * math.pi / length)
            //g1 = cos(bw * 2 * math.pi / length)
            //s1 = (1 / g1) - sqrt(1 / pow(g1, 2) - 1)

            //bp = 0.0
            //bp:= bar_index < 3 ? 0 : (0.5 * (1 - s1) * (src - nz(src[2]))) + (l1 * (1 + s1) * nz(bp[1])) - (s1 * nz(bp[2]))

            //hannLength = ceil(length / 1.4)
            //filt = 0.0, coef = 0.0
            //for i = 1 to hannLength
            //    cos = 1 - cos(2 * math.pi * i / (hannLength + 1))
            //    filt := filt + (cos * nz(bp[i - 1]))
            //    coef := coef + cos
            //hFilt = coef != 0 ? filt / coef : 0

            //slo = hFilt - nz(hFilt[1])
            //sig = slo > 0 ? slo > nz(slo[1]) ? 2 : 1 : slo < 0 ? slo < nz(slo[1]) ? -2 : -1 : 0
            //alertcondition(crossover(sig, 1), "Strong Buy Signal", "Strong Bullish Change Detected")
            //alertcondition(crossunder(sig, -1), "Strong Sell Signal", "Strong Bearish Change Detected")
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //irColor = sig > 1 ? color.green : sig > 0 ? color.lime : sig < -1 ? color.maroon : sig < 0 ? color.red : color.black
            //barcolor(bar ? irColor : na)
            //hline(0)
            //plot(hFilt, title = "Filter", color = irColor, linewidth = 2)
            List<decimal> cosList = new();
            List<decimal> bpList = new();
            List<decimal> filtSumList = new();
            List<decimal> coefSumList = new();
            List<decimal> filtList = new();
            List<Signal> signalsList = new();

            try
            {
                int length = days;
                int hannLength = MinOrMax((int)Math.Ceiling(days / 1.4));
                decimal bw = 1;
                decimal l1 = Cos(MinOrMax(2 * Math.PI / days, 0.99, 0.01));
                decimal g1 = Cos(MinOrMax((double)bw * 2 * Math.PI / days, 0.99, 0.01));
                decimal s1 = (1 / g1) - Sqrt(1 / Pow(g1, 2) - 1);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue1 = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevValue2 = i >= 2 ? stockDataClass.InputValues.ElementAtOrDefault(i - 2) : 0;
                    decimal prevBp1 = i >= 1 ? bpList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevBp2 = i >= 2 ? bpList.ElementAtOrDefault(i - 2) : 0;
                    decimal prevFilt1 = i >= 1 ? filtList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevFilt2 = i >= 2 ? filtList.ElementAtOrDefault(i - 2) : 0;

                    decimal bp = i < 3 ? 0 : (0.5m * (1 - s1) * (currentValue - prevValue2)) + (l1 * (1 + s1) * prevBp1) - (s1 * prevBp2);
                    bpList.Add(bp);

                    decimal filtSum = 0, coefSum = 0, cos = 0;
                    for (int j = 1; j <= hannLength; j++)
                    {
                        decimal prevBp = i >= j - 1 ? bpList.ElementAtOrDefault(i - (j - 1)) : 0;
                        cos = 1 - Cos(ToRadians((double)360 * j / (hannLength + 1)));
                        filtSum += cos * prevBp;
                        coefSum += cos;
                    }
                    cosList.Add(cos);
                    filtSumList.Add(filtSum);
                    coefSumList.Add(coefSum);

                    decimal filt = coefSum != 0 ? filtSum / coefSum : 0;
                    filtList.Add(filt);

                    var signal = GetCompareSignal(filt - prevFilt1, prevFilt1 - prevFilt2);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (filtSumList, filtList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>)
            CalculateEhlersMesaPredictIndicatorV1(StockData stockDataClass, int days = 4)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Ehlers Mesa Predict Indicator V1 [CC] script may be freely distributed under the MIT license.
            //study("Ehlers Mesa Predict Indicator V1 [CC]", overlay = false)

            //inp = input(title = "Source", type = input.source, defval = close)
            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //src = security(syminfo.tickerid, res, inp[rep ? 0 : barstate.isrealtime ? 1 : 0])[rep ? 0 : barstate.isrealtime ? 0 : 1]
            //lowerLength = input(title = "LowerLength", type = input.integer, defval = 12, minval = 1)
            //upperLength = input(title = "UpperLength", type = input.integer, defval = 54, minval = 1)
            //barsFwd = input(title = "BarsFwd", type = input.integer, defval = 5, minval = 1)
            //coefLength = input(title = "CoefLength", type = input.integer, defval = 4, minval = 1)
            //lbLength = input(title = "LbLength", type = input.integer, defval = 10, minval = 1)

            //a1 = exp(-1.414 * math.pi / upperLength)
            //b1 = 2 * a1 * cos(1.414 * math.pi / upperLength)
            //c2 = b1
            //c3 = -a1 * a1
            //c1 = (1 + c2 - c3) / 4
            //a = exp(-1.414 * math.pi / lowerLength)
            //b = 2 * a * cos(1.414 * math.pi / lowerLength)
            //coef2 = b
            //coef3 = -a * a
            //coef1 = 1 - coef2 - coef3
            //x = array.new_float(50, 0.0)
            //y = array.new_float(50, 0.0)
            //p = array.new_float(500, 0.0)
            //bb1 = array.new_float(500, 0.0)
            //bb2 = array.new_float(500, 0.0)
            //coef = array.new_float(500, 0.0)
            //coefA = array.new_float(500, 0.0)
            //xx = array.new_float(520, 0.0)
            //hCoef = array.new_float(520, 0.0)

            //hp = 0.0
            //hp:= bar_index < 4 ? 0 : (c1 * (src - (2 * nz(src[1])) + nz(src[2]))) + (c2 * nz(hp[1])) + (c3 * nz(hp[2]))

            //ssf = 0.0
            //ssf:= bar_index < 3 ? hp : (coef1 * ((hp + nz(hp[1])) / 2)) + (coef2 * nz(ssf[1])) + (coef3 * nz(ssf[2]))

            //pwr = 0.0
            //for int i = 0 to upperLength - 1
            //    pwr := pwr + pow(nz(ssf[i]), 2)
            //pwr := pwr / upperLength

            //array.set(bb1, 1, ssf)
            //array.set(bb2, upperLength - 1, nz(ssf[upperLength - 1]))
            //for int i = 2 to upperLength - 1
            //    array.set(bb1, i, nz(ssf[i - 1]))
            //    array.set(bb2, i - 1, nz(ssf[i - 1]))

            //num = 0.0, denom = 0.0
            //for int i = 1 to upperLength - 1
            //    num := num + (array.get(bb1, i) * array.get(bb2, i))
            //    denom := denom + pow(array.get(bb1, i), 2) + pow(array.get(bb2, i), 2)

            //array.set(coef, 1, denom != 0 ? 2 * num / denom : 0)
            //array.set(p, 1, pwr * (1 - pow(array.get(coef, 1), 2)))
            //for int i = 2 to coefLength
            //    for int j = 1 to i - 1
            //        array.set(coefA, j, array.get(coef, j))
            //    for int j = 1 to upperLength - i
            //        array.set(bb1, j, array.get(bb1, j) - (array.get(coefA, i - 1) * array.get(bb2, j)))
            //        array.set(bb2, j, array.get(bb2, j + 1) - (array.get(coefA, i - 1) * array.get(bb1, j + 1)))

            //    num1 = 0.0, denom1 = 0.0
            //    for int j = 1 to upperLength - i
            //        num1 := num1 + (array.get(bb1, i) * array.get(bb2, i))
            //        denom1 := denom1 + pow(array.get(bb1, i), 2) + pow(array.get(bb2, i), 2)

            //    array.set(coef, i, denom1 != 0 ? 2 * num1 / denom1 : 0)
            //    array.set(p, i, array.get(p, i - 1) * (1 - pow(array.get(coef, i), 2)))

            //    for int j = 1 to i - 1
            //        array.set(coef, j, array.get(coefA, j) - (array.get(coef, i) * array.get(coefA, i - j)))

            //coefArray = array.new_float(50, 0.0)
            //for int i = 1 to coefLength
            //    array.set(coefArray, 1, array.get(coef, i))
            //    for int j = lowerLength to 2
            //        array.set(coefArray, j, array.get(coefArray, j - 1))
            //for int i = 1 to coefLength
            //    array.set(hCoef, i, 0.0)
            //    cc = 0.0
            //    for int j = 1 to lowerLength
            //        array.set(hCoef, i, array.get(hCoef, i) + ((1 - cos(2 * math.pi * j / (lowerLength + 1))) * array.get(coefArray, j)))
            //        cc := cc + (1 - cos(2 * math.pi * j / (lowerLength + 1)))
            //    array.set(hCoef, i, cc != 0 ? array.get(hCoef, i) / cc : 0)

            //for int i = 1 to upperLength
            //    array.set(xx, i, nz(ssf[upperLength - i]))
            //for int i = 1 to lbLength
            //    array.set(xx, upperLength + i, 0)
            //    for int j = 1 to coefLength
            //        array.set(xx, upperLength + i, array.get(xx, upperLength + i) + (array.get(hCoef, j) * array.get(xx, upperLength + i - j)))

            //prePredict = array.get(xx, upperLength + barsFwd)
            //predict = (prePredict + nz(prePredict[1])) / 2

            //slo = predict - nz(predict[1])
            //sig = slo > 0 ? slo > nz(slo[1]) ? 2 : 1 : slo < 0 ? slo < nz(slo[1]) ? -2 : -1 : 0
            //alertcondition(crossover(sig, 1), "Strong Buy Signal", "Strong Bullish Change Detected")
            //alertcondition(crossunder(sig, -1), "Strong Sell Signal", "Strong Bearish Change Detected")
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //mpiColor = sig > 1 ? color.green : sig > 0 ? color.lime : sig < -1 ? color.maroon : sig < 0 ? color.red : color.black
            //barcolor(bar ? mpiColor : na)
            //plot(ssf, title = "Filter", color = mpiColor, linewidth = 1)
            //plot(predict, title = "Predict", color = color.yellow, linewidth = 1)
            List<decimal> pwrList = new();
            List<decimal> ssfList = new();
            List<decimal> hpList = new();
            List<decimal> pwrSumList = new();
            List<decimal> prePredictList = new();
            List<decimal> predictList = new();
            List<decimal> numList = new();
            List<decimal> denomList = new();
            List<decimal> coefList = new();
            List<decimal> pList = new();
            List<Signal> signalsList = new();

            try
            {
                int coefLength = days;
                int barsFwd = (int)Math.Ceiling(days / 0.8);
                int lbLength = barsFwd * 2;
                int lowerLength = coefLength * 3;
                int upperLength = (int)Math.Ceiling(lowerLength / 0.223);
                decimal a1 = Exp(MinOrMax(-1.414 * Math.PI / upperLength, -0.01, -0.99));
                decimal b1 = 2 * a1 * Cos(MinOrMax(1.414 * Math.PI / upperLength, 0.99, 0.01));
                decimal c2 = b1;
                decimal c3 = -a1 * a1;
                decimal c1 = (1 + c2 - c3) / 4;
                decimal a = Exp(MinOrMax(-1.414 * Math.PI / lowerLength, -0.01, -0.99));
                decimal b = 2 * a * Cos(MinOrMax(1.414 * Math.PI / lowerLength, 0.99, 0.01));
                decimal coef2 = b;
                decimal coef3 = -a * a;
                decimal coef1 = 1 - coef2 - coef3;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue1 = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevValue2 = i >= 2 ? stockDataClass.InputValues.ElementAtOrDefault(i - 2) : 0;
                    decimal prevHp1 = i >= 1 ? hpList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevHp2 = i >= 2 ? hpList.ElementAtOrDefault(i - 2) : 0;
                    decimal prevSsf1 = i >= 1 ? ssfList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevSsf2 = i >= 2 ? ssfList.ElementAtOrDefault(i - 2) : 0;
                    decimal prevPredict1 = i >= 1 ? predictList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevPredict2 = i >= 2 ? predictList.ElementAtOrDefault(i - 2) : 0;
                    decimal priorSsf = i >= upperLength - 1 ? ssfList.ElementAtOrDefault(i - (upperLength - 1)) : 0;
                    var xArray = new decimal[50];
                    var yArray = new decimal[50];
                    var pArray = new decimal[500];
                    var bb1Array = new decimal[500];
                    var bb2Array = new decimal[500];
                    var coefArray = new decimal[500];
                    var coefAArray = new decimal[500];
                    var xxArray = new decimal[520];
                    var hCoefArray = new decimal[520];

                    decimal hp = i < 4 ? 0 : (c1 * (currentValue - (2 * prevValue1) + prevValue2)) + (c2 * prevHp1) + (c3 * prevHp2);
                    hpList.Add(hp);

                    decimal ssf = i < 3 ? hp : (coef1 * ((hp + prevHp1) / 2)) + (coef2 * prevSsf1) + (coef3 * prevSsf2);
                    ssfList.Add(ssf);

                    decimal pwrSum = 0;
                    for (int j = 0; j < upperLength; j++)
                    {
                        decimal prevSsf = i >= j ? ssfList.ElementAtOrDefault(i - j) : 0;
                        pwrSum += Pow(prevSsf, 2);
                    }
                    pwrSumList.Add(pwrSum);

                    decimal pwr = pwrSum / upperLength;
                    pwrList.Add(pwr);

                    bb1Array[1] = ssf;
                    bb2Array[upperLength - 1] = priorSsf;
                    for (int j = 2; j < upperLength; j++)
                    {
                        decimal prevSsf = i >= j - 1 ? ssfList.ElementAtOrDefault(i - (j - 1)) : 0;
                        bb1Array[j] = prevSsf;
                        bb2Array[j - 1] = prevSsf;
                    }

                    decimal num = 0, denom = 0;
                    for (int j = 1; j < upperLength; j++)
                    {
                        num += (bb1Array[j] * bb2Array[j]);
                        denom += (Pow(bb1Array[j], 2) + Pow(bb2Array[j], 2));
                    }
                    numList.Add(num);
                    denomList.Add(denom);

                    decimal coef = denom != 0 ? 2 * num / denom : 0;
                    coefList.Add(coef);

                    decimal p = pwr * (1 - Pow(coef, 2));
                    pList.Add(p);

                    coefArray[1] = coef;
                    pArray[1] = p;
                    for (int j = 2; j <= coefLength; j++)
                    {
                        for (int k = 1; k < j; k++)
                        {
                            coefAArray[k] = coefArray[k];
                        }

                        for (int k = 1; k < upperLength; k++)
                        {
                            bb1Array[k] = bb1Array[k] - (coefAArray[j - 1] * bb2Array[k]);
                            bb2Array[k] = bb2Array[k + 1] - (coefAArray[j - 1] * bb1Array[k + 1]);
                        }

                        decimal num1 = 0, denom1 = 0;
                        for (int k = 1; k <= upperLength - j; k++)
                        {
                            num1 += (bb1Array[k] * bb2Array[k]);
                            denom1 += (Pow(bb1Array[k], 2) + Pow(bb2Array[k], 2));
                        }

                        coefArray[j] = denom1 != 0 ? 2 * num1 / denom1 : 0;
                        pArray[j] = pArray[j - 1] * (1 - Pow(coefArray[j], 2));
                        for (int k = 1; k < j; k++)
                        {
                            coefArray[k] = coefAArray[k] - (coefArray[j] * coefAArray[j - k]);
                        }
                    }

                    var coef1Array = new decimal[500];
                    for (int j = 1; j <= coefLength; j++)
                    {
                        coef1Array[1] = coefArray[j];
                        for (int k = lowerLength; k >= 2; k--)
                        {
                            coef1Array[k] = coef1Array[k - 1];
                        }
                    }

                    for (int j = 1; j <= coefLength; j++)
                    {
                        hCoefArray[j] = 0;
                        decimal cc = 0;
                        for (int k = 1; k <= lowerLength; k++)
                        {
                            hCoefArray[j] = hCoefArray[j] + ((1 - Cos(MinOrMax(2 * Math.PI * k / (lowerLength + 1), 0.99, 0.01))) * coef1Array[k]);
                            cc += (1 - Cos(MinOrMax(2 * Math.PI * k / (lowerLength + 1), 0.99, 0.01)));
                        }
                        hCoefArray[j] = cc != 0 ? hCoefArray[j] / cc : 0;
                    }

                    for (int j = 1; j <= upperLength; j++)
                    {
                        xxArray[j] = i >= upperLength - j ? ssfList.ElementAtOrDefault(i - (upperLength - j)) : 0;
                    }

                    for (int j = 1; j <= lbLength; j++)
                    {
                        xxArray[upperLength + j] = 0;
                        for (int k = 1; k <= coefLength; k++)
                        {
                            xxArray[upperLength + j] = xxArray[upperLength + j] + (hCoefArray[k] * xxArray[upperLength + j - k]);
                        }
                    }

                    decimal prevPrePredict = prePredictList.LastOrDefault();
                    decimal prePredict = xxArray[upperLength + barsFwd];
                    prePredictList.Add(prePredict);

                    decimal predict = (prePredict + prevPrePredict) / 2;
                    predictList.Add(predict);

                    var signal = GetCompareSignal(ssf - predict, prevSsf1 - prevPredict1);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (hpList, ssfList, pwrSumList, pwrList, numList, denomList, coefList, prePredictList, predictList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>)
            CalculateEhlersMesaPredictIndicatorV2(StockData stockDataClass, int days = 4)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Ehlers Mesa Predict Indicator V2 [CC] script may be freely distributed under the MIT license.
            //study("Ehlers Mesa Predict Indicator V2 [CC]", overlay = false)

            //inp = input(title = "Source", type = input.source, defval = close)
            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //src = security(syminfo.tickerid, res, inp[rep ? 0 : barstate.isrealtime ? 1 : 0])[rep ? 0 : barstate.isrealtime ? 0 : 1]
            //length = input(title = "Length", type = input.integer, defval = 5, minval = 1)
            //hpLength = input(title = "HPLength", type = input.integer, defval = 135, minval = 1)
            //lpLength = input(title = "LPLength", type = input.integer, defval = 12, minval = 1)
            //barsFwd = input(title = "BarsFwd", type = input.integer, defval = 4, minval = 1)

            //a1 = exp(-1.414 * math.pi / hpLength)
            //b1 = 2 * a1 * cos(1.414 * math.pi / hpLength)
            //c2 = b1
            //c3 = -a1 * a1
            //c1 = (1 + c2 - c3) / 4
            //a = exp(-1.414 * math.pi / lpLength)
            //b = 2 * a * cos(1.414 * math.pi / lpLength)
            //coef2 = b
            //coef3 = -a * a
            //coef1 = 1 - coef2 - coef3

            //hp = 0.0
            //hp:= bar_index < 4 ? 0 : (c1 * (src - (2 * nz(src[1])) + nz(src[2]))) + (c2 * nz(hp[1])) + (c3 * nz(hp[2]))

            //ssf = 0.0
            //ssf:= bar_index < 3 ? hp : (coef1 * ((hp + nz(hp[1])) / 2)) + (coef2 * nz(ssf[1])) + (coef3 * nz(ssf[2]))

            //filt = 0.0, coef = 0.0
            //for i = 1 to lpLength
            //    cos = 1 - cos(2 * math.pi * i / (lpLength + 1))
            //    filt := filt + (cos * nz(ssf[i - 1]))
            //    coef := coef + cos
            //hFilt = coef != 0 ? filt / coef : 0

            //coefArray = array.new_float(length, 0.0)
            //xx = array.new_float(100, 0.0)
            //yy = array.new_float(100, 0.0)
            //array.set(coefArray, 0, 4.525)
            //array.set(coefArray, 1, -8.45)
            //array.set(coefArray, 2, 8.145)
            //array.set(coefArray, 3, -4.045)
            //array.set(coefArray, 4, 0.825)

            //for i = 1 to length
            //    prevFilt = nz(hFilt[length - i])
            //    array.set(xx, i, prevFilt)
            //    array.set(yy, i, prevFilt)

            //for i = 1 to length
            //    array.set(xx, length + i, 0)
            //    for j = 1 to length
            //        array.set(xx, length + i, array.get(xx, length + i) + (array.get(coefArray, j - 1) * array.get(xx, length + i - j)))

            //for i = 0 to length
            //    array.set(yy, length + i + 1, (2 * array.get(yy, length + i)) - array.get(yy, length + i - 1))

            //predict = array.get(xx, length + barsFwd)
            //extrap = array.get(yy, length + barsFwd)

            //slo = predict - nz(predict[1])
            //sig = slo > 0 ? slo > nz(slo[1]) ? 2 : 1 : slo < 0 ? slo < nz(slo[1]) ? -2 : -1 : 0
            //alertcondition(crossover(sig, 1), "Strong Buy Signal", "Strong Bullish Change Detected")
            //alertcondition(crossunder(sig, -1), "Strong Sell Signal", "Strong Bearish Change Detected")
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //mpiColor = sig > 1 ? color.green : sig > 0 ? color.lime : sig < -1 ? color.maroon : sig < 0 ? color.red : color.black
            //barcolor(bar ? mpiColor : na)
            //plot(hFilt, title = "Filter", color = mpiColor, linewidth = 1)
            //plot(predict, title = "Predict", color = color.yellow, linewidth = 1)
            //plot(extrap, title = "Extrap", color = color.blue, linewidth = 1)
            List<decimal> cosList = new();
            List<decimal> ssfList = new();
            List<decimal> hpList = new();
            List<decimal> filtSumList = new();
            List<decimal> coefSumList = new();
            List<decimal> filtList = new();
            List<decimal> predictList = new();
            List<decimal> extrapList = new();
            List<Signal> signalsList = new();

            try
            {
                var coefArray = new decimal[5];
                coefArray[0] = 4.525m;
                coefArray[1] = -8.45m;
                coefArray[2] = 8.145m;
                coefArray[3] = -4.045m;
                coefArray[4] = 0.825m;

                int barsFwd = days;
                int length = (int)Math.Ceiling(days / 0.8);
                int lpLength = days * 3;
                int hpLength = (int)Math.Ceiling(lpLength / 0.0889);
                decimal a1 = Exp(MinOrMax(-1.414 * Math.PI / hpLength, -0.01, -0.99));
                decimal b1 = 2 * a1 * Cos(MinOrMax(1.414 * Math.PI / hpLength, 0.99, 0.01));
                decimal c2 = b1;
                decimal c3 = -a1 * a1;
                decimal c1 = (1 + c2 - c3) / 4;
                decimal a = Exp(MinOrMax(-1.414 * Math.PI / lpLength, -0.01, -0.99));
                decimal b = 2 * a * Cos(MinOrMax(1.414 * Math.PI / lpLength, 0.99, 0.01));
                decimal coef2 = b;
                decimal coef3 = -a * a;
                decimal coef1 = 1 - coef2 - coef3;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue1 = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevValue2 = i >= 2 ? stockDataClass.InputValues.ElementAtOrDefault(i - 2) : 0;
                    decimal prevHp1 = i >= 1 ? hpList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevHp2 = i >= 2 ? hpList.ElementAtOrDefault(i - 2) : 0;
                    decimal prevSsf1 = i >= 1 ? ssfList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevSsf2 = i >= 2 ? ssfList.ElementAtOrDefault(i - 2) : 0;
                    decimal prevPredict1 = i >= 1 ? predictList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevPredict2 = i >= 2 ? predictList.ElementAtOrDefault(i - 2) : 0;

                    decimal hp = i < 4 ? 0 : (c1 * (currentValue - (2 * prevValue1) + prevValue2)) + (c2 * prevHp1) + (c3 * prevHp2);
                    hpList.Add(hp);

                    decimal ssf = i < 3 ? hp : (coef1 * ((hp + prevHp1) / 2)) + (coef2 * prevSsf1) + (coef3 * prevSsf2);
                    ssfList.Add(ssf);

                    decimal filtSum = 0, coefSum = 0, cos = 0;
                    for (int j = 1; j <= lpLength; j++)
                    {
                        decimal prevSsf = i >= j - 1 ? ssfList.ElementAtOrDefault(i - (j - 1)) : 0;
                        cos = 1 - Cos(ToRadians((double)360 * j / (lpLength + 1)));
                        filtSum += cos * prevSsf;
                        coefSum += cos;
                    }
                    cosList.Add(cos);
                    filtSumList.Add(filtSum);
                    coefSumList.Add(coefSum);

                    decimal filt = coefSum != 0 ? filtSum / coefSum : 0;
                    filtList.Add(filt);

                    var xxArray = new decimal[100];
                    var yyArray = new decimal[100];
                    for (int j = 1; j <= length; j++)
                    {
                        decimal prevFilt = i >= length - j ? filtList.ElementAtOrDefault(i - (length - j)) : 0;
                        xxArray[j] = prevFilt;
                        yyArray[j] = prevFilt;
                    }

                    for (int j = 1; j <= length; j++)
                    {
                        xxArray[length + j] = 0;
                        for (int k = 1; k <= 5; k++)
                        {
                            xxArray[length + j] = xxArray[length + j] + (coefArray[k - 1] * xxArray[length + j - (k - 1)]);
                        }
                    }

                    for (int j = 0; j <= length; j++)
                    {
                        yyArray[length + j + 1] = (2 * yyArray[length + j]) - yyArray[length + j - 1];
                    }

                    decimal predict = xxArray[length + barsFwd];
                    predictList.Add(predict);

                    decimal extrap = yyArray[length + barsFwd];
                    extrapList.Add(extrap);

                    var signal = GetCompareSignal(predict - prevPredict1, prevPredict1 - prevPredict2);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (hpList, ssfList, filtSumList, filtList, predictList, extrapList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateEhlersAnticipateIndicator(StockData stockDataClass, int days = 14)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Ehlers Anticipate Indicator [CC] script may be freely distributed under the MIT license.
            //study("Ehlers Anticipate Indicator [CC]", overlay = false)

            //inp = input(title = "Source", type = input.source, defval = close)
            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //src = security(syminfo.tickerid, res, inp[rep ? 0 : barstate.isrealtime ? 1 : 0])[rep ? 0 : barstate.isrealtime ? 0 : 1]
            //length = input(title = "Length", type = input.integer, defval = 14, minval = 1)
            //bw = input(title = "BW", type = input.float, defval = 1.0, minval = 0.01)

            //l1 = cos(2 * math.pi / length)
            //g1 = cos(bw * 2 * math.pi / length)
            //s1 = 1 / g1 - sqrt(1 / pow(g1, 2) - 1)

            //bp = 0.0
            //bp:= bar_index < 3 ? 0 : (0.5 * (1 - s1) * (src - nz(src[2]))) + (l1 * (1 + s1) * nz(bp[1])) - (s1 * nz(bp[2]))

            //hannLength = ceil(length / 1.4)
            //filt = 0.0, coef = 0.0
            //for i = 1 to hannLength
            //    cos = 1 - cos(2 * math.pi * i / (hannLength + 1))
            //    filt := filt + (cos * nz(bp[i - 1]))
            //    coef := coef + cos
            //hFilt = coef != 0 ? filt / coef : 0

            //maxCorr = -1.0, start = 0.0
            //for i = 0 to length - 1
            //    sx = 0.0, sy = 0.0, sxx = 0.0, syy = 0.0, sxy = 0.0
            //    for j = 0 to length - 1
            //        x = nz(hFilt[j])
            //        y = -sin(2 * math.pi * (i + j) / length)
            //        sx := sx + x
            //        sy := sy + y
            //        sxx := sxx + pow(x, 2)
            //        sxy := sxy + (x * y)
            //        syy := syy + pow(y, 2)
            //    corr = ((length * sxx) - pow(sx, 2)) * ((length * syy) - pow(sy, 2)) > 0 ? ((length * sxy) - (sx * sy)) / sqrt(((length * sxx) - pow(sx, 2)) * ((length * syy) - pow(sy, 2))) : 0
            //    start := corr > maxCorr ? length - i : 0
            //    maxCorr := corr > maxCorr ? corr : maxCorr
            //predict = sin(2 * math.pi * (start + 0) / length)

            //slo = predict - nz(predict[1])
            //sig = slo > 0 ? slo > nz(slo[1]) ? 2 : 1 : slo < 0 ? slo < nz(slo[1]) ? -2 : -1 : 0
            //alertcondition(crossover(sig, 1), "Strong Buy Signal", "Strong Bullish Change Detected")
            //alertcondition(crossunder(sig, -1), "Strong Sell Signal", "Strong Bearish Change Detected")
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //aiColor = sig > 1 ? color.green : sig > 0 ? color.lime : sig < -1 ? color.maroon : sig < 0 ? color.red : color.black
            //barcolor(bar ? aiColor : na)
            //plot(predict, title = "Predict", color = aiColor, linewidth = 2)
            List<decimal> predictList = new();
            List<decimal> corrList = new();
            List<decimal> maxCorrList = new();
            List<decimal> startList = new();
            List<Signal> signalsList = new();

            try
            {
                var hFiltList = CalculateEhlersImpulseResponse(stockDataClass, days).Item2;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal maxCorr = -1, corr = 0, start = 0;
                    for (int j = 0; j < days; j++)
                    {
                        decimal sx = 0, sy = 0, sxx = 0, syy = 0, sxy = 0;
                        for (int k = 0; k < days; k++)
                        {
                            decimal x = i >= k ? hFiltList.ElementAtOrDefault(i - k) : 0;
                            decimal y = -Sin(MinOrMax(2 * Math.PI * (j + k) / days, 0.99, 0.01));
                            sx += x;
                            sy += y;
                            sxx += Pow(x, 2);
                            sxy += (x * y);
                            syy += Pow(y, 2);
                        }
                        corr = ((days * sxx) - Pow(sx, 2)) * ((days * syy) - Pow(sy, 2)) > 0 ? ((days * sxy) - (sx * sy)) /
                            Sqrt(((days * sxx) - Pow(sx, 2)) * ((days * syy) - Pow(sy, 2))) : 0;
                        start = corr > maxCorr ? days - j : 0;
                        maxCorr = corr > maxCorr ? corr : maxCorr;
                    }
                    corrList.Add(corr);
                    startList.Add(start);
                    maxCorrList.Add(maxCorr);

                    decimal prevPredict = predictList.LastOrDefault();
                    decimal predict = Sin(MinOrMax(2 * Math.PI * (double)start / days, 0.99, 0.01));
                    predictList.Add(predict);

                    var signal = GetCompareSignal(predict, prevPredict);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (corrList, startList, maxCorrList, predictList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateEhlersImpulseReaction(StockData stockDataClass, string maType, int days = 2)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Ehlers Impulse Reaction [CC] script may be freely distributed under the MIT license.
            //study("Ehlers Impulse Reaction [CC]", overlay = false)

            //inp = input(title = "Source", type = input.source, defval = close)
            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //src = security(syminfo.tickerid, res, inp[rep ? 0 : barstate.isrealtime ? 1 : 0])[rep ? 0 : barstate.isrealtime ? 0 : 1]
            //momLength = input(title = "MomLength", type = input.integer, defval = 2, minval = 1)
            //length = input(title = "Length", type = input.integer, defval = 20, minval = 1)
            //qq = input(title = "QQ", type = input.float, defval = 0.9, minval = 0.01)

            //c2 = 2 * qq * cos(2 * math.pi / length)
            //c3 = -qq * qq
            //c1 = (1 + c3) / 2

            //reaction = 0.0
            //reaction:= (c1 * (src - nz(src[momLength]))) + (c2 * nz(reaction[1])) + (c3 * nz(reaction[2]))
            //ireact = src != 0 ? 100 * reaction / src : 0

            //slo = ireact - nz(ireact[1])
            //sig = slo > 0 ? slo > nz(slo[1]) ? 2 : 1 : slo < 0 ? slo < nz(slo[1]) ? -2 : -1 : 0
            //alertcondition(crossover(sig, 1), "Strong Buy Signal", "Strong Bullish Change Detected")
            //alertcondition(crossunder(sig, -1), "Strong Sell Signal", "Strong Bearish Change Detected")
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //irColor = sig > 1 ? color.green : sig > 0 ? color.lime : sig < -1 ? color.maroon : sig < 0 ? color.red : color.black
            //barcolor(bar ? irColor : na)
            //hline(0)
            //plot(ireact, title = "IReaction", color = irColor, linewidth = 2)
            List<decimal> reactionList = new();
            List<decimal> ireactList = new();
            List<decimal> ireactMaList = new();
            List<Signal> signalsList = new();

            try
            {
                int momLength = days;
                int length = momLength * 10;
                decimal qq = 0.9m;
                decimal c2 = 2 * qq * (decimal)Cos(2 * Math.PI / length);
                decimal c3 = -qq * qq;
                decimal c1 = (1 + c3) / 2;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal priorValue = i >= momLength ? stockDataClass.InputValues.ElementAtOrDefault(i - momLength) : 0;
                    decimal prevReaction1 = i >= 1 ? reactionList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevReaction2 = i >= 2 ? reactionList.ElementAtOrDefault(i - 2) : 0;

                    decimal reaction = (c1 * (currentValue - priorValue)) + (c2 * prevReaction1) + (c3 * prevReaction2);
                    reactionList.Add(reaction);

                    decimal ireact = currentValue != 0 ? 100 * reaction / currentValue : 0;
                    ireactList.Add(ireact);
                }

                ireactMaList = GetMovingAverageList(maType, ireactList, stockDataClass, length);
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal ireactMa = ireactMaList.ElementAtOrDefault(j);
                    decimal prevIReactMa1 = j >= 1 ? ireactMaList.ElementAtOrDefault(j - 1) : 0;
                    decimal prevIReactMa2 = j >= 2 ? ireactMaList.ElementAtOrDefault(j - 2) : 0;

                    var signal = GetCompareSignal(ireactMa - prevIReactMa1, prevIReactMa1 - prevIReactMa2);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (reactionList, ireactList, ireactMaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>)
            CalculateEhlersUniversalTradingFilter(StockData stockDataClass, int days = 16)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Ehlers Universal Trading Filter [CC] script may be freely distributed under the MIT license.
            //study("Ehlers Universal Trading Filter [CC]", overlay = false)

            //inp = input(title = "Source", type = input.source, defval = close)
            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //src = security(syminfo.tickerid, res, inp[rep ? 0 : barstate.isrealtime ? 1 : 0])[rep ? 0 : barstate.isrealtime ? 0 : 1]
            //length = input(title = "Length", type = input.integer, defval = 16, minval = 1)
            //mult = input(title = "Mult", type = input.float, defval = 2.0, minval = 0.01)
            //rmsLength = input(title = "RMSLength", type = input.integer, defval = 50, minval = 1)

            //hannLength = ceil(mult * length)
            //deriv = src - nz(src[hannLength])

            //filt = 0.0, coef = 0.0
            //for i = 1 to length
            //    cos = 1 - cos(2 * math.pi * i / (length + 1))
            //    filt := filt + (cos * nz(deriv[i - 1]))
            //    coef := coef + cos
            //hFilt = coef != 0 ? filt / coef : 0

            //filtMa = sum(pow(hFilt, 2), rmsLength) / rmsLength
            //rms = filtMa > 0 ? sqrt(filtMa) : 0

            //slo = hFilt - nz(hFilt[1])
            //sig = slo > 0 ? slo > nz(slo[1]) ? 2 : 1 : slo < 0 ? slo < nz(slo[1]) ? -2 : -1 : 0
            //alertcondition(crossover(sig, 1), "Strong Buy Signal", "Strong Bullish Change Detected")
            //alertcondition(crossunder(sig, -1), "Strong Sell Signal", "Strong Bearish Change Detected")
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //sutfColor = sig > 1 ? color.green : sig > 0 ? color.lime : sig < -1 ? color.maroon : sig < 0 ? color.red : color.black
            //barcolor(bar ? sutfColor : na)
            //hline(0)
            //plot(hFilt, title = "Filter", color = color.yellow, linewidth = 1)
            //plot(rms, title = "RMS", color = sutfColor, linewidth = 2)
            //plot(-rms, title = "-RMS", color = sutfColor, linewidth = 2)
            List<decimal> cosList = new();
            List<decimal> momList = new();
            List<decimal> negRmsList = new();
            List<decimal> filtSumList = new();
            List<decimal> coefSumList = new();
            List<decimal> filtList = new();
            List<decimal> filtPowList = new();
            List<decimal> rmsList = new();
            List<decimal> filtPowMaList = new();
            List<Signal> signalsList = new();

            try
            {
                int length = days;
                int rmsLength = (int)Math.Ceiling(days / 0.32);
                int hannLength = days * 2;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal priorValue = i >= hannLength ? stockDataClass.InputValues.ElementAtOrDefault(i - hannLength) : 0;
                    decimal prevFilt1 = i >= 1 ? filtList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevFilt2 = i >= 2 ? filtList.ElementAtOrDefault(i - 2) : 0;

                    decimal mom = currentValue - priorValue;
                    momList.Add(mom);

                    decimal filtSum = 0, coefSum = 0, cos = 0;
                    for (int j = 1; j <= days; j++)
                    {
                        decimal prevMom = i >= j - 1 ? momList.ElementAtOrDefault(i - (j - 1)) : 0;
                        cos = 1 - Cos(ToRadians((double)360 * j / (days + 1)));
                        filtSum += cos * prevMom;
                        coefSum += cos;
                    }
                    cosList.Add(cos);
                    filtSumList.Add(filtSum);
                    coefSumList.Add(coefSum);

                    decimal filt = coefSum != 0 ? filtSum / coefSum : 0;
                    filtList.Add(filt);

                    decimal filtPow = Pow(filt, 2);
                    filtPowList.Add(filtPow);

                    decimal filtPowMa = filtPowList.TakeLast(rmsLength).Average();
                    filtPowMaList.Add(filtPowMa);

                    decimal rms = filtPowMa > 0 ? Sqrt(filtPowMa) : 0;
                    rmsList.Add(rms);

                    decimal negRms = -rms;
                    negRmsList.Add(negRms);

                    var signal = GetCompareSignal(filt - prevFilt1, prevFilt1 - prevFilt2);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (filtSumList, filtList, filtPowList, filtPowMaList, rmsList, negRmsList, signalsList);
        }

        public static (List<decimal>, List<Signal>) CalculateEhlers2PoleSuperSmootherFilterV2(StockData stockDataClass, int days = 10)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Ehlers 2 Pole Super Smoother Filter V2 [CC] script may be freely distributed under the MIT license.
            //study("Ehlers 2 Pole Super Smoother Filter V2 [CC]", overlay = true)

            //inp = input(title = "Source", type = input.source, defval = close)
            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //src = security(syminfo.tickerid, res, inp[rep ? 0 : barstate.isrealtime ? 1 : 0])[rep ? 0 : barstate.isrealtime ? 0 : 1]
            //length = input(title = "Length", type = input.integer, defval = 10, minval = 1)

            //pi = 2 * asin(1)
            //a = exp(-1.414 * pi / length)
            //b = 2 * a * cos(1.414 * pi / length)
            //c2 = b
            //c3 = -a * a
            //c1 = 1 - c2 - c3

            //ssf = 0.0
            //ssf:= (c1 * ((src + nz(src[1])) / 2)) + (c2 * nz(ssf[1])) + (c3 * nz(ssf[2]))

            //sig = src > ssf ? 1 : src < ssf ? -1 : 0
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //ssfColor = sig > 0 ? color.green : sig < 0 ? color.red : color.black
            //barcolor(bar ? ssfColor : na)
            //plot(ssf, title = "SSF", color = ssfColor, linewidth = 2)
            List<decimal> filtList = new();
            List<Signal> signalsList = new();

            try
            {
                decimal a = Exp(MinOrMax(-1.414 * Math.PI / days, -0.01, -0.99));
                decimal b = 2 * a * Cos(MinOrMax(1.414 * Math.PI / days, 0.99, 0.01));
                decimal c2 = b;
                decimal c3 = -a * a;
                decimal c1 = 1 - c2 - c3;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevFilter1 = i >= 1 ? filtList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevFilter2 = i >= 2 ? filtList.ElementAtOrDefault(i - 2) : 0;

                    decimal filt = (c1 * ((currentValue + prevValue) / 2)) + (c2 * prevFilter1) + (c3 * prevFilter2);
                    filtList.Add(filt);

                    var signal = GetCompareSignal(currentValue - filt, prevValue - prevFilter1);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (filtList, signalsList);
        }

        public static (List<decimal>, List<Signal>) CalculateEhlers3PoleSuperSmootherFilter(StockData stockDataClass, int days = 20)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Ehlers 3 Pole Super Smoother Filter [CC] script may be freely distributed under the MIT license.
            //study("Ehlers 3 Pole Super Smoother Filter [CC]", overlay = true)

            //inp = input(title = "Source", type = input.source, defval = hl2)
            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //src = security(syminfo.tickerid, res, inp[rep ? 0 : barstate.isrealtime ? 1 : 0])[rep ? 0 : barstate.isrealtime ? 0 : 1]
            //length = input(title = "Length", type = input.integer, defval = 15, minval = 1)

            //pi = 2 * asin(1)
            //a1 = exp(-pi / length)
            //b1 = 2 * a1 * cos(1.738 * pi / length)
            //c1 = a1 * a1
            //coef2 = b1 + c1
            //coef3 = -(c1 + (b1 * c1))
            //coef4 = c1 * c1
            //coef1 = 1 - coef2 - coef3 - coef4

            //ssf = 0.0
            //ssf:= bar_index < 4 ? src : (coef1 * src) + (coef2 * nz(ssf[1])) + (coef3 * nz(ssf[2])) + (coef4 * nz(ssf[3]))

            //sig = src > ssf ? 1 : src < ssf ? -1 : 0
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //ssfColor = sig > 0 ? color.green : sig < 0 ? color.red : color.black
            //barcolor(bar ? ssfColor : na)
            //plot(ssf, title = "SSF", color = ssfColor, linewidth = 2)
            List<decimal> filtList = new();
            List<Signal> signalsList = new();

            try
            {
                decimal arg = (decimal)MinOrMax(Math.PI / days, 0.99, 0.01);
                decimal a1 = Exp(-arg);
                decimal b1 = 2 * a1 * Cos(1.738m * arg);
                decimal c1 = a1 * a1;
                decimal coef2 = b1 + c1;
                decimal coef3 = -(c1 + (b1 * c1));
                decimal coef4 = c1 * c1;
                decimal coef1 = 1 - coef2 - coef3 - coef4;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevFilter1 = i >= 1 ? filtList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevFilter2 = i >= 2 ? filtList.ElementAtOrDefault(i - 2) : 0;
                    decimal prevFilter3 = i >= 3 ? filtList.ElementAtOrDefault(i - 3) : 0;

                    decimal filt = i < 4 ? currentValue : (coef1 * currentValue) + (coef2 * prevFilter1) + (coef3 * prevFilter2) + (coef4 * prevFilter3);
                    filtList.Add(filt);

                    var signal = GetCompareSignal(currentValue - filt, prevValue - prevFilter1);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (filtList, signalsList);
        }

        public static (List<decimal>, List<Signal>) CalculateEhlers2PoleButterworthFilter(StockData stockDataClass, int days = 10)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Ehlers 2 Pole Butterworth Filter V1 [CC] script may be freely distributed under the MIT license.
            //study("Ehlers 2 Pole Butterworth Filter V1 [CC]", overlay = true)

            //inp = input(title = "Source", type = input.source, defval = close)
            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //src = security(syminfo.tickerid, res, inp[rep ? 0 : barstate.isrealtime ? 1 : 0])[rep ? 0 : barstate.isrealtime ? 0 : 1]
            //length = input(title = "Length", type = input.integer, defval = 10, minval = 1)

            //pi = 2 * asin(1)
            //a = exp(-1.414 * pi / length)
            //b = 2 * a * cos(1.414 * 1.25 * pi / length)
            //c2 = b
            //c3 = -a * a
            //c1 = 1 - c2 - c3

            //bf = 0.0
            //bf:= (c1 * src) + (c2 * nz(bf[1])) + (c3 * nz(bf[2]))

            //sig = src > bf ? 1 : src < bf ? -1 : 0
            //bfColor = sig > 0 ? color.green : sig < 0 ? color.red : color.black
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //barcolor(bar ? bfColor : na)
            //plot(bf, title = "2PBF", color = bfColor, linewidth = 2)
            List<decimal> filtList = new();
            List<Signal> signalsList = new();

            try
            {
                decimal a = Exp(MinOrMax(-1.414 * Math.PI / days, -0.01, -0.99));
                decimal b = 2 * a * Cos(MinOrMax(1.414 * 1.25 * Math.PI / days, 0.99, 0.01));
                decimal c2 = b;
                decimal c3 = -a * a;
                decimal c1 = 1 - c2 - c3;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevFilter1 = i >= 1 ? filtList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevFilter2 = i >= 2 ? filtList.ElementAtOrDefault(i - 2) : 0;

                    decimal filt = (c1 * currentValue) + (c2 * prevFilter1) + (c3 * prevFilter2);
                    filtList.Add(filt);

                    var signal = GetCompareSignal(currentValue - filt, prevValue - prevFilter1);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (filtList, signalsList);
        }

        public static (List<decimal>, List<Signal>) CalculateEhlers2PoleButterworthFilterV2(StockData stockDataClass, int days = 15)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Ehlers 2 Pole Butterworth Filter V2 [CC] script may be freely distributed under the MIT license.
            //study("Ehlers 2 Pole Butterworth Filter V2 [CC]", overlay = true)

            //inp = input(title = "Source", type = input.source, defval = hl2)
            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //src = security(syminfo.tickerid, res, inp[rep ? 0 : barstate.isrealtime ? 1 : 0])[rep ? 0 : barstate.isrealtime ? 0 : 1]
            //length = input(title = "Length", type = input.integer, defval = 15, minval = 1)

            //pi = 2 * asin(1)
            //a = exp(-1.414 * pi / length)
            //b = 2 * a * cos(1.414 * pi / length)
            //c2 = b
            //c3 = -a * a
            //c1 = (1 - b + pow(a, 2)) / 4

            //bf = 0.0
            //bf:= bar_index < 3 ? src : (c1 * (src + (2 * nz(src[1])) + nz(src[3]))) + (c2 * nz(bf[1])) + (c3 * nz(bf[2]))

            //sig = src > bf ? 1 : src < bf ? -1 : 0
            //bfColor = sig > 0 ? color.green : sig < 0 ? color.red : color.black
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //barcolor(bar ? bfColor : na)
            //plot(bf, title = "2PBF", color = bfColor, linewidth = 2)
            List<decimal> filtList = new();
            List<Signal> signalsList = new();

            try
            {
                decimal a = Exp(MinOrMax(-1.414 * Math.PI / days, -0.01, -0.99));
                decimal b = 2 * a * Cos(MinOrMax(1.414 * Math.PI / days, 0.99, 0.01));
                decimal c2 = b;
                decimal c3 = -a * a;
                decimal c1 = (1 - b + Pow(a, 2)) / 4;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevFilter1 = i >= 1 ? filtList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevFilter2 = i >= 2 ? filtList.ElementAtOrDefault(i - 2) : 0;
                    decimal prevValue1 = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevValue3 = i >= 3 ? stockDataClass.InputValues.ElementAtOrDefault(i - 3) : 0;

                    decimal filt = i < 3 ? currentValue : (c1 * (currentValue + (2 * prevValue1) + prevValue3)) + (c2 * prevFilter1) + (c3 * prevFilter2);
                    filtList.Add(filt);

                    var signal = GetCompareSignal(currentValue - filt, prevValue1 - prevFilter1);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (filtList, signalsList);
        }

        public static (List<decimal>, List<Signal>) CalculateEhlers3PoleButterworthFilter(StockData stockDataClass, int days = 10)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Ehlers 3 Pole Butterworth Filter V1 [CC] script may be freely distributed under the MIT license.
            //study("Ehlers 3 Pole Butterworth Filter V1 [CC]", overlay = true)

            //inp = input(title = "Source", type = input.source, defval = close)
            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //src = security(syminfo.tickerid, res, inp[rep ? 0 : barstate.isrealtime ? 1 : 0])[rep ? 0 : barstate.isrealtime ? 0 : 1]
            //length = input(title = "Length", type = input.integer, defval = 10, minval = 1)

            //pi = 2 * asin(1)
            //a = exp(-pi / length)
            //b = 2 * a * cos(1.738 * pi / length)
            //c = a * a
            //d2 = b + c
            //d3 = -(c + (b * c))
            //d4 = c * c
            //d1 = 1 - d2 - d3 - d4

            //bf = 0.0
            //bf:= (d1 * src) + (d2 * nz(bf[1])) + (d3 * nz(bf[2])) + (d4 * nz(bf[3]))

            //sig = src > bf ? 1 : src < bf ? -1 : 0
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //bfColor = sig > 0 ? color.green : sig < 0 ? color.red : color.black
            //barcolor(bar ? bfColor : na)
            //plot(bf, title = "3PBF", color = bfColor, linewidth = 2)
            List<decimal> filtList = new();
            List<Signal> signalsList = new();

            try
            {
                decimal a = Exp(MinOrMax(-Math.PI / days, -0.01, -0.99));
                decimal b = 2 * a * Cos(MinOrMax(1.738 * Math.PI / days, 0.99, 0.01));
                decimal c = a * a;
                decimal d2 = b + c;
                decimal d3 = -(c + (b * c));
                decimal d4 = c * c;
                decimal d1 = 1 - d2 - d3 - d4;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevFilter1 = i >= 1 ? filtList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevFilter2 = i >= 2 ? filtList.ElementAtOrDefault(i - 2) : 0;
                    decimal prevFilter3 = i >= 3 ? filtList.ElementAtOrDefault(i - 3) : 0;

                    decimal filt = (d1 * currentValue) + (d2 * prevFilter1) + (d3 * prevFilter2) + (d4 * prevFilter3);
                    filtList.Add(filt);

                    var signal = GetCompareSignal(currentValue - filt, prevValue - prevFilter1);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (filtList, signalsList);
        }

        public static (List<decimal>, List<Signal>) CalculateEhlers3PoleButterworthFilterV2(StockData stockDataClass, int days = 15)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Ehlers 3 Pole Butterworth Filter V2 [CC] script may be freely distributed under the MIT license.
            //study("Ehlers 3 Pole Butterworth Filter V2 [CC]", overlay = true)

            //inp = input(title = "Source", type = input.source, defval = hl2)
            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //src = security(syminfo.tickerid, res, inp[rep ? 0 : barstate.isrealtime ? 1 : 0])[rep ? 0 : barstate.isrealtime ? 0 : 1]
            //length = input(title = "Length", type = input.integer, defval = 15, minval = 1)

            //pi = 2 * asin(1)
            //a1 = exp(-pi / length)
            //b1 = 2 * a1 * cos(1.738 * pi / length)
            //c1 = a1 * a1
            //coef2 = b1 + c1
            //coef3 = -(c1 + (b1 * c1))
            //coef4 = c1 * c1
            //coef1 = (1 - b1 + c1) * (1 - c1) / 8

            //bf = 0.0
            //bf:= bar_index < 4 ? src : (coef1 * (src + (3 * nz(src[1])) + (3 * nz(src[2])) + nz(src[3]))) + (coef2 * nz(bf[1])) + (coef3 * nz(bf[2])) + (coef4 * nz(bf[3]))

            //sig = src > bf ? 1 : src < bf ? -1 : 0
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //bfColor = sig > 0 ? color.green : sig < 0 ? color.red : color.black
            //barcolor(bar ? bfColor : na)
            //plot(bf, title = "3PBF", color = bfColor, linewidth = 2)
            List<decimal> filtList = new();
            List<Signal> signalsList = new();

            try
            {
                decimal a1 = Exp(MinOrMax(-Math.PI / days, -0.01, -0.99));
                decimal b1 = 2 * a1 * Cos(MinOrMax(1.738 * Math.PI / days, 0.99, 0.01));
                decimal c1 = a1 * a1;
                decimal coef2 = b1 + c1;
                decimal coef3 = -(c1 + (b1 * c1));
                decimal coef4 = c1 * c1;
                decimal coef1 = (1 - b1 + c1) * (1 - c1) / 8;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue1 = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevValue2 = i >= 2 ? stockDataClass.InputValues.ElementAtOrDefault(i - 2) : 0;
                    decimal prevValue3 = i >= 3 ? stockDataClass.InputValues.ElementAtOrDefault(i - 3) : 0;
                    decimal prevFilter1 = i >= 1 ? filtList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevFilter2 = i >= 2 ? filtList.ElementAtOrDefault(i - 2) : 0;
                    decimal prevFilter3 = i >= 3 ? filtList.ElementAtOrDefault(i - 3) : 0;

                    decimal filt = i < 4 ? currentValue : (coef1 * (currentValue + (3 * prevValue1) + (3 * prevValue2) + prevValue3)) + (coef2 * prevFilter1) +
                        (coef3 * prevFilter2) + (coef4 * prevFilter3);
                    filtList.Add(filt);

                    var signal = GetCompareSignal(currentValue - filt, prevValue1 - prevFilter1);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (filtList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateEhlersGaussianFilter(StockData stockDataClass, int days = 14)
        {
            //@version=3
            // Copyright (c) 2018-present, Alex Orekhov (everget)
            // Gaussian Filter script may be freely distributed under the MIT license.
            //study("Gaussian Filter", shorttitle = "GF", overlay = true)

            //cyclePeriod = input(title = "Cycle Period", type = integer, minval = 1, defval = 14)
            //polesNumber = input(title = "Number of Poles", type = integer, defval = 4, options =[1, 2, 3, 4])
            //src = input(title = "Source", type = source, defval = close)

            //PI = 2 * asin(1)

            //beta = (1 - cos(2 * PI / cyclePeriod)) / (pow(2, 1 / polesNumber) - 1)
            //alpha = -beta + sqrt(pow(beta, 2) + 2 * beta)

            //getGF(poles) =>
            //    filter = 0.0

            //    if poles == 1
            //        filter:= alpha * src + (1 - alpha) * nz(filter[1])

            //    if  poles == 2
            //        filter:= pow(alpha, 2) * src + 2 * (1 - alpha) * nz(filter[1]) - pow(1 - alpha, 2) * nz(filter[2])

            //    if poles == 3
            //        filter:= pow(alpha, 3) * src + 3 * (1 - alpha) * nz(filter[1]) - 3 * pow(1 - alpha, 2) * nz(filter[2]) + pow(1 - alpha, 3) * nz(filter[3])

            //    if poles == 4
            //        filter:= pow(alpha, 4) * src + 4 * (1 - alpha) * nz(filter[1]) - 6 * pow(1 - alpha, 2) * nz(filter[2]) + 4 * pow(1 - alpha, 3) * nz(filter[3]) - pow(1 - alpha, 4) * nz(filter[4])

            //    filter
            //gf = getGF(polesNumber)

            //plot(gf, title = "GF", linewidth = 2, color =#6d1e7f, transp=0)
            List<decimal> gf1List = new();
            List<decimal> gf2List = new();
            List<decimal> gf3List = new();
            List<decimal> gf4List = new();
            List<Signal> signalsList = new();

            try
            {
                decimal cosVal = (decimal)MinOrMax(2 * Math.PI / days, 0.99, 0.01);
                decimal beta1 = (1 - (decimal)Cos((double)cosVal)) / (Pow(2, (double)1 / 1) - 1);
                decimal beta2 = (1 - (decimal)Cos((double)cosVal)) / (Pow(2, (double)1 / 2) - 1);
                decimal beta3 = (1 - (decimal)Cos((double)cosVal)) / (Pow(2, (double)1 / 3) - 1);
                decimal beta4 = (1 - (decimal)Cos((double)cosVal)) / (Pow(2, (double)1 / 4) - 1);
                decimal alpha1 = -beta1 + (decimal)Sqrt((double)(Pow(beta1, 2) + (2 * beta1)));
                decimal alpha2 = -beta2 + (decimal)Sqrt((double)(Pow(beta2, 2) + (2 * beta2)));
                decimal alpha3 = -beta3 + (decimal)Sqrt((double)(Pow(beta3, 2) + (2 * beta3)));
                decimal alpha4 = -beta4 + (decimal)Sqrt((double)(Pow(beta4, 2) + (2 * beta4)));

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevGf1 = i >= 1 ? gf1List.ElementAtOrDefault(i - 1) : 0;
                    decimal prevGf2_1 = i >= 1 ? gf2List.ElementAtOrDefault(i - 1) : 0;
                    decimal prevGf2_2 = i >= 2 ? gf2List.ElementAtOrDefault(i - 2) : 0;
                    decimal prevGf3_1 = i >= 1 ? gf3List.ElementAtOrDefault(i - 1) : 0;
                    decimal prevGf4_1 = i >= 1 ? gf4List.ElementAtOrDefault(i - 1) : 0;
                    decimal prevGf3_2 = i >= 2 ? gf3List.ElementAtOrDefault(i - 2) : 0;
                    decimal prevGf4_2 = i >= 2 ? gf4List.ElementAtOrDefault(i - 2) : 0;
                    decimal prevGf3_3 = i >= 3 ? gf3List.ElementAtOrDefault(i - 3) : 0;
                    decimal prevGf4_3 = i >= 3 ? gf4List.ElementAtOrDefault(i - 3) : 0;
                    decimal prevGf4_4 = i >= 4 ? gf4List.ElementAtOrDefault(i - 4) : 0;

                    decimal gf1 = (alpha1 * currentValue) + ((1 - alpha1) * prevGf1);
                    gf1List.Add(gf1);

                    decimal gf2 = (Pow(alpha2, 2) * currentValue) + (2 * (1 - alpha2) * prevGf2_1) - (Pow(1 - alpha2, 2) * prevGf2_2);
                    gf2List.Add(gf2);

                    decimal gf3 = (Pow(alpha3, 3) * currentValue) + (3 * (1 - alpha3) * prevGf3_1) - (3 * Pow(1 - alpha3, 2) * prevGf3_2) +
                        (Pow(1 - alpha3, 3) * prevGf3_3);
                    gf3List.Add(gf3);

                    decimal gf4 = (Pow(alpha4, 4) * currentValue) + (4 * (1 - alpha4) * prevGf4_1) - (6 * Pow(1 - alpha4, 2) * prevGf4_2) +
                        (4 * Pow(1 - alpha4, 3) * prevGf4_3) - (Pow(1 - alpha4, 4) * prevGf4_4);
                    gf4List.Add(gf4);

                    var signal = GetCompareSignal(currentValue - gf4, prevValue - prevGf4_1);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (gf1List, gf2List, gf3List, gf4List, signalsList);
        }

        public static (List<decimal>, List<Signal>) CalculateEhlersRecursiveMedianFilter(StockData stockDataClass, int days = 5)
        {
            //@version=3
            // Copyright (c) 2018-present, Alex Orekhov (everget)
            // Recursive Median Filter script may be freely distributed under the MIT license.
            //study("Recursive Median Filter", shorttitle = "RMF", overlay = true)

            //medianLength = input(title = "Median Length", type = integer, defval = 5, minval = 1)
            //lowpassLength = input(title = "Lowpass Length", type = integer, defval = 12, minval = 1)
            //highlightMovements = input(title = "Highlight Movements ?", type = bool, defval = true)
            //src = input(title = "Source", type = source, defval = close)

            //median(src, length) =>
            //    percentile_nearest_rank(src, length, 50)

            //PI = 2 * asin(1)

            //alphaArg = 2 * PI / lowpassLength

            //alpha = 0.0
            //alpha:= cos(alphaArg) != 0
            //    ? (cos(alphaArg) + sin(alphaArg) - 1) / cos(alphaArg)
            //    : nz(alpha[1])

            //rmf = 0.0
            //rmf:= alpha * median(src, medianLength) + (1 - alpha) * nz(rmf[1])

            //rmfColor = highlightMovements ? (rmf > rmf[1] ? green : red) : #6d1e7f
            //plot(rmf, title = "RMF", linewidth = 2, color = rmfColor, transp = 0)
            List<decimal> tempList = new();
            List<decimal> rmfList = new();
            List<Signal> signalsList = new();

            try
            {
                int medianLength = MinOrMax((int)Math.Ceiling(days / 0.4167));
                decimal alphaArg = (decimal)MinOrMax(2 * Math.PI / days, 0.99, 0.01);
                decimal alphaArgCos = Cos(alphaArg);
                decimal alpha = alphaArgCos != 0 ? (alphaArgCos + Sin(alphaArg) - 1) / alphaArgCos : 0;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal prevValue = tempList.LastOrDefault();
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    tempList.Add(currentValue);

                    decimal median = Median(tempList.TakeLast(medianLength));

                    decimal prevRmf = rmfList.LastOrDefault();
                    decimal rmf = (alpha * median) + ((1 - alpha) * prevRmf);
                    rmfList.Add(rmf);

                    var signal = GetCompareSignal(currentValue - rmf, prevValue - prevRmf);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (rmfList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateEhlersRecursiveMedianOscillator(StockData stockDataClass, int days = 5)
        {
            //@version=3
            // Copyright (c) 2018-present, Alex Orekhov (everget)
            // Recursive Median Oscillator script may be freely distributed under the MIT license.
            //study("Recursive Median Oscillator", shorttitle = "RMO")

            //medianLength = input(title = "Median Length", type = integer, minval = 1, defval = 5)
            //lowpassLength = input(title = "Lowpass Length", type = integer, minval = 1, defval = 12)
            //highpassLength = input(title = "Highpass Length", type = integer, minval = 1, defval = 30)
            //src = input(title = "Source", type = source, defval = close)

            //median = percentile_nearest_rank(src, medianLength, 50)

            //PI = 2 * asin(1)

            //alpha1Arg = 2 * PI / lowpassLength
            //alpha1 = (cos(alpha1Arg) + sin(alpha1Arg) - 1) / cos(alpha1Arg)

            //rm = 0.0
            //rm:= alpha1 * median + (1 - alpha1) * nz(rm[1])

            //alpha2Arg = 1 / sqrt(2) * 2 * PI / highpassLength
            //alpha2 = (cos(alpha2Arg) + sin(alpha2Arg) - 1) / cos(alpha2Arg)

            //rmo = 0.0
            //rmo:= pow(1 - alpha2 / 2, 2) * (rm - 2 * nz(rm[1]) + nz(rm[2])) + 2 * (1 - alpha2) * nz(rmo[1]) - pow(1 - alpha2, 2) * nz(rmo[2])

            //rmoColor = rmo >= 0 ? #0ebb23 : red

            //plot(rmo, title = "RMO", linewidth = 2, color = rmoColor, transp = 0)

            //hline(0, title = "Zero Level", linestyle = dotted, color = gray)
            List<decimal> rmList = new();
            List<decimal> tempList = new();
            List<decimal> rmoList = new();
            List<Signal> signalsList = new();

            try
            {
                int lowPassLength = (int)Math.Ceiling(days / 0.4167);
                int highPassLength = days * 6;

                decimal alpha1Arg = (decimal)MinOrMax(2 * Math.PI / lowPassLength, 0.99, 0.01);
                decimal alpha1ArgCos = Cos(alpha1Arg);
                decimal alpha2Arg = (decimal)MinOrMax(1 / Math.Sqrt(2) * 2 * Math.PI / highPassLength, 0.99, 0.01);
                decimal alpha2ArgCos = Cos(alpha2Arg);
                decimal alpha1 = alpha1ArgCos != 0 ? (alpha1ArgCos + Sin(alpha1Arg) - 1) / alpha1ArgCos : 0;
                decimal alpha2 = alpha2ArgCos != 0 ? (alpha2ArgCos + Sin(alpha2Arg) - 1) / alpha2ArgCos : 0;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    tempList.Add(currentValue);

                    decimal median = Median(tempList.TakeLast(days));
                    decimal prevRm1 = i >= 1 ? rmList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevRm2 = i >= 2 ? rmList.ElementAtOrDefault(i - 2) : 0;
                    decimal prevRmo1 = i >= 1 ? rmoList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevRmo2 = i >= 2 ? rmoList.ElementAtOrDefault(i - 2) : 0;

                    decimal rm = (alpha1 * median) + ((1 - alpha1) * prevRm1);
                    rmList.Add(rm);

                    decimal rmo = (Pow(1 - (alpha2 / 2), 2) * (rm - (2 * prevRm1) + prevRm2)) + (2 * (1 - alpha2) * prevRmo1) - (Pow(1 - alpha2, 2) * prevRmo2);
                    rmoList.Add(rmo);

                    var signal = GetCompareSignal(rmo, prevRmo1);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (rmList, rmoList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateEhlersSuperPassbandFilter(StockData stockDataClass, int days = 5)
        {
            //@version=3
            // Copyright (c) 2018-present, Alex Orekhov (everget)
            // Ehlers Super Passband Filter script may be freely distributed under the MIT license.
            //study("Ehlers Super Passband Filter", shorttitle = "ESPF")

            //fastLength = input(title = "Fast Length", type = integer, minval = 1, defval = 40)
            //slowLength = input(title = "Slow Length", type = integer, minval = 1, defval = 60)
            //src = input(title = "Source", type = source, defval = close)

            //getESPF(src, fastLength, slowLength) =>
            //    a1 = 5 / fastLength
            //    a2 = 5 / slowLength

            //    espf = 0.0
            //    espf:= (a1 - a2) * src +
            //        (a2 * (1 - a1) - a1 * (1 - a2)) * nz(src[1]) +
            //        ((1 - a1) + (1 - a2)) * nz(espf[1]) -
            //        (1 - a1) * (1 - a2) * nz(espf[2])

            //espf = getESPF(src, fastLength, slowLength)

            // Compute Root Mean Square
            //rms = sqrt(sum(espf * espf, 50) / 50)

            //spbColor = espf > rms ? #0ebb23 : espf < -rms ? red : #674ea7

            //plot(rms, title = "+RMS", color =#f6b26b, transp=0)
            //plot(espf, title = "ESPF", linewidth = 2, color = spbColor, transp = 0)
            //plot(-rms, title = "-RMS", color =#f6b26b, transp=0)

            //hline(0, title = "Zero Level", linestyle = dotted, color =#989898)
            List<decimal> espfList = new();
            List<decimal> squareList = new();
            List<decimal> squareSumList = new();
            List<decimal> rmsList = new();
            List<decimal> negRmsList = new();
            List<Signal> signalsList = new();

            try
            {
                int fastLength = days * 8;
                int slowLength = days * 12;
                int sumLength = days * 10;
                int alphaLength = days;
                decimal a1 = MinOrMax((decimal)alphaLength / fastLength, 0.99m, 0.01m);
                decimal a2 = MinOrMax((decimal)alphaLength / slowLength, 0.99m, 0.01m);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue1 = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevEspf1 = i >= 1 ? espfList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevEspf2 = i >= 2 ? espfList.ElementAtOrDefault(i - 2) : 0;

                    decimal espf = ((a1 - a2) * currentValue) + (((a2 * (1 - a1)) - (a1 * (1 - a2))) * prevValue1) + ((1 - a1 + (1 - a2)) * prevEspf1) - ((1 - a1) * (1 - a2) * prevEspf2);
                    espfList.Add(espf);

                    decimal square = espf * espf;
                    squareList.Add(square);

                    decimal squareSum = squareList.TakeLast(sumLength).Sum();
                    squareSumList.Add(squareSum);

                    decimal prevRms = rmsList.LastOrDefault();
                    decimal rms = Sqrt(squareSum / sumLength);
                    rmsList.Add(rms);

                    decimal prevNegRms = negRmsList.LastOrDefault();
                    decimal negRms = -rms;
                    negRmsList.Add(negRms);

                    var signal = GetBullishBearishSignal(espf - rms, prevEspf1 - prevRms, espf - negRms, prevEspf1 - prevNegRms);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (espfList, squareList, squareSumList, rmsList, negRmsList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateEhlersSimpleDerivIndicator(StockData stockDataClass, string maType, int days = 2)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Ehlers Simple Deriv Indicator [CC] script may be freely distributed under the MIT license.
            //study("Ehlers Simple Deriv Indicator [CC]", overlay = false)

            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //inp = input(title = "Source", type = input.source, defval = close)
            //src = security(syminfo.tickerid, res, inp[rep ? 0 : barstate.isrealtime ? 1 : 0])[rep ? 0 : barstate.isrealtime ? 0 : 1]
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //sigLength = input(title = "SignalLength", type = input.integer, defval = 8, minval = 1)
            //rocLength = input(title = "RocLength", type = input.integer, defval = 2, minval = 1)

            //deriv = src - nz(src[2])
            //z3 = deriv + nz(deriv[1]) + nz(deriv[2]) + nz(deriv[3])
            //signal = ema(z3, sigLength)

            //roc = signal - nz(signal[rocLength])
            //sig = signal > 0 ? roc > nz(roc[1]) ? 2 : 1 : signal < 0 ? roc < nz(roc[1]) ? -2 : -1 : 0
            //alertcondition(crossover(sig, 1), "Strong Buy Signal", "Strong Bullish Change Detected")
            //alertcondition(crossunder(sig, -1), "Strong Sell Signal", "Strong Bearish Change Detected")
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //esdColor = sig > 1 ? color.green : sig > 0 ? color.lime : sig < -1 ? color.maroon : sig < 0 ? color.red : color.black
            //barcolor(bar ? esdColor : na)
            //plot(signal, title = "ESD", color = esdColor, linewidth = 2)
            List<decimal> derivList = new();
            List<decimal> z3EmaList = new();
            List<decimal> z3List = new();
            List<Signal> signalsList = new();

            try
            {
                int sigLength = days * 4;
                int rocLength = days;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= rocLength ? stockDataClass.InputValues.ElementAtOrDefault(i - rocLength) : 0;
                    decimal prevDeriv1 = i >= 1 ? derivList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevDeriv2 = i >= 2 ? derivList.ElementAtOrDefault(i - 2) : 0;
                    decimal prevDeriv3 = i >= 3 ? derivList.ElementAtOrDefault(i - 3) : 0;

                    decimal deriv = currentValue - prevValue;
                    derivList.Add(deriv);

                    decimal z3 = deriv + prevDeriv1 + prevDeriv2 + prevDeriv3;
                    z3List.Add(z3);
                }

                z3EmaList = GetMovingAverageList(maType, z3List, stockDataClass, sigLength);
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal z3Ema = z3EmaList.ElementAtOrDefault(j);
                    decimal prevZ3Ema = j >= 1 ? z3EmaList.ElementAtOrDefault(j - 1) : 0;

                    var signal = GetCompareSignal(z3Ema, prevZ3Ema);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (z3List, z3EmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateEhlersSimpleClipIndicator(StockData stockDataClass, string maType, int days = 2)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Ehlers Simple Clip Indicator [CC] script may be freely distributed under the MIT license.
            //study("Ehlers Simple Clip Indicator [CC]", overlay = false)

            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //inp = input(title = "Source", type = input.source, defval = close)
            //src = security(syminfo.tickerid, res, inp[rep ? 0 : barstate.isrealtime ? 1 : 0])[rep ? 0 : barstate.isrealtime ? 0 : 1]
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //sigLength = input(title = "SignalLength", type = input.integer, defval = 22, minval = 1)
            //rocLength = input(title = "RocLength", type = input.integer, defval = 10, minval = 1)
            //rmsLength = input(title = "RmsLength", type = input.integer, defval = 50, minval = 1)

            //deriv = src - nz(src[2])
            //rms = 0.0
            //for int i = 0 to rmsLength - 1
            //    rms := rms + (nz(deriv[i]) * nz(deriv[i]))

            //clip = rms != 0 ? 2 * deriv / sqrt(rms / rmsLength) : 0
            //clip := clip > 1 ? 1 : clip
            //clip := clip < -1 ? -1 : clip
            //z3 = clip + nz(clip[1]) + nz(clip[2]) + nz(clip[3])
            //signal = ema(z3, sigLength)

            //roc = signal - nz(signal[rocLength])
            //sig = signal > 0 ? roc > nz(roc[1]) ? 2 : 1 : signal < 0 ? roc < nz(roc[1]) ? -2 : -1 : 0
            //alertcondition(crossover(sig, 1), "Strong Buy Signal", "Strong Bullish Change Detected")
            //alertcondition(crossunder(sig, -1), "Strong Sell Signal", "Strong Bearish Change Detected")
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //escColor = sig > 1 ? color.green : sig > 0 ? color.lime : sig < -1 ? color.maroon : sig < 0 ? color.red : color.black
            //barcolor(bar ? escColor : na)
            //plot(signal, title = "ESC", color = escColor, linewidth = 2)
            List<decimal> rmsList = new();
            List<decimal> derivList = new();
            List<decimal> clipList = new();
            List<decimal> z3EmaList = new();
            List<decimal> z3List = new();
            List<Signal> signalsList = new();

            try
            {
                int sigLength = (int)Math.Ceiling(days / 0.091);
                int rocLength = days * 5;
                int derLength = days;
                int rmsLength = rocLength * 5;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= derLength ? stockDataClass.InputValues.ElementAtOrDefault(i - derLength) : 0;
                    decimal prevClip1 = i >= 1 ? clipList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevClip2 = i >= 2 ? clipList.ElementAtOrDefault(i - 2) : 0;
                    decimal prevClip3 = i >= 3 ? clipList.ElementAtOrDefault(i - 3) : 0;

                    decimal deriv = currentValue - prevValue;
                    derivList.Add(deriv);

                    decimal rms = 0;
                    for (int j = 0; j < rmsLength; j++)
                    {
                        decimal prevDeriv = i >= j ? derivList.ElementAtOrDefault(i - j) : 0;
                        rms += Pow(prevDeriv, 2);
                    }
                    rmsList.Add(rms);

                    decimal clip = rms != 0 ? MinOrMax(2 * deriv / Sqrt(rms / rmsLength), 1, -1) : 0;
                    clipList.Add(clip);

                    decimal z3 = clip + prevClip1 + prevClip2 + prevClip3;
                    z3List.Add(z3);
                }

                z3EmaList = GetMovingAverageList(maType, z3List, stockDataClass, sigLength);
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal z3Ema = z3EmaList.ElementAtOrDefault(j);
                    decimal prevZ3Ema = j >= 1 ? z3EmaList.ElementAtOrDefault(j - 1) : 0;

                    var signal = GetCompareSignal(z3Ema, prevZ3Ema);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (rmsList, clipList, z3List, z3EmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateOptimizedTrendTracker(StockData stockDataClass, string maType, int days = 2)
        {
            //@version=4
            // This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
            // © KivancOzbilgic

            //created by: @Anil_Ozeksi
            //developer: ANIL ÖZEKŞİ
            //author: @kivancozbilgic

            //study("Optimized Trend Tracker", "OTT", overlay = true)
            //src = input(close, title = "Source")
            //length = input(2, "OTT Period", minval = 1)
            //percent = input(1.4, "OTT Percent", type = input.float, step = 0.1, minval = 0)
            //showsupport = input(title = "Show Support Line?", type = input.bool, defval = true)
            //showsignalsk = input(title = "Show Support Line Crossing Signals?", type = input.bool, defval = true)
            //showsignalsc = input(title = "Show Price/OTT Crossing Signals?", type = input.bool, defval = false)
            //highlight = input(title = "Show OTT Color Changes?", type = input.bool, defval = false)
            //showsignalsr = input(title = "Show OTT Color Change Signals?", type = input.bool, defval = false)
            //highlighting = input(title = "Highlighter On/Off ?", type = input.bool, defval = true)
            //mav = input(title = "Moving Average Type", defval = "VAR", options =["SMA", "EMA", "WMA", "TMA", "VAR", "WWMA", "ZLEMA", "TSF"])
            //MAvg = getMA(src, length)
            //fark = MAvg * percent * 0.01
            //longStop = MAvg - fark
            //longStopPrev = nz(longStop[1], longStop)
            //longStop:= MAvg > longStopPrev ? max(longStop, longStopPrev) : longStop
            //shortStop = MAvg + fark
            //shortStopPrev = nz(shortStop[1], shortStop)
            //shortStop:= MAvg < shortStopPrev ? min(shortStop, shortStopPrev) : shortStop
            //dir = 1
            //dir:= nz(dir[1], dir)
            //dir:= dir == -1 and MAvg > shortStopPrev ? 1 : dir == 1 and MAvg<longStopPrev ? -1 : dir
            //MT = dir == 1 ? longStop : shortStop
            //OTT = MAvg > MT ? MT * (200 + percent) / 200 : MT * (200 - percent) / 200
            //plot(showsupport ? MAvg : na, color =#0585E1, linewidth=2, title="Support Line")
            //OTTC = highlight ? OTT[2] > OTT[3] ? color.green : color.red : #B800D9 
            //pALL = plot(nz(OTT[2]), color = OTTC, linewidth = 2, title = "OTT", transp = 0)
            //alertcondition(cross(OTT[2], OTT[3]), title = "Color ALARM", message = "OTT Has Changed Color!")
            //alertcondition(crossover(OTT[2], OTT[3]), title = "GREEN ALERT", message = "OTT GREEN BUY SIGNAL!")
            //alertcondition(crossunder(OTT[2], OTT[3]), title = "RED ALERT", message = "OTT RED SELL SIGNAL!")
            //alertcondition(cross(MAvg, OTT[2]), title = "Cross Alert", message = "OTT - Support Line Crossing!")
            //alertcondition(crossover(MAvg, OTT[2]), title = "Crossover Alarm", message = "Support Line BUY SIGNAL!")
            //alertcondition(crossunder(MAvg, OTT[2]), title = "Crossunder Alarm", message = "Support Line SELL SIGNAL!")
            //alertcondition(cross(src, OTT[2]), title = "Price Cross Alert", message = "OTT - Price Crossing!")
            //alertcondition(crossover(src, OTT[2]), title = "Price Crossover Alarm", message = "PRICE OVER OTT - BUY SIGNAL!")
            //alertcondition(crossunder(src, OTT[2]), title = "Price Crossunder Alarm", message = "PRICE UNDER OTT - SELL SIGNAL!")
            //buySignalk = crossover(MAvg, OTT[2])
            //plotshape(buySignalk and showsignalsk ? OTT * 0.995 : na, title = "Buy", text = "Buy", location = location.absolute, style = shape.labelup, size = size.tiny, color = color.green, textcolor = color.white, transp = 0)
            //sellSignallk = crossunder(MAvg, OTT[2])
            //plotshape(sellSignallk and showsignalsk ? OTT * 1.005 : na, title = "Sell", text = "Sell", location = location.absolute, style = shape.labeldown, size = size.tiny, color = color.red, textcolor = color.white, transp = 0)
            //buySignalc = crossover(src, OTT[2])
            //plotshape(buySignalc and showsignalsc ? OTT * 0.995 : na, title = "Buy", text = "Buy", location = location.absolute, style = shape.labelup, size = size.tiny, color = color.green, textcolor = color.white, transp = 0)
            //sellSignallc = crossunder(src, OTT[2])
            //plotshape(sellSignallc and showsignalsc ? OTT * 1.005 : na, title = "Sell", text = "Sell", location = location.absolute, style = shape.labeldown, size = size.tiny, color = color.red, textcolor = color.white, transp = 0)
            //mPlot = plot(ohlc4, title = "", style = plot.style_circles, linewidth = 0, display = display.none)
            //longFillColor = highlighting ? (MAvg > OTT ? color.green : na) : na
            //shortFillColor = highlighting ? (MAvg < OTT ? color.red : na) : na
            //fill(mPlot, pALL, title = "UpTrend Highligter", color = longFillColor)
            //fill(mPlot, pALL, title = "DownTrend Highligter", color = shortFillColor)
            //buySignalr = crossover(OTT[2], OTT[3])
            //plotshape(buySignalr and showsignalsr ? OTT * 0.995 : na, title = "Buy", text = "Buy", location = location.absolute, style = shape.labelup, size = size.tiny, color = color.green, textcolor = color.white, transp = 0)
            //sellSignallr = crossunder(OTT[2], OTT[3])
            //plotshape(sellSignallr and showsignalsr ? OTT * 1.005 : na, title = "Sell", text = "Sell", location = location.absolute, style = shape.labeldown, size = size.tiny, color = color.red, textcolor = color.white, transp = 0)
            List<decimal> longStopList = new();
            List<decimal> shortStopList = new();
            List<decimal> ottList = new();
            List<decimal> farkList = new();
            List<Signal> signalsList = new();

            try
            {
                decimal percent = 1.4m;

                var maList = GetMovingAverageList(maType, null, stockDataClass, days);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal ma = maList.ElementAtOrDefault(i);

                    decimal fark = ma * percent * 0.01m;
                    farkList.Add(fark);

                    decimal prevLongStop = longStopList.LastOrDefault();
                    decimal longStop = ma - fark;
                    longStop = ma > prevLongStop ? Math.Max(longStop, prevLongStop) : longStop;
                    longStopList.Add(longStop);

                    decimal prevShortStop = shortStopList.LastOrDefault();
                    decimal shortStop = ma + fark;
                    decimal minShortStop = ma < prevShortStop ? Math.Min(shortStop, prevShortStop) : shortStop;
                    shortStopList.Add(shortStop);

                    decimal prevOtt = ottList.LastOrDefault();
                    decimal mt = ma > prevShortStop ? longStop : ma < prevLongStop ? shortStop : 0;
                    decimal ott = ma > mt ? mt * (200 + percent) / 200 : mt * (200 - percent) / 200;
                    ottList.Add(ott);

                    var signal = GetCompareSignal(currentValue - ott, prevValue - prevOtt);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (farkList, longStopList, shortStopList, ottList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateSigmaSpikes(StockData stockDataClass, string maType, int days = 20)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Sigma Spikes [CC] script may be freely distributed under the MIT license.
            //study("Sigma Spikes [CC]", shorttitle = "SS", overlay = false)

            //inp = input(title = "Source", type = input.source, defval = close)
            //length = input(title = "Length", type = input.integer, defval = 20, minval = 1)
            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //src = security(syminfo.tickerid, res, inp[rep ? 0 : barstate.isrealtime ? 1 : 0])[rep ? 0 : barstate.isrealtime ? 0 : 1]

            //ret = (src / nz(src[1])) - 1
            //std = stdev(ret, length)
            //sigma = nz(std[1]) != 0 ? ret / nz(std[1]) : 0
            //ss = ema(sigma, length)

            //sig = ss > 0 ? 1 : ss < 0 ? -1 : 0
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //ssColor = sig > 0 ? color.green : sig < 0 ? color.red : color.black
            //barcolor(bar ? ssColor : na)
            //plot(sigma, title = "SIGMA", color = ssColor, linewidth = 2)
            //plot(ss, title = "SS", color = color.black, linewidth = 1)
            List<decimal> retList = new();
            List<decimal> stdList = new();
            List<decimal> sigmaList = new();
            List<decimal> ssList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal ret = prevValue != 0 ? (currentValue / prevValue) - 1 : 0;
                    retList.Add(ret);
                }

                stdList = CalculateStandardDeviationVolatility(retList, stockDataClass, days).Item4;
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal prevStd = j >= 1 ? stdList.ElementAtOrDefault(j - 1) : 0;
                    decimal ret = retList.ElementAtOrDefault(j);

                    decimal sigma = prevStd != 0 ? ret / prevStd : 0;
                    sigmaList.Add(sigma);
                }

                ssList = GetMovingAverageList(maType, sigmaList, stockDataClass, days);
                for (int k = 0; k < stockDataClass.InputValues.Count; k++)
                {
                    decimal ss = ssList.ElementAtOrDefault(k);
                    decimal prevSs = k >= 1 ? ssList.ElementAtOrDefault(k - 1) : 0;

                    var signal = GetCompareSignal(ss, prevSs);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (stdList, sigmaList, ssList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateEhlersSpearmanRankIndicator(StockData stockDataClass, int days = 20)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Ehlers Spearman Rank Indicator [CC] script may be freely distributed under the MIT license.
            //study("Ehlers Spearman Rank Indicator [CC]", overlay = false)

            //inp = input(title = "Source", type = input.source, defval = close)
            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //src = security(syminfo.tickerid, res, inp[rep ? 0 : barstate.isrealtime ? 1 : 0])[rep ? 0 : barstate.isrealtime ? 0 : 1]
            //length = input(title = "Length", type = input.integer, defval = 20, minval = 1)

            //priceArray = array.new_float(50, 0.0)
            //rank = array.new_float(50, 0.0)
            //for i = 1 to length
            //    array.set(priceArray, i, nz(src[i - 1]))
            //    array.set(rank, i, i)

            //for i = 1 to length
            //    count = length + 1 - i
            //    for j = 1 to length - count
            //        if array.get(priceArray, j + 1) < array.get(priceArray, j)
            //            tempPrice = array.get(priceArray, j)
            //            tempRank = array.get(rank, j)
            //            array.set(priceArray, j, array.get(priceArray, j + 1))
            //            array.set(rank, j, array.get(rank, j + 1))
            //            array.set(priceArray, j + 1, tempPrice)
            //            array.set(rank, j + 1, tempRank)

            //sum = 0.0
            //for i = 1 to length
            //    sum := sum + pow(i - array.get(rank, i), 2)
            //signal = 2 * (0.5 - (1 - ((6 * sum) / (length * (pow(length, 2) - 1)))))

            //sig = signal > 0 ? 1 : signal < 0 ? -1 : 0
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //sriColor = sig > 0 ? color.green : sig < 0 ? color.red : color.black
            //barcolor(bar ? sriColor : na)
            //plot(signal, title = "Signal", linewidth = 2, color = sriColor)
            List<decimal> sumList = new();
            List<decimal> sriList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    var priceArray = new decimal[50];
                    var rankArray = new decimal[50];
                    for (int j = 0; j < days; j++)
                    {
                        var prevPrice = i >= j - 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - j - 1) : 0;
                        priceArray[j] = prevPrice;
                        rankArray[j] = j;
                    }

                    for (int j = 0; j < days; j++)
                    {
                        var count = days + 1 - j;

                        for (int k = 0; k < days - count; k++)
                        {
                            var array1 = priceArray[k + 1];

                            if (array1 < priceArray[k])
                            {
                                var tempPrice = priceArray[k];
                                var tempRank = rankArray[k];

                                priceArray[k] = array1;
                                rankArray[k] = rankArray[k + 1];
                                priceArray[k + 1] = tempPrice;
                                rankArray[k + 1] = tempRank;
                            }
                        }
                    }

                    decimal sum = 0;
                    for (int j = 0; j < days; j++)
                    {
                        sum += Pow(j - rankArray[j], 2);
                    }
                    sumList.Add(sum);

                    decimal prevSri = sriList.LastOrDefault();
                    decimal sri = 2 * (0.5m - (1 - (6 * sum / (days * (Pow(days, 2) - 1)))));
                    sriList.Add(sri);

                    var signal = GetCompareSignal(sri, prevSri);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (sumList, sriList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateEhlersNoiseEliminationTechnology(StockData stockDataClass, int days = 14)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Ehlers Noise Elimination Technology [CC] script may be freely distributed under the MIT license.
            //study("Ehlers Noise Elimination Technology [CC]", overlay = false)

            //inp = input(title = "Source", type = input.source, defval = close)
            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //src = security(syminfo.tickerid, res, inp[rep ? 0 : barstate.isrealtime ? 1 : 0])[rep ? 0 : barstate.isrealtime ? 0 : 1]
            //length = input(title = "Length", type = input.integer, defval = 14, minval = 1)

            //x = array.new_float(100, 0.0)
            //for i = 1 to length
            //    array.set(x, i, nz(src[i - 1]))

            //num = 0.0
            //for i = 2 to length
            //    for j = 1 to i - 1
            //        num := num - sign(array.get(x, i) - array.get(x, j))
            //denom = 0.5 * length * (length - 1)
            //net = denom != 0 ? num / denom : 0

            //sig = net > 0 ? 1 : net < 0 ? -1 : 0
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //sriColor = sig > 0 ? color.green : sig < 0 ? color.red : color.black
            //barcolor(bar ? sriColor : na)
            //plot(net, title = "Signal", linewidth = 2, color = sriColor)
            List<decimal> netList = new();
            List<decimal> numList = new();
            List<Signal> signalsList = new();

            try
            {
                decimal denom = 0.5m * days * (days - 1);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    var xArray = new decimal[50];
                    for (int j = 0; j < days; j++)
                    {
                        var prevPrice = i >= j - 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - j - 1) : 0;
                        xArray[j] = prevPrice;
                    }

                    decimal num = 0;
                    for (int j = 1; j < days; j++)
                    {
                        for (int k = 0; k < j - 1; k++)
                        {
                            num -= Math.Sign(xArray[j] - xArray[k]);
                        }
                    }
                    numList.Add(num);

                    decimal prevNet = netList.LastOrDefault();
                    decimal net = denom != 0 ? num / denom : 0;
                    netList.Add(net);

                    var signal = GetCompareSignal(net, prevNet);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (numList, netList, signalsList);
        }

        public static (List<decimal>, List<Signal>) CalculateEhlersTruncatedBandPassFilter(StockData stockDataClass, int days = 10)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Ehlers Truncated BandPass Filter [CC] script may be freely distributed under the MIT license.
            //study("Ehlers Truncated BandPass Filter [CC]", overlay = false)

            //inp = input(title = "Source", type = input.source, defval = close)
            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //src = security(syminfo.tickerid, res, inp[rep ? 0 : barstate.isrealtime ? 1 : 0])[rep ? 0 : barstate.isrealtime ? 0 : 1]
            //period = input(title = "Period", type = input.integer, defval = 20, minval = 1)
            //length = input(title = "Length", type = input.integer, defval = 10, minval = 1)
            //bw = input(title = "Bandwidth", type = input.float, defval = 0.1, minval = 0.01, step = 0.01)

            //pi = 2 * asin(1)
            //l1 = cos(2 * pi / period)
            //g1 = cos(bw * 2 * pi / period)
            //s1 = (1 / g1) - sqrt((1 / pow(g1, 2)) - 1)

            //trun = array.new_float(100, 0.0)
            //array.fill(trun, 0)
            //for i = length to 1
            //    array.set(trun, i, (0.5 * (1 - s1) * (nz(src[i - 1]) - nz(src[i + 1]))) + (l1 * (1 + s1) * array.get(trun, i + 1)) - (s1 * array.get(trun, i + 2)))
            //bpt = array.get(trun, 1)

            //sig = bpt > 0 ? 1 : bpt < 0 ? -1 : 0
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //sigColor = sig > 0 ? color.green : sig < 0 ? color.red : color.black
            //barcolor(bar ? sigColor : na)
            //plot(bpt, title = "BandPassTrunc", color = sigColor, linewidth = 2)
            List<decimal> bptList = new();
            List<Signal> signalsList = new();

            try
            {
                int length = days;
                int period = length * 2;
                decimal bw = 0.1m;
                decimal l1 = (decimal)Cos((double)MinOrMax(2 * Math.PI / period, 0.99, 0.01));
                decimal g1 = (decimal)Cos((double)bw * 2 * Math.PI / period);
                decimal s1 = (1 / g1) - (decimal)Sqrt((double)(1 / Pow(g1, 2)) - 1);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    var trunArray = new decimal[100];
                    for (int j = length; j > 0; j--)
                    {
                        decimal prevValue1 = i >= j - 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - j - 1) : 0;
                        decimal prevValue2 = i >= j + 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - (j + 1)) : 0;
                        trunArray[j] = (0.5m * (1 - s1) * (prevValue1 - prevValue2)) + (l1 * (1 + s1) * trunArray[j + 1]) - (s1 * trunArray[j + 2]);
                    }

                    decimal prevBpt = bptList.LastOrDefault();
                    decimal bpt = trunArray[1];
                    bptList.Add(bpt);

                    var signal = GetCompareSignal(bpt, prevBpt);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (bptList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>)
            CalculateEhlersAutoCorrelationIndicator(StockData stockDataClass, int days = 10)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Ehlers AutoCorrelation Indicator [CC] script may be freely distributed under the MIT license.
            //study("Ehlers AutoCorrelation Indicator [CC]", overlay = false)

            //inp = input(title = "Source", type = input.source, defval = close)
            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //src = security(syminfo.tickerid, res, inp[rep ? 0 : barstate.isrealtime ? 1 : 0])[rep ? 0 : barstate.isrealtime ? 0 : 1]
            //hpLength = input(title = "HPLength", type = input.integer, defval = 48, minval = 1)
            //ssfLength = input(title = "SSFLength", type = input.integer, defval = 10, minval = 1)

            //pi = 2 * asin(1)
            //twoPiPrd = 0.707 * 2 * pi / hpLength
            //a1 = (cos(twoPiPrd) + sin(twoPiPrd) - 1) / cos(twoPiPrd)
            //a2 = exp(-1.414 * pi / ssfLength)
            //beta = 2 * a2 * cos(1.414 * pi / ssfLength)
            //c2 = beta
            //c3 = -a2 * a2
            //c1 = 1 - c2 - c3

            //hp = 0.0
            //hp:= ((1 - (a1 / 2)) * (1 - (a1 / 2)) * (src - (2 * nz(src[1])) + nz(src[2]))) + (2 * (1 - a1) * nz(hp[1])) - ((1 - a1) * (1 - a1) * nz(hp[2]))

            //rfilt = 0.0
            //rfilt:= (c1 * ((hp + nz(hp[1])) / 2)) + (c2 * nz(rfilt[1])) + (c3 * nz(rfilt[2]))

            //corr = 0.0, sx = 0.0, sy = 0.0, sxx = 0.0, syy = 0.0, sxy = 0.0
            //for i = 0 to hpLength
            //    x = nz(rfilt[i])
            //    y = nz(rfilt[hpLength + i])
            //    sx := sx + x
            //    sy := sy + y
            //    sxx := sxx + (x * x)
            //    sxy := sxy + (x * y)
            //    syy := syy + (y * y)

            //    corr := ((i * sxx) - (sx * sx)) * ((i * syy) - (sy * sy)) > 0 ? ((i * sxy) - (sx * sy)) / sqrt(((i * sxx) - (sx * sx)) * ((i * syy) - (sy * sy))) : 0
            //    corr := 0.5 * (corr + 1)

            //corrSig = 0.0
            //corrSig := (c1 * ((corr + nz(corr[1])) / 2)) + (c2 * nz(corrSig[1])) + (c3 * nz(corrSig[2]))

            //sig = corr > corrSig ? 1 : corr < corrSig ? -1 : 0
            //corrColor = sig > 0 ? color.green : sig < 0 ? color.red : color.black
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //barcolor(bar ? corrColor : na)
            //plot(corr, title = "Correlation", color = corrColor, linewidth = 2)
            //plot(corrSig, title = "CorrelationSignal", color = color.black, linewidth = 1)
            List<decimal> corrList = new();
            List<decimal> sxList = new();
            List<decimal> syList = new();
            List<decimal> sxxList = new();
            List<decimal> syyList = new();
            List<decimal> sxyList = new();
            List<decimal> xList = new();
            List<decimal> yList = new();
            List<decimal> xxList = new();
            List<decimal> yyList = new();
            List<decimal> xyList = new();
            List<Signal> signalsList = new();

            try
            {
                var hpLength = (int)Math.Ceiling(days / 0.2084);

                var roofingFilterList = CalculateEhlersRoofingFilter(stockDataClass, days).Item2;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal prevCorr1 = i >= 1 ? corrList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevCorr2 = i >= 2 ? corrList.ElementAtOrDefault(i - 2) : 0;

                    decimal x = roofingFilterList.ElementAtOrDefault(i);
                    xList.Add(x);

                    decimal y = i >= hpLength ? roofingFilterList.ElementAtOrDefault(i - hpLength) : 0;
                    yList.Add(y);

                    decimal xx = x * x;
                    xxList.Add(xx);

                    decimal yy = y * y;
                    yyList.Add(yy);

                    decimal xy = x * y;
                    xyList.Add(xy);

                    decimal sx = xList.TakeLast(hpLength).Sum();
                    sxList.Add(sx);

                    decimal sy = yList.TakeLast(hpLength).Sum();
                    syList.Add(sy);

                    decimal sxx = xxList.TakeLast(hpLength).Sum();
                    sxxList.Add(sxx);

                    decimal syy = yyList.TakeLast(hpLength).Sum();
                    syyList.Add(syy);

                    decimal sxy = xyList.TakeLast(hpLength).Sum();
                    sxyList.Add(sxy);

                    decimal corr = ((i * sxx) - (sx * sx)) * ((i * syy) - (sy * sy)) > 0 ? 0.5m * ((((i * sxy) - (sx * sy)) / Sqrt(((i * sxx) - (sx * sx)) * ((i * syy) - (sy * sy)))) + 1) : 0;
                    corrList.Add(corr);

                    var signal = GetCompareSignal(corr - prevCorr1, prevCorr1 - prevCorr2);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (yList, xxList, yyList, xyList, sxList, syList, sxxList, syyList, sxyList, corrList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateEhlersAutoCorrelationPeriodogram(
            StockData stockDataClass, int days = 3)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Ehlers AutoCorrelation Periodogram [CC] script may be freely distributed under the MIT license.
            //study("Ehlers AutoCorrelation Periodogram [CC]", overlay = false)

            //inp = input(title = "Source", type = input.source, defval = close)
            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //src = security(syminfo.tickerid, res, inp[rep ? 0 : barstate.isrealtime ? 1 : 0])[rep ? 0 : barstate.isrealtime ? 0 : 1]
            //hpLength = input(title = "HPLength", type = input.integer, defval = 48, minval = 1)
            //ssfLength = input(title = "SSFLength", type = input.integer, defval = 10, minval = 1)
            //avgLength = input(title = "AvgLength", type = input.integer, defval = 3, minval = 1)

            //pi = 2 * asin(1)
            //twoPiPrd = 0.707 * 2 * pi / hpLength
            //a1 = (cos(twoPiPrd) + sin(twoPiPrd) - 1) / cos(twoPiPrd)
            //a2 = exp(-1.414 * pi / ssfLength)
            //beta = 2 * a2 * cos(1.414 * pi / ssfLength)
            //c2 = beta
            //c3 = -a2 * a2
            //c1 = 1 - c2 - c3

            //hp = 0.0
            //hp:= (pow(1 - (a1 / 2), 2) * (src - (2 * nz(src[1])) + nz(src[2]))) + (2 * (1 - a1) * nz(hp[1])) - (pow(1 - a1, 2) * nz(hp[2]))

            //rfilt = 0.0
            //rfilt:= (c1 * ((hp + nz(hp[1])) / 2)) + (c2 * nz(rfilt[1])) + (c3 * nz(rfilt[2]))

            //corr = 0.0, sx = 0.0, sy = 0.0, sxx = 0.0, syy = 0.0, sxy = 0.0
            //for i = 0 to hpLength
            //    x = nz(rfilt[i])
            //    y = nz(rfilt[hpLength + i])
            //    sx := sx + x
            //    sy := sy + y
            //    sxx := sxx + (x * x)
            //    sxy := sxy + (x * y)
            //    syy := syy + (y * y)

            //    corr := ((i * sxx) - (sx * sx)) * ((i * syy) - (sy * sy)) > 0 ? ((i * sxy) - (sx * sy)) / sqrt(((i * sxx) - (sx * sx)) * ((i * syy) - (sy * sy))) : 0
            //    corr := 0.5 * (corr + 1)

            //sqSum = 0.0, r = 0.0, maxPwr = 0.0, pwr = 0.0, spx = 0.0, sp = 0.0
            //for i = ssfLength to hpLength

            //    cosPart = 0.0, sinPart = 0.0
            //    for n = avgLength to hpLength
            //        cosPart := cosPart + (nz(corr[n]) * cos(2 * pi * n / i))
            //        sinPart := sinPart + (nz(corr[n]) * sin(2 * pi * n / i))

            //    sqSum := pow(cosPart, 2) + pow(sinPart, 2)
            //    r := (0.2 * pow(sqSum, 2)) + (0.8 * nz(r[1]))
            //    maxPwr := r > maxPwr ? r : maxPwr
            //    pwr := r / maxPwr

            //    if pwr >= 0.5
            //        spx:= spx + (i * pwr)
            //        sp:= sp + pwr

            //domCyc = sp != 0 ? spx / sp : 0

            //sig = rfilt > 0 ? 1 : rfilt < 0 ? -1 : 0
            //corrColor = sig > 0 ? color.green : sig < 0 ? color.red : color.black
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //barcolor(bar ? corrColor : na)
            //plot(rfilt, title = "RoofingFilter", color = corrColor, linewidth = 2)
            //plot(domCyc, title = "DominantCycle", color = color.blue, linewidth = 2)
            List<decimal> corrList = new();
            List<decimal> sxList = new();
            List<decimal> syList = new();
            List<decimal> sxxList = new();
            List<decimal> syyList = new();
            List<decimal> sxyList = new();
            List<decimal> xList = new();
            List<decimal> yList = new();
            List<decimal> xxList = new();
            List<decimal> yyList = new();
            List<decimal> xyList = new();
            List<decimal> sqSumList = new();
            List<decimal> maxPwrList = new();
            List<decimal> pwrList = new();
            List<decimal> domCycList = new();
            List<decimal> spxList = new();
            List<decimal> spList = new();
            List<decimal> spxSumList = new();
            List<decimal> spSumList = new();
            List<decimal> rList = new();
            List<decimal> cosPartList = new();
            List<decimal> sinPartList = new();
            List<decimal> cosPartSumList = new();
            List<decimal> sinPartSumList = new();
            List<Signal> signalsList = new();

            try
            {
                int length = (int)Math.Ceiling(days / 0.3);
                int hpLength = (int)Math.Ceiling(length / 0.2084);

                var roofingFilterList = CalculateEhlersRoofingFilter(stockDataClass, days).Item2;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal value = ToRadians(360 * (decimal)days / (i + length));
                    decimal priorCorr = i >= days ? corrList.ElementAtOrDefault(i - days) : 0;
                    decimal prevCorr1 = i >= 1 ? corrList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevCorr2 = i >= 2 ? corrList.ElementAtOrDefault(i - 2) : 0;

                    decimal x = roofingFilterList.ElementAtOrDefault(i);
                    xList.Add(x);

                    decimal y = i >= days ? roofingFilterList.ElementAtOrDefault(i - days) : 0;
                    yList.Add(y);

                    decimal xx = x * x;
                    xxList.Add(xx);

                    decimal yy = y * y;
                    yyList.Add(yy);

                    decimal xy = x * y;
                    xyList.Add(xy);

                    decimal sx = xList.TakeLast(days).Sum();
                    sxList.Add(sx);

                    decimal sy = yList.TakeLast(days).Sum();
                    syList.Add(sy);

                    decimal sxx = xxList.TakeLast(days).Sum();
                    sxxList.Add(sxx);

                    decimal syy = yyList.TakeLast(days).Sum();
                    syyList.Add(syy);

                    decimal sxy = xyList.TakeLast(days).Sum();
                    sxyList.Add(sxy);

                    decimal corr = ((i * sxx) - (sx * sx)) * ((i * syy) - (sy * sy)) > 0 ? 0.5m * ((((i * sxy) - (sx * sy)) /
                        Sqrt(((i * sxx) - (sx * sx)) * ((i * syy) - (sy * sy)))) + 1) : 0;
                    corrList.Add(corr);

                    decimal cosPart = priorCorr * Cos(value);
                    cosPartList.Add(cosPart);

                    decimal sinPart = priorCorr * Sin(value);
                    sinPartList.Add(sinPart);

                    decimal cosPartSum = cosPartList.TakeLast(hpLength - days).Sum();
                    cosPartSumList.Add(cosPartSum);

                    decimal sinPartSum = sinPartList.TakeLast(hpLength - days).Sum();
                    sinPartSumList.Add(sinPartSum);

                    decimal sqSum = Pow(cosPartSum, 2) + Pow(sinPartSum, 2);
                    sqSumList.Add(sqSum);

                    decimal prevR = rList.LastOrDefault();
                    decimal r = (0.2m * Pow(sqSum, 2)) + (0.8m * prevR);
                    rList.Add(r);

                    decimal maxPwr = rList.TakeLast(hpLength - length).Max();
                    maxPwrList.Add(maxPwr);

                    decimal pwr = maxPwr != 0 ? r / maxPwr : 0;
                    pwrList.Add(pwr);

                    decimal spx = 0, sp = 0;
                    if (pwr >= 0.5m)
                    {
                        spx = (i + length) * pwr;
                        sp = pwr;
                    }
                    spxList.Add(spx);
                    spList.Add(sp);

                    decimal spxSum = spxList.TakeLast(hpLength - length).Sum();
                    spxSumList.Add(spxSum);

                    decimal spSum = spList.TakeLast(hpLength - length).Sum();
                    spSumList.Add(spSum);

                    decimal domCyc = spSum != 0 ? spxSum / spSum : 0;
                    domCycList.Add(domCyc);

                    var signal = GetCompareSignal(corr - prevCorr1, prevCorr1 - prevCorr2);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (yList, xxList, yyList, xyList, sxList, syList, sxxList, syyList, sxyList, corrList, cosPartList, sinPartList, cosPartSumList, sinPartSumList, sqSumList, rList, maxPwrList, pwrList, spxList, spList,
                spxSumList, spSumList, domCycList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateEhlersAdaptiveRelativeStrengthIndexV2(StockData stockDataClass, string maType, int days = 3)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Ehlers Adaptive Relative Strength Index V2 [CC] script may be freely distributed under the MIT license.
            //study("Ehlers Adaptive Relative Strength Index V2 [CC]", overlay = false)

            //inp = input(title = "Source", type = input.source, defval = close)
            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //src = security(syminfo.tickerid, res, inp[rep ? 0 : barstate.isrealtime ? 1 : 0])[rep ? 0 : barstate.isrealtime ? 0 : 1]
            //hpLength = input(title = "HPLength", type = input.integer, defval = 48, minval = 1)
            //ssfLength = input(title = "SSFLength", type = input.integer, defval = 10, minval = 1)
            //avgLength = input(title = "AvgLength", type = input.integer, defval = 3, minval = 1)
            //obLevel = input(title = "ObLevel", type = input.float, defval = 0.7, minval = 0.01, step = 0.01)
            //osLevel = input(title = "OsLevel", type = input.float, defval = 0.3, minval = 0.01, step = 0.01)

            //pi = 2 * asin(1)
            //twoPiPrd = 0.707 * 2 * pi / hpLength
            //a1 = (cos(twoPiPrd) + sin(twoPiPrd) - 1) / cos(twoPiPrd)
            //a2 = exp(-1.414 * pi / ssfLength)
            //beta = 2 * a2 * cos(1.414 * pi / ssfLength)
            //c2 = beta
            //c3 = -a2 * a2
            //c1 = 1 - c2 - c3

            //hp = 0.0
            //hp:= (pow(1 - (a1 / 2), 2) * (src - (2 * nz(src[1])) + nz(src[2]))) + (2 * (1 - a1) * nz(hp[1])) - (pow(1 - a1, 2) * nz(hp[2]))

            //rfilt = 0.0
            //rfilt:= (c1 * ((hp + nz(hp[1])) / 2)) + (c2 * nz(rfilt[1])) + (c3 * nz(rfilt[2]))

            //corr = 0.0, sx = 0.0, sy = 0.0, sxx = 0.0, syy = 0.0, sxy = 0.0
            //for i = 0 to hpLength
            //    x = nz(rfilt[i])
            //    y = nz(rfilt[hpLength + i])
            //    sx := sx + x
            //    sy := sy + y
            //    sxx := sxx + (x * x)
            //    sxy := sxy + (x * y)
            //    syy := syy + (y * y)

            //    corr := ((i * sxx) - (sx * sx)) * ((i * syy) - (sy * sy)) > 0 ? ((i * sxy) - (sx * sy)) / sqrt(((i * sxx) - (sx * sx)) * ((i * syy) - (sy * sy))) : 0
            //    corr := 0.5 * (corr + 1)

            //sqSum = 0.0, r = 0.0, maxPwr = 0.0, pwr = 0.0, spx = 0.0, sp = 0.0
            //for i = ssfLength to hpLength

            //    cosPart = 0.0, sinPart = 0.0
            //    for n = avgLength to hpLength
            //        cosPart := cosPart + (nz(corr[n]) * cos(2 * pi * n / i))
            //        sinPart := sinPart + (nz(corr[n]) * sin(2 * pi * n / i))

            //    sqSum := pow(cosPart, 2) + pow(sinPart, 2)
            //    r := (0.2 * pow(sqSum, 2)) + (0.8 * nz(r[1]))
            //    maxPwr := r > maxPwr ? r : maxPwr
            //    pwr := r / maxPwr

            //    if pwr >= 0.5
            //        spx:= spx + (i * pwr)
            //        sp:= sp + pwr

            //domCyc = sp != 0 ? spx / sp : 0
            //domCyc:= min(max(domCyc, ssfLength), hpLength)

            //upChg = 0.0, dnChg = 0.0
            //for i = 0 to ceil((domCyc / 2) - 1)
            //    filt = nz(rfilt[i])
            //    pFilt = nz(rfilt[i + 1])
            //    upChg := upChg + (filt > pFilt ? filt - pFilt : 0)
            //    dnChg := dnChg + (filt < pFilt ? pFilt - filt : 0)

            //denom = upChg + dnChg
            //arsi = 0.0
            //arsi := denom != 0 and nz(denom[1]) != 0 ? (c1 * (((upChg / denom) + (nz(upChg[1]) / nz(denom[1]))) / 2)) + (c2 * nz(arsi[1])) + (c3 * nz(arsi[2])) : 0
            //arsiEma = ema(arsi, ssfLength)

            //hline(obLevel, color = color.green)
            //hline(osLevel, color = color.red)
            //sig = arsi > arsiEma or(nz(arsi[1]) < osLevel and arsi > osLevel) ? 1 : arsi < arsiEma or(nz(arsi[1]) > obLevel and arsi < obLevel) ? -1 : 0
            //arsiColor = sig > 0 ? color.green : sig < 0 ? color.red : color.black
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //barcolor(bar ? arsiColor : na)
            //plot(arsi, title = "ARSI", color = arsiColor, linewidth = 2)
            //plot(arsiEma, title = "Signal", color = color.black, linewidth = 1)
            List<decimal> upChgList = new();
            List<decimal> dnChgList = new();
            List<decimal> denomList = new();
            List<decimal> arsiList = new();
            List<decimal> arsiEmaList = new();
            List<Signal> signalsList = new();

            try
            {
                int length = (int)Math.Ceiling(days / 0.3);
                int hpLength = (int)Math.Ceiling(length / 0.2084);
                decimal alphaArg = (decimal)Math.Min(0.707 * 2 * Math.PI / hpLength, 0.99);
                decimal alphaCos = Cos(alphaArg);
                decimal alpha1 = alphaCos != 0 ? (alphaCos + Sin(alphaArg) - 1) / alphaCos : 0;
                decimal a1 = Exp(-1.414 * 3.14159 / length);
                decimal b1 = 2 * a1 * Cos(Math.Min(ToRadians(1.414 * 180 / length), 0.99m));
                decimal c2 = b1;
                decimal c3 = -1 * a1 * a1;
                decimal c1 = 1 - c2 - c3;

                var domCycList = CalculateEhlersAutoCorrelationPeriodogram(stockDataClass, days).Item23;
                var roofingFilterList = CalculateEhlersRoofingFilter(stockDataClass, length).Item2;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal domCyc = MinOrMax(domCycList.ElementAtOrDefault(i), hpLength, length);
                    decimal prevArsi1 = i >= 1 ? arsiList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevArsi2 = i >= 2 ? arsiList.ElementAtOrDefault(i - 2) : 0;

                    decimal prevUpChg = upChgList.LastOrDefault();
                    decimal upChg = 0, dnChg = 0;
                    for (int j = 0; j < (int)Math.Ceiling(domCyc / 2); j++)
                    {
                        decimal filt = i >= j ? roofingFilterList.ElementAtOrDefault(i - j) : 0;
                        decimal prevFilt = i >= j + 1 ? roofingFilterList.ElementAtOrDefault(i - (j + 1)) : 0;
                        upChg += filt > prevFilt ? filt - prevFilt : 0;
                        dnChg += filt < prevFilt ? prevFilt - filt : 0;
                    }
                    upChgList.Add(upChg);
                    dnChgList.Add(dnChg);

                    decimal prevDenom = denomList.LastOrDefault();
                    decimal denom = upChg + dnChg;
                    denomList.Add(denom);

                    decimal arsi = denom != 0 && prevDenom != 0 ? (c1 * ((upChg / denom) + (prevUpChg / prevDenom)) / 2) + (c2 * prevArsi1) + (c3 * prevArsi2) : 0;
                    arsiList.Add(arsi);
                }

                arsiEmaList = GetMovingAverageList(maType, arsiList, stockDataClass, length);
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal arsi = arsiList.ElementAtOrDefault(j);
                    decimal arsiEma = arsiEmaList.ElementAtOrDefault(j);
                    decimal prevArsi = j >= 1 ? arsiList.ElementAtOrDefault(j - 1) : 0;
                    decimal prevArsiEma = j >= 1 ? arsiEmaList.ElementAtOrDefault(j - 1) : 0;

                    var signal = GetRsiSignal(arsi - arsiEma, prevArsi - prevArsiEma, arsi, prevArsi, 0.7m, 0.3m);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (upChgList, dnChgList, denomList, arsiList, arsiEmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateEhlersAdaptiveRsiV2FisherTransform(StockData stockDataClass, string maType, int days = 3)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Ehlers Adaptive Rsi V2 Fisher Transform [CC] script may be freely distributed under the MIT license.
            //study("Ehlers Adaptive Rsi V2 Fisher Transform [CC]", overlay = false)

            //inp = input(title = "Source", type = input.source, defval = close)
            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //src = security(syminfo.tickerid, res, inp[rep ? 0 : barstate.isrealtime ? 1 : 0])[rep ? 0 : barstate.isrealtime ? 0 : 1]
            //hpLength = input(title = "HPLength", type = input.integer, defval = 48, minval = 1)
            //ssfLength = input(title = "SSFLength", type = input.integer, defval = 10, minval = 1)
            //avgLength = input(title = "AvgLength", type = input.integer, defval = 3, minval = 1)
            //obLevel = input(title = "ObLevel", type = input.integer, defval = 2)
            //osLevel = input(title = "OsLevel", type = input.integer, defval = -2)

            //pi = 2 * asin(1)
            //twoPiPrd = 0.707 * 2 * pi / hpLength
            //a1 = (cos(twoPiPrd) + sin(twoPiPrd) - 1) / cos(twoPiPrd)
            //a2 = exp(-1.414 * pi / ssfLength)
            //beta = 2 * a2 * cos(1.414 * pi / ssfLength)
            //c2 = beta
            //c3 = -a2 * a2
            //c1 = 1 - c2 - c3

            //hp = 0.0
            //hp:= (pow(1 - (a1 / 2), 2) * (src - (2 * nz(src[1])) + nz(src[2]))) + (2 * (1 - a1) * nz(hp[1])) - (pow(1 - a1, 2) * nz(hp[2]))

            //rfilt = 0.0
            //rfilt:= (c1 * ((hp + nz(hp[1])) / 2)) + (c2 * nz(rfilt[1])) + (c3 * nz(rfilt[2]))

            //corr = 0.0, sx = 0.0, sy = 0.0, sxx = 0.0, syy = 0.0, sxy = 0.0
            //for i = 0 to hpLength
            //    x = nz(rfilt[i])
            //    y = nz(rfilt[hpLength + i])
            //    sx := sx + x
            //    sy := sy + y
            //    sxx := sxx + (x * x)
            //    sxy := sxy + (x * y)
            //    syy := syy + (y * y)

            //    corr := ((i * sxx) - (sx * sx)) * ((i * syy) - (sy * sy)) > 0 ? ((i * sxy) - (sx * sy)) / sqrt(((i * sxx) - (sx * sx)) * ((i * syy) - (sy * sy))) : 0
            //    corr := 0.5 * (corr + 1)

            //sqSum = 0.0, r = 0.0, maxPwr = 0.0, pwr = 0.0, spx = 0.0, sp = 0.0
            //for i = ssfLength to hpLength

            //    cosPart = 0.0, sinPart = 0.0
            //    for n = avgLength to hpLength
            //        cosPart := cosPart + (nz(corr[n]) * cos(2 * pi * n / i))
            //        sinPart := sinPart + (nz(corr[n]) * sin(2 * pi * n / i))

            //    sqSum := pow(cosPart, 2) + pow(sinPart, 2)
            //    r := (0.2 * pow(sqSum, 2)) + (0.8 * nz(r[1]))
            //    maxPwr := r > maxPwr ? r : maxPwr
            //    pwr := r / maxPwr

            //    if pwr >= 0.5
            //        spx:= spx + (i * pwr)
            //        sp:= sp + pwr

            //domCyc = sp != 0 ? spx / sp : 0
            //domCyc:= min(max(domCyc, ssfLength), hpLength)

            //upChg = 0.0, dnChg = 0.0
            //for i = 0 to ceil((domCyc / 2) - 1)
            //    filt = nz(rfilt[i])
            //    pFilt = nz(rfilt[i + 1])
            //    upChg := upChg + (filt > pFilt ? filt - pFilt : 0)
            //    dnChg := dnChg + (filt < pFilt ? pFilt - filt : 0)

            //denom = upChg + dnChg
            //arsi = 0.0
            //arsi := denom != 0 and nz(denom[1]) != 0 ? (c1 * (((upChg / denom) + (nz(upChg[1]) / nz(denom[1]))) / 2)) + (c2 * nz(arsi[1])) + (c3 * nz(arsi[2])) : 0

            //tranRsi = 2 * (arsi - 0.5)
            //ampRsi = 1.5 * tranRsi
            //ampRsi := min(max(ampRsi, -0.999), 0.999)
            //fish = 0.5 * log((1 + ampRsi) / (1 - ampRsi))

            //hline(obLevel, color = color.green)
            //hline(osLevel, color = color.red)
            //sig = fish > 0 or(nz(fish[1]) < osLevel and fish > osLevel) ? 1 : fish < 0 or(nz(fish[1]) > obLevel and fish < obLevel) ? -1 : 0
            //arsiftColor = sig > 0 ? color.green : sig < 0 ? color.red : color.black
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //barcolor(bar ? arsiftColor : na)
            //plot(fish, title = "FISH", color = arsiftColor, linewidth = 2)
            List<decimal> tranRsiList = new();
            List<decimal> ampRsiList = new();
            List<decimal> fishList = new();
            List<Signal> signalsList = new();

            try
            {
                var arsiList = CalculateEhlersAdaptiveRelativeStrengthIndexV2(stockDataClass, maType, days).Item4;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal arsi = arsiList.ElementAtOrDefault(i) / 100;
                    decimal prevFish1 = i >= 1 ? fishList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevFish2 = i >= 2 ? fishList.ElementAtOrDefault(i - 2) : 0;

                    decimal tranRsi = 2 * (arsi - 0.5m);
                    tranRsiList.Add(tranRsi);

                    decimal ampRsi = MinOrMax(1.5m * tranRsi, 0.999m, -0.999m);
                    ampRsiList.Add(ampRsi);

                    decimal fish = 0.5m * Log((1 + ampRsi) / (1 - ampRsi));
                    fishList.Add(fish);

                    var signal = GetRsiSignal(fish - prevFish1, prevFish1 - prevFish2, fish, prevFish1, 2, -2);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (tranRsiList, ampRsiList, fishList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateEhlersAdaptiveStochasticIndicatorV2(StockData stockDataClass, string maType, int days = 3)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Ehlers Adaptive Stochastic Indicator V2 [CC] script may be freely distributed under the MIT license.
            //study("Ehlers Adaptive Stochastic Indicator V2 [CC]", overlay = false)

            //inp = input(title = "Source", type = input.source, defval = close)
            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //src = security(syminfo.tickerid, res, inp[rep ? 0 : barstate.isrealtime ? 1 : 0])[rep ? 0 : barstate.isrealtime ? 0 : 1]
            //hpLength = input(title = "HPLength", type = input.integer, defval = 48, minval = 1)
            //ssfLength = input(title = "SSFLength", type = input.integer, defval = 10, minval = 1)
            //avgLength = input(title = "AvgLength", type = input.integer, defval = 3, minval = 1)
            //obLevel = input(title = "ObLevel", type = input.float, defval = 0.7, minval = 0.01, step = 0.01)
            //osLevel = input(title = "OsLevel", type = input.float, defval = 0.3, minval = 0.01, step = 0.01)

            //pi = 2 * asin(1)
            //twoPiPrd = 0.707 * 2 * pi / hpLength
            //a1 = (cos(twoPiPrd) + sin(twoPiPrd) - 1) / cos(twoPiPrd)
            //a2 = exp(-1.414 * pi / ssfLength)
            //beta = 2 * a2 * cos(1.414 * pi / ssfLength)
            //c2 = beta
            //c3 = -a2 * a2
            //c1 = 1 - c2 - c3

            //hp = 0.0
            //hp:= (pow(1 - (a1 / 2), 2) * (src - (2 * nz(src[1])) + nz(src[2]))) + (2 * (1 - a1) * nz(hp[1])) - (pow(1 - a1, 2) * nz(hp[2]))

            //rfilt = 0.0
            //rfilt:= (c1 * ((hp + nz(hp[1])) / 2)) + (c2 * nz(rfilt[1])) + (c3 * nz(rfilt[2]))

            //corr = 0.0, sx = 0.0, sy = 0.0, sxx = 0.0, syy = 0.0, sxy = 0.0
            //for i = 0 to hpLength
            //    x = nz(rfilt[i])
            //    y = nz(rfilt[hpLength + i])
            //    sx := sx + x
            //    sy := sy + y
            //    sxx := sxx + (x * x)
            //    sxy := sxy + (x * y)
            //    syy := syy + (y * y)

            //    corr := ((i * sxx) - (sx * sx)) * ((i * syy) - (sy * sy)) > 0 ? ((i * sxy) - (sx * sy)) / sqrt(((i * sxx) - (sx * sx)) * ((i * syy) - (sy * sy))) : 0
            //    corr := 0.5 * (corr + 1)

            //sqSum = 0.0, r = 0.0, maxPwr = 0.0, pwr = 0.0, spx = 0.0, sp = 0.0
            //for i = ssfLength to hpLength

            //    cosPart = 0.0, sinPart = 0.0
            //    for n = avgLength to hpLength
            //        cosPart := cosPart + (nz(corr[n]) * cos(2 * pi * n / i))
            //        sinPart := sinPart + (nz(corr[n]) * sin(2 * pi * n / i))

            //    sqSum := pow(cosPart, 2) + pow(sinPart, 2)
            //    r := (0.2 * pow(sqSum, 2)) + (0.8 * nz(r[1]))
            //    maxPwr := r > maxPwr ? r : maxPwr
            //    pwr := r / maxPwr

            //    if pwr >= 0.5
            //        spx:= spx + (i * pwr)
            //        sp:= sp + pwr

            //domCyc = sp != 0 ? spx / sp : 0
            //domCyc:= min(max(domCyc, ssfLength), hpLength)

            //highestC = rfilt, lowestC = rfilt
            //for i = 0 to domCyc - 1
            //    filt = nz(rfilt[i])
            //    highestC := filt > highestC ? filt : highestC
            //    lowestC := filt < lowestC ? filt : lowestC

            //stoc = highestC != lowestC ? (rfilt - lowestC) / (highestC - lowestC) : 0
            //astoc = 0.0
            //astoc := (c1 * ((stoc + nz(stoc[1])) / 2)) + (c2 * nz(astoc[1])) + (c3 * nz(astoc[2]))
            //astocEma = ema(astoc, ssfLength)

            //hline(obLevel, color = color.green)
            //hline(osLevel, color = color.red)
            //sig = astoc > astocEma or(nz(astoc[1]) < osLevel and astoc > osLevel) ? 1 : astoc < astocEma or(nz(astoc[1]) > obLevel and astoc < obLevel) ? -1 : 0
            //astocColor = sig > 0 ? color.green : sig < 0 ? color.red : color.black
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //barcolor(bar ? astocColor : na)
            //plot(astoc, title = "ASTOC", color = astocColor, linewidth = 2)
            //plot(astocEma, title = "Signal", color = color.black, linewidth = 1)
            List<decimal> highestList = new();
            List<decimal> lowestList = new();
            List<decimal> stocList = new();
            List<decimal> astocList = new();
            List<decimal> astocEmaList = new();
            List<Signal> signalsList = new();

            try
            {
                int length = (int)Math.Ceiling(days / 0.3);
                int hpLength = (int)Math.Ceiling(length / 0.2084);
                decimal alphaArg = (decimal)Math.Min(0.707 * 2 * Math.PI / hpLength, 0.99);
                decimal alphaCos = Cos(alphaArg);
                decimal alpha1 = alphaCos != 0 ? (alphaCos + Sin(alphaArg) - 1) / alphaCos : 0;
                decimal a1 = Exp(-1.414 * 3.14159 / length);
                decimal b1 = 2 * a1 * Cos(Math.Min(ToRadians(1.414 * 180 / length), 0.99m));
                decimal c2 = b1;
                decimal c3 = -1 * a1 * a1;
                decimal c1 = 1 - c2 - c3;

                var domCycList = CalculateEhlersAutoCorrelationPeriodogram(stockDataClass, days).Item23;
                var roofingFilterList = CalculateEhlersRoofingFilter(stockDataClass, length).Item2;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal domCyc = MinOrMax(domCycList.ElementAtOrDefault(i), hpLength, length);
                    decimal roofingFilter = roofingFilterList.ElementAtOrDefault(i);
                    decimal prevAstoc1 = i >= 1 ? astocList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevAstoc2 = i >= 2 ? astocList.ElementAtOrDefault(i - 2) : 0;

                    decimal highest = 0, lowest = 0;
                    for (int j = 0; j < (int)Math.Ceiling(domCyc); j++)
                    {
                        decimal filt = i >= j ? roofingFilterList.ElementAtOrDefault(i - j) : 0;
                        highest = filt > highest ? filt : highest;
                        lowest = filt < lowest ? filt : lowest;
                    }
                    highestList.Add(highest);
                    lowestList.Add(lowest);

                    decimal prevStoc = stocList.LastOrDefault();
                    decimal stoc = highest != lowest ? (roofingFilter - lowest) / (highest - lowest) : 0;
                    stocList.Add(stoc);

                    decimal astoc = (c1 * ((stoc + prevStoc) / 2)) + (c2 * prevAstoc1) + (c3 * prevAstoc2);
                    astocList.Add(astoc);
                }

                astocEmaList = GetMovingAverageList(maType, astocList, stockDataClass, length);
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal astoc = astocList.ElementAtOrDefault(j);
                    decimal astocEma = astocEmaList.ElementAtOrDefault(j);
                    decimal prevAstoc = j >= 1 ? astocList.ElementAtOrDefault(j - 1) : 0;
                    decimal prevAstocEma = j >= 1 ? astocEmaList.ElementAtOrDefault(j - 1) : 0;

                    var signal = GetRsiSignal(astoc - astocEma, prevAstoc - prevAstocEma, astoc, prevAstoc, 0.7m, 0.3m);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (highestList, lowestList, stocList, astocList, astocEmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateEhlersAdaptiveStochasticInverseFisherTransform(StockData stockDataClass, string maType, int days = 3)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Ehlers Adaptive Stochastic Inverse Fisher Transform [CC] script may be freely distributed under the MIT license.
            //study("Ehlers Adaptive Stochastic Inverse Fisher Transform [CC]", overlay = false)

            //inp = input(title = "Source", type = input.source, defval = close)
            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //src = security(syminfo.tickerid, res, inp[rep ? 0 : barstate.isrealtime ? 1 : 0])[rep ? 0 : barstate.isrealtime ? 0 : 1]
            //hpLength = input(title = "HPLength", type = input.integer, defval = 48, minval = 1)
            //ssfLength = input(title = "SSFLength", type = input.integer, defval = 10, minval = 1)
            //avgLength = input(title = "AvgLength", type = input.integer, defval = 3, minval = 1)

            //pi = 2 * asin(1)
            //twoPiPrd = 0.707 * 2 * pi / hpLength
            //a1 = (cos(twoPiPrd) + sin(twoPiPrd) - 1) / cos(twoPiPrd)
            //a2 = exp(-1.414 * pi / ssfLength)
            //beta = 2 * a2 * cos(1.414 * pi / ssfLength)
            //c2 = beta
            //c3 = -a2 * a2
            //c1 = 1 - c2 - c3

            //hp = 0.0
            //hp:= (pow(1 - (a1 / 2), 2) * (src - (2 * nz(src[1])) + nz(src[2]))) + (2 * (1 - a1) * nz(hp[1])) - (pow(1 - a1, 2) * nz(hp[2]))

            //rfilt = 0.0
            //rfilt:= (c1 * ((hp + nz(hp[1])) / 2)) + (c2 * nz(rfilt[1])) + (c3 * nz(rfilt[2]))

            //corr = 0.0, sx = 0.0, sy = 0.0, sxx = 0.0, syy = 0.0, sxy = 0.0
            //for i = 0 to hpLength
            //    x = nz(rfilt[i])
            //    y = nz(rfilt[hpLength + i])
            //    sx := sx + x
            //    sy := sy + y
            //    sxx := sxx + (x * x)
            //    sxy := sxy + (x * y)
            //    syy := syy + (y * y)

            //    corr := ((i * sxx) - (sx * sx)) * ((i * syy) - (sy * sy)) > 0 ? ((i * sxy) - (sx * sy)) / sqrt(((i * sxx) - (sx * sx)) * ((i * syy) - (sy * sy))) : 0
            //    corr := 0.5 * (corr + 1)

            //sqSum = 0.0, r = 0.0, maxPwr = 0.0, pwr = 0.0, spx = 0.0, sp = 0.0
            //for i = ssfLength to hpLength

            //    cosPart = 0.0, sinPart = 0.0
            //    for n = avgLength to hpLength
            //        cosPart := cosPart + (nz(corr[n]) * cos(2 * pi * n / i))
            //        sinPart := sinPart + (nz(corr[n]) * sin(2 * pi * n / i))

            //    sqSum := pow(cosPart, 2) + pow(sinPart, 2)
            //    r := (0.2 * pow(sqSum, 2)) + (0.8 * nz(r[1]))
            //    maxPwr := r > maxPwr ? r : maxPwr
            //    pwr := r / maxPwr

            //    if pwr >= 0.5
            //        spx:= spx + (i * pwr)
            //        sp:= sp + pwr

            //domCyc = sp != 0 ? spx / sp : 0
            //domCyc:= min(max(domCyc, ssfLength), hpLength)

            //highestC = rfilt, lowestC = rfilt
            //for i = 0 to domCyc - 1
            //    filt = nz(rfilt[i])
            //    highestC := filt > highestC ? filt : highestC
            //    lowestC := filt < lowestC ? filt : lowestC

            //stoc = highestC != lowestC ? (rfilt - lowestC) / (highestC - lowestC) : 0
            //astoc = 0.0
            //astoc := (c1 * ((stoc + nz(stoc[1])) / 2)) + (c2 * nz(astoc[1])) + (c3 * nz(astoc[2]))

            //v1 = 2 * (astoc - 0.5)
            //ifish = (exp(2 * 3 * v1) - 1) / (exp(2 * 3 * v1) + 1)
            //trigger = 0.9 * nz(ifish[1])

            //sig = ifish > trigger ? 1 : ifish < trigger ? -1 : 0
            //asiftColor = sig > 0 ? color.green : sig < 0 ? color.red : color.black
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //barcolor(bar ? asiftColor : na)
            //plot(ifish, title = "IFISH", color = asiftColor, linewidth = 2)
            //plot(trigger, title = "Signal", color = color.black, linewidth = 1)
            List<decimal> v1List = new();
            List<decimal> fishList = new();
            List<decimal> triggerList = new();
            List<Signal> signalsList = new();

            try
            {
                var astocList = CalculateEhlersAdaptiveStochasticIndicatorV2(stockDataClass, maType, days).Item4;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal astoc = astocList.ElementAtOrDefault(i);

                    decimal v1 = 2 * (astoc - 0.5m);
                    v1List.Add(v1);

                    decimal prevFish = fishList.LastOrDefault();
                    decimal fish = (Exp(6 * v1) - 1) / (Exp(6 * v1) + 1);
                    fishList.Add(fish);

                    decimal prevTrigger = triggerList.LastOrDefault();
                    decimal trigger = 0.9m * prevFish;
                    triggerList.Add(trigger);

                    var signal = GetCompareSignal(fish - trigger, prevFish - prevTrigger);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (v1List, fishList, triggerList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateEhlersAdaptiveCommodityChannelIndexV2(
            StockData stockDataClass, string maType, int days = 3)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Ehlers Adaptive Commodity Channel Index V2 [CC] script may be freely distributed under the MIT license.
            //study("Ehlers Adaptive Commodity Channel Index V2 [CC]", overlay = false)

            //inp = input(title = "Source", type = input.source, defval = close)
            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //src = security(syminfo.tickerid, res, inp[rep ? 0 : barstate.isrealtime ? 1 : 0])[rep ? 0 : barstate.isrealtime ? 0 : 1]
            //hpLength = input(title = "HPLength", type = input.integer, defval = 48, minval = 1)
            //ssfLength = input(title = "SSFLength", type = input.integer, defval = 10, minval = 1)
            //avgLength = input(title = "AvgLength", type = input.integer, defval = 3, minval = 1)
            //obLevel = input(title = "ObLevel", type = input.integer, defval = 100, minval = 1)
            //osLevel = input(title = "OsLevel", type = input.integer, defval = -100, minval = 1)

            //pi = 2 * asin(1)
            //twoPiPrd = 0.707 * 2 * pi / hpLength
            //a1 = (cos(twoPiPrd) + sin(twoPiPrd) - 1) / cos(twoPiPrd)
            //a2 = exp(-1.414 * pi / ssfLength)
            //beta = 2 * a2 * cos(1.414 * pi / ssfLength)
            //c2 = beta
            //c3 = -a2 * a2
            //c1 = 1 - c2 - c3

            //hp = 0.0
            //hp:= (pow(1 - (a1 / 2), 2) * (src - (2 * nz(src[1])) + nz(src[2]))) + (2 * (1 - a1) * nz(hp[1])) - (pow(1 - a1, 2) * nz(hp[2]))

            //rfilt = 0.0
            //rfilt:= (c1 * ((hp + nz(hp[1])) / 2)) + (c2 * nz(rfilt[1])) + (c3 * nz(rfilt[2]))

            //corr = 0.0, sx = 0.0, sy = 0.0, sxx = 0.0, syy = 0.0, sxy = 0.0
            //for i = 0 to hpLength
            //    x = nz(rfilt[i])
            //    y = nz(rfilt[hpLength + i])
            //    sx := sx + x
            //    sy := sy + y
            //    sxx := sxx + (x * x)
            //    sxy := sxy + (x * y)
            //    syy := syy + (y * y)

            //    corr := ((i * sxx) - (sx * sx)) * ((i * syy) - (sy * sy)) > 0 ? ((i * sxy) - (sx * sy)) / sqrt(((i * sxx) - (sx * sx)) * ((i * syy) - (sy * sy))) : 0
            //    corr := 0.5 * (corr + 1)

            //sqSum = 0.0, r = 0.0, maxPwr = 0.0, pwr = 0.0, spx = 0.0, sp = 0.0
            //for i = ssfLength to hpLength

            //    cosPart = 0.0, sinPart = 0.0
            //    for n = avgLength to hpLength
            //        cosPart := cosPart + (nz(corr[n]) * cos(2 * pi * n / i))
            //        sinPart := sinPart + (nz(corr[n]) * sin(2 * pi * n / i))

            //    sqSum := pow(cosPart, 2) + pow(sinPart, 2)
            //    r := (0.2 * pow(sqSum, 2)) + (0.8 * nz(r[1]))
            //    maxPwr := r > maxPwr ? r : maxPwr
            //    pwr := r / maxPwr

            //    if pwr >= 0.5
            //        spx:= spx + (i * pwr)
            //        sp:= sp + pwr

            //domCyc = sp != 0 ? spx / sp : 0
            //domCyc:= min(max(domCyc, ssfLength), hpLength)

            //avgPrice = 0.0
            //for i = 0 to domCyc - 1
            //    avgPrice := avgPrice + nz(rfilt[i])
            //avgPrice := avgPrice / domCyc

            //rms = 0.0
            //for i = 0 to domCyc - 1
            //    rms := rms + pow(nz(rfilt[i]) - avgPrice, 2)
            //rms := sqrt(rms / domCyc)

            //num = rfilt - avgPrice
            //denom = 0.015 * rms
            //ratio = denom != 0 ? num / denom : 0

            //acci = 0.0
            //acci := (c1 * ((ratio + nz(ratio[1])) / 2)) + (c2 * nz(acci[1])) + (c3 * nz(acci[2]))
            //acciEma = ema(acci, ssfLength)

            //hline(obLevel, color = color.green)
            //hline(osLevel, color = color.red)
            //sig = acci > acciEma or(nz(acci[1]) < osLevel and acci > osLevel) ? 1 : acci < acciEma or(nz(acci[1]) > obLevel and acci < obLevel) ? -1 : 0
            //acciColor = sig > 0 ? color.green : sig < 0 ? color.red : color.black
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //barcolor(bar ? acciColor : na)
            //plot(acci, title = "ACCI", color = acciColor, linewidth = 2)
            //plot(acciEma, title = "Signal", color = color.black, linewidth = 1)
            List<decimal> acciList = new();
            List<decimal> tempList = new();
            List<decimal> tpAvgList = new();
            List<decimal> mdAvgList = new();
            List<decimal> mdList = new();
            List<decimal> acciEmaList = new();
            List<decimal> rmsList = new();
            List<decimal> numList = new();
            List<decimal> denomList = new();
            List<decimal> ratioList = new();
            List<Signal> signalsList = new();

            try
            {
                int length = (int)Math.Ceiling(days / 0.3);
                int hpLength = (int)Math.Ceiling(length / 0.2084);
                decimal alphaArg = (decimal)Math.Min(0.707 * 2 * Math.PI / hpLength, 0.99);
                decimal alphaCos = Cos(alphaArg);
                decimal alpha1 = alphaCos != 0 ? (alphaCos + Sin(alphaArg) - 1) / alphaCos : 0;
                decimal a1 = Exp(-1.414 * 3.14159 / length);
                decimal b1 = 2 * a1 * Cos(Math.Min(ToRadians(1.414m * 180 / length), 0.99m));
                decimal c2 = b1;
                decimal c3 = -1 * a1 * a1;
                decimal c1 = 1 - c2 - c3;

                var domCycList = CalculateEhlersAutoCorrelationPeriodogram(stockDataClass, days).Item23;
                var roofingFilterList = CalculateEhlersRoofingFilter(stockDataClass, length).Item2;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal domCyc = MinOrMax(domCycList.ElementAtOrDefault(i), hpLength, length);
                    decimal prevAcci1 = i >= 1 ? acciList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevAcci2 = i >= 2 ? acciList.ElementAtOrDefault(i - 2) : 0;
                    int cycLength = (int)Math.Ceiling(domCyc);

                    decimal roofingFilter = roofingFilterList.ElementAtOrDefault(i);
                    tempList.Add(roofingFilter);

                    decimal avg = tempList.TakeLast(cycLength).Average();
                    tpAvgList.Add(avg);

                    decimal md = Pow(roofingFilter - avg, 2);
                    mdList.Add(md);

                    decimal mdAvg = mdList.TakeLast(cycLength).Average();
                    mdAvgList.Add(mdAvg);

                    decimal rms = cycLength >= 0 ? Sqrt(mdAvg) : 0;
                    rmsList.Add(rms);

                    decimal num = roofingFilter - avg;
                    numList.Add(num);

                    decimal denom = 0.015m * rms;
                    denomList.Add(denom);

                    decimal prevRatio = ratioList.LastOrDefault();
                    decimal ratio = denom != 0 ? num / denom : 0;
                    ratioList.Add(ratio);

                    decimal acci = (c1 * ((ratio + prevRatio) / 2)) + (c2 * prevAcci1) + (c3 * prevAcci2);
                    acciList.Add(acci);
                }

                acciEmaList = GetMovingAverageList(maType, acciList, stockDataClass, length);
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal acci = acciList.ElementAtOrDefault(j);
                    decimal acciEma = acciEmaList.ElementAtOrDefault(j);
                    decimal prevAcci = j >= 1 ? acciList.ElementAtOrDefault(j - 1) : 0;
                    decimal prevAcciEma = j >= 1 ? acciEmaList.ElementAtOrDefault(j - 1) : 0;

                    var signal = GetRsiSignal(acci - acciEma, prevAcci - prevAcciEma, acci, prevAcci, 100, -100);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (tpAvgList, mdList, mdAvgList, rmsList, numList, denomList, ratioList, acciList, acciEmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>)
            CalculateEhlersDiscreteFourierTransformSpectralEstimate(StockData stockDataClass, int days = 10)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Ehlers Discrete Fourier Transform Spectral Estimate [CC] script may be freely distributed under the MIT license.
            //study("Ehlers Discrete Fourier Transform Spectral Estimate [CC]", overlay = false)

            //inp = input(title = "Source", type = input.source, defval = close)
            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //src = security(syminfo.tickerid, res, inp[rep ? 0 : barstate.isrealtime ? 1 : 0])[rep ? 0 : barstate.isrealtime ? 0 : 1]
            //hpLength = input(title = "HPLength", type = input.integer, defval = 48, minval = 1)
            //ssfLength = input(title = "SSFLength", type = input.integer, defval = 10, minval = 1)

            //pi = 2 * asin(1)
            //twoPiPrd = 0.707 * 2 * pi / hpLength
            //a1 = (cos(twoPiPrd) + sin(twoPiPrd) - 1) / cos(twoPiPrd)
            //a2 = exp(-1.414 * pi / ssfLength)
            //beta = 2 * a2 * cos(1.414 * pi / ssfLength)
            //c2 = beta
            //c3 = -a2 * a2
            //c1 = 1 - c2 - c3

            //hp = 0.0
            //hp:= (pow(1 - (a1 / 2), 2) * (src - (2 * nz(src[1])) + nz(src[2]))) + (2 * (1 - a1) * nz(hp[1])) - (pow(1 - a1, 2) * nz(hp[2]))

            //rfilt = 0.0
            //rfilt:= (c1 * ((hp + nz(hp[1])) / 2)) + (c2 * nz(rfilt[1])) + (c3 * nz(rfilt[2]))

            //maxPwr = 0.0, pwr = 0.0, spx = 0.0, sp = 0.0
            //for i = ssfLength to hpLength

            //    cosPart = 0.0, sinPart = 0.0
            //    for n = 0 to hpLength - 1
            //        cosPart := cosPart + (nz(rfilt[n]) * cos(2 * pi * n / i) / i)
            //        sinPart := sinPart + (nz(rfilt[n]) * sin(2 * pi * n / i) / i)

            //    pwr := pow(cosPart, 2) + pow(sinPart, 2)
            //    maxPwr := pwr > maxPwr ? pwr : maxPwr
            //    pwr := maxPwr > 0 ? pwr / maxPwr : pwr
            //    spx := spx + (i * pwr)
            //    sp := sp + pwr

            //domCyc = sp != 0 ? spx / sp : 0

            //sig = rfilt > 0 ? 1 : rfilt < 0 ? -1 : 0
            //dftseColor = sig > 0 ? color.green : sig < 0 ? color.red : color.black
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //barcolor(bar ? dftseColor : na)
            //plot(domCyc, title = "DominantCycle", color = dftseColor, linewidth = 2)
            List<decimal> sqSumList = new();
            List<decimal> maxPwrList = new();
            List<decimal> pwrList = new();
            List<decimal> domCycList = new();
            List<decimal> spxList = new();
            List<decimal> spList = new();
            List<decimal> pxList = new();
            List<decimal> pList = new();
            List<decimal> cosPartList = new();
            List<decimal> sinPartList = new();
            List<decimal> cosPartSumList = new();
            List<decimal> sinPartSumList = new();
            List<Signal> signalsList = new();

            try
            {
                int hpLength = (int)Math.Ceiling(days / 0.2084);

                var roofingFilterList = CalculateEhlersRoofingFilter(stockDataClass, days).Item2;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal roofingFilter = roofingFilterList.ElementAtOrDefault(i);
                    decimal prevRoofingFilter1 = i >= 1 ? roofingFilterList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevRoofingFilter2 = i >= 2 ? roofingFilterList.ElementAtOrDefault(i - 2) : 0;

                    decimal cosPart = 0, sinPart = 0;
                    for (int j = 0; j < hpLength; j++)
                    {
                        decimal filter = i >= j ? roofingFilterList.ElementAtOrDefault(i - j) : 0;
                        decimal value = ToRadians(360 * (decimal)j / days);

                        cosPart += filter * Cos(value) / days;
                        sinPart += filter * Sin(value) / days;
                    }
                    cosPartList.Add(cosPart);
                    sinPartList.Add(sinPart);

                    decimal cosPartSum = cosPartList.TakeLast(hpLength).Sum();
                    cosPartSumList.Add(cosPartSum);

                    decimal sinPartSum = sinPartList.TakeLast(hpLength).Sum();
                    sinPartSumList.Add(sinPartSum);

                    decimal sqSum = (cosPartSum * cosPartSum) + (sinPartSum * sinPartSum);
                    sqSumList.Add(sqSum);

                    decimal maxPwr = sqSumList.TakeLast(hpLength).Max();
                    maxPwrList.Add(maxPwr);

                    decimal pwr = maxPwr != 0 ? sqSum / maxPwr : 0;
                    pwrList.Add(pwr);

                    decimal px = pwr >= 0.5m ? i * pwr : 0;
                    pxList.Add(px);

                    decimal p = pwr >= 0.5m ? pwr : 0;
                    pList.Add(p);

                    decimal spx = pxList.TakeLast(hpLength).Sum();
                    spxList.Add(spx);

                    decimal sp = pList.TakeLast(hpLength).Sum();
                    spList.Add(sp);

                    decimal domCyc = sp != 0 ? spx / sp : 0;
                    domCycList.Add(domCyc);

                    var signal = GetCompareSignal(roofingFilter - prevRoofingFilter1, prevRoofingFilter1 - prevRoofingFilter2);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (cosPartList, sinPartList, cosPartSumList, sinPartSumList, sqSumList, maxPwrList, pwrList, pxList, pList, spxList, spList, domCycList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>)
            CalculateEhlersCombFilterSpectralEstimate(StockData stockDataClass, int days = 10)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Ehlers Comb Filter Spectral Estimate [CC] script may be freely distributed under the MIT license.
            //study("Ehlers Comb Filter Spectral Estimate [CC]", overlay = false)

            //inp = input(title = "Source", type = input.source, defval = close)
            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //src = security(syminfo.tickerid, res, inp[rep ? 0 : barstate.isrealtime ? 1 : 0])[rep ? 0 : barstate.isrealtime ? 0 : 1]
            //hpLength = input(title = "HPLength", type = input.integer, defval = 48, minval = 1)
            //ssfLength = input(title = "SSFLength", type = input.integer, defval = 10, minval = 1)
            //bw = input(title = "Bandwidth", type = input.float, defval = 0.3, minval = 0.01, step = 0.01)

            //pi = 2 * asin(1)
            //twoPiPrd = 0.707 * 2 * pi / hpLength
            //a1 = (cos(twoPiPrd) + sin(twoPiPrd) - 1) / cos(twoPiPrd)
            //a2 = exp(-1.414 * pi / ssfLength)
            //b1 = 2 * a2 * cos(1.414 * pi / ssfLength)
            //c2 = b1
            //c3 = -a2 * a2
            //c1 = 1 - c2 - c3

            //hp = 0.0
            //hp:= (pow(1 - (a1 / 2), 2) * (src - (2 * nz(src[1])) + nz(src[2]))) + (2 * (1 - a1) * nz(hp[1])) - (pow(1 - a1, 2) * nz(hp[2]))

            //rfilt = 0.0
            //rfilt:= (c1 * ((hp + nz(hp[1])) / 2)) + (c2 * nz(rfilt[1])) + (c3 * nz(rfilt[2]))

            //maxPwr = 0.0, pwr = 0.0, spx = 0.0, sp = 0.0, bp = 0.0
            //for i = ssfLength to hpLength
            //    beta = cos(2 * pi / i)
            //    gamma = 1 / cos(2 * pi * bw / i)
            //    alpha = gamma - sqrt((gamma * gamma) - 1)
            //    bp := (0.5 * (1 - alpha) * (rfilt - nz(rfilt[2]))) + (beta * (1 + alpha) * nz(bp[1])) - (alpha * nz(bp[2]))
            //    pwr := pwr + pow(bp / i, 2)
            //    maxPwr := pwr > maxPwr ? pwr : maxPwr
            //    pwr := pwr / maxPwr

            //    if pwr >= 0.5
            //        spx:= spx + (i * pwr)
            //        sp:= sp + pwr

            //domCyc = sp != 0 ? spx / sp : 0

            //sig = rfilt > 0 ? 1 : rfilt < 0 ? -1 : 0
            //dftseColor = sig > 0 ? color.green : sig < 0 ? color.red : color.black
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //barcolor(bar ? dftseColor : na)
            //plot(domCyc, title = "DominantCycle", color = dftseColor, linewidth = 2)
            List<decimal> sqSumList = new();
            List<decimal> maxPwrList = new();
            List<decimal> pwrList = new();
            List<decimal> domCycList = new();
            List<decimal> spxList = new();
            List<decimal> spList = new();
            List<decimal> pxList = new();
            List<decimal> pList = new();
            List<decimal> bpList = new();
            List<Signal> signalsList = new();

            try
            {
                int hpLength = (int)Math.Ceiling(days / 0.2084);
                decimal bw = 0.3m;

                var roofingFilterList = CalculateEhlersRoofingFilter(stockDataClass, days).Item2;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal roofingFilter = roofingFilterList.ElementAtOrDefault(i);
                    decimal prevRoofingFilter1 = i >= 1 ? roofingFilterList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevRoofingFilter2 = i >= 2 ? roofingFilterList.ElementAtOrDefault(i - 2) : 0;
                    decimal prevBp1 = i >= 1 ? bpList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevBp2 = i >= 2 ? bpList.ElementAtOrDefault(i - 2) : 0;

                    decimal bp = 0, sqSum = 0;
                    for (int j = days; j <= hpLength; j++)
                    {
                        decimal beta = Cos(ToRadians((double)360 / j));
                        decimal gamma = 1 / Cos(360 * bw / j);
                        decimal alpha = MinOrMax(gamma - Sqrt((gamma * gamma) - 1), 0.99m, 0.01m);
                        bp = (0.5m * (1 - alpha) * (roofingFilter - prevRoofingFilter2)) + (beta * (1 + alpha) * prevBp1) - (alpha * prevBp2);

                        for (int k = 1; k <= j; k++)
                        {
                            decimal prevBp = i >= k ? bpList.ElementAtOrDefault(i - k) : 0;
                            sqSum += prevBp / j >= 0 ? Pow(prevBp / j, 2) : 0;
                        }
                    }
                    bpList.Add(bp);
                    sqSumList.Add(sqSum);

                    decimal maxPwr = sqSumList.TakeLast(hpLength - days).Max();
                    maxPwrList.Add(maxPwr);

                    decimal pwr = maxPwr != 0 ? sqSum / maxPwr : 0;
                    pwrList.Add(pwr);

                    decimal px = pwr >= 0.5m ? i * pwr : 0;
                    pxList.Add(px);

                    decimal p = pwr >= 0.5m ? pwr : 0;
                    pList.Add(p);

                    decimal spx = pxList.TakeLast(hpLength - days).Sum();
                    spxList.Add(spx);

                    decimal sp = pList.TakeLast(hpLength - days).Sum();
                    spList.Add(sp);

                    decimal domCyc = sp != 0 ? spx / sp : 0;
                    domCycList.Add(domCyc);

                    var signal = GetCompareSignal(roofingFilter - prevRoofingFilter1, prevRoofingFilter1 - prevRoofingFilter2);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (bpList, sqSumList, maxPwrList, pwrList, pxList, pList, spxList, spList, domCycList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateEhlersAutoCorrelationReversals(StockData stockDataClass, int days = 3)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Ehlers AutoCorrelation Reversals [CC] script may be freely distributed under the MIT license.
            //study("Ehlers AutoCorrelation Reversals [CC]", overlay = false)

            //inp = input(title = "Source", type = input.source, defval = close)
            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //src = security(syminfo.tickerid, res, inp[rep ? 0 : barstate.isrealtime ? 1 : 0])[rep ? 0 : barstate.isrealtime ? 0 : 1]
            //hpLength = input(title = "HPLength", type = input.integer, defval = 48, minval = 1)
            //ssfLength = input(title = "SSFLength", type = input.integer, defval = 10, minval = 1)
            //avgLength = input(title = "AvgLength", type = input.integer, defval = 3, minval = 1)

            //pi = 2 * asin(1)
            //twoPiPrd = 0.707 * 2 * pi / hpLength
            //a1 = (cos(twoPiPrd) + sin(twoPiPrd) - 1) / cos(twoPiPrd)
            //a2 = exp(-1.414 * pi / ssfLength)
            //beta = 2 * a2 * cos(1.414 * pi / ssfLength)
            //c2 = beta
            //c3 = -a2 * a2
            //c1 = 1 - c2 - c3

            //hp = 0.0
            //hp:= (pow(1 - (a1 / 2), 2) * (src - (2 * nz(src[1])) + nz(src[2]))) + (2 * (1 - a1) * nz(hp[1])) - (pow(1 - a1, 2) * nz(hp[2]))

            //rfilt = 0.0
            //rfilt:= (c1 * ((hp + nz(hp[1])) / 2)) + (c2 * nz(rfilt[1])) + (c3 * nz(rfilt[2]))

            //corr = 0.0, sx = 0.0, sy = 0.0, sxx = 0.0, syy = 0.0, sxy = 0.0
            //for i = 0 to hpLength
            //    x = nz(rfilt[i])
            //    y = nz(rfilt[hpLength + i])
            //    sx := sx + x
            //    sy := sy + y
            //    sxx := sxx + (x * x)
            //    sxy := sxy + (x * y)
            //    syy := syy + (y * y)

            //    corr := ((i * sxx) - (sx * sx)) * ((i * syy) - (sy * sy)) > 0 ? ((i * sxy) - (sx * sy)) / sqrt(((i * sxx) - (sx * sx)) * ((i * syy) - (sy * sy))) : 0
            //    corr := 0.5 * (corr + 1)

            //deltaSum = 0.0
            //for i = avgLength to hpLength
            //    deltaSum := deltaSum + ((corr > 0.5 and nz(corr[1]) < 0.5) or(corr < 0.5 and nz(corr[1]) > 0.5) ? 1 : 0)

            //reversal = deltaSum > hpLength / 2 ? 1 : 0

            //sig = rfilt > 0 ? 1 : rfilt < 0 ? -1 : 0
            //corrColor = sig > 0 ? color.green : sig < 0 ? color.red : color.black
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //barcolor(bar ? corrColor : na)
            //plot(reversal, title = "Reversal", color = corrColor, linewidth = 2)
            List<decimal> deltaList = new();
            List<decimal> sumDeltasList = new();
            List<decimal> reversalList = new();
            List<Signal> signalsList = new();

            try
            {
                int length = (int)Math.Ceiling(days / 0.3);
                int hpLength = (int)Math.Ceiling(length / 0.2084);

                var corrList = CalculateEhlersAutoCorrelationIndicator(stockDataClass, length).Item10;
                var emaList = CalculateExponentialMovingAverage(stockDataClass, length).Item1;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal corr = corrList.ElementAtOrDefault(i);
                    decimal prevCorr1 = i >= 1 ? corrList.ElementAtOrDefault(i - 1) : 0;
                    decimal ema = emaList.ElementAtOrDefault(i);
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);

                    decimal delta = (corr > 0.5m && prevCorr1 < 0.5m) || (corr < 0.5m && prevCorr1 > 0.5m) ? 1 : 0;
                    deltaList.Add(delta);

                    decimal sumDeltas = deltaList.TakeLast(hpLength).Sum();
                    sumDeltasList.Add(sumDeltas);

                    decimal reversal = sumDeltas > (decimal)hpLength / 2 ? 1 : 0;
                    reversalList.Add(reversal);

                    var signal = GetConditionSignal(currentValue < ema && reversal == 1, currentValue > ema && reversal == 1);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (deltaList, sumDeltasList, reversalList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>)
            CalculateEhlersReverseExponentialMovingAverageIndicator(StockData stockDataClass)
        {
            //{ Reverse EMA Indicator(C) 2017 John F. Ehlers }
            //Inputs: AA(.1);
            //Vars: CC(0), EMA(0), RE1(0), RE2(0), RE3(0), RE4(0), RE5(0), RE6(0), RE7(0), RE8(0), Wave(0); 

            //Classic EMA 
            //CC = 1 - AA; 
            //EMA = AA*Close + CC*EMA[1];

            //Compute Reverse EMA 
            //RE1 = CC*EMA + EMA[1]; 
            //RE2 = Power(CC, 2)*RE1 + RE1[1]; 
            //RE3 = Power(CC, 4)*RE2 + RE2[1]; 
            //RE4 = Power(CC, 8)*RE3 + RE3[1]; 
            //RE5 = Power(CC, 16)*RE4 + RE4[1]; 
            //RE6 = Power(CC, 32)*RE5 + RE5[1]; 
            //RE7 = Power(CC, 64)*RE6 + RE6[1]; 
            //RE8 = Power(CC, 128)*RE7 + RE7[1]; 

            //Indicator as difference 
            //Wave = EMA - AA*RE8; 

            //Plot1(Wave); 
            //Plot2(0);
            List<decimal> emaList = new();
            List<decimal> re1List = new();
            List<decimal> re2List = new();
            List<decimal> re3List = new();
            List<decimal> re4List = new();
            List<decimal> re5List = new();
            List<decimal> re6List = new();
            List<decimal> re7List = new();
            List<decimal> re8List = new();
            List<decimal> waveList = new();
            List<Signal> signalsList = new();
            decimal aa = 0.1m;

            try
            {
                decimal cc = 1 - aa;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);

                    decimal prevEma = emaList.LastOrDefault();
                    decimal ema = (aa * currentValue) + (cc * prevEma);
                    emaList.Add(ema);

                    decimal prevRe1 = re1List.LastOrDefault();
                    decimal re1 = (cc * ema) + prevEma;
                    re1List.Add(re1);

                    decimal prevRe2 = re2List.LastOrDefault();
                    decimal re2 = (Pow(cc, 2) * re1) + prevRe1;
                    re2List.Add(re2);

                    decimal prevRe3 = re3List.LastOrDefault();
                    decimal re3 = (Pow(cc, 4) * re2) + prevRe2;
                    re3List.Add(re3);

                    decimal prevRe4 = re4List.LastOrDefault();
                    decimal re4 = (Pow(cc, 8) * re3) + prevRe3;
                    re4List.Add(re4);

                    decimal prevRe5 = re5List.LastOrDefault();
                    decimal re5 = (Pow(cc, 16) * re4) + prevRe4;
                    re5List.Add(re5);

                    decimal prevRe6 = re6List.LastOrDefault();
                    decimal re6 = (Pow(cc, 32) * re5) + prevRe5;
                    re6List.Add(re6);

                    decimal prevRe7 = re7List.LastOrDefault();
                    decimal re7 = (Pow(cc, 64) * re6) + prevRe6;
                    re7List.Add(re7);

                    decimal prevRe8 = re8List.LastOrDefault();
                    decimal re8 = (Pow(cc, 128) * re7) + prevRe7;
                    re8List.Add(re8);

                    decimal prevWave = waveList.LastOrDefault();
                    decimal wave = ema - (aa * re8);
                    waveList.Add(wave);

                    var signal = GetCompareSignal(wave, prevWave);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (emaList, re1List, re2List, re3List, re4List, re5List, re6List, re7List, re8List, waveList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateEhlersReverseExponentialMovingAverageIndicatorV2(StockData stockDataClass)
        {
            //@version=3
            // Copyright (c) 2018-present, Alex Orekhov (everget)
            // Ehlers Reverse Exponential Moving Average script may be freely distributed under the MIT license.
            //study("Ehlers Reverse Exponential Moving Average", shorttitle = "EREMA")

            //trendAlpha = input(title = "Trend Alpha", type = float, defval = 0.05)
            //cycleAlpha = input(title = "Cycle Alpha", type = float, defval = 0.3)
            //src = input(title = "Source", type = source, defval = close)

            //erema(src, alpha) =>
            //    delta = 1 - alpha

            //    ema = 0.0
            //    ema:= alpha * src + delta * nz(ema[1])

            // Compute Reverse EMA
            //re1 = delta * ema + nz(ema[1])
            //re2 = pow(delta, 2) * re1 + nz(re1[1])
            //re3 = pow(delta, 4) * re2 + nz(re2[1])
            //re4 = pow(delta, 8) * re3 + nz(re3[1])
            //re5 = pow(delta, 16) * re4 + nz(re4[1])
            //re6 = pow(delta, 32) * re5 + nz(re5[1])
            //re7 = pow(delta, 64) * re6 + nz(re6[1])
            //re8 = pow(delta, 128) * re7 + nz(re7[1])

            //erema = ema - alpha * re8

            //eremaTrend = erema(src, trendAlpha)
            //eremaTrendColor = #674ea7

            //eremaCycle = erema(src, cycleAlpha)
            //eremaCycleColor = eremaCycle > 0 ? #0ebb23 : red

            //eremaTrendPlot = plot(eremaTrend, title = "Trend", linewidth = 2, color = eremaTrendColor, transp = 0)
            //eremaCyclePlot = plot(eremaCycle, title = "Cycle", linewidth = 2, color = eremaCycleColor, transp = 0)

            //fillColor = eremaTrend >= 0 and eremaCycle >= 0 ? #0ebb23 : eremaTrend < 0 and eremaCycle < 0 ? red : color(white, 100)

            //fill(eremaTrendPlot, eremaCyclePlot, color = fillColor, transp = 80)

            //hline(0, title = "Zero Level", linestyle = dotted, color =#989898)
            List<decimal> emaTrendList = new();
            List<decimal> re1TrendList = new();
            List<decimal> re2TrendList = new();
            List<decimal> re3TrendList = new();
            List<decimal> re4TrendList = new();
            List<decimal> re5TrendList = new();
            List<decimal> re6TrendList = new();
            List<decimal> re7TrendList = new();
            List<decimal> re8TrendList = new();
            List<decimal> waveTrendList = new();
            List<decimal> emaCycleList = new();
            List<decimal> re1CycleList = new();
            List<decimal> re2CycleList = new();
            List<decimal> re3CycleList = new();
            List<decimal> re4CycleList = new();
            List<decimal> re5CycleList = new();
            List<decimal> re6CycleList = new();
            List<decimal> re7CycleList = new();
            List<decimal> re8CycleList = new();
            List<decimal> waveCycleList = new();
            List<Signal> signalsList = new();
            decimal trendAlpha = 0.05m, cycleAlpha = 0.3m;

            try
            {
                decimal trendDelta = 1 - trendAlpha;
                decimal cycleDelta = 1 - cycleAlpha;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);

                    decimal prevEmaTrend = emaTrendList.LastOrDefault();
                    decimal emaTrend = (trendAlpha * currentValue) + (trendDelta * prevEmaTrend);
                    emaTrendList.Add(emaTrend);

                    decimal prevRe1Trend = re1TrendList.LastOrDefault();
                    decimal re1Trend = (trendDelta * emaTrend) + prevEmaTrend;
                    re1TrendList.Add(re1Trend);

                    decimal prevRe2Trend = re2TrendList.LastOrDefault();
                    decimal re2Trend = (Pow(trendDelta, 2) * re1Trend) + prevRe1Trend;
                    re2TrendList.Add(re2Trend);

                    decimal prevRe3Trend = re3TrendList.LastOrDefault();
                    decimal re3Trend = (Pow(trendDelta, 4) * re2Trend) + prevRe2Trend;
                    re3TrendList.Add(re3Trend);

                    decimal prevRe4Trend = re4TrendList.LastOrDefault();
                    decimal re4Trend = (Pow(trendDelta, 8) * re3Trend) + prevRe3Trend;
                    re4TrendList.Add(re4Trend);

                    decimal prevRe5Trend = re5TrendList.LastOrDefault();
                    decimal re5Trend = (Pow(trendDelta, 16) * re4Trend) + prevRe4Trend;
                    re5TrendList.Add(re5Trend);

                    decimal prevRe6Trend = re6TrendList.LastOrDefault();
                    decimal re6Trend = (Pow(trendDelta, 32) * re5Trend) + prevRe5Trend;
                    re6TrendList.Add(re6Trend);

                    decimal prevRe7Trend = re7TrendList.LastOrDefault();
                    decimal re7Trend = (Pow(trendDelta, 64) * re6Trend) + prevRe6Trend;
                    re7TrendList.Add(re7Trend);

                    decimal prevRe8Trend = re8TrendList.LastOrDefault();
                    decimal re8Trend = (Pow(trendDelta, 128) * re7Trend) + prevRe7Trend;
                    re8TrendList.Add(re8Trend);

                    decimal prevWaveTrend = waveTrendList.LastOrDefault();
                    decimal waveTrend = emaTrend - (trendAlpha * re8Trend);
                    waveTrendList.Add(waveTrend);

                    decimal prevEmaCycle = emaCycleList.LastOrDefault();
                    decimal emaCycle = (cycleAlpha * currentValue) + (cycleDelta * prevEmaCycle);
                    emaCycleList.Add(emaCycle);

                    decimal prevRe1Cycle = re1CycleList.LastOrDefault();
                    decimal re1Cycle = (cycleDelta * emaCycle) + prevEmaCycle;
                    re1CycleList.Add(re1Cycle);

                    decimal prevRe2Cycle = re2CycleList.LastOrDefault();
                    decimal re2Cycle = (Pow(cycleDelta, 2) * re1Cycle) + prevRe1Cycle;
                    re2CycleList.Add(re2Cycle);

                    decimal prevRe3Cycle = re3CycleList.LastOrDefault();
                    decimal re3Cycle = (Pow(cycleDelta, 4) * re2Cycle) + prevRe2Cycle;
                    re3CycleList.Add(re3Cycle);

                    decimal prevRe4Cycle = re4CycleList.LastOrDefault();
                    decimal re4Cycle = (Pow(cycleDelta, 8) * re3Cycle) + prevRe3Cycle;
                    re4CycleList.Add(re4Cycle);

                    decimal prevRe5Cycle = re5CycleList.LastOrDefault();
                    decimal re5Cycle = (Pow(cycleDelta, 16) * re4Cycle) + prevRe4Cycle;
                    re5CycleList.Add(re5Cycle);

                    decimal prevRe6Cycle = re6CycleList.LastOrDefault();
                    decimal re6Cycle = (Pow(cycleDelta, 32) * re5Cycle) + prevRe5Cycle;
                    re6CycleList.Add(re6Cycle);

                    decimal prevRe7Cycle = re7CycleList.LastOrDefault();
                    decimal re7Cycle = (Pow(cycleDelta, 64) * re6Cycle) + prevRe6Cycle;
                    re7CycleList.Add(re7Cycle);

                    decimal prevRe8Cycle = re8CycleList.LastOrDefault();
                    decimal re8Cycle = (Pow(cycleDelta, 128) * re7Cycle) + prevRe7Cycle;
                    re8CycleList.Add(re8Cycle);

                    decimal prevWaveCycle = waveCycleList.LastOrDefault();
                    decimal waveCycle = emaCycle - (cycleAlpha * re8Cycle);
                    waveCycleList.Add(waveCycle);

                    var signal = GetCompareSignal(waveCycle - waveTrend, prevWaveCycle - prevWaveTrend);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (emaTrendList, re1TrendList, re2TrendList, re3TrendList, re4TrendList, re5TrendList, re6TrendList, re7TrendList, re8TrendList, waveTrendList,
                emaCycleList, re1CycleList, re2CycleList, re3CycleList, re4CycleList, re5CycleList, re6CycleList, re7CycleList, re8CycleList, waveCycleList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateEhlersLeadingIndicator(StockData stockDataClass)
        {
            //@version=3
            // Copyright (c) 2018-present, Alex Orekhov (everget)
            // Ehlers Leading Indicator script may be freely distributed under the MIT license.
            //study("Ehlers Leading Indicator", shorttitle = "ELI", overlay = true)

            //alpha1 = input(title = "Alpha 1", type = float, step = 0.1, defval = 0.25)
            //alpha2 = input(title = "Alpha 2", type = float, step = 0.1, defval = 0.33)
            //src = input(title = "Source", type = source, defval = hl2)

            //lead = 0.0
            //lead:= 2 * src + (alpha1 - 2) * nz(src[1]) + (1 - alpha1) * nz(lead[1])

            //leadingIndicator = 0.0
            //leadingIndicator:= alpha2 * lead + (1 - alpha2) * nz(leadingIndicator[1])

            //plot(leadingIndicator, title = "ELI", linewidth = 2, color =#741b47, transp=0)
            List<decimal> leadList = new();
            List<decimal> leadIndicatorList = new();
            List<Signal> signalsList = new();
            decimal alpha1 = 0.25m, alpha2 = 0.33m;

            try
            {
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal prevLead = leadList.LastOrDefault();
                    decimal lead = (2 * currentValue) + ((alpha1 - 2) * prevValue) + ((1 - alpha1) * prevLead);
                    leadList.Add(lead);

                    decimal prevLeadIndicator = leadIndicatorList.LastOrDefault();
                    decimal leadIndicator = (alpha2 * lead) + ((1 - alpha2) * prevLeadIndicator);
                    leadIndicatorList.Add(leadIndicator);

                    var signal = GetCompareSignal(currentValue - leadIndicator, prevValue - prevLeadIndicator);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (leadList, leadIndicatorList, signalsList);
        }

        public static (List<decimal>, List<Signal>) CalculateEhlersOptimumEllipticFilter(StockData stockDataClass)
        {
            //@version=3
            // Copyright (c) 2019-present, Alex Orekhov (everget)
            // Ehlers Optimum Elliptic Filter script may be freely distributed under the MIT license.
            //study("Ehlers Optimum Elliptic Filter", shorttitle = "OEF", overlay = true)

            //src = input(title = "Source", type = source, defval = hl2)
            //highlightMovements = input(title = "Highlight Movements ?", type = bool, defval = false)

            //oef = 0.0
            //oef:= 0.13785 * src + 0.0007 * nz(src[1]) + 0.13785 * nz(src[2]) + 1.2103 * nz(oef[1]) - 0.4867 * nz(oef[2])

            //oefColor = highlightMovements ? (oef > oef[1] ? green : red) : #6d1e7f
            //plot(oef, title = "OEF", linewidth = 2, color = oefColor, transp = 0)
            List<decimal> oefList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue1 = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevValue2 = i >= 2 ? stockDataClass.InputValues.ElementAtOrDefault(i - 2) : 0;
                    decimal prevOef1 = i >= 1 ? oefList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevOef2 = i >= 2 ? oefList.ElementAtOrDefault(i - 2) : 0;

                    decimal oef = (0.13785m * currentValue) + (0.0007m * prevValue1) + (0.13785m * prevValue2) + (1.2103m * prevOef1) - (0.4867m * prevOef2);
                    oefList.Add(oef);

                    var signal = GetCompareSignal(currentValue - oef, prevValue1 - prevOef1);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (oefList, signalsList);
        }

        public static (List<decimal>, List<Signal>) CalculateEhlersModifiedOptimumEllipticFilter(StockData stockDataClass)
        {
            //@version=3
            // Copyright (c) 2019-present, Alex Orekhov (everget)
            // Ehlers Modified Optimum Elliptic Filter script may be freely distributed under the MIT license.
            //study("Ehlers Modified Optimum Elliptic Filter", shorttitle = "MOEF", overlay = true)

            //src = input(title = "Source", type = source, defval = hl2)
            //highlightMovements = input(title = "Highlight Movements ?", type = bool, defval = false)

            //src1 = nz(src[1], src)
            //src2 = nz(src[2], src1)
            //src3 = nz(src[3], src2)

            //moef = src
            //moef:= 0.13785 * (2 * src - src1) +
            //        0.0007 * (2 * src1 - src2) +
            //        0.13785 * (2 * src2 - src3) +
            //        1.2103 * nz(moef[1], moef) -
            //        0.4867 * nz(moef[2], moef)

            //moefColor = highlightMovements ? (moef > moef[1] ? green : red) : #6d1e7f
            //plot(moef, title = "MOEF", linewidth = 2, color = moefColor, transp = 0)
            List<decimal> moefList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue1 = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : currentValue;
                    decimal prevValue2 = i >= 2 ? stockDataClass.InputValues.ElementAtOrDefault(i - 2) : prevValue1;
                    decimal prevValue3 = i >= 3 ? stockDataClass.InputValues.ElementAtOrDefault(i - 3) : prevValue2;
                    decimal prevMoef1 = i >= 1 ? moefList.ElementAtOrDefault(i - 1) : currentValue;
                    decimal prevMoef2 = i >= 2 ? moefList.ElementAtOrDefault(i - 2) : prevMoef1;

                    decimal moef = (0.13785m * ((2 * currentValue) - prevValue1)) + (0.0007m * ((2 * prevValue1) - prevValue2)) + (0.13785m * ((2 * prevValue2) - prevValue3)) +
                        (1.2103m * prevMoef1) - (0.4867m * prevMoef2);
                    moefList.Add(moef);

                    var signal = GetCompareSignal(currentValue - moef, prevValue1 - prevMoef1);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (moefList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateTrimean(StockData stockDataClass, int days = 14)
        {
            //@version=3
            // Copyright (c) 2018-present, Alex Orekhov (everget)
            // Trimean script may be freely distributed under the MIT license.
            //study("Trimean", shorttitle = "Trimean", overlay = true)

            //length = input(title = "Length", type = integer, minval = 1, defval = 14)
            //highlightMovements = input(title = "Highlight Movements ?", type = bool, defval = true)
            //src = input(title = "Source", type = source, defval = close)

            //q1 = percentile_nearest_rank(src, length, 25)
            //median = percentile_nearest_rank(src, length, 50)
            //q3 = percentile_nearest_rank(src, length, 75)

            //trimean = (q1 + 2 * median + q3) / 4

            //trimeanColor = highlightMovements ? (trimean > trimean[1] ? green : red) : #6d1e7f
            //plot(trimean, title = "Trimean", linewidth = 2, color = trimeanColor, transp = 0)
            List<decimal> tempList = new();
            List<decimal> medianList = new();
            List<decimal> q1List = new();
            List<decimal> q3List = new();
            List<decimal> trimeanList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal prevValue = tempList.LastOrDefault();
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    tempList.Add(currentValue);

                    List<decimal> lookBackList = tempList.TakeLast(days).ToList();

                    decimal q1 = PercentileNearestRank(lookBackList, 25);
                    q1List.Add(q1);

                    decimal median = PercentileNearestRank(lookBackList, 50);
                    medianList.Add(median);

                    decimal q3 = PercentileNearestRank(lookBackList, 75);
                    q3List.Add(q3);

                    decimal prevTrimean = trimeanList.LastOrDefault();
                    decimal trimean = (q1 + (2 * median) + q3) / 4;
                    trimeanList.Add(trimean);

                    var signal = GetCompareSignal(currentValue - trimean, prevValue - prevTrimean);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (q1List, medianList, q3List, trimeanList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>)
            CalculateSupertrendFilter(StockData stockDataClass, int days = 200)
        {
            //@version=2
            //study("Supertrend Filter", overlay = true)
            //
            //Pd = input(200)
            //Factor = input(0.9)
            //
            //P = pow(Pd, 2)
            //a = 2 / (P + 1)
            //d = abs(close - nz(Tsl[0], hl2))
            //t = a * d + (1 - a) * nz(t[1], d)
            //src = Factor * nz(Tsl[0], hl2) + (1 - Factor) * close
            //Up = nz(Tsl[0], hl2) - t
            //Dn = nz(Tsl[0], hl2) + t
            //
            //TrendUp = src[1] > TrendUp[1] ? max(Up, TrendUp[1]) : Up
            //TrendDown = src[1] < TrendDown[1] ? min(Dn, TrendDown[1]) : Dn
            //
            //Trend = src > TrendDown[1] ? 1 : src < TrendUp[1] ? -1 : nz(Trend[1], 1)
            //Tsl = Trend == 1 ? TrendDown : TrendUp
            //css = Tsl > Tsl[1] ? #0080FF : Tsl < Tsl[1] ? #FF0040 : na
            //plot(Tsl, color = fixnan(css), transp = 0)
            List<decimal> dList = new();
            List<decimal> tList = new();
            List<decimal> srcList = new();
            List<decimal> upList = new();
            List<decimal> dnList = new();
            List<decimal> trendUpList = new();
            List<decimal> trendDnList = new();
            List<decimal> trendList = new();
            List<decimal> tslList = new();
            List<Signal> signalsList = new();
            decimal factor = 0.9m;

            try
            {
                decimal p = Pow(days, 2);
                decimal a = 2 / (p + 1);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevTsl1 = i >= 1 ? tslList.ElementAtOrDefault(i - 1) : currentValue;
                    decimal prevTsl2 = i >= 2 ? tslList.ElementAtOrDefault(i - 2) : 0;

                    decimal d = Math.Abs(currentValue - prevTsl1);
                    dList.Add(d);

                    decimal prevT = i >= 1 ? tList.ElementAtOrDefault(i - 1) : d;
                    decimal t = (a * d) + ((1 - a) * prevT);
                    tList.Add(t);

                    decimal prevSrc = srcList.LastOrDefault();
                    decimal src = (factor * prevTsl1) + ((1 - factor) * currentValue);
                    srcList.Add(src);

                    decimal up = prevTsl1 - t;
                    upList.Add(up);

                    decimal dn = prevTsl1 + t;
                    dnList.Add(dn);

                    decimal prevTrendUp = trendUpList.LastOrDefault();
                    decimal trendUp = prevSrc > prevTrendUp ? Math.Max(up, prevTrendUp) : up;
                    trendUpList.Add(trendUp);

                    decimal prevTrendDn = trendDnList.LastOrDefault();
                    decimal trendDn = prevSrc < prevTrendDn ? Math.Min(dn, prevTrendDn) : dn;
                    trendDnList.Add(trendDn);

                    decimal prevTrend = i >= 1 ? trendList.ElementAtOrDefault(i - 1) : 1;
                    decimal trend = src > prevTrendDn ? 1 : src < prevTrendUp ? -1 : prevTrend;
                    trendList.Add(trend);

                    decimal tsl = trend == 1 ? trendDn : trendUp;
                    tslList.Add(tsl);

                    var signal = GetCompareSignal(tsl - prevTsl1, prevTsl1 - prevTsl2);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (dList, tList, srcList, upList, dnList, trendUpList, trendDnList, trendList, tslList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateSuperTrend(StockData stockDataClass, string maType, int days = 22)
        {
            //@version=3
            // Copyright (c) 2019-present, Alex Orekhov (everget)
            // SuperTrend script may be freely distributed under the terms of the GPL-3.0 license.
            //study("SuperTrend", overlay = true)

            //length = input(title = "ATR Period", type = integer, defval = 22)
            //mult = input(title = "ATR Multiplier", type = float, step = 0.1, defval = 3.0)
            //showLabels = input(title = "Show Buy/Sell Labels ?", type = bool, defval = true)

            //atr = mult * atr(length)

            //longStop = hl2 - atr
            //longStopPrev = nz(longStop[1], longStop)
            //longStop:= close[1] > longStopPrev ? max(longStop, longStopPrev) : longStop

            //shortStop = hl2 + atr
            //shortStopPrev = nz(shortStop[1], shortStop)
            //shortStop:= close[1] < shortStopPrev ? min(shortStop, shortStopPrev) : shortStop

            //dir = 1
            //dir:= nz(dir[1], dir)
            //dir:= dir == -1 and close > shortStopPrev ? 1 : dir == 1 and close<longStopPrev ? -1 : dir

            //longColor = green
            //shortColor = red

            //plot(dir == 1 ? longStop : na, title = "Long Stop", style = linebr, linewidth = 2, color = longColor)
            //buySignal = dir == 1 and dir[1] == -1
            //plotshape(buySignal ? longStop : na, title = "Long Stop Start", location = location.absolute, style = shape.circle, size = size.tiny, color = longColor, transp = 0)
            //plotshape(buySignal and showLabels ? longStop : na, title = "Buy Label", text = "Buy", location = location.absolute, style = shape.labelup, size = size.tiny, color = longColor, textcolor = white, transp = 0)

            //plot(dir == 1 ? na : shortStop, title = "Short Stop", style = linebr, linewidth = 2, color = shortColor)
            //sellSignal = dir == -1 and dir[1] == 1
            //plotshape(sellSignal ? shortStop : na, title = "Short Stop Start", location = location.absolute, style = shape.circle, size = size.tiny, color = shortColor, transp = 0)
            //plotshape(sellSignal and showLabels ? shortStop : na, title = "Sell Label", text = "Sell", location = location.absolute, style = shape.labeldown, size = size.tiny, color = shortColor, textcolor = white, transp = 0)

            //alertcondition(buySignal, title = "Alert on SuperTrend Buy", message = "SuperTrend Buy!")
            //alertcondition(sellSignal, title = "Alert on SuperTrend Sell", message = "SuperTrend Sell!")

            //changeCond = dir != dir[1]
            //alertcondition(changeCond, title = "Alert on SuperTrend Direction Change", message = "SuperTrend has changed direction!")
            List<decimal> atrValueList = new();
            List<decimal> longStopList = new();
            List<decimal> shortStopList = new();
            List<decimal> dirList = new();
            List<decimal> trendList = new();
            List<Signal> signalsList = new();
            decimal atrMult = 3;

            try
            {
                var atrList = CalculateAverageTrueRange(stockDataClass, maType, days).Item1;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal currentAtr = atrList.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal atrValue = atrMult * currentAtr;
                    atrValueList.Add(atrValue);

                    decimal tempLongStop = currentValue - atrValue;
                    decimal prevLongStop = i >= 1 ? longStopList.ElementAtOrDefault(i - 1) : tempLongStop;
                    decimal tempShortStop = currentValue + atrValue;
                    decimal prevShortStop = i >= 1 ? shortStopList.ElementAtOrDefault(i - 1) : tempShortStop;
                    decimal prevDir = i >= 1 ? dirList.ElementAtOrDefault(i - 1) : 0;

                    decimal longStop = prevValue > prevLongStop ? Math.Max(tempLongStop, prevLongStop) : tempLongStop;
                    longStopList.Add(longStop);

                    decimal shortStop = prevValue < prevShortStop ? Math.Max(tempShortStop, prevShortStop) : tempShortStop;
                    shortStopList.Add(shortStop);

                    decimal dir = prevDir == -1 && currentValue > prevShortStop ? 1 : prevDir == 1 && currentValue < prevLongStop ? -1 : prevDir;
                    dirList.Add(dir);

                    decimal prevTrend = trendList.LastOrDefault();
                    decimal trend = dir > 0 ? longStop : shortStop;
                    trendList.Add(trend);

                    var signal = GetCompareSignal(currentValue - trend, prevValue - prevTrend);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (longStopList, shortStopList, dirList, trendList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateTrender(StockData stockDataClass, string maType, int days = 14)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Trender script may be freely distributed under the MIT license.
            //study("Trender", shorttitle = "TRNDR", overlay = true)

            //length = input(title = "Length", type = input.integer, defval = 14, minval = 1)
            //factor = input(title = "Factor", type = input.integer, defval = 2, minval = 1)
            //src = input(title = "Source", type = input.source, defval = hl2)

            //mpEma = ema(src, length)
            //trEma = ema(tr, length)
            //stdDev = stdev(trEma, length)

            //ad = src > src[1] ? mpEma + (trEma / 2) : src < src[1] ? mpEma - (trEma / 2) : mpEma
            //adm = ema(ad, length)

            //trndDn = 0.0
            //trndDn:= crossunder(adm, mpEma) ? high[2] : src < src[1] ? src + (stdDev * factor) : nz(trndDn[1], high[2])
            //trndUp = 0.0
            //trndUp:= crossover(adm, mpEma) ? low[2] : src > src[1] ? src - (stdDev * factor) : nz(trndUp[1], low[2])
            //trndr = 0.0
            //trndr:= adm < mpEma ? trndDn : adm > mpEma ? trndUp : nz(trndr[1], 0)

            //trndrColor = src > trndr ? color.green : src < trndr ? color.red : color.black
            //plot(trndr, color = trndrColor, linewidth = 2)
            //plot(mpEma, color = color.blue, linewidth = 2)
            //plot(adm, color = color.black, linewidth = 1)
            List<decimal> stdDevList = new();
            List<decimal> adList = new();
            List<decimal> admList = new();
            List<decimal> trndDnList = new();
            List<decimal> trndUpList = new();
            List<decimal> trndrList = new();
            List<Signal> signalsList = new();
            decimal atrMult = 2;

            try
            {
                var emaList = GetMovingAverageList(maType, null, stockDataClass, days);
                var atrList = CalculateAverageTrueRange(stockDataClass, maType, days).Item1;
                stdDevList = CalculateStandardDeviationVolatility(atrList, stockDataClass, days).Item4;

                for (int h = 0; h < stockDataClass.InputValues.Count; h++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(h);
                    decimal prevValue = h >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(h - 1) : 0;
                    decimal mpEma = emaList.ElementAtOrDefault(h);
                    decimal trEma = atrList.ElementAtOrDefault(h);

                    decimal ad = currentValue > prevValue ? mpEma + (trEma / 2) : currentValue < prevValue ? mpEma - (trEma / 2) : mpEma;
                    adList.Add(ad);
                }

                admList = GetMovingAverageList(maType, adList, stockDataClass, days);
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal adm = admList.ElementAtOrDefault(i);
                    decimal prevAdm = i >= 1 ? admList.ElementAtOrDefault(i - 1) : 0;
                    decimal mpEma = emaList.ElementAtOrDefault(i);
                    decimal prevMpEma = i >= 1 ? emaList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevHigh = i >= 2 ? stockDataClass.HighPrices.ElementAtOrDefault(i - 2) : 0;
                    decimal prevLow = i >= 2 ? stockDataClass.LowPrices.ElementAtOrDefault(i - 2) : 0;
                    decimal stdDev = stdDevList.ElementAtOrDefault(i);

                    decimal prevTrndDn = trndDnList.LastOrDefault();
                    decimal trndDn = adm < mpEma && prevAdm > prevMpEma ? prevHigh : currentValue < prevValue ? currentValue + (stdDev * atrMult) : prevTrndDn;
                    trndDnList.Add(trndDn);

                    decimal prevTrndUp = trndUpList.LastOrDefault();
                    decimal trndUp = adm > mpEma && prevAdm < prevMpEma ? prevLow : currentValue > prevValue ? currentValue - (stdDev * atrMult) : prevTrndUp;
                    trndUpList.Add(trndUp);

                    decimal prevTrndr = trndrList.LastOrDefault();
                    decimal trndr = adm < mpEma ? trndDn : adm > mpEma ? trndUp : prevTrndr;
                    trndrList.Add(trndr);

                    var signal = GetCompareSignal(currentValue - trndr, prevValue - prevTrndr);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (stdDevList, adList, admList, trndUpList, trndDnList, trndrList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>)
            CalculateFearAndGreedIndicator(StockData stockDataClass, string maType, int days = 10)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Fear And Greed Indicator script may be freely distributed under the MIT license.
            //study("Fear And Greed Indicator", shorttitle = "FGI", overlay = false)

            //fastLength = input(title = "FastLength", type = input.integer, defval = 10, minval = 1)
            //slowLength = input(title = "SlowLength", type = input.integer, defval = 30, minval = 1)
            //smoothLength = input(title = "SmoothLength", type = input.integer, defval = 2, minval = 1)
            //src = input(title = "Source", type = input.source, defval = close)

            //trUp = src > src[1] ? tr : 0
            //trDn = src < src[1] ? tr : 0
            //fastDiff = wma(trUp, fastLength) - wma(trDn, fastLength)
            //slowDiff = wma(trUp, slowLength) - wma(trDn, slowLength)
            //fgi = wma(fastDiff - slowDiff, smoothLength)

            //fgiColor = fgi > 0 ? color.green : fgi < 0 ? color.red : color.black
            //plot(fgi, color = fgiColor, style = plot.style_histogram, linewidth = 2)
            List<decimal> trUpList = new();
            List<decimal> trDnList = new();
            List<decimal> fastDiffList = new();
            List<decimal> slowDiffList = new();
            List<decimal> fgiList = new();
            List<decimal> fgiEmaList = new();
            List<decimal> fastTrUpList = new();
            List<decimal> fastTrDnList = new();
            List<decimal> slowTrUpList = new();
            List<decimal> slowTrDnList = new();
            List<Signal> signalsList = new();

            try
            {
                int smoothLength = MinOrMax((int)Math.Ceiling((decimal)days / 5));
                int slowLength = days * 3;

                var trList = CalculateVortexIndicator(stockDataClass, days).Item5;

                for (int h = 0; h < stockDataClass.InputValues.Count; h++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(h);
                    decimal prevValue = h >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(h - 1) : 0;
                    decimal tr = trList.ElementAtOrDefault(h);

                    decimal trUp = currentValue > prevValue ? tr : 0;
                    trUpList.Add(trUp);

                    decimal trDn = currentValue < prevValue ? tr : 0;
                    trDnList.Add(trDn);
                }

                fastTrUpList = GetMovingAverageList(maType, trUpList, stockDataClass, days);
                fastTrDnList = GetMovingAverageList(maType, trDnList, stockDataClass, days);
                slowTrUpList = GetMovingAverageList(maType, trUpList, stockDataClass, slowLength);
                slowTrDnList = GetMovingAverageList(maType, trDnList, stockDataClass, slowLength);
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal fastTrUp = fastTrUpList.ElementAtOrDefault(i);
                    decimal fastTrDn = fastTrDnList.ElementAtOrDefault(i);
                    decimal slowTrUp = slowTrUpList.ElementAtOrDefault(i);
                    decimal slowTrDn = slowTrDnList.ElementAtOrDefault(i);

                    decimal fastDiff = fastTrUp - fastTrDn;
                    fastDiffList.Add(fastDiff);

                    decimal slowDiff = slowTrUp - slowTrDn;
                    slowDiffList.Add(slowDiff);

                    decimal fgi = fastDiff - slowDiff;
                    fgiList.Add(fgi);
                }

                fgiEmaList = GetMovingAverageList(maType, fgiList, stockDataClass, smoothLength);
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal fgiEma = fgiEmaList.ElementAtOrDefault(j);
                    decimal prevFgiEma = j >= 1 ? fgiEmaList.ElementAtOrDefault(j - 1) : 0;

                    var signal = GetCompareSignal(fgiEma, prevFgiEma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (trUpList, trDnList, fastTrUpList, fastTrDnList, slowTrUpList, slowTrDnList, fastDiffList, slowDiffList, fgiList, fgiEmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateHampelFilter(StockData stockDataClass, int days = 14)
        {
            //@version=3
            // Copyright (c) 2018-present, Alex Orekhov (everget)
            // Hampel Filter script may be freely distributed under the MIT license.
            //study("Hampel Filter", shorttitle = "HF", overlay = true)

            //length = input(title = "Length", type = integer, minval = 1, defval = 14)
            //scalingFactor = input(title = "Scaling Factor", type = float, step = 0.1, defval = 3)
            //src = input(title = "Source", type = source, defval = close)

            //median(src, length) =>
            //    percentile_nearest_rank(src, length, 50)

            //getHF(src, length, scalingFactor) =>
            //    sampleMedian = median(src, length)

            // Median Absolute Deviation
            //mad = median(abs(src - sampleMedian), length)

            //hf = abs(src - sampleMedian) <= scalingFactor * mad ? src : sampleMedian
            //hf

            //hf = getHF(src, length, scalingFactor)

            // Calculate EMA of the filtered samples
            //alpha = 2 / (length + 1)
            //ema = 0.0
            //ema:= alpha * hf + (1 - alpha) * nz(ema[1])

            //plot(ema, title = "HF", linewidth = 2, color =#6d1e7f, transp=0)
            List<decimal> tempList = new();
            List<decimal> absDiffList = new();
            List<decimal> sampleMedianList = new();
            List<decimal> madList = new();
            List<decimal> hfList = new();
            List<decimal> hfEmaList = new();
            List<Signal> signalsList = new();
            decimal scalingFactor = 3;

            try
            {
                decimal alpha = (decimal)2 / (days + 1);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal prevValue = tempList.LastOrDefault();
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    tempList.Add(currentValue);

                    decimal sampleMedian = Median(tempList.TakeLast(days));
                    sampleMedianList.Add(sampleMedian);

                    decimal absDiff = Math.Abs(currentValue - sampleMedian);
                    absDiffList.Add(absDiff);

                    decimal mad = Median(absDiffList.TakeLast(days));
                    madList.Add(mad);

                    decimal hf = absDiff <= scalingFactor * mad ? currentValue : sampleMedian;
                    hfList.Add(hf);

                    decimal prevHfEma = hfEmaList.LastOrDefault();
                    decimal hfEma = (alpha * hf) + ((1 - alpha) * prevHfEma);
                    hfEmaList.Add(hfEma);

                    var signal = GetCompareSignal(currentValue - hfEma, prevValue - prevHfEma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (absDiffList, madList, hfList, hfEmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateInterquartileRangeBands(StockData stockDataClass, int days = 14)
        {
            //@version=3
            // Copyright (c) 2018-present, Alex Orekhov (everget)
            // Interquartile Range Bands script may be freely distributed under the MIT license.
            //study("Interquartile Range Bands", shorttitle = "IQRB", overlay = true)

            //length = input(title = "Length", type = integer, minval = 1, defval = 14)
            //mult = input(title = "Multiplier", type = float, minval = 0, step = 0.1, defval = 1.5)
            //src = input(title = "Source", type = source, defval = close)

            //q1 = percentile_nearest_rank(src, length, 25)
            //median = percentile_nearest_rank(src, length, 50)
            //q3 = percentile_nearest_rank(src, length, 75)

            //iqr = q3 - q1

            //upperBand = q3 + mult * iqr
            //lowerBand = q1 - mult * iqr

            //upperBandPlot = plot(upperBand, title = "Upper", color =#138484, transp=0)
            //plot(median, title = "Median", color =#741b47, transp=0)
            //lowerBandPlot = plot(lowerBand, title = "Lower", color =#138484, transp=0)
            //fill(upperBandPlot, lowerBandPlot, title = "Background", color = color(#ffd966, 84))
            List<decimal> iqrList = new();
            List<decimal> upperBandList = new();
            List<decimal> lowerBandList = new();
            List<decimal> middleBandList = new();
            List<Signal> signalsList = new();
            decimal mult = 1.5m;

            try
            {
                var trimeanList = CalculateTrimean(stockDataClass, days);
                var q1List = trimeanList.Item1;
                var medianList = trimeanList.Item2;
                var q3List = trimeanList.Item3;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal q1 = q1List.ElementAtOrDefault(i);
                    decimal median = medianList.ElementAtOrDefault(i);
                    decimal q3 = q3List.ElementAtOrDefault(i);

                    decimal iqr = q3 - q1;
                    iqrList.Add(iqr);

                    decimal upperBand = q3 + (mult * iqr);
                    upperBandList.Add(upperBand);

                    decimal lowerBand = q1 - (mult * iqr);
                    lowerBandList.Add(lowerBand);

                    decimal prevMiddleBand = middleBandList.LastOrDefault();
                    decimal middleBand = (upperBand + lowerBand) / 2;
                    middleBandList.Add(middleBand);

                    var signal = GetCompareSignal(currentValue - middleBand, prevValue - prevMiddleBand);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (iqrList, upperBandList, lowerBandList, middleBandList, signalsList);
        }

        public static (List<decimal>, List<Signal>) CalculateEhlersFiniteImpulseResponseFilter(StockData stockDataClass)
        {
            //@version=3
            // Copyright (c) 2018-present, Alex Orekhov (everget)
            // Finite Impulse Response (FIR) Filter indicator script may be freely distributed under the MIT license.
            //study("Finite Impulse Response (FIR) Filter", shorttitle = "FIRF", overlay = true)

            //coef1 = input(title = "1st Coefficient", type = float, defval = 1, step = 0.1)
            //coef2 = input(title = "2nd Coefficient", type = float, defval = 3.5, step = 0.1)
            //coef3 = input(title = "3rd Coefficient", type = float, defval = 4.5, step = 0.1)
            //coef4 = input(title = "4th Coefficient", type = float, defval = 3, step = 0.1)
            //coef5 = input(title = "5th Coefficient", type = float, defval = 0.5, step = 0.1)
            //coef6 = input(title = "6th Coefficient", type = float, defval = -0.5, step = 0.1)
            //coef7 = input(title = "7th Coefficient", type = float, defval = -1.5, step = 0.1)
            //src = input(title = "Source", type = source, defval = close)

            //coefSum = coef1 + coef2 + coef3 + coef4 + coef5 + coef6 + coef7

            //firf = (coef1 * src + coef2 * nz(src[1]) + coef3 * nz(src[2]) + coef4 * nz(src[3]) + coef5 * nz(src[4]) + coef6 * nz(src[5]) + coef7 * nz(src[6])) / coefSum

            //plot(firf, title = "IIRF", linewidth = 2, color =#741b47, transp=0)
            List<decimal> filterList = new();
            List<Signal> signalsList = new();
            decimal coef1 = 1, coef2 = 3.5m, coef3 = 4.5m, coef4 = 3, coef5 = 0.5m, coef6 = -0.5m, coef7 = -1.5m;

            try
            {
                decimal coefSum = coef1 + coef2 + coef3 + coef4 + coef5 + coef6 + coef7;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue1 = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevValue2 = i >= 2 ? stockDataClass.InputValues.ElementAtOrDefault(i - 2) : 0;
                    decimal prevValue3 = i >= 3 ? stockDataClass.InputValues.ElementAtOrDefault(i - 3) : 0;
                    decimal prevValue4 = i >= 4 ? stockDataClass.InputValues.ElementAtOrDefault(i - 4) : 0;
                    decimal prevValue5 = i >= 5 ? stockDataClass.InputValues.ElementAtOrDefault(i - 5) : 0;
                    decimal prevValue6 = i >= 6 ? stockDataClass.InputValues.ElementAtOrDefault(i - 6) : 0;

                    decimal prevFilter = filterList.LastOrDefault();
                    decimal filter = ((coef1 * currentValue) + (coef2 * prevValue1) + (coef3 * prevValue2) + (coef4 * prevValue3) + (coef5 * prevValue4) + (coef6 * prevValue5) +
                        (coef7 * prevValue6)) / coefSum;
                    filterList.Add(filter);

                    var signal = GetCompareSignal(currentValue - filter, prevValue1 - prevFilter);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (filterList, signalsList);
        }

        public static (List<decimal>, List<Signal>) CalculateEhlersInfiniteImpulseResponseFilter(StockData stockDataClass, int days = 14)
        {
            //@version=3
            // Copyright (c) 2018-present, Alex Orekhov (everget)
            // Infinite Impulse Response (IIR) Filter script may be freely distributed under the MIT license.
            //study("Infinite Impulse Response (IIR) Filter", shorttitle = "IIRF", overlay = true)

            //length = input(title = "Length", type = integer, defval = 14, minval = 1)
            //highlightMovements = input(title = "Highlight Movements ?", type = bool, defval = true)
            //src = input(title = "Source", type = source, defval = close)

            //iirfAlpha = 2 / (length + 1)

            //iirfLag = round((1 / iirfAlpha) - 1)

            //iirf = 0.0
            //iirf:= iirfAlpha * (src + change(src, iirfLag)) + (1 - iirfAlpha) * nz(iirf[1])

            //iirfColor = highlightMovements ? (iirf > iirf[1] ? green : red) : #6d1e7f
            //plot(iirf, title = "IIRF", linewidth = 2, color = iirfColor, transp = 0)
            List<decimal> filterList = new();
            List<Signal> signalsList = new();

            try
            {
                decimal alpha = (decimal)2 / (days + 1);
                int lag = MinOrMax((int)Math.Ceiling((1 / alpha) - 1));

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= lag ? stockDataClass.InputValues.ElementAtOrDefault(i - lag) : 0;
                    decimal prevFilter1 = i >= 1 ? filterList.ElementAtOrDefault(i - 1) : 0;

                    decimal filter = (alpha * (currentValue + (currentValue - prevValue))) + ((1 - alpha) * prevFilter1);
                    filterList.Add(filter);

                    var signal = GetCompareSignal(currentValue - filter, prevValue - prevFilter1);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (filterList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateEhlersDeviationScaledMovingAverage(
            StockData stockDataClass, string maType, int days = 20)
        {
            //@version=3
            // Copyright (c) 2018-present, Alex Orekhov (everget)
            // Ehlers Deviation-Scaled Moving Average script may be freely distributed under the MIT license.
            //study("Ehlers Deviation-Scaled Moving Average", shorttitle = "EDSMA", overlay = true)

            //length = input(title = "Length", type = integer, minval = 2, defval = 40)
            //ssfLength = input(title = "Super Smoother Filter Length", type = integer, minval = 1, defval = 20)
            //ssfPoles = input(title = "Super Smoother Filter Poles", type = integer, defval = 2, options =[2, 3])
            //highlightMovements = input(title = "Highlight Movements ?", type = bool, defval = true)
            //src = input(title = "Source", type = source, defval = close)

            //zeros = src - nz(src[2])
            //avgZeros = (zeros + zeros[1]) / 2

            // Ehlers Super Smoother Filter 
            //    ssf = ssfPoles == 2
            //     ? get2PoleSSF(avgZeros, ssfLength)
            //     : get3PoleSSF(avgZeros, ssfLength)

            // Rescale filter in terms of Standard Deviations
            //stdev = stdev(ssf, length)
            //scaledFilter = stdev != 0
            //     ? ssf / stdev
            //     : 0

            //alpha = 5 * abs(scaledFilter) / length

            //edsma = 0.0
            //edsma:= alpha * src + (1 - alpha) * nz(edsma[1])

            //edsmaColor = highlightMovements ? (edsma > edsma[1] ? green : red) : #6d1e7f
            //plot(edsma, title = "EDSMA", linewidth = 2, color = edsmaColor, transp = 0)
            List<decimal> edsma2PoleList = new();
            List<decimal> ssf2PoleList = new();
            List<decimal> ssf2PoleStdDevList = new();
            List<decimal> zerosList = new();
            List<decimal> avgZerosList = new();
            List<decimal> scaledFilter2PoleList = new();
            List<decimal> alpha2PoleList = new();
            List<Signal> signalsList = new();

            try
            {
                int length = days * 2;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue2 = i >= 2 ? stockDataClass.InputValues.ElementAtOrDefault(i - 2) : 0;

                    decimal prevZeros = zerosList.LastOrDefault();
                    decimal zeros = currentValue - prevValue2;
                    zerosList.Add(zeros);

                    decimal avgZeros = (zeros + prevZeros) / 2;
                    avgZerosList.Add(avgZeros);
                }

                ssf2PoleList = GetMovingAverageList(maType, avgZerosList, stockDataClass, days);
                ssf2PoleStdDevList = CalculateStandardDeviationVolatility(ssf2PoleList, stockDataClass, length).Item4;
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(j);
                    decimal currentSsf2Pole = ssf2PoleList.ElementAtOrDefault(j);
                    decimal currentSsf2PoleStdDev = ssf2PoleStdDevList.ElementAtOrDefault(j);
                    decimal prevValue = j >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(j - 1) : 0;

                    decimal prevScaledFilter2Pole = scaledFilter2PoleList.LastOrDefault();
                    decimal scaledFilter2Pole = currentSsf2PoleStdDev != 0 ? currentSsf2Pole / currentSsf2PoleStdDev : prevScaledFilter2Pole;
                    scaledFilter2PoleList.Add(scaledFilter2Pole);

                    decimal alpha2Pole = MinOrMax(5 * Math.Abs(scaledFilter2Pole) / length, 0.99m, 0.01m);
                    alpha2PoleList.Add(alpha2Pole);

                    decimal prevEdsma2pole = edsma2PoleList.LastOrDefault();
                    decimal edsma2Pole = (alpha2Pole * currentValue) + ((1 - alpha2Pole) * prevEdsma2pole);
                    edsma2PoleList.Add(edsma2Pole);

                    var signal = GetCompareSignal(currentValue - edsma2Pole, prevValue - prevEdsma2pole);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (zerosList, avgZerosList, ssf2PoleList, ssf2PoleStdDevList, scaledFilter2PoleList, alpha2PoleList, edsma2PoleList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateEhlersHighPassFilterV2(StockData stockDataClass, string maType, int days = 20)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Ehlers High Pass Filter [CC] script may be freely distributed under the MIT license.
            //study("Ehlers High Pass Filter [CC]", overlay = false)

            //inp = input(title = "Source", type = input.source, defval = close)
            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //src = security(syminfo.tickerid, res, inp[rep ? 0 : barstate.isrealtime ? 1 : 0])[rep ? 0 : barstate.isrealtime ? 0 : 1]
            //length = input(title = "Length", type = input.integer, defval = 20, minval = 1)

            //a1 = exp(-1.414 * math.pi / length)
            //b1 = 2 * a1 * cos(1.414 * math.pi / length)
            //c2 = b1
            //c3 = -a1 * a1
            //c1 = (1 + c2 - c3) / 4

            //hp = 0.0
            //hp:= bar_index < 4 ? 0 : (c1 * (src - (2 * nz(src[1])) + nz(src[2]))) + (c2 * nz(hp[1])) + (c3 * nz(hp[2]))
            //hpMa = wma(wma(hp, length), length)

            //slo = hpMa - nz(hpMa[1])
            //sig = slo > 0 ? slo > nz(slo[1]) ? 2 : 1 : slo < 0 ? slo < nz(slo[1]) ? -2 : -1 : 0
            //alertcondition(crossover(sig, 1), "Strong Buy Signal", "Strong Bullish Change Detected")
            //alertcondition(crossunder(sig, -1), "Strong Sell Signal", "Strong Bearish Change Detected")
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //hpColor = sig > 1 ? color.green : sig > 0 ? color.lime : sig < -1 ? color.maroon : sig < 0 ? color.red : color.black
            //barcolor(bar ? hpColor : na)
            //hline(0)
            //plot(hpMa, title = "HP", color = hpColor, linewidth = 2)
            List<decimal> hpList = new();
            List<decimal> hpMa1List = new();
            List<decimal> hpMa2List = new();
            List<Signal> signalsList = new();

            try
            {
                decimal a1 = Exp(-1.414 * Math.PI / days);
                decimal b1 = 2 * a1 * Cos(1.414 * Math.PI / days);
                decimal c2 = b1;
                decimal c3 = -a1 * a1;
                decimal c1 = (1 + c2 - c3) / 4;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue1 = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevValue2 = i >= 2 ? stockDataClass.InputValues.ElementAtOrDefault(i - 2) : 0;
                    decimal prevHp1 = i >= 1 ? hpList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevHp2 = i >= 2 ? hpList.ElementAtOrDefault(i - 2) : 0;

                    decimal hp = i < 4 ? 0 : (c1 * (currentValue - (2 * prevValue1) + prevValue2)) + (c2 * prevHp1) + (c3 * prevHp2);
                    hpList.Add(hp);
                }

                hpMa1List = GetMovingAverageList(maType, hpList, stockDataClass, days);
                hpMa2List = GetMovingAverageList(maType, hpMa1List, stockDataClass, days);
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal hp = hpMa2List.ElementAtOrDefault(j);
                    decimal prevHp1 = j >= 1 ? hpMa2List.ElementAtOrDefault(j - 1) : 0;
                    decimal prevHp2 = j >= 2 ? hpMa2List.ElementAtOrDefault(j - 2) : 0;

                    var signal = GetCompareSignal(hp - prevHp1, prevHp1 - prevHp2);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (hpList, hpMa1List, hpMa2List, signalsList);
        }

        public static (List<decimal>, List<Signal>) CalculateEhlersMovingAverageDifferenceIndicator(StockData stockDataClass, string maType, int days = 8)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Ehlers Moving Average Difference Indicator [CC] script may be freely distributed under the MIT license.
            //study("Ehlers Moving Average Difference Indicator [CC]", overlay = false)

            //inp = input(title = "Source", type = input.source, defval = close)
            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //src = security(syminfo.tickerid, res, inp[rep ? 0 : barstate.isrealtime ? 1 : 0])[rep ? 0 : barstate.isrealtime ? 0 : 1]
            //shortLength = input(title = "ShortLength", type = input.integer, defval = 8, minval = 1)
            //longLength = input(title = "LongLength", type = input.integer, defval = 23, minval = 1)

            //shortMa = wma(src, shortLength)
            //longMa = wma(src, longLength)
            //mad = longMa != 0 ? 100 * (shortMa - longMa) / longMa : 0

            //slo = mad - nz(mad[1])
            //sig = slo > 0 ? slo > nz(slo[1]) ? 2 : 1 : slo < 0 ? slo < nz(slo[1]) ? -2 : -1 : 0
            //alertcondition(crossover(sig, 1), "Strong Buy Signal", "Strong Bullish Change Detected")
            //alertcondition(crossunder(sig, -1), "Strong Sell Signal", "Strong Bearish Change Detected")
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //madColor = sig > 1 ? color.green : sig > 0 ? color.lime : sig < -1 ? color.maroon : sig < 0 ? color.red : color.white
            //barcolor(bar ? madColor : na)
            //hline(0)
            //plot(mad, title = "MAD", color = madColor, linewidth = 2)
            List<decimal> madList = new();
            List<Signal> signalsList = new();

            try
            {
                int shortLength = days;
                int longLength = (int)Math.Ceiling(days / 0.3479);

                var shortMaList = GetMovingAverageList(maType, null, stockDataClass, shortLength);
                var longMaList = GetMovingAverageList(maType, null, stockDataClass, longLength);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal shortMa = shortMaList.ElementAtOrDefault(i);
                    decimal longMa = longMaList.ElementAtOrDefault(i);
                    decimal prevMad1 = i >= 1 ? madList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevMad2 = i >= 2 ? madList.ElementAtOrDefault(i - 2) : 0;

                    decimal mad = longMa != 0 ? 100 * (shortMa - longMa) / longMa : 0;
                    madList.Add(mad);

                    var signal = GetCompareSignal(mad - prevMad1, prevMad1 - prevMad2);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (madList, signalsList);
        }

        public static (List<decimal>, List<Signal>) CalculateEhlersFisherizedDeviationScaledOscillator(StockData stockDataClass, string maType, int days = 40)
        {
            //@version=3
            // Copyright (c) 2018-present, Alex Orekhov (everget)
            // Ehlers Fisherized Deviation-Scaled Oscillator script may be freely distributed under the MIT license.
            //study("Ehlers Fisherized Deviation-Scaled Oscillator", shorttitle = "EFDSO")

            //length = input(title = "Length", type = integer, defval = 40, minval = 1)
            //ssfLength = input(title = "Super Smoother Filter Length", type = integer, defval = 20, minval = 1)
            //numberOfPoles = input(title = "Number of Poles", type = integer, defval = 2, options =[2, 3])
            //obLevel = input(title = "Overbought Level", type = float, step = 0.1, defval = 2)
            //osLevel = input(title = "Oversold Level", type = float, step = 0.1, defval = -2)
            //maxLevel = input(title = "Max Level", type = float, step = 0.1, defval = 4.0)
            //minLevel = input(title = "Min Level", type = float, step = 0.1, defval = -4.0)
            //highlightBreakouts = input(title = "Highlight Overbought/Oversold Breakouts ?", type = bool, defval = true)
            //src = input(title = "Source", type = source, defval = close)

            //PI = 2 * asin(1)

            //get2PoleSSF(src, length) =>
            //    arg = sqrt(2) * PI / length
            //    a1 = exp(-arg)
            //    b1 = 2 * a1 * cos(arg)
            //    c2 = b1
            //    c3 = -pow(a1, 2)
            //    c1 = 1 - c2 - c3

            //    ssf = 0.0
            //    ssf:= c1 * src + c2 * nz(ssf[1]) + c3 * nz(ssf[2])

            //get3PoleSSF(src, length) =>
            //    arg = PI / length
            //    a1 = exp(-arg)
            //    b1 = 2 * a1 * cos(1.738 * arg)
            //    c1 = pow(a1, 2)

            //    coef2 = b1 + c1
            //    coef3 = -(c1 + b1 * c1)
            //    coef4 = pow(c1, 2)
            //    coef1 = 1 - coef2 - coef3 - coef4

            //    ssf = 0.0
            //    ssf:= coef1 * src + coef2 * nz(ssf[1]) + coef3 * nz(ssf[2]) + coef4 * nz(ssf[3])

            //zeros = src - nz(src[2])
            //arg = avg(zeros, zeros[1])

            // Ehlers Super Smoother Filter 
            //     essf = numberOfPoles == 2
            //     ? get2PoleSSF(arg, ssfLength)
            //     : get3PoleSSF(arg, ssfLength)

            // Rescale filter in terms of Standard Deviations
            //stdev = stdev(essf, length)
            //scaledFilter = 0.0
            //scaledFilter:= stdev != 0
            //    ? essf / stdev
            //    : nz(scaledFilter[1])

            // Apply Fisher Transform to establish real Gaussian Probability Distribution
            //efdso = 0.0
            //efdso:= abs(scaledFilter) < 2
            //    ? 0.5 * log((1 + scaledFilter / 2) / (1 - scaledFilter / 2))
            //    : nz(efdso[1])

            //efdsoColor = efdso > obLevel ? #0ebb23 : efdso < osLevel ? #ff0000 : #f4b77d
            //plot(efdso, title = "EFDSO", linewidth = 2, color = efdsoColor, transp = 0)

            //transparent = color(white, 100)

            //maxLevelPlot = hline(maxLevel, title = "Max Level", linestyle = dotted, color = transparent)
            //obLevelPlot = hline(obLevel, title = "Overbought Level", linestyle = dotted)
            //hline(0, title = "Zero Level", linestyle = dotted)
            //osLevelPlot = hline(osLevel, title = "Oversold Level", linestyle = dotted)
            //minLevelPlot = hline(minLevel, title = "Min Level", linestyle = dotted, color = transparent)

            //fill(obLevelPlot, osLevelPlot, color = purple, transp = 95)

            //obFillColor = efdso > obLevel and highlightBreakouts ? green: transparent
            //osFillColor = efdso < osLevel and highlightBreakouts ? red: transparent

            //fill(maxLevelPlot, obLevelPlot, color = obFillColor, transp = 90)
            //fill(minLevelPlot, osLevelPlot, color = osFillColor, transp = 90)
            List<decimal> efdso2PoleList = new();
            List<Signal> signalsList = new();

            try
            {
                var scaledFilter2PoleList = CalculateEhlersDeviationScaledMovingAverage(stockDataClass, maType, days).Item7;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentScaledFilter2Pole = scaledFilter2PoleList.ElementAtOrDefault(i);
                    decimal prevEfdsoPole1 = i >= 1 ? efdso2PoleList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevEfdsoPole2 = i >= 2 ? efdso2PoleList.ElementAtOrDefault(i - 2) : 0;

                    decimal efdso2Pole = Math.Abs(currentScaledFilter2Pole) < 2 ? 0.5m * Log((1 + (currentScaledFilter2Pole / 2)) / (1 - (currentScaledFilter2Pole / 2))) : prevEfdsoPole1;
                    efdso2PoleList.Add(efdso2Pole);

                    var signal = GetRsiSignal(efdso2Pole - prevEfdsoPole1, prevEfdsoPole1 - prevEfdsoPole2, efdso2Pole, prevEfdsoPole1, 2, -2);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (efdso2PoleList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateFractalAdaptiveMovingAverage(StockData stockDataClass, int days = 20)
        {
            //input = price, user defined, default is midpoint
            //period = p1 = user defined, default is 20
            //exp = function, returns Euler’s number (e) raised to power of its argument
            //log = function, returns natural logarithm of its argument
            //index = current bar number, prev = previous

            //prevF = ifNull(price, filt[index - 1]);  //feedback ingredent
            //hh = highest(index, p1, HIGH);
            //ll = lowest(index, p1, LOW);
            //n3 = (hh - ll) / p1;
            //halfP = p1 / 2;
            //hh = highest(index, halfP, HIGH);
            //ll = lowest(index, halfP, LOW);
            //n1 = (hh - ll) / halfP;
            //hh = highest(index - halfP, halfP, HIGH);
            //ll = lowest(index - halfP, halfP, LOW);
            //n2 = (hh - ll) / halfP;
            //if (n1 moreThan 0 AND n2 moreThan 0 AND n3 moreThan 0) 
            //dm = (Math.log(n1 + n2) - Math.log(n3)) / Math.log(2);
            //alpha = Math.exp(-4.6 * (dm - 1));
            //if (alpha lessThan .01) alpha = .01;
            //if (alpha moreThan 1) alpha = 1;
            //Plot: filt = alpha * price + (1 - alpha) * prevF;
            List<decimal> filterList = new();
            List<decimal> tempHighList = new();
            List<decimal> tempLowList = new();
            List<decimal> dmList = new();
            List<decimal> n1List = new();
            List<decimal> n2List = new();
            List<decimal> n3List = new();
            List<Signal> signalsList = new();

            try
            {
                int halfP = MinOrMax((int)Math.Ceiling((decimal)days / 2));

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevFilter = i >= 1 ? filterList.LastOrDefault() : currentValue;
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal currentHigh = stockDataClass.HighPrices.ElementAtOrDefault(i);
                    tempHighList.Add(currentHigh);

                    decimal currentLow = stockDataClass.LowPrices.ElementAtOrDefault(i);
                    tempLowList.Add(currentLow);

                    decimal highestHigh1 = tempHighList.TakeLast(days).Max();
                    decimal lowestLow1 = tempLowList.TakeLast(days).Min();

                    decimal n3 = (highestHigh1 - lowestLow1) / days;
                    n3List.Add(n3);

                    decimal highestHigh2 = tempHighList.TakeLast(halfP).Max();
                    decimal lowestLow2 = tempLowList.TakeLast(halfP).Min();

                    decimal n1 = (highestHigh2 - lowestLow2) / halfP;
                    n1List.Add(n1);

                    decimal highestHigh3 = tempHighList.Slice(Math.Max(i - halfP, 0), halfP).Max();
                    decimal lowestLow3 = tempLowList.Slice(Math.Max(i - halfP, 0), halfP).Min();

                    decimal n2 = (highestHigh3 - lowestLow3) / halfP;
                    n2List.Add(n2);

                    decimal dm = n1 > 0 && n2 > 0 && n3 > 0 ? (Log(n1 + n2) - Log(n3)) / Log((double)2) : 0;
                    dmList.Add(dm);

                    decimal alpha = MinOrMax(Exp(-4.6m * (dm - 1)), 1, 0.01m);
                    decimal filter = (alpha * currentValue) + ((1 - alpha) * prevFilter);
                    filterList.Add(filter);

                    var signal = GetCompareSignal(currentValue - filter, prevValue - prevFilter);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (n1List, n2List, n3List, dmList, filterList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateApirineSlowRelativeStrengthIndex(
            StockData stockDataClass, string maType, int days = 6)
        {
            //
            // @author LazyBear 
            // 
            // List of my public indicators: http://bit.ly/1LQaPK8  
            // List of my app-store indicators: http://blog.tradingview.com/?p=970 
            //
            //study("Apirine Slow RSI [LazyBear]", shorttitle = "ASRSI_LB", overlay = false, precision = 3)
            //periods = input(6, title = "Smoothing", minval = 1, maxval = 100)
            //smooth = input(14, title = "RSI Length", minval = 1, maxval = 100)
            //price = input(close, title = "Source")
            //calc_wima(src, length) => 
            //    MA_s = (src + nz(MA_s[1] * (length - 1))) / length
            //    MA_s

            //r1 = ema(price, periods)
            //r2 = iff(price > r1, price - r1, 0)
            //r3 = iff(price < r1, r1 - price, 0)
            //r4 = calc_wima(r2, smooth)
            //r5 = calc_wima(r3, smooth)
            //rr = iff(r5 == 0, 100, 100 - (100 / (1 + (r4 / r5))))
            //obl = input(70, title = "OB Level")
            //ovl = input(30, title = "OS Level")
            List<decimal> r2List = new();
            List<decimal> r3List = new();
            List<decimal> r4List = new();
            List<decimal> r5List = new();
            List<decimal> rrList = new();
            List<decimal> rsList = new();
            List<Signal> signalsList = new();

            try
            {
                int smoothPeriod = MinOrMax((int)Math.Ceiling(days / 0.428));

                List<decimal> emaList = CalculateExponentialMovingAverage(stockDataClass, days).Item1;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal r1 = emaList.ElementAtOrDefault(i);

                    decimal r2 = currentValue > r1 ? currentValue - r1 : 0;
                    r2List.Add(r2);

                    decimal r3 = currentValue < r1 ? r1 - currentValue : 0;
                    r3List.Add(r3);
                }

                r4List = GetMovingAverageList(maType, r2List, stockDataClass, smoothPeriod);
                r5List = GetMovingAverageList(maType, r3List, stockDataClass, smoothPeriod);
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal r4 = r4List.ElementAtOrDefault(j);
                    decimal r5 = r5List.ElementAtOrDefault(j);
                    decimal prevRr1 = j >= 1 ? rrList.ElementAtOrDefault(j - 1) : 0;
                    decimal prevRr2 = j >= 2 ? rrList.ElementAtOrDefault(j - 2) : 0;

                    decimal rs = r5 != 0 ? r4 / r5 : 0;
                    rsList.Add(rs);

                    decimal rr = r5 == 0 ? 100 : r4 == 0 ? 0 : MinOrMax(100 - (100 / (1 + rs)), 100, 0);
                    rrList.Add(rr);

                    var signal = GetRsiSignal(rr - prevRr1, prevRr1 - prevRr2, rr, prevRr1, 70, 30);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (r2List, r3List, r4List, r5List, rsList, rrList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateAdaptiveMovingAverage(StockData stockDataClass, int days = 2)
        {
            //@version=3
            // Copyright (c) 2018-present, Alex Orekhov (everget)
            // Adaptive Moving Average script may be freely distributed under the MIT license.
            //study("Adaptive Moving Average", shorttitle = "AMA", overlay = true)

            //length = input(title = "Length", type = integer, defval = 14)
            //fastLength = input(title = "Fast EMA Length", type = integer, defval = 2)
            //slowLength = input(title = "Slow EMA Length", type = integer, defval = 30)
            //highlightMovements = input(title = "Highlight Movements ?", type = bool, defval = true)
            //src = input(title = "Source", type = source, defval = close)

            //fastAlpha = 2 / (fastLength + 1)
            //slowAlpha = 2 / (slowLength + 1)

            //hh = highest(length + 1)
            //ll = lowest(length + 1)

            //mltp = hh - ll != 0 ? abs(2 * src - ll - hh) / (hh - ll) : 0

            //ssc = mltp * (fastAlpha - slowAlpha) + slowAlpha

            //ama = 0.0
            //ama:= nz(ama[1]) + pow(ssc, 2) * (src - nz(ama[1]))

            //amaColor = highlightMovements ? (ama > ama[1] ? green : red) : #6d1e7f
            //plot(ama, title = "AMA", linewidth = 2, color = amaColor, transp = 0)
            List<decimal> mltpList = new();
            List<decimal> sscList = new();
            List<decimal> amaList = new();
            List<Signal> signalsList = new();

            try
            {
                int length = days * 7;
                int slowLength = days * 15;
                decimal fastAlpha = (decimal)2 / (days + 1);
                decimal slowAlpha = (decimal)2 / (slowLength + 1);

                var list = VolumeInputCheck(stockDataClass, length + 1, true);
                var highList = list.Item1;
                var lowList = list.Item2;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal hh = highList.ElementAtOrDefault(i);
                    decimal ll = lowList.ElementAtOrDefault(i);

                    decimal mltp = hh - ll != 0 ? MinOrMax(Math.Abs((2 * currentValue) - ll - hh) / (hh - ll), 1, 0) : 0;
                    mltpList.Add(mltp);

                    decimal ssc = (mltp * (fastAlpha - slowAlpha)) + slowAlpha;
                    sscList.Add(ssc);

                    decimal prevAma = amaList.LastOrDefault();
                    decimal ama = prevAma + (Pow(ssc, 2) * (currentValue - prevAma));
                    amaList.Add(ama);

                    var signal = GetCompareSignal(currentValue - ama, prevValue - prevAma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (mltpList, sscList, amaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateAdaptiveExponentialMovingAverage(StockData stockDataClass, int days = 10)
        {
            //@version=3
            // Copyright (c) 2019-present, Vitali Apirine
            // Copyright (c) 2019-present, Alex Orekhov (everget)
            //study("Adaptive Exponential Moving Average", shorttitle = "AEMA", overlay = true)

            //length = input(title = "Length", type = integer, defval = 10)
            //hlLookback = input(title = "Highest/Lowest Lookback", type = integer, defval = 10)
            //src = input(title = "Source", type = source, defval = close)
            //highlightMovements = input(title = "Highlight Movements ?", type = bool, defval = false)

            //hh = highest(hlLookback)
            ///ll = lowest(hlLookback)

            //mltp1 = 2 / (length + 1)
            //mltp2 = hh - ll != 0 ? abs(2 * src - ll - hh) / (hh - ll) : 0

            //rate = mltp1 * (1 + mltp2)

            //ma = 0.0
            //if n <= length
            //    ma:= sma(src, length)
            //else
            //    ma:= nz(ma[1], src) + rate * (src - nz(ma[1], src))

            //maColor = highlightMovements ? (ma > ma[1] ? green : red) : #512da8
            //plot(ma, title = "AMA", linewidth = 2, color = maColor, transp = 0)
            List<decimal> mltpList = new();
            List<decimal> rateList = new();
            List<decimal> aemaList = new();
            List<Signal> signalsList = new();

            try
            {
                decimal mltp1 = (decimal)2 / (days + 1);

                var list = VolumeInputCheck(stockDataClass, days, true);
                var highList = list.Item1;
                var lowList = list.Item2;
                var smaList = CalculateSimpleMovingAverage(stockDataClass, days).Item1;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal hh = highList.ElementAtOrDefault(i);
                    decimal ll = lowList.ElementAtOrDefault(i);
                    decimal sma = smaList.ElementAtOrDefault(i);

                    decimal mltp2 = hh - ll != 0 ? MinOrMax(Math.Abs((2 * currentValue) - ll - hh) / (hh - ll), 1, 0) : 0;
                    mltpList.Add(mltp2);

                    decimal rate = mltp1 * (1 + mltp2);
                    rateList.Add(rate);

                    decimal prevAema = i >= 1 ? aemaList.LastOrDefault() : currentValue;
                    decimal aema = i <= days ? sma : prevAema + (rate * (currentValue - prevAema));
                    aemaList.Add(aema);

                    var signal = GetCompareSignal(currentValue - aema, prevValue - prevAema);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (mltpList, rateList, aemaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateEhlersHilbertTransformIndicator(StockData stockDataClass, int days = 7)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Ehlers Hilbert Transform [CC] script may be freely distributed under the MIT license.
            //study("Ehlers Hilbert Transform [CC]", overlay = false)

            //inp = input(title = "Source", type = input.source, defval = hl2)
            //res = input(title = "Resolution", type = input.resolution, defval = "D")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //src = security(syminfo.tickerid, res, inp[rep ? 0 : barstate.isrealtime ? 1 : 0])[rep ? 0 : barstate.isrealtime ? 0 : 1]
            //length = input(title = "Length", type = input.integer, defval = 7, minval = 1)

            //v1 = src - nz(src[length])

            //ip = 0.0
            //ip:= (1.25 * (nz(v1[4]) - (0.635 * nz(v1[2])))) + (0.635 * nz(ip[3]))

            //qu = 0.0
            //qu:= nz(v1[2]) - (0.338 * v1) + (0.338 * nz(qu[2]))

            //sig = qu > -ip ? 1 : qu < -ip ? -1 : 0
            //htColor = sig > 0 ? color.green : sig < 0 ? color.red : color.black
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //barcolor(bar ? htColor : na)
            //hline(0)
            //plot(-ip, title = "InPhase", color = color.red, linewidth = 2)
            //plot(qu, title = "Quadrature", color = color.blue, linewidth = 2)
            decimal iMult = 0.635m, qMult = 0.338m;
            List<decimal> v1List = new();
            List<decimal> inPhaseList = new();
            List<decimal> quadList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= days ? stockDataClass.InputValues.ElementAtOrDefault(i - days) : 0;
                    decimal v2 = i >= 2 ? v1List.ElementAtOrDefault(i - 2) : 0;
                    decimal v4 = i >= 4 ? v1List.ElementAtOrDefault(i - 4) : 0;
                    decimal inPhase3 = i >= 3 ? inPhaseList.ElementAtOrDefault(i - 3) : 0;
                    decimal quad2 = i >= 2 ? quadList.ElementAtOrDefault(i - 2) : 0;

                    decimal v1 = currentValue - prevValue;
                    v1List.Add(v1);

                    decimal prevInPhase = inPhaseList.LastOrDefault();
                    decimal inPhase = (1.25m * (v4 - (iMult * v2))) + (iMult * inPhase3);
                    inPhaseList.Add(inPhase);

                    decimal prevQuad = quadList.LastOrDefault();
                    decimal quad = v2 - (qMult * v1) + (qMult * quad2);
                    quadList.Add(quad);

                    var signal = GetCompareSignal(quad - (-1 * inPhase), prevQuad - (-1 * prevInPhase));
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (inPhaseList, quadList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateEhlersInstantaneousPhaseIndicator(StockData stockDataClass, int days = 7)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Ehlers Instantaneous Phase Indicator [CC] script may be freely distributed under the MIT license.
            //study("Ehlers Instantaneous Phase Indicator [CC]", overlay = false)

            //inp = input(title = "Source", type = input.source, defval = hl2)
            //res = input(title = "Resolution", type = input.resolution, defval = "D")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //src = security(syminfo.tickerid, res, inp[rep ? 0 : barstate.isrealtime ? 1 : 0])[rep ? 0 : barstate.isrealtime ? 0 : 1]
            //length = input(title = "Length", type = input.integer, defval = 7, minval = 1)
            //maxLength = input(title = "MaxLength", type = input.integer, defval = 50, minval = 1)

            //v1 = src - nz(src[length])

            //ip = 0.0
            //ip:= (1.25 * (nz(v1[4]) - (0.635 * nz(v1[2])))) + (0.635 * nz(ip[3]))

            //qu = 0.0
            //qu:= nz(v1[2]) - (0.338 * v1) + (0.338 * nz(qu[2]))

            //phase = abs(ip + nz(ip[1])) > 0 ? atan(abs((qu + nz(qu[1])) / (ip + nz(ip[1])))) * 180 / math.pi : 0
            //phase:= ip < 0 and qu > 0 ? 180 - phase : phase
            //phase:= ip < 0 and qu< 0 ? 180 + phase : phase
            //phase:= ip > 0 and qu< 0 ? 360 - phase : phase

            //dPhase = nz(phase[1]) - phase
            //dPhase:= nz(phase[1]) < 90 and phase > 270 ? 360 + nz(phase[1]) - phase : dPhase
            //dPhase:= max(min(60, dPhase), 1)

            //instPeriod = 0.0, v4 = 0.0
            //for i = 0 to maxLength
            //    v4 := v4 + nz(dPhase[i])

            //    if (v4 > 360 and instPeriod == 0)
            //        instPeriod:= i

            //dcPeriod = 0.0
            //dcPeriod:= (0.25 * instPeriod) + (0.75 * nz(dcPeriod[1]))

            //sig = qu > -ip ? 1 : qu < -ip ? -1 : 0
            //ipiColor = sig > 0 ? color.green : sig < 0 ? color.red : color.black
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //barcolor(bar ? ipiColor : na)
            //plot(dcPeriod, title = "Period", color = ipiColor, linewidth = 2)
            List<decimal> phaseList = new();
            List<decimal> dPhaseList = new();
            List<decimal> instPeriodList = new();
            List<decimal> dcPeriodList = new();
            List<decimal> v4List = new();
            List<Signal> signalsList = new();

            try
            {
                int maxLength = (int)Math.Ceiling(days / 0.14);

                var ehtList = CalculateEhlersHilbertTransformIndicator(stockDataClass, days);
                var ipList = ehtList.Item1;
                var quList = ehtList.Item2;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal ip = ipList.ElementAtOrDefault(i);
                    decimal qu = quList.ElementAtOrDefault(i);
                    decimal prevIp = i >= 1 ? ipList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevQu = i >= 1 ? quList.ElementAtOrDefault(i - 1) : 0;

                    decimal prevPhase = phaseList.LastOrDefault();
                    decimal phase = Math.Abs(ip + prevIp) > 0 ? ToDegrees(Atan(Math.Abs((qu + prevQu) / (ip + prevIp)))) : 0;
                    phase = ip < 0 && qu > 0 ? 180 - phase : phase;
                    phase = ip < 0 && qu < 0 ? 180 + phase : phase;
                    phase = ip > 0 && qu < 0 ? 360 - phase : phase;
                    phaseList.Add(phase);

                    decimal dPhase = prevPhase - phase;
                    dPhase = prevPhase < 90 && phase > 270 ? 360 + prevPhase - phase : dPhase;
                    dPhase = MinOrMax(dPhase, 60, 1);
                    dPhaseList.Add(dPhase);

                    decimal instPeriod = 0, v4 = 0;
                    for (int j = 0; j <= maxLength; j++)
                    {
                        decimal prevDPhase = i >= j ? dPhaseList.ElementAtOrDefault(i - j) : 0;
                        v4 += prevDPhase;
                        instPeriod = v4 > 360 && instPeriod == 0 ? j : instPeriod;
                    }
                    v4List.Add(v4);
                    instPeriodList.Add(instPeriod);

                    decimal prevDcPeriod = dcPeriodList.LastOrDefault();
                    decimal dcPeriod = (0.25m * instPeriod) + (0.75m * prevDcPeriod);
                    dcPeriodList.Add(dcPeriod);

                    var signal = GetCompareSignal(qu - (-1 * ip), prevQu - (-1 * prevIp));
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (phaseList, dPhaseList, v4List, instPeriodList, dcPeriodList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateEhlersSquelchIndicator(StockData stockDataClass, int days = 6)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Ehlers Squelch Indicator [CC] script may be freely distributed under the MIT license.
            //study("Ehlers Squelch Indicator [CC]", overlay = false)

            //inp = input(title = "Source", type = input.source, defval = hl2)
            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //src = security(syminfo.tickerid, res, inp[rep ? 0 : barstate.isrealtime ? 1 : 0])[rep ? 0 : barstate.isrealtime ? 0 : 1]
            //length = input(title = "Length", type = input.integer, defval = 6, minval = 1)
            //squelch = input(title = "Squelch", type = input.integer, defval = 20, minval = 1)
            //maxLength = input(title = "MaxLength", type = input.integer, defval = 40, minval = 1)

            //v1 = src - nz(src[length])
            //v2 = nz(v1[3])
            //v3 = (0.75 * (v1 - nz(v1[length]))) + (0.25 * (nz(v1[2]) - nz(v1[4])))

            //ip = 0.0
            //ip:= (0.33 * v2) + (0.67 * nz(ip[1]))

            //qu = 0.0
            //qu:= (0.2 * v3) + (0.8 * nz(qu[1]))

            //phase = abs(ip + nz(ip[1])) > 0 ? atan(abs((qu + nz(qu[1])) / (ip + nz(ip[1])))) * 180 / math.pi : 0
            //phase:= ip < 0 and qu > 0 ? 180 - phase : phase
            //phase:= ip < 0 and qu< 0 ? 180 + phase : phase
            //phase:= ip > 0 and qu< 0 ? 360 - phase : phase

            //dPhase = nz(phase[1]) - phase
            //dPhase:= nz(phase[1]) < 90 and phase > 270 ? 360 + nz(phase[1]) - phase : dPhase
            //dPhase:= max(min(60, dPhase), 1)

            //instPeriod = 0.0, v4 = 0.0
            //for i = 0 to maxLength
            //    v4 := v4 + nz(dPhase[i])
            //    instPeriod := v4 > 360 and instPeriod == 0 ? i : instPeriod

            //dcPeriod = 0.0
            //dcPeriod := (0.25 * instPeriod) + (0.75 * nz(dcPeriod[1]))
            //si = dcPeriod < squelch ? 0 : 1

            //sig = qu > -ip ? 1 : qu < -ip ? -1 : 0
            //siColor = sig > 0 ? color.green : sig < 0 ? color.red : color.black
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //barcolor(bar ? siColor : na)
            //plot(si, title = "Squelch", color = siColor, linewidth = 2)
            List<decimal> phaseList = new();
            List<decimal> dPhaseList = new();
            List<decimal> instPeriodList = new();
            List<decimal> dcPeriodList = new();
            List<decimal> v4List = new();
            List<decimal> v1List = new();
            List<decimal> v2List = new();
            List<decimal> v3List = new();
            List<decimal> ipList = new();
            List<decimal> quList = new();
            List<decimal> siList = new();
            List<Signal> signalsList = new();

            try
            {
                int length = days;
                int squelch = (int)Math.Ceiling(days / 0.3);
                int maxLength = squelch * 2;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= length ? stockDataClass.InputValues.ElementAtOrDefault(i - length) : 0;
                    decimal priorV1 = i >= length ? v1List.ElementAtOrDefault(i - length) : 0;
                    decimal prevV12 = i >= 2 ? v1List.ElementAtOrDefault(i - 2) : 0;
                    decimal prevV14 = i >= 4 ? v1List.ElementAtOrDefault(i - 4) : 0;

                    decimal v1 = currentValue - prevValue;
                    v1List.Add(v1);

                    decimal v2 = i >= 3 ? v1List.ElementAtOrDefault(i - 3) : 0;
                    v2List.Add(v2);

                    decimal v3 = (0.75m * (v1 - priorV1)) + (0.25m * (prevV12 - prevV14));
                    v3List.Add(v3);

                    decimal prevIp = ipList.LastOrDefault();
                    decimal ip = (0.33m * v2) + (0.67m * prevIp);
                    ipList.Add(ip);

                    decimal prevQu = quList.LastOrDefault();
                    decimal qu = (0.2m * v3) + (0.8m * prevQu);
                    quList.Add(qu);

                    decimal prevPhase = phaseList.LastOrDefault();
                    decimal phase = Math.Abs(ip + prevIp) > 0 ? ToDegrees(Atan(Math.Abs((qu + prevQu) / (ip + prevIp)))) : 0;
                    phase = ip < 0 && qu > 0 ? 180 - phase : phase;
                    phase = ip < 0 && qu < 0 ? 180 + phase : phase;
                    phase = ip > 0 && qu < 0 ? 360 - phase : phase;
                    phaseList.Add(phase);

                    decimal dPhase = prevPhase - phase;
                    dPhase = prevPhase < 90 && phase > 270 ? 360 + prevPhase - phase : dPhase;
                    dPhase = MinOrMax(dPhase, 60, 1);
                    dPhaseList.Add(dPhase);

                    decimal instPeriod = 0, v4 = 0;
                    for (int j = 0; j <= maxLength; j++)
                    {
                        decimal prevDPhase = i >= j ? dPhaseList.ElementAtOrDefault(i - j) : 0;
                        v4 += prevDPhase;
                        instPeriod = v4 > 360 && instPeriod == 0 ? j : instPeriod;
                    }
                    v4List.Add(v4);
                    instPeriodList.Add(instPeriod);

                    decimal prevDcPeriod = dcPeriodList.LastOrDefault();
                    decimal dcPeriod = (0.25m * instPeriod) + (0.75m * prevDcPeriod);
                    dcPeriodList.Add(dcPeriod);

                    decimal si = dcPeriod < squelch ? 0 : 1;
                    siList.Add(si);

                    var signal = GetCompareSignal(qu - (-1 * ip), prevQu - (-1 * prevIp));
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (v2List, v3List, ipList, quList, phaseList, dPhaseList, v4List, instPeriodList, dcPeriodList, siList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateEhlersClassicHilbertTransformer(StockData stockDataClass, int days = 10)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Ehlers Classic Hilbert Transformer [CC] script may be freely distributed under the MIT license.
            //study("Ehlers Classic Hilbert Transformer [CC]", overlay = false)

            //inp = input(title = "Source", type = input.source, defval = close)
            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //src = security(syminfo.tickerid, res, inp[rep ? 0 : barstate.isrealtime ? 1 : 0])[rep ? 0 : barstate.isrealtime ? 0 : 1]
            //hpLength = input(title = "HPLength", type = input.integer, defval = 48, minval = 1)
            //ssfLength = input(title = "SSFLength", type = input.integer, defval = 10, minval = 1)

            //pi = 2 * asin(1)
            //twoPiPrd = 0.707 * 2 * pi / hpLength
            //a1 = (cos(twoPiPrd) + sin(twoPiPrd) - 1) / cos(twoPiPrd)
            //a2 = exp(-1.414 * pi / ssfLength)
            //b1 = 2 * a2 * cos(1.414 * pi / ssfLength)
            //c2 = b1
            //c3 = -a2 * a2
            //c1 = 1 - c2 - c3

            //hp = 0.0
            //hp:= (pow(1 - (a1 / 2), 2) * (src - (2 * nz(src[1])) + nz(src[2]))) + (2 * (1 - a1) * nz(hp[1])) - (pow(1 - a1, 2) * nz(hp[2]))

            //rfilt = 0.0
            //rfilt:= (c1 * ((hp + nz(hp[1])) / 2)) + (c2 * nz(rfilt[1])) + (c3 * nz(rfilt[2]))

            //peak = 0.0
            //peak:= 0.991 * nz(peak[1])
            //peak:= abs(rfilt) > peak ? abs(rfilt) : peak

            //real = peak != 0 ? rfilt / peak : 0
            //imag = ((0.091 * real) + (0.111 * nz(real[2])) + (0.143 * nz(real[4])) + (0.2 * nz(real[6])) + (0.333 * nz(real[8])) + nz(real[10]) - nz(real[12]) -
            //       (0.333 * nz(real[14])) - (0.2 * nz(real[16])) - (0.143 * nz(real[18])) - (0.111 * nz(real[20])) - (0.091 * nz(real[22]))) / 1.865

            //sig = hp > 0 ? 1 : hp < 0 ? -1 : 0
            //chtColor = sig > 0 ? color.green : sig < 0 ? color.red : color.black
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //barcolor(bar ? chtColor : na)
            //plot(nz(real[ssfLength + 1]), title = "Real", color = color.blue, linewidth = 2)
            //plot(imag, title = "Imag", color = color.red, linewidth = 2)
            List<decimal> peakList = new();
            List<decimal> realList = new();
            List<decimal> imagList = new();
            List<Signal> signalsList = new();

            try
            {
                var roofingFilterList = CalculateEhlersRoofingFilter(stockDataClass, days).Item2;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal roofingFilter = roofingFilterList.ElementAtOrDefault(i);
                    decimal prevReal1 = i >= 1 ? realList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevReal2 = i >= 2 ? realList.ElementAtOrDefault(i - 2) : 0;
                    decimal prevReal4 = i >= 4 ? realList.ElementAtOrDefault(i - 4) : 0;
                    decimal prevReal6 = i >= 6 ? realList.ElementAtOrDefault(i - 6) : 0;
                    decimal prevReal8 = i >= 8 ? realList.ElementAtOrDefault(i - 8) : 0;
                    decimal prevReal10 = i >= 10 ? realList.ElementAtOrDefault(i - 10) : 0;
                    decimal prevReal12 = i >= 12 ? realList.ElementAtOrDefault(i - 12) : 0;
                    decimal prevReal14 = i >= 14 ? realList.ElementAtOrDefault(i - 14) : 0;
                    decimal prevReal16 = i >= 16 ? realList.ElementAtOrDefault(i - 16) : 0;
                    decimal prevReal18 = i >= 18 ? realList.ElementAtOrDefault(i - 18) : 0;
                    decimal prevReal20 = i >= 20 ? realList.ElementAtOrDefault(i - 20) : 0;
                    decimal prevReal22 = i >= 22 ? realList.ElementAtOrDefault(i - 22) : 0;

                    decimal prevPeak = peakList.LastOrDefault();
                    decimal peak = Math.Max(0.991m * prevPeak, Math.Abs(roofingFilter));
                    peakList.Add(peak);

                    decimal real = peak != 0 ? roofingFilter / peak : 0;
                    realList.Add(real);

                    decimal imag = ((0.091m * real) + (0.111m * prevReal2) + (0.143m * prevReal4) + (0.2m * prevReal6) + (0.333m * prevReal8) + prevReal10 -
                        prevReal12 - (0.333m * prevReal14) - (0.2m * prevReal16) - (0.143m * prevReal18) - (0.111m * prevReal20) - (0.091m * prevReal22)) / 1.865m;
                    imagList.Add(imag);

                    var signal = GetCompareSignal(real - prevReal1, prevReal1 - prevReal2);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (peakList, realList, imagList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateEhlersHilbertTransformer(StockData stockDataClass, int days = 20)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Ehlers Hilbert Transformer [CC] script may be freely distributed under the MIT license.
            //study("Ehlers Hilbert Transformer [CC]", overlay = false)

            //inp = input(title = "Source", type = input.source, defval = close)
            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //src = security(syminfo.tickerid, res, inp[rep ? 0 : barstate.isrealtime ? 1 : 0])[rep ? 0 : barstate.isrealtime ? 0 : 1]
            //hpLength = input(title = "HPLength", type = input.integer, defval = 48, minval = 1)
            //ssfLength = input(title = "SSFLength", type = input.integer, defval = 20, minval = 1)

            //pi = 2 * asin(1)
            //twoPiPrd = 0.707 * 2 * pi / hpLength
            //a1 = (cos(twoPiPrd) + sin(twoPiPrd) - 1) / cos(twoPiPrd)
            //a2 = exp(-1.414 * pi / ssfLength)
            //b1 = 2 * a2 * cos(1.414 * pi / ssfLength)
            //c2 = b1
            //c3 = -a2 * a2
            //c1 = 1 - c2 - c3

            //hp = 0.0
            //hp:= (pow(1 - (a1 / 2), 2) * (src - (2 * nz(src[1])) + nz(src[2]))) + (2 * (1 - a1) * nz(hp[1])) - (pow(1 - a1, 2) * nz(hp[2]))

            //rfilt = 0.0
            //rfilt:= (c1 * ((hp + nz(hp[1])) / 2)) + (c2 * nz(rfilt[1])) + (c3 * nz(rfilt[2]))

            //peak = 0.0
            //peak:= 0.991 * nz(peak[1])
            //peak:= abs(rfilt) > peak ? abs(rfilt) : peak
            //real = peak != 0 ? rfilt / peak : 0

            //qFilt = real - nz(real[1])
            //qPeak = 0.0
            //qPeak:= 0.991 * nz(qPeak[1])
            //qPeak:= abs(qFilt) > qPeak ? abs(qFilt) : qPeak
            //imag = qPeak != 0 ? qFilt / qPeak : 0

            //sig = hp > 0 ? 1 : hp < 0 ? -1 : 0
            //chtColor = sig > 0 ? color.green : sig < 0 ? color.red : color.black
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //barcolor(bar ? chtColor : na)
            //plot(real, title = "Real", color = color.blue, linewidth = 2)
            //plot(imag, title = "Imag", color = color.red, linewidth = 2)
            List<decimal> peakList = new();
            List<decimal> realList = new();
            List<decimal> imagList = new();
            List<decimal> hpList = new();
            List<decimal> roofingFilterList = new();
            List<decimal> qFiltList = new();
            List<decimal> qPeakList = new();
            List<Signal> signalsList = new();

            try
            {
                int ssfLength = days;
                int hpLength = (int)Math.Ceiling(days / 0.4167);
                decimal piPrd = ToRadians(0.707 * 360 / hpLength);
                decimal alpha = (Cos(piPrd) + Sin(piPrd) - 1) / Cos(piPrd);
                decimal a1 = Exp(-1.414 * Math.PI / ssfLength);
                decimal b1 = 2 * a1 * Cos(ToRadians(1.414 * 180 / ssfLength));
                decimal c2 = b1;
                decimal c3 = -a1 * a1;
                decimal c1 = 1 - c2 - c3;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue1 = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevValue2 = i >= 2 ? stockDataClass.InputValues.ElementAtOrDefault(i - 2) : 0;
                    decimal prevHp1 = i >= 1 ? hpList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevHp2 = i >= 2 ? hpList.ElementAtOrDefault(i - 2) : 0;
                    decimal prevRoofingFilter1 = i >= 1 ? roofingFilterList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevRoofingFilter2 = i >= 2 ? roofingFilterList.ElementAtOrDefault(i - 2) : 0;
                    decimal prevReal1 = i >= 1 ? realList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevReal2 = i >= 2 ? realList.ElementAtOrDefault(i - 2) : 0;

                    decimal highPass = (Pow(1 - (alpha / 2), 2) * (currentValue - (2 * prevValue1) + prevValue2)) + (2 * (1 - alpha) * prevHp1) - (Pow(1 - alpha, 2) * prevHp2);
                    hpList.Add(highPass);

                    decimal roofingFilter = (c1 * ((highPass + prevHp1) / 2)) + (c2 * prevRoofingFilter1) + (c3 * prevRoofingFilter2);
                    roofingFilterList.Add(roofingFilter);

                    decimal prevPeak = peakList.LastOrDefault();
                    decimal peak = Math.Max(0.991m * prevPeak, Math.Abs(roofingFilter));
                    peakList.Add(peak);

                    decimal prevReal = realList.LastOrDefault();
                    decimal real = peak != 0 ? roofingFilter / peak : 0;
                    realList.Add(real);

                    decimal qFilt = real - prevReal;
                    qFiltList.Add(qFilt);

                    decimal prevQPeak = qPeakList.LastOrDefault();
                    decimal qPeak = Math.Max(0.991m * prevQPeak, Math.Abs(qFilt));
                    qPeakList.Add(qPeak);

                    decimal imag = qPeak != 0 ? qFilt / qPeak : 0;
                    imagList.Add(imag);

                    var signal = GetCompareSignal(real - prevReal1, prevReal1 - prevReal2);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (hpList, roofingFilterList, peakList, realList, qFiltList, qPeakList, imagList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateEhlersHilbertTransformerIndicator(StockData stockDataClass, int days = 10)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Ehlers Hilbert Transformer Indicator [CC] script may be freely distributed under the MIT license.
            //study("Ehlers Hilbert Transformer Indicator [CC]", overlay = false)

            //inp = input(title = "Source", type = input.source, defval = close)
            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //src = security(syminfo.tickerid, res, inp[rep ? 0 : barstate.isrealtime ? 1 : 0])[rep ? 0 : barstate.isrealtime ? 0 : 1]
            //hpLength = input(title = "HPLength", type = input.integer, defval = 48, minval = 1)
            //lpLength = input(title = "LPLength", type = input.integer, defval = 20, minval = 1)
            //ssfLength = input(title = "SSFLength", type = input.integer, defval = 10, minval = 1)

            //pi = 2 * asin(1)
            //twoPiPrd = 0.707 * 2 * pi / hpLength
            //a1 = (cos(twoPiPrd) + sin(twoPiPrd) - 1) / cos(twoPiPrd)
            //a2 = exp(-1.414 * pi / lpLength)
            //a3 = exp(-1.414 * pi / ssfLength)
            //b1 = 2 * a2 * cos(1.414 * pi / lpLength)
            //b2 = 2 * a3 * cos(1.414 * pi / ssfLength)
            //c2 = b1
            //c3 = -a2 * a2
            //c1 = 1 - c2 - c3
            //coef2 = b2
            //coef3 = -a3 * a3
            //coef1 = 1 - coef2 - coef3

            //hp = 0.0
            //hp:= (pow(1 - (a1 / 2), 2) * (src - (2 * nz(src[1])) + nz(src[2]))) + (2 * (1 - a1) * nz(hp[1])) - (pow(1 - a1, 2) * nz(hp[2]))

            //rfilt = 0.0
            //rfilt:= (c1 * ((hp + nz(hp[1])) / 2)) + (c2 * nz(rfilt[1])) + (c3 * nz(rfilt[2]))

            //peak = 0.0
            //peak:= 0.991 * nz(peak[1])
            //peak:= abs(rfilt) > peak ? abs(rfilt) : peak
            //real = peak != 0 ? rfilt / peak : 0

            //qFilt = real - nz(real[1])
            //qPeak = 0.0
            //qPeak:= 0.991 * nz(qPeak[1])
            //qPeak:= abs(qFilt) > qPeak ? abs(qFilt) : qPeak
            //qFilt:= qPeak != 0 ? qFilt / qPeak : 0

            //imag = 0.0
            //imag:= (coef1 * ((qFilt + nz(qFilt[1])) / 2)) + (coef2 * nz(imag[1])) + (coef3 * nz(imag[2]))

            //sig = hp > 0 ? 1 : hp < 0 ? -1 : 0
            //chtColor = sig > 0 ? color.green : sig < 0 ? color.red : color.black
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //barcolor(bar ? chtColor : na)
            //plot(real, title = "Real", color = color.blue, linewidth = 2)
            //plot(imag, title = "Imag", color = color.red, linewidth = 2)
            List<decimal> imagList = new();
            List<decimal> realList = new();
            List<Signal> signalsList = new();

            try
            {
                int ssfLength = days;
                int lpLength = days * 2;
                decimal a1 = Exp(-1.414 * Math.PI / ssfLength);
                decimal b2 = 2 * a1 * Cos(ToRadians(1.414 * 180 / ssfLength));
                decimal c2 = b2;
                decimal c3 = -a1 * a1;
                decimal c1 = 1 - c2 - c3;

                var hilbertList = CalculateEhlersHilbertTransformer(stockDataClass, lpLength);
                realList = hilbertList.Item4;
                var qFiltList = hilbertList.Item7;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal qFilt = qFiltList.ElementAtOrDefault(i);
                    decimal prevQFilt = i >= 1 ? qFiltList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevImag1 = i >= 1 ? imagList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevImag2 = i >= 2 ? imagList.ElementAtOrDefault(i - 2) : 0;

                    decimal imag = (c1 * ((qFilt + prevQFilt) / 2)) + (c2 * prevImag1) + (c3 * prevImag2);
                    imagList.Add(imag);

                    var signal = GetCompareSignal(imag - qFilt, prevImag1 - prevQFilt);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (realList, imagList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateEhlersDualDifferentiatorDominantCycle(StockData stockDataClass, int days = 8)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Ehlers Dual Differentiator Dominant Cycle [CC] script may be freely distributed under the MIT license.
            //study("Ehlers Dual Differentiator Dominant Cycle [CC]", overlay = false)

            //inp = input(title = "Source", type = input.source, defval = close)
            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //src = security(syminfo.tickerid, res, inp[rep ? 0 : barstate.isrealtime ? 1 : 0])[rep ? 0 : barstate.isrealtime ? 0 : 1]
            //hpLength = input(title = "HPLength", type = input.integer, defval = 48, minval = 1)
            //lpLength = input(title = "LPLength", type = input.integer, defval = 20, minval = 1)
            //minLength = input(title = "MinLength", type = input.integer, defval = 8, minval = 1)

            //pi = 2 * asin(1)
            //twoPiPrd = 0.707 * 2 * pi / hpLength
            //a1 = (cos(twoPiPrd) + sin(twoPiPrd) - 1) / cos(twoPiPrd)
            //a2 = exp(-1.414 * pi / lpLength)
            //b1 = 2 * a2 * cos(1.414 * pi / lpLength)
            //c2 = b1
            //c3 = -a2 * a2
            //c1 = 1 - c2 - c3

            //hp = 0.0
            //hp:= (pow(1 - (a1 / 2), 2) * (src - (2 * nz(src[1])) + nz(src[2]))) + (2 * (1 - a1) * nz(hp[1])) - (pow(1 - a1, 2) * nz(hp[2]))

            //rfilt = 0.0
            //rfilt:= (c1 * ((hp + nz(hp[1])) / 2)) + (c2 * nz(rfilt[1])) + (c3 * nz(rfilt[2]))

            //peak = 0.0
            //peak:= 0.991 * nz(peak[1])
            //peak:= abs(rfilt) > peak ? abs(rfilt) : peak
            //real = peak != 0 ? rfilt / peak : 0

            //qFilt = real - nz(real[1])
            //qPeak = 0.0
            //qPeak:= 0.991 * nz(qPeak[1])
            //qPeak:= abs(qFilt) > qPeak ? abs(qFilt) : qPeak
            //imag = qPeak != 0 ? qFilt / qPeak : 0

            //iDot = real - nz(real[1])
            //qDot = imag - nz(imag[1])
            //period = (real * qDot) - (imag * iDot) != 0 ? 6.28318 * ((real * real) + (imag * imag)) / ((-real * qDot) + (imag * iDot)) : 0
            //period:= min(max(period, minLength), hpLength)

            //domCyc = 0.0
            //domCyc:= (c1 * ((period + nz(period[1])) / 2)) + (c2 * nz(domCyc[1])) + (c3 * nz(domCyc[2]))

            //sig = hp > 0 ? 1 : hp < 0 ? -1 : 0
            //dddcColor = sig > 0 ? color.green : sig < 0 ? color.red : color.black
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //barcolor(bar ? dddcColor : na)
            //plot(domCyc, title = "DominantCycle", color = dddcColor, linewidth = 2)
            List<decimal> qDotList = new();
            List<decimal> periodList = new();
            List<decimal> domCycList = new();
            List<Signal> signalsList = new();

            try
            {
                int minLength = days;
                int ssfLength = (int)Math.Ceiling(days / 0.4);
                int hpLength = (int)Math.Ceiling(ssfLength / 0.4167);
                decimal piPrd = ToRadians(0.707 * 360 / hpLength);
                decimal alpha = (Cos(piPrd) + Sin(piPrd) - 1) / Cos(piPrd);
                decimal a1 = Exp(-1.414 * Math.PI / ssfLength);
                decimal b1 = 2 * a1 * Cos(ToRadians(1.414 * 180 / ssfLength));
                decimal c2 = b1;
                decimal c3 = -a1 * a1;
                decimal c1 = 1 - c2 - c3;

                var hilbertList = CalculateEhlersHilbertTransformer(stockDataClass, ssfLength);
                var roofingFilterList = hilbertList.Item2;
                var realList = hilbertList.Item4;
                var imagList = hilbertList.Item7;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal real = realList.ElementAtOrDefault(i);
                    decimal imag = imagList.ElementAtOrDefault(i);
                    decimal prevReal1 = i >= 1 ? realList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevImag1 = i >= 1 ? imagList.ElementAtOrDefault(i - 1) : 0;
                    decimal iDot = real - prevReal1;
                    decimal prevDomCyc1 = i >= 1 ? domCycList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevDomCyc2 = i >= 2 ? domCycList.ElementAtOrDefault(i - 2) : 0;
                    decimal prevRoofingFilter1 = i >= 1 ? roofingFilterList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevRoofingFilter2 = i >= 2 ? roofingFilterList.ElementAtOrDefault(i - 2) : 0;
                    decimal roofingFilter = roofingFilterList.ElementAtOrDefault(i);

                    decimal qDot = imag - prevImag1;
                    qDotList.Add(qDot);

                    decimal prevPeriod = periodList.LastOrDefault();
                    decimal period = (real * qDot) - (imag * iDot) != 0 ? 6.28318m * ((real * real) + (imag * imag)) / ((-real * qDot) + (imag * iDot)) : 0;
                    period = MinOrMax(period, hpLength, minLength);
                    periodList.Add(period);

                    decimal domCyc = (c1 * ((period + prevPeriod) / 2)) + (c2 * prevDomCyc1) + (c3 * prevDomCyc2);
                    domCycList.Add(domCyc);

                    var signal = GetCompareSignal(roofingFilter - prevRoofingFilter1, prevRoofingFilter1 - prevRoofingFilter2);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (qDotList, periodList, domCycList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateEhlersPhaseAccumulationDominantCycle(StockData stockDataClass, int days = 10)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Ehlers Phase Accumulation Dominant Cycle [CC] script may be freely distributed under the MIT license.
            //study("Ehlers Phase Accumulation Dominant Cycle [CC]", overlay = false)

            //inp = input(title = "Source", type = input.source, defval = close)
            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //src = security(syminfo.tickerid, res, inp[rep ? 0 : barstate.isrealtime ? 1 : 0])[rep ? 0 : barstate.isrealtime ? 0 : 1]
            //hpLength = input(title = "HPLength", type = input.integer, defval = 48, minval = 1)
            //lpLength = input(title = "LPLength", type = input.integer, defval = 20, minval = 1)
            //minLength = input(title = "MinLength", type = input.integer, defval = 10, minval = 1)
            //sumLength = input(title = "SumLength", type = input.integer, defval = 40, minval = 1)

            //pi = 2 * asin(1)
            //twoPiPrd = 0.707 * 2 * pi / hpLength
            //a1 = (cos(twoPiPrd) + sin(twoPiPrd) - 1) / cos(twoPiPrd)
            //a2 = exp(-1.414 * pi / lpLength)
            //b1 = 2 * a2 * cos(1.414 * pi / lpLength)
            //c2 = b1
            //c3 = -a2 * a2
            //c1 = 1 - c2 - c3

            //hp = 0.0
            //hp:= (pow(1 - (a1 / 2), 2) * (src - (2 * nz(src[1])) + nz(src[2]))) + (2 * (1 - a1) * nz(hp[1])) - (pow(1 - a1, 2) * nz(hp[2]))

            //rfilt = 0.0
            //rfilt:= (c1 * ((hp + nz(hp[1])) / 2)) + (c2 * nz(rfilt[1])) + (c3 * nz(rfilt[2]))

            //peak = 0.0
            //peak:= 0.991 * nz(peak[1])
            //peak:= abs(rfilt) > peak ? abs(rfilt) : peak
            //real = peak != 0 ? rfilt / peak : 0

            //qFilt = real - nz(real[1])
            //qPeak = 0.0
            //qPeak:= 0.991 * nz(qPeak[1])
            //qPeak:= abs(qFilt) > qPeak ? abs(qFilt) : qPeak
            //imag = qPeak != 0 ? qFilt / qPeak : 0

            //phase = abs(real) > 0 ? atan(abs(imag / real)) * 180 / pi : 0
            //phase:= real < 0 and imag > 0 ? 180 - phase : phase
            //phase:= real < 0 and imag< 0 ? 180 + phase : phase
            //phase:= real > 0 and imag< 0 ? 360 - phase : phase

            //dPhase = nz(phase[1]) - phase
            //dPhase:= nz(phase[1]) < 90 and phase > 270 ? 360 + nz(phase[1]) - phase : dPhase
            //dPhase:= min(max(dPhase, minLength), hpLength)

            //instPeriod = 0.0, phaseSum = 0.0
            //for i = 0 to sumLength
            //    phaseSum := phaseSum + nz(dPhase[i])
            //    if phaseSum > 360 and instPeriod == 0
            //        instPeriod:= i
            //instPeriod:= instPeriod == 0 ? nz(instPeriod[1]) : instPeriod

            //domCyc = 0.0
            //domCyc:= (c1 * ((instPeriod + nz(instPeriod[1])) / 2)) + (c2 * nz(domCyc[1])) + (c3 * nz(domCyc[2]))

            //sig = hp > 0 ? 1 : hp < 0 ? -1 : 0
            //dddcColor = sig > 0 ? color.green : sig < 0 ? color.red : color.black
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //barcolor(bar ? dddcColor : na)
            //plot(domCyc, title = "DominantCycle", color = dddcColor, linewidth = 2)
            List<decimal> phaseList = new();
            List<decimal> phaseSumList = new();
            List<decimal> dPhaseList = new();
            List<decimal> instPeriodList = new();
            List<decimal> domCycList = new();
            List<Signal> signalsList = new();

            try
            {
                int minLength = days;
                int ssfLength = days * 2;
                int sumLength = days * 4;
                int hpLength = (int)Math.Ceiling(ssfLength / 0.4167);
                decimal piPrd = ToRadians(0.707 * 360 / hpLength);
                decimal alpha = (Cos(piPrd) + Sin(piPrd) - 1) / Cos(piPrd);
                decimal a1 = Exp(-1.414 * Math.PI / ssfLength);
                decimal b1 = 2 * a1 * Cos(ToRadians(1.414 * 180 / ssfLength));
                decimal c2 = b1;
                decimal c3 = -a1 * a1;
                decimal c1 = 1 - c2 - c3;

                var hilbertList = CalculateEhlersHilbertTransformer(stockDataClass, ssfLength);
                var roofingFilterList = hilbertList.Item2;
                var realList = hilbertList.Item4;
                var imagList = hilbertList.Item7;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal real = realList.ElementAtOrDefault(i);
                    decimal imag = imagList.ElementAtOrDefault(i);
                    decimal prevReal1 = i >= 1 ? realList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevImag1 = i >= 1 ? imagList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevDomCyc1 = i >= 1 ? domCycList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevDomCyc2 = i >= 2 ? domCycList.ElementAtOrDefault(i - 2) : 0;
                    decimal prevRoofingFilter1 = i >= 1 ? roofingFilterList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevRoofingFilter2 = i >= 2 ? roofingFilterList.ElementAtOrDefault(i - 2) : 0;
                    decimal roofingFilter = roofingFilterList.ElementAtOrDefault(i);

                    decimal prevPhase = phaseList.LastOrDefault();
                    decimal phase = Math.Abs(real) > 0 ? ToDegrees(Atan(Math.Abs(imag / real))) : 0;
                    phase = real < 0 && imag > 0 ? 180 - phase : phase;
                    phase = real < 0 && imag < 0 ? 180 + phase : phase;
                    phase = real > 0 && imag < 0 ? 360 - phase : phase;
                    phaseList.Add(phase);

                    decimal dPhase = prevPhase - phase;
                    dPhase = prevPhase < 90 && phase > 270 ? 360 + prevPhase - phase : dPhase;
                    dPhase = MinOrMax(dPhase, hpLength, minLength);
                    dPhaseList.Add(dPhase);

                    decimal prevInstPeriod = instPeriodList.LastOrDefault();
                    decimal instPeriod = 0, phaseSum = 0;
                    for (int j = 0; j < sumLength; j++)
                    {
                        decimal prevDPhase = i >= j ? dPhaseList.ElementAtOrDefault(i - j) : 0;
                        phaseSum += prevDPhase;

                        if (phaseSum > 360 && instPeriod == 0)
                        {
                            instPeriod = j;
                        }
                    }
                    phaseSumList.Add(phaseSum);
                    instPeriod = instPeriod == 0 ? prevInstPeriod : instPeriod;
                    instPeriodList.Add(instPeriod);

                    decimal domCyc = (c1 * ((instPeriod + prevInstPeriod) / 2)) + (c2 * prevDomCyc1) + (c3 * prevDomCyc2);
                    domCycList.Add(domCyc);

                    var signal = GetCompareSignal(roofingFilter - prevRoofingFilter1, prevRoofingFilter1 - prevRoofingFilter2);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (phaseList, dPhaseList, phaseSumList, instPeriodList, domCycList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateEhlersHomodyneDominantCycle(StockData stockDataClass, int days = 10)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Ehlers Homodyne Dominant Cycle [CC] script may be freely distributed under the MIT license.
            //study("Ehlers Homodyne Dominant Cycle [CC]", overlay = false)

            //inp = input(title = "Source", type = input.source, defval = close)
            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //src = security(syminfo.tickerid, res, inp[rep ? 0 : barstate.isrealtime ? 1 : 0])[rep ? 0 : barstate.isrealtime ? 0 : 1]
            //hpLength = input(title = "HPLength", type = input.integer, defval = 48, minval = 1)
            //lpLength = input(title = "LPLength", type = input.integer, defval = 20, minval = 1)
            //minLength = input(title = "MinLength", type = input.integer, defval = 10, minval = 1)

            //pi = 2 * asin(1)
            //twoPiPrd = 0.707 * 2 * pi / hpLength
            //a1 = (cos(twoPiPrd) + sin(twoPiPrd) - 1) / cos(twoPiPrd)
            //a2 = exp(-1.414 * pi / lpLength)
            //b1 = 2 * a2 * cos(1.414 * pi / lpLength)
            //c2 = b1
            //c3 = -a2 * a2
            //c1 = 1 - c2 - c3

            //hp = 0.0
            //hp:= (pow(1 - (a1 / 2), 2) * (src - (2 * nz(src[1])) + nz(src[2]))) + (2 * (1 - a1) * nz(hp[1])) - (pow(1 - a1, 2) * nz(hp[2]))

            //rfilt = 0.0
            //rfilt:= (c1 * ((hp + nz(hp[1])) / 2)) + (c2 * nz(rfilt[1])) + (c3 * nz(rfilt[2]))

            //peak = 0.0
            //peak:= 0.991 * nz(peak[1])
            //peak:= abs(rfilt) > peak ? abs(rfilt) : peak
            //real = peak != 0 ? rfilt / peak : 0

            //qFilt = real - nz(real[1])
            //qPeak = 0.0
            //qPeak:= 0.991 * nz(qPeak[1])
            //qPeak:= abs(qFilt) > qPeak ? abs(qFilt) : qPeak
            //imag = qPeak != 0 ? qFilt / qPeak : 0

            //re = (real * nz(real[1])) + (imag * nz(imag[1]))
            //im = (nz(real[1]) * imag) - (real * nz(imag[1]))
            //period = im != 0 and re != 0 ? 6.28318 / abs(im / re) : 0
            //period:= min(max(period, minLength), hpLength)

            //domCyc = 0.0
            //domCyc:= (c1 * ((period + nz(period[1])) / 2)) + (c2 * nz(domCyc[1])) + (c3 * nz(domCyc[2]))

            //sig = hp > 0 ? 1 : hp < 0 ? -1 : 0
            //hdcColor = sig > 0 ? color.green : sig < 0 ? color.red : color.black
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //barcolor(bar ? hdcColor : na)
            //plot(domCyc, title = "DominantCycle", color = hdcColor, linewidth = 2)
            List<decimal> reList = new();
            List<decimal> imList = new();
            List<decimal> periodList = new();
            List<decimal> domCycList = new();
            List<Signal> signalsList = new();

            try
            {
                int minLength = days;
                int ssfLength = days * 2;
                int hpLength = (int)Math.Ceiling(ssfLength / 0.4167);
                decimal piPrd = ToRadians(0.707 * 360 / hpLength);
                decimal alpha = (Cos(piPrd) + Sin(piPrd) - 1) / Cos(piPrd);
                decimal a1 = Exp(-1.414 * Math.PI / ssfLength);
                decimal b1 = 2 * a1 * Cos(ToRadians(1.414 * 180 / ssfLength));
                decimal c2 = b1;
                decimal c3 = -a1 * a1;
                decimal c1 = 1 - c2 - c3;

                var hilbertList = CalculateEhlersHilbertTransformer(stockDataClass, ssfLength);
                var roofingFilterList = hilbertList.Item2;
                var realList = hilbertList.Item4;
                var imagList = hilbertList.Item7;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal real = realList.ElementAtOrDefault(i);
                    decimal imag = imagList.ElementAtOrDefault(i);
                    decimal prevReal1 = i >= 1 ? realList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevImag1 = i >= 1 ? imagList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevDomCyc1 = i >= 1 ? domCycList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevDomCyc2 = i >= 2 ? domCycList.ElementAtOrDefault(i - 2) : 0;
                    decimal prevRoofingFilter1 = i >= 1 ? roofingFilterList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevRoofingFilter2 = i >= 2 ? roofingFilterList.ElementAtOrDefault(i - 2) : 0;
                    decimal roofingFilter = roofingFilterList.ElementAtOrDefault(i);

                    decimal re = (real * prevReal1) + (imag * prevImag1);
                    reList.Add(re);

                    decimal im = (prevReal1 * imag) - (real * prevImag1);
                    imList.Add(im);

                    decimal prevPeriod = periodList.LastOrDefault();
                    decimal period = im != 0 && re != 0 ? 6.28318m / Math.Abs(im / re) : 0;
                    period = MinOrMax(period, hpLength, minLength);
                    periodList.Add(period);

                    decimal domCyc = (c1 * ((period + prevPeriod) / 2)) + (c2 * prevDomCyc1) + (c3 * prevDomCyc2);
                    domCycList.Add(domCyc);

                    var signal = GetCompareSignal(roofingFilter - prevRoofingFilter1, prevRoofingFilter1 - prevRoofingFilter2);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (reList, imList, periodList, domCycList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateEhlersSignalToNoiseRatio(StockData stockDataClass, int days = 7)
        {
            //input = price, user defined, default is midpoint price
            //Hilbert period = user defined, default is 7
            //quad = quadrature = imaginary part of complex number
            //inPhase = real part of complex number
            //amp = amplitude
            //index = current bar number

            //iMult = .635;
            //qMult = .338;

            //priorPrice = price[index - period];
            //v1 = detrend price
            //v1 = price - priorPrice;

            //high = series.getHigh(index);
            //low = series.getLow(index);
            //prevRange = range[index - 1];
            //range = (.2 * (high - low)) + (.8 * prevRange);

            //v2 = v1[index - 2];
            //v4 = v1[index - 4];

            //inPhase3 = inPhase[index - 3];
            //quad2 = quad[index - 2];

            //Hilbert transform complex number components, inPhase (real part), quad (imaginary part)
            //inPhase = 1.25 * (v4 - (iMult * v2) + (iMult * inPhase3));
            //quad = v2 - (qMult * v1) + (qMult * quad2);

            //prevV2 = v2[index - 1];
            //smoothed signal amplitude
            //v2 = .2 * (inPhase * inPhase + quad * quad) + .8 * prevV2;
            //prevAmp = amp[index - 1];
            //smoothed SNR in decibels 
            //if (v2 lessThan .001) v2 = .001;
            //if (range lessThan 0) 
            //amp = .25 * (10 * Math.log(v2 / (range * range)) / Math.log(10) + 1.9) + .75 * prevAmp;
            //endIf
            //Plot amp;
            List<decimal> ampList = new();
            List<decimal> v2List = new();
            List<decimal> rangeList = new();
            List<Signal> signalsList = new();

            try
            {
                var hilbertTransformList = CalculateEhlersHilbertTransformIndicator(stockDataClass, days);
                var inPhaseList = hilbertTransformList.Item1;
                var quadList = hilbertTransformList.Item2;
                var emaList = CalculateExponentialMovingAverage(stockDataClass, days).Item1;
                var list = VolumeInputCheck(stockDataClass, days, false);
                var highList = list.Item1;
                var lowList = list.Item2;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentEma = emaList.ElementAtOrDefault(i);
                    decimal currentHigh = highList.ElementAtOrDefault(i);
                    decimal currentLow = lowList.ElementAtOrDefault(i);
                    decimal inPhase = inPhaseList.ElementAtOrDefault(i);
                    decimal quad = quadList.ElementAtOrDefault(i);
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevEma = i >= 1 ? emaList.ElementAtOrDefault(i - 1) : 0;

                    decimal prevV2 = v2List.LastOrDefault();
                    decimal v2 = (0.2m * ((inPhase * inPhase) + (quad * quad))) + (0.8m * prevV2);
                    v2List.Add(v2);

                    decimal prevRange = rangeList.LastOrDefault();
                    decimal range = (0.2m * (currentHigh - currentLow)) + (0.8m * prevRange);
                    rangeList.Add(range);

                    decimal prevAmp = ampList.LastOrDefault();
                    decimal amp = range != 0 ? (0.25m * ((10 * Log(v2 / (range * range)) / Log((double)10)) + 1.9m)) + (0.75m * prevAmp) : 0;
                    ampList.Add(amp);

                    var signal = GetVolatilitySignal(currentValue - currentEma, prevValue - prevEma, amp, 1.9m);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (v2List, rangeList, ampList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateEhlersHannWindowIndicator(StockData stockDataClass, int days = 20)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Ehlers Hann Window Indicator [CC] script may be freely distributed under the MIT license.
            //study("Ehlers Hann Window Indicator [CC]", overlay = false)

            //f_security (_symbol, _res, _src, _repaint) =>
            //    security(_symbol, _res, _src[_repaint ? 0 : barstate.isrealtime ? 1 : 0])[_repaint ? 0 : barstate.isrealtime ? 0 : 1]

            //length = input(title = "Length", type = input.integer, defval = 20, minval = 1)
            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //c = f_security(syminfo.tickerid, res, close, rep)
            //o = f_security(syminfo.tickerid, res, open, rep)

            //deriv = c - o
            //filt = 0.0, coef = 0.0
            //for i = 1 to length
            //    cosine = 1 - cos(360 * i / (length + 1) * math.pi / 180)
            //    filt := filt + (cosine * nz(deriv[i - 1]))
            //    coef := coef + cosine

            //filt := coef != 0 ? filt / coef : 0
            //roc = (length / 6.28) * (filt - nz(filt[1]))

            //slo = filt - nz(filt[1])
            //sig = slo > 0 ? slo > nz(slo[1]) ? 2 : 1 : slo < 0 ? slo < nz(slo[1]) ? -2 : -1 : 0
            //alertcondition(crossover(sig, 1), "Strong Buy Signal", "Strong Bullish Change Detected")
            //alertcondition(crossunder(sig, -1), "Strong Sell Signal", "Strong Bearish Change Detected")
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //hwiColor = sig > 1 ? color.green : sig > 0 ? color.lime : sig < -1 ? color.maroon : sig < 0 ? color.red : color.white
            //barcolor(bar ? hwiColor : na)
            //hline(0)
            //plot(filt, title = "Hwi", color = hwiColor, linewidth = 2)
            List<decimal> filtList = new();
            List<decimal> rocList = new();
            List<decimal> filtSumList = new();
            List<decimal> coefSumList = new();
            List<decimal> cosList = new();
            List<decimal> derivList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentOpen = stockDataClass.OpenPrices.ElementAtOrDefault(i);
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevFilt1 = i >= 1 ? filtList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevFilt2 = i >= 2 ? filtList.ElementAtOrDefault(i - 2) : 0;

                    decimal deriv = currentValue - currentOpen;
                    derivList.Add(deriv);

                    decimal filtSum = 0, coefSum = 0, cos = 0;
                    for (int j = 1; j <= days; j++)
                    {
                        decimal prevDeriv = i >= j - 1 ? derivList.ElementAtOrDefault(i - (j - 1)) : 0;
                        cos = 1 - Cos(ToRadians((double)360 * j / (days + 1)));
                        filtSum += cos * prevDeriv;
                        coefSum += cos;
                    }
                    cosList.Add(cos);
                    filtSumList.Add(filtSum);
                    coefSumList.Add(coefSum);

                    decimal filt = coefSum != 0 ? filtSum / coefSum : 0;
                    filtList.Add(filt);

                    decimal roc = days / 6.28m * (filt - prevFilt1);
                    rocList.Add(roc);

                    var signal = GetCompareSignal(filt - prevFilt1, prevFilt1 - prevFilt2);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (cosList, filtSumList, coefSumList, filtList, rocList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateEhlersHammingWindowIndicator(StockData stockDataClass, int days = 10)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Ehlers Hamming Window Indicator [CC] script may be freely distributed under the MIT license.
            //study("Ehlers Hamming Window Indicator [CC]", overlay = false)

            //f_security (_symbol, _res, _src, _repaint) =>
            //    security(_symbol, _res, _src[_repaint ? 0 : barstate.isrealtime ? 1 : 0])[_repaint ? 0 : barstate.isrealtime ? 0 : 1]

            //length = input(title = "Length", type = input.integer, defval = 20, minval = 1)
            //pedestal = input(title = "Pedestal", type = input.integer, defval = 10, minval = 1)
            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //c = f_security(syminfo.tickerid, res, close, rep)
            //o = f_security(syminfo.tickerid, res, open, rep)

            //deriv = c - o
            //filt = 0.0, coef = 0.0
            //for i = 0 to length - 1
            //    sine = sin((pedestal + ((180 - (2 * pedestal)) * i / (length - 1))) * math.pi / 180)
            //    filt := filt + (sine * nz(deriv[i]))
            //    coef := coef + sine

            //filt := coef != 0 ? filt / coef : 0
            //roc = (length / 6.28) * (filt - nz(filt[1]))

            //slo = filt - nz(filt[1])
            //sig = slo > 0 ? slo > nz(slo[1]) ? 2 : 1 : slo < 0 ? slo < nz(slo[1]) ? -2 : -1 : 0
            //alertcondition(crossover(sig, 1), "Strong Buy Signal", "Strong Bullish Change Detected")
            //alertcondition(crossunder(sig, -1), "Strong Sell Signal", "Strong Bearish Change Detected")
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //hwiColor = sig > 1 ? color.green : sig > 0 ? color.lime : sig < -1 ? color.maroon : sig < 0 ? color.red : color.white
            //barcolor(bar ? hwiColor : na)
            //hline(0)
            //plot(filt, title = "Hwi", color = hwiColor, linewidth = 2)
            List<decimal> filtList = new();
            List<decimal> rocList = new();
            List<decimal> filtSumList = new();
            List<decimal> coefSumList = new();
            List<decimal> sineList = new();
            List<decimal> derivList = new();
            List<Signal> signalsList = new();

            try
            {
                int pedestal = days;
                int length = days * 2;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentOpen = stockDataClass.OpenPrices.ElementAtOrDefault(i);
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevFilt1 = i >= 1 ? filtList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevFilt2 = i >= 2 ? filtList.ElementAtOrDefault(i - 2) : 0;

                    decimal deriv = currentValue - currentOpen;
                    derivList.Add(deriv);

                    decimal filtSum = 0, coefSum = 0, sine = 0;
                    for (int j = 0; j < length; j++)
                    {
                        decimal prevDeriv = i >= j ? derivList.ElementAtOrDefault(i - j) : 0;
                        sine = Sin(ToRadians((double)pedestal + ((180 - (2 * pedestal)) * j / (length - 1))));
                        filtSum += sine * prevDeriv;
                        coefSum += sine;
                    }
                    sineList.Add(sine);
                    filtSumList.Add(filtSum);
                    coefSumList.Add(coefSum);

                    decimal filt = coefSum != 0 ? filtSum / coefSum : 0;
                    filtList.Add(filt);

                    decimal roc = length / 6.28m * (filt - prevFilt1);
                    rocList.Add(roc);

                    var signal = GetCompareSignal(filt - prevFilt1, prevFilt1 - prevFilt2);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (sineList, filtSumList, coefSumList, filtList, rocList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateEhlersTriangleWindowIndicator(StockData stockDataClass, int days = 20)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Ehlers Triangle Window Indicator [CC] script may be freely distributed under the MIT license.
            //study("Ehlers Triangle Window Indicator [CC]", overlay = false)

            //f_security (_symbol, _res, _src, _repaint) =>
            //    security(_symbol, _res, _src[_repaint ? 0 : barstate.isrealtime ? 1 : 0])[_repaint ? 0 : barstate.isrealtime ? 0 : 1]

            //length = input(title = "Length", type = input.integer, defval = 20, minval = 1)
            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //c = f_security(syminfo.tickerid, res, close, rep)
            //o = f_security(syminfo.tickerid, res, open, rep)

            //deriv = c - o
            //filt = 0.0, coefSum = 0.0
            //for i = 1 to length
            //    coef = i < length / 2 ? i : i == length / 2 ? length / 2 : length + 1 - i
            //    filt := filt + (coef * nz(deriv[i - 1]))
            //    coefSum := coefSum + coef

            //filt := coefSum != 0 ? filt / coefSum : 0
            //roc = (length / 6.28) * (filt - nz(filt[1]))

            //slo = filt - nz(filt[1])
            //sig = slo > 0 ? slo > nz(slo[1]) ? 2 : 1 : slo < 0 ? slo < nz(slo[1]) ? -2 : -1 : 0
            //alertcondition(crossover(sig, 1), "Strong Buy Signal", "Strong Bullish Change Detected")
            //alertcondition(crossunder(sig, -1), "Strong Sell Signal", "Strong Bearish Change Detected")
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //twiColor = sig > 1 ? color.green : sig > 0 ? color.lime : sig < -1 ? color.maroon : sig < 0 ? color.red : color.white
            //barcolor(bar ? twiColor : na)
            //hline(0)
            //plot(filt, title = "Twi", color = twiColor, linewidth = 2)
            List<decimal> filtList = new();
            List<decimal> rocList = new();
            List<decimal> filtSumList = new();
            List<decimal> coefSumList = new();
            List<decimal> coefList = new();
            List<decimal> derivList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentOpen = stockDataClass.OpenPrices.ElementAtOrDefault(i);
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevFilt1 = i >= 1 ? filtList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevFilt2 = i >= 2 ? filtList.ElementAtOrDefault(i - 2) : 0;

                    decimal deriv = currentValue - currentOpen;
                    derivList.Add(deriv);

                    decimal filtSum = 0, coefSum = 0, coef = 0;
                    for (int j = 1; j <= days; j++)
                    {
                        decimal prevDeriv = i >= j - 1 ? derivList.ElementAtOrDefault(i - (j - 1)) : 0;
                        decimal len = (decimal)days / 2;
                        coef = j < len ? j : j == days / 2 ? len : days + 1 - j;
                        filtSum += coef * prevDeriv;
                        coefSum += coef;
                    }
                    coefList.Add(coef);
                    filtSumList.Add(filtSum);
                    coefSumList.Add(coefSum);

                    decimal filt = coefSum != 0 ? filtSum / coefSum : 0;
                    filtList.Add(filt);

                    decimal roc = days / 6.28m * (filt - prevFilt1);
                    rocList.Add(roc);

                    var signal = GetCompareSignal(filt - prevFilt1, prevFilt1 - prevFilt2);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (coefList, filtSumList, coefSumList, filtList, rocList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateEhlersSimpleWindowIndicator(StockData stockDataClass, string maType, int days = 20)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Ehlers Simple Window Indicator [CC] script may be freely distributed under the MIT license.
            //study("Ehlers Simple Window Indicator [CC]", overlay = false)

            //f_security (_symbol, _res, _src, _repaint) =>
            //    security(_symbol, _res, _src[_repaint ? 0 : barstate.isrealtime ? 1 : 0])[_repaint ? 0 : barstate.isrealtime ? 0 : 1]

            //length = input(title = "Length", type = input.integer, defval = 20, minval = 1)
            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //c = f_security(syminfo.tickerid, res, close, rep)
            //o = f_security(syminfo.tickerid, res, open, rep)

            //deriv = c - o
            //filt = 0.0, coef = 0.0
            //for i = 1 to length
            //    filt := filt + nz(deriv[i])
            //    coef := coef + 1

            //filt := coef != 0 ? wma(filt / coef, length) : 0
            //roc = wma((length / 6.28) * (filt - nz(filt[1])), length)

            //slo = roc - nz(roc[1])
            //sig = slo > 0 ? slo > nz(slo[1]) ? 2 : 1 : slo < 0 ? slo < nz(slo[1]) ? -2 : -1 : 0
            //alertcondition(crossover(sig, 1), "Strong Buy Signal", "Strong Bullish Change Detected")
            //alertcondition(crossunder(sig, -1), "Strong Sell Signal", "Strong Bearish Change Detected")
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //smafColor = sig > 1 ? color.green : sig > 0 ? color.lime : sig < -1 ? color.maroon : sig < 0 ? color.red : color.white
            //barcolor(bar ? smafColor : na)
            //hline(0)
            //plot(roc, title = "SmaFilt", color = smafColor, linewidth = 2)
            List<decimal> filtList = new();
            List<decimal> rocList = new();
            List<decimal> filtSumList = new();
            List<decimal> coefSumList = new();
            List<decimal> filtMa1List = new();
            List<decimal> filtMa2List = new();
            List<decimal> derivList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentOpen = stockDataClass.OpenPrices.ElementAtOrDefault(i);
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevFilt1 = i >= 1 ? filtList.ElementAtOrDefault(i - 1) : 0;

                    decimal deriv = currentValue - currentOpen;
                    derivList.Add(deriv);

                    decimal filtSum = 0, coefSum = 0;
                    for (int j = 1; j <= days; j++)
                    {
                        decimal prevDeriv = i >= j - 1 ? derivList.ElementAtOrDefault(i - (j - 1)) : 0;
                        filtSum += prevDeriv;
                        coefSum += 1;
                    }
                    filtSumList.Add(filtSum);
                    coefSumList.Add(coefSum);

                    decimal filt = coefSum != 0 ? filtSum / coefSum : 0;
                    filtList.Add(filt);
                }

                filtMa1List = GetMovingAverageList(maType, filtList, stockDataClass, days);
                filtMa2List = GetMovingAverageList(maType, filtMa1List, stockDataClass, days);
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal filt = filtMa2List.ElementAtOrDefault(j);
                    decimal prevFilt1 = j >= 1 ? filtMa2List.ElementAtOrDefault(j - 1) : 0;
                    decimal prevFilt2 = j >= 2 ? filtMa2List.ElementAtOrDefault(j - 2) : 0;

                    decimal roc = days / 6.28m * (filt - prevFilt1);
                    rocList.Add(roc);

                    var signal = GetCompareSignal(filt - prevFilt1, prevFilt1 - prevFilt2);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (filtSumList, coefSumList, filtList, filtMa1List, filtMa2List, rocList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateEhlersSignalToNoiseRatioV2(StockData stockDataClass, int days = 6)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Ehlers Signal To Noise Ratio [CC] script may be freely distributed under the MIT license.
            //study("Ehlers Signal To Noise Ratio [CC]", overlay = false)

            //f_security(_symbol, _res, _src, _repaint) => 
            //    security(_symbol, _res, _src[_repaint ? 0 : barstate.isrealtime ? 1 : 0])[_repaint ? 0 : barstate.isrealtime ? 0 : 1]

            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //src = f_security(syminfo.tickerid, res, hl2, rep)
            //h = f_security(syminfo.tickerid, res, high, rep)
            //l = f_security(syminfo.tickerid, res, low, rep)

            //pi = 2 * asin(1)
            //period = 0.0
            //range = 0.0
            //range:= (0.1 * (h - l)) + (0.9 * nz(range[1]))

            //smooth = ((4 * src) + (3 * nz(src[1])) + (2 * nz(src[2])) + nz(src[3])) / 10
            //detrender = ((0.0962 * smooth) + (0.5769 * nz(smooth[2])) - (0.5769 * nz(smooth[4])) - (0.0962 * nz(smooth[6]))) * ((0.075 * nz(period[1])) + 0.54)

            //q1 = ((0.0962 * detrender) + (0.5769 * nz(detrender[2])) - (0.5769 * nz(detrender[4])) - (0.0962 * nz(detrender[6]))) * ((0.075 * nz(period[1])) + 0.54)
            //i1 = nz(detrender[3])

            //jI = ((0.0962 * i1) + (0.5769 * nz(i1[2])) - (0.5769 * nz(i1[4])) - (0.0962 * nz(i1[6]))) * ((0.075 * nz(period[1])) + 0.54)
            //jQ = ((0.0962 * q1) + (0.5769 * nz(q1[2])) - (0.5769 * nz(q1[4])) - (0.0962 * nz(q1[6]))) * ((0.075 * nz(period[1])) + 0.54)

            //i2 = i1 - jQ
            //i2:= (0.2 * i2) + (0.8 * nz(i2[1]))
            //q2 = q1 + jI
            //q2:= (0.2 * q2) + (0.8 * nz(q2[1]))

            //re = (i2 * nz(i2[1])) + (q2 * nz(q2[1]))
            //re:= (0.2 * re) + (0.8 * nz(re[1]))
            //im = (i2 * nz(q2[1])) - (q2 * nz(i2[1]))
            //im:= (0.2 * im) + (0.8 * nz(im[1]))

            //period:= im != 0 and re != 0 ? 2 * pi / atan(im / re) : 0
            //period:= min(max(period, 0.67 * nz(period[1])), 1.5 * nz(period[1]))
            //period:= min(max(period, 6), 50)
            //period:= (0.2 * period) + (0.8 * nz(period[1]))

            //snr = 0.0
            //snr:= range > 0 ? (0.25 * ((10 * log(((i1 * i1) + (q1 * q1)) / (range * range)) / log(10)) + 6)) + (0.75 * nz(snr[1])) : 0

            //hline(6)
            //sig = src > smooth ? 1 : src < smooth ? -1 : 0
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //snrColor = sig > 0 ? color.green : sig < 0 ? color.red : color.black
            //barcolor(bar ? snrColor : na)
            //plot(snr, title = "SNR", color = snrColor, linewidth = 2)
            List<decimal> snrList = new();
            List<decimal> tempList = new();
            List<decimal> tempLogList = new();
            List<decimal> rangeList = new();
            List<Signal> signalsList = new();

            try
            {
                var ehlersMamaList = CalculateEhlersMotherOfAdaptiveMovingAverages(stockDataClass);
                var i1List = ehlersMamaList.Item4;
                var q1List = ehlersMamaList.Item3;
                var smoothList = ehlersMamaList.Item1;
                var minMaxList = VolumeInputCheck(stockDataClass, days, false);
                var highList = minMaxList.Item1;
                var lowList = minMaxList.Item2;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal smooth = smoothList.ElementAtOrDefault(i);
                    decimal currentHigh = highList.ElementAtOrDefault(i);
                    decimal currentLow = lowList.ElementAtOrDefault(i);
                    decimal i1 = i1List.ElementAtOrDefault(i);
                    decimal q1 = q1List.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevSmooth = i >= 1 ? smoothList.ElementAtOrDefault(i - 1) : 0;

                    decimal prevRange = rangeList.LastOrDefault();
                    decimal range = (0.1m * (currentHigh - currentLow)) + (0.9m * prevRange);
                    rangeList.Add(range);

                    decimal temp = range != 0 ? ((i1 * i1) + (q1 * q1)) / (range * range) : 0;
                    tempList.Add(temp);

                    decimal tempLog = temp > 0 ? Log(temp) : 0;
                    tempLogList.Add(tempLog);

                    decimal prevSnr = snrList.LastOrDefault();
                    decimal snr = range > 0 ? (0.25m * ((10 * tempLog / (decimal)Math.Log(10)) + days)) + (0.75m * prevSnr) : 0;
                    snrList.Add(snr);

                    var signal = GetVolatilitySignal(currentValue - smooth, prevValue - prevSmooth, snr, days);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (rangeList, tempList, tempLogList, snrList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>)
            CalculateEhlersEnhancedSignalToNoiseRatio(StockData stockDataClass, int days = 6)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Ehlers Enhanced Signal To Noise Ratio [CC] script may be freely distributed under the MIT license.
            //study("Ehlers Enhanced Signal To Noise Ratio [CC]", overlay = false)

            //f_security(_symbol, _res, _src, _repaint) => 
            //    security(_symbol, _res, _src[_repaint ? 0 : barstate.isrealtime ? 1 : 0])[_repaint ? 0 : barstate.isrealtime ? 0 : 1]

            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //src = f_security(syminfo.tickerid, res, hl2, rep)
            //h = f_security(syminfo.tickerid, res, high, rep)
            //l = f_security(syminfo.tickerid, res, low, rep)

            //pi = 2 * asin(1)
            //period = 0.0
            //smooth = ((4 * src) + (3 * nz(src[1])) + (2 * nz(src[2])) + nz(src[3])) / 10
            //detrender = ((0.0962 * smooth) + (0.5769 * nz(smooth[2])) - (0.5769 * nz(smooth[4])) - (0.0962 * nz(smooth[6]))) * ((0.075 * nz(period[1])) + 0.54)

            //q1 = ((0.0962 * detrender) + (0.5769 * nz(detrender[2])) - (0.5769 * nz(detrender[4])) - (0.0962 * nz(detrender[6]))) * ((0.075 * nz(period[1])) + 0.54)
            //i1 = nz(detrender[3])

            //jI = ((0.0962 * i1) + (0.5769 * nz(i1[2])) - (0.5769 * nz(i1[4])) - (0.0962 * nz(i1[6]))) * ((0.075 * nz(period[1])) + 0.54)
            //jQ = ((0.0962 * q1) + (0.5769 * nz(q1[2])) - (0.5769 * nz(q1[4])) - (0.0962 * nz(q1[6]))) * ((0.075 * nz(period[1])) + 0.54)

            //i2 = i1 - jQ
            //i2:= (0.2 * i2) + (0.8 * nz(i2[1]))
            //q2 = q1 + jI
            //q2:= (0.2 * q2) + (0.8 * nz(q2[1]))

            //re = (i2 * nz(i2[1])) + (q2 * nz(q2[1]))
            //re:= (0.2 * re) + (0.8 * nz(re[1]))
            //im = (i2 * nz(q2[1])) - (q2 * nz(i2[1]))
            //im:= (0.2 * im) + (0.8 * nz(im[1]))

            //period:= im != 0 and re != 0 ? 2 * pi / atan(im / re) : 0
            //period:= min(max(period, 0.67 * nz(period[1])), 1.5 * nz(period[1]))
            //period:= min(max(period, 6), 50)
            //period:= (0.2 * period) + (0.8 * nz(period[1]))

            //smoothPeriod = 0.0
            //smoothPeriod:= (0.33 * period) + (0.67 * nz(smoothPeriod[1]))

            //q3 = 0.5 * (smooth - nz(smooth[2])) * ((0.1759 * smoothPeriod) + 0.4607)

            //i3 = 0.0, sp = ceil(smoothPeriod / 2)
            //for i = 0 to sp - 1
            //    i3 := i3 + nz(q3[i])
            //i3 := (1.57 * i3) / sp

            //signal = (i3 * i3) + (q3 * q3)
            //noise = 0.0
            //noise := (0.1 * (h - l) * (h - l) * 0.25) + (0.9 * nz(noise[1]))

            //snr = 0.0
            //snr := noise != 0 and signal != 0 ? (0.33 * (10 * log(signal / noise) / log(10))) + (0.67 * nz(snr[1])) : 0

            //hline(6)
            //sig = src > smooth ? 1 : src < smooth ? -1 : 0
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //snrColor = sig > 0 ? color.green : sig < 0 ? color.red : color.black
            //barcolor(bar ? snrColor : na)
            //plot(snr, title = "SNR", color = snrColor, linewidth = 2)
            List<decimal> tempList = new();
            List<decimal> tempLogList = new();
            List<decimal> q3List = new();
            List<decimal> i3List = new();
            List<decimal> i3_2List = new();
            List<decimal> signalList = new();
            List<decimal> noiseList = new();
            List<decimal> snrList = new();
            List<Signal> signalsList = new();

            try
            {
                var ehlersMamaList = CalculateEhlersMotherOfAdaptiveMovingAverages(stockDataClass);
                var smoothList = ehlersMamaList.Item1;
                var smoothPeriodList = ehlersMamaList.Item12;
                var minMaxList = VolumeInputCheck(stockDataClass, days, false);
                var highList = minMaxList.Item1;
                var lowList = minMaxList.Item2;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentHigh = highList.ElementAtOrDefault(i);
                    decimal currentLow = lowList.ElementAtOrDefault(i);
                    decimal smooth = smoothList.ElementAtOrDefault(i);
                    decimal prevSmooth2 = i >= 2 ? smoothList.ElementAtOrDefault(i - 2) : 0;
                    decimal prevNoise1 = i >= 1 ? noiseList.ElementAtOrDefault(i - 1) : 0;
                    decimal smoothPeriod = smoothPeriodList.ElementAtOrDefault(i);
                    decimal prevSnr1 = i >= 1 ? snrList.ElementAtOrDefault(i - 1) : 0;
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevSmooth = i >= 1 ? smoothList.ElementAtOrDefault(i - 1) : 0;

                    decimal q3 = 0.5m * (smooth - prevSmooth2) * ((0.1759m * smoothPeriod) + 0.4607m);
                    q3List.Add(q3);

                    int sp = (int)Math.Ceiling(smoothPeriod / 2);
                    decimal i3 = 0;
                    for (int j = 0; j <= sp - 1; j++)
                    {
                        decimal prevQ3 = i >= j ? q3List.ElementAtOrDefault(i - j) : 0;
                        i3 += prevQ3;
                    }
                    i3List.Add(i3);

                    decimal i3_2 = sp != 0 ? (1.57m * i3) / sp : 0;
                    i3_2List.Add(i3_2);

                    decimal signalValue = (i3 * i3) + (q3 * q3);
                    signalList.Add(signalValue);

                    decimal noise = (0.1m * (currentHigh - currentLow) * (currentHigh - currentLow) * 0.25m) + (0.9m * prevNoise1);
                    noiseList.Add(noise);

                    decimal temp = noise != 0 ? signalValue / noise : 0;
                    tempList.Add(temp);

                    decimal tempLog = temp > 0 ? Log(temp) : 0;
                    tempLogList.Add(tempLog);

                    decimal snr = (0.33m * (10 * tempLog / Log((double)10))) + (0.67m * prevSnr1);
                    snrList.Add(snr);

                    var signal = GetVolatilitySignal(currentValue - smooth, prevValue - prevSmooth, snr, days);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (q3List, i3List, i3_2List, signalList, noiseList, tempList, tempLogList, snrList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateEhlersHilbertOscillator(StockData stockDataClass, int days = 7)
        {
            //Hilbert Oscillator

            //Inputs: Price((H + L) / 2);

            //If CurrentBar > 5 then begin
            //{ Compute ‘Noise” as the average range}
            //Range = .l*(H - L) + .9*Range[1];

            //Smooth = (4*Price + 3*Price[1] + 2*Price[2] + Price[3]) / 10;
            //Detrender = (.0962*Smooth + .5769*Smooth[2] - .5769*Smooth[4] - .0962*Smooth[6]) * (.075*Period[1] + .54);

            //{ Compute InPhase and Quadrature components}
            //Q1 = (.0962*Detrender + .5769*Detrender[2] - .5769*Detrender[4] - .0962*Detrender[6]) * (.075*Period[1] + .54);
            //I1 = Detrender[3];

            //{ Advance the phase of I1 and Q1 by 90 degrees}
            //jI = (.0962*I1 + .5769*I1[2] - .5769*I1[4] - .0962*I1[6]) * (.075*Period[1] + .54);
            //jQ = (.0962*Ql + .5769*Q1[2] - .5769*Q1[4] - .0962*Ql[6]) * (.075*Period[1] + .54);

            //{ Phasor addition for 3 bar averaging}
            //I2 = I1 - jQ;
            //Q2 = Q1 + jI;

            //{ Smooth the I and Q components before applying the discriminator}
            //I2 = .2*I2 + .8*I2[1];
            //Q2 = .2*Q2 + .8*Q2[l];

            //{ Homodyne Discriminator}
            //Re = I2*I2[1] + Q2*Q2[1];
            //Im = I2*Q2[1] - Q2*I2[1];
            //Re = .2*Re + .8*Re[1];
            //Im = .2*Im + .8*Im[1];
            //If Im <> 0 and Re <> 0 then Period = 360/ArcTangent(Im/Re);
            //If Period > 1.5*Period[1] then Period = 1.5*Period[1];
            //If Period < .67*Period[1] then Period = .67*Period[1];
            //If Period < 6 then Period = 6;
            //If Period > 50 then Period = 50;
            //Period = .2*Period + .8*Period[1];
            //SmoothPeriod = .33*Period + .67*SmoothPeriod[l];

            //Q3 = .5*(Smooth - Smooth[2])*(.1759*SmoothPeriod + .4607);
            //I3 = 0;
            //For count = 0 to Int(SmoothPeriod / 2) -1 begin
            //  I3 = I3 + Q3[count];
            //End;
            //I3 = 1.57*13 / Int(SmoothPeriod / 2);

            //Valuel = 0;
            //For count = 0 to Int(SmoothPeriod / 4) - 1 begin
            // Valuel = Valuel + Q3[count];
            //End;
            //Valuel = 1.25 * Valuel / Int(SmoothPeriod / 4);
            //Plot1(I3, "I");
            //Plot2(Valuel, "IQ");
            //End;
            List<decimal> value1List = new();
            List<decimal> value1_2List = new();
            List<Signal> signalsList = new();

            try
            {
                List<decimal> emaList = CalculateExponentialMovingAverage(stockDataClass, days).Item1;
                var snrv2List = CalculateEhlersEnhancedSignalToNoiseRatio(stockDataClass, days);
                List<decimal> smoothPeriodList = snrv2List.Item1;
                List<decimal> q3List = snrv2List.Item2;
                List<decimal> i3List = snrv2List.Item4;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal currentEma = emaList.ElementAtOrDefault(i);
                    decimal smoothPeriod = smoothPeriodList.ElementAtOrDefault(i);
                    decimal i3 = i3List.ElementAtOrDefault(i);
                    decimal prevI3 = i >= 1 ? i3List.ElementAtOrDefault(i - 1) : 0;

                    int maxCount = (int)Math.Ceiling(smoothPeriod / 4);
                    decimal value1 = 0;
                    for (int count = 0; count <= maxCount - 1; count++)
                    {
                        decimal prevQ3 = i >= count ? q3List.ElementAtOrDefault(i - count) : 0;
                        value1 += prevQ3;
                    }
                    value1List.Add(value1);

                    decimal prevValue1_2 = value1_2List.LastOrDefault();
                    decimal value1_2 = maxCount != 0 ? (1.25m * value1) / maxCount : 0;
                    value1_2List.Add(value1_2);

                    var signal = GetCompareSignal(value1_2 - i3, prevValue1_2 - prevI3);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (value1List, value1_2List, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>)
            CalculateTradingMadeMoreSimplerOscillator(StockData stockDataClass, string maType, int days = 3)
        {
            //PRC_smTMMS-Oscillator_v3.0 | indicator
            //13.09.2019
            //Nicolas @ www.prorealcode.com
            //Sharing ProRealTime knowledge
            //translated from mt4 version

            // --- settings
            //RSIPeriod = 14
            //Stochastic1PeriodK = 8
            //Stochastic1PeriodD = 3
            //Stochastic2PeriodK = 14
            //Stochastic2PeriodD = 3
            //DrawHullTrend = 1 //(1=true ; 0=false)
            //HullPeriod = 12
            //HullDivisor = 2
            // --- end of settings

            //once threshold = 50
            //once ilimit = 0

            //bufRSI = rsi[RSIPeriod]
            //bufStoch1 = stochastic[Stochastic1PeriodK, Stochastic1PeriodD]
            //bufStoch2 = stochastic[Stochastic2PeriodK, Stochastic2PeriodD]
            //bufRSI = bufRSI - threshold
            //bufStoch1 = bufStoch1 - threshold
            //bufStoch2 = bufStoch2 - threshold

            //bufHistUP = 0
            //bufHistDN = 0
            //bufHistNO = 0
            //if (bufRSI > ilimit and bufStoch1 > ilimit and bufStoch2 > ilimit) then
            //bufHistUP = bufStoch2
            //else
            //if (bufRSI < ilimit and bufStoch1 < ilimit and bufStoch2 < ilimit) then
            //bufHistDN = bufStoch2
            //else
            //bufHistNO = bufStoch2
            //endif
            //endif

            //if (DrawHullTrend) then
            //inner = 2 * weightedaverage[round(HullPeriod / HullDivisor)](close) - weightedaverage[HullPeriod](close)
            //MMHULL = weightedaverage[round(sqrt(HullPeriod))](inner)
            //r = 255
            //g = 155
            //if MMHULL > MMHULL[1] then
            //r = 0
            //g = 255
            //endif
            //drawtext("●", barindex, 0, dialog, bold, 16) coloured(r, g, 0)
            //endif

            //return bufHistUP coloured(0, 128, 0) style(histogram) as "Up", bufHistDN coloured(255,0,0) style(histogram) as "Dn", 
            //bufHistNO coloured(169,169,169) style(histogram) as "No",0 coloured(168, 168, 168) style(point, 1) as "level0", 20  coloured(168, 168, 168) 
            //style(dottedline, 1) as "level20", -20  coloured(168, 168, 168) style(dottedline, 1) as "level-20"
            List<decimal> bufRsiList = new();
            List<decimal> bufStoch1List = new();
            List<decimal> bufStoch2List = new();
            List<decimal> bufHistUpList = new();
            List<decimal> bufHistDnList = new();
            List<decimal> bufHistNoList = new();
            List<decimal> stochastic1DList = new();
            List<decimal> stochastic2DList = new();
            List<Signal> signalsList = new();
            decimal threshold = 50, ilimit = 0;

            try
            {
                int rsiPeriod = (int)Math.Ceiling(days / 0.2143);
                int stochastic1PeriodK = (int)Math.Ceiling(days / 0.375);
                int stochastic1PeriodD = days;
                int stochastic2PeriodK = rsiPeriod;
                int stochastic2PeriodD = days;

                List<decimal> rsiList = CalculateRelativeStrengthIndex(null, stockDataClass, maType, rsiPeriod).Item4;
                List<decimal> stochastic1KList = CalculateStochasticOscillator(null, stockDataClass, maType, stochastic1PeriodK).Item3;
                stochastic1DList = GetMovingAverageList(maType, stochastic1KList, stockDataClass, stochastic1PeriodD);
                List<decimal> stochastic2KList = CalculateStochasticOscillator(null, stockDataClass, maType, stochastic2PeriodK).Item3;
                stochastic2DList = GetMovingAverageList(maType, stochastic2KList, stockDataClass, stochastic2PeriodD);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal rsi = rsiList.ElementAtOrDefault(i);
                    decimal stoch1 = stochastic1DList.ElementAtOrDefault(i);
                    decimal stoch2 = stochastic2DList.ElementAtOrDefault(i);

                    decimal bufRsi = rsi - threshold;
                    bufRsiList.Add(bufRsi);

                    decimal bufStoch1 = stoch1 - threshold;
                    bufStoch1List.Add(bufStoch1);

                    decimal bufStoch2 = stoch2 - threshold;
                    bufStoch2List.Add(bufStoch2);

                    decimal prevBufHistUp = bufHistUpList.LastOrDefault();
                    decimal bufHistUp = bufRsi > ilimit && bufStoch1 > ilimit && bufStoch2 > ilimit ? bufStoch2 : 0;
                    bufHistUpList.Add(bufHistUp);

                    decimal prevBufHistDn = bufHistDnList.LastOrDefault();
                    decimal bufHistDn = bufRsi < ilimit && bufStoch1 < ilimit && bufStoch2 < ilimit ? bufStoch2 : 0;
                    bufHistDnList.Add(bufHistDn);

                    decimal bufHistNo = bufHistUp == 0 && bufHistDn == 0 ? bufStoch2 : 0;
                    bufHistNoList.Add(bufHistNo);

                    var signal = GetCompareSignal(bufHistUp - bufHistDn, prevBufHistUp - prevBufHistDn);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (stochastic1DList, stochastic2DList, bufRsiList, bufStoch1List, bufStoch2List, bufHistUpList, bufHistDnList, bufHistNoList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateEhlersAlternateSignalToNoiseRatio(StockData stockDataClass, int days = 6)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Ehlers Alternate Signal To Noise Ratio [CC] script may be freely distributed under the MIT license.
            //study("Ehlers Alternate Signal To Noise Ratio [CC]", overlay = false)

            //f_security(_symbol, _res, _src, _repaint) => 
            //    security(_symbol, _res, _src[_repaint ? 0 : barstate.isrealtime ? 1 : 0])[_repaint ? 0 : barstate.isrealtime ? 0 : 1]

            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //src = f_security(syminfo.tickerid, res, hl2, rep)
            //h = f_security(syminfo.tickerid, res, high, rep)
            //l = f_security(syminfo.tickerid, res, low, rep)

            //pi = 2 * asin(1)
            //period = 0.0
            //range = 0.0
            //range:= (0.1 * (h - l)) + (0.9 * nz(range[1]))

            //smooth = ((4 * src) + (3 * nz(src[1])) + (2 * nz(src[2])) + nz(src[3])) / 10
            //detrender = ((0.0962 * smooth) + (0.5769 * nz(smooth[2])) - (0.5769 * nz(smooth[4])) - (0.0962 * nz(smooth[6]))) * ((0.075 * nz(period[1])) + 0.54)

            //q1 = ((0.0962 * detrender) + (0.5769 * nz(detrender[2])) - (0.5769 * nz(detrender[4])) - (0.0962 * nz(detrender[6]))) * ((0.075 * nz(period[1])) + 0.54)
            //i1 = nz(detrender[3])

            //jI = ((0.0962 * i1) + (0.5769 * nz(i1[2])) - (0.5769 * nz(i1[4])) - (0.0962 * nz(i1[6]))) * ((0.075 * nz(period[1])) + 0.54)
            //jQ = ((0.0962 * q1) + (0.5769 * nz(q1[2])) - (0.5769 * nz(q1[4])) - (0.0962 * nz(q1[6]))) * ((0.075 * nz(period[1])) + 0.54)

            //i2 = i1 - jQ
            //i2:= (0.2 * i2) + (0.8 * nz(i2[1]))
            //q2 = q1 + jI
            //q2:= (0.2 * q2) + (0.8 * nz(q2[1]))

            //re = (i2 * nz(i2[1])) + (q2 * nz(q2[1]))
            //re:= (0.2 * re) + (0.8 * nz(re[1]))
            //im = (i2 * nz(q2[1])) - (q2 * nz(i2[1]))
            //im:= (0.2 * im) + (0.8 * nz(im[1]))

            //period:= im != 0 and re != 0 ? 2 * pi / atan(im / re) : 0
            //period:= min(max(period, 0.67 * nz(period[1])), 1.5 * nz(period[1]))
            //period:= min(max(period, 6), 50)
            //period:= (0.2 * period) + (0.8 * nz(period[1]))

            //snr = 0.0
            //snr:= range > 0 ? (0.25 * ((10 * log((re + im) / (range * range)) / log(10)) + 6)) + (0.75 * nz(snr[1])) : 0

            //hline(6)
            //sig = src > smooth ? 1 : src < smooth ? -1 : 0
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //snrColor = sig > 0 ? color.green : sig < 0 ? color.red : color.black
            //barcolor(bar ? snrColor : na)
            //plot(snr, title = "SNR", color = snrColor, linewidth = 2)
            List<decimal> tempList = new();
            List<decimal> tempLogList = new();
            List<decimal> snrList = new();
            List<decimal> rangeList = new();
            List<Signal> signalsList = new();

            try
            {
                var ehlersMamaList = CalculateEhlersMotherOfAdaptiveMovingAverages(stockDataClass);
                var reList = ehlersMamaList.Item9;
                var imList = ehlersMamaList.Item10;
                var smoothList = ehlersMamaList.Item1;
                var minMaxList = VolumeInputCheck(stockDataClass, days, false);
                var highList = minMaxList.Item1;
                var lowList = minMaxList.Item2;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal smooth = smoothList.ElementAtOrDefault(i);
                    decimal re = reList.ElementAtOrDefault(i);
                    decimal im = imList.ElementAtOrDefault(i);
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal currentHigh = highList.ElementAtOrDefault(i);
                    decimal currentLow = lowList.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevSmooth = i >= 1 ? smoothList.ElementAtOrDefault(i - 1) : 0;

                    decimal prevRange = rangeList.LastOrDefault();
                    decimal range = (0.1m * (currentHigh - currentLow)) + (0.9m * prevRange);
                    rangeList.Add(range);

                    decimal temp = range != 0 ? (re + im) / (range * range) : 0;
                    tempList.Add(temp);

                    decimal tempLog = temp > 0 ? Log(temp) : 0;
                    tempLogList.Add(tempLog);

                    decimal prevSnr = snrList.LastOrDefault();
                    decimal snr = (0.25m * ((10 * tempLog / Log((double)10)) + days)) + (0.75m * prevSnr);
                    snrList.Add(snr);

                    var signal = GetVolatilitySignal(currentValue - smooth, prevValue - prevSmooth, snr, days);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (tempList, tempLogList, snrList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateEhlersEarlyOnsetTrendIndicator(StockData stockDataClass, int days = 30)
        {
            //Ehlers Early-Onset Trend Indicator
            //Inputs: LPPeriod(30), K(.85);
            //Vars: alpha1(0), HP(0), a1(0), b1(0), c1(0), c2(0), c3(0), Filt(0), Peak(0), X(0), Quotient(0);
            //Highpass filter cyclic components whose periods are shorter than 100 bars 
            //alpha1 = (Cosine(.707*360 / 100) + Sine (.707*360 / 100) - 1) / Cosine(.707*360 / 100); 
            //HP = (1 - alpha1 / 2)*(1 - alpha1 / 2)*(Close - 2*Close[1] + Close[2]) + 2*(1 - alpha1)*HP[1] - (1 - alpha1)*(1 - alpha1) * HP[2]; 
            //SuperSmoother Filter
            //a1 = expvalue(-1.414*3.14159 / LPPeriod); 
            //b1 = 2*a1*Cosine(1.414*180 / LPPeriod); 
            //c2 = b1; 
            //c3 = -a1*a1; 
            //c1 = 1 - c2 - c3; 
            //Filt = c1*(HP + HP[1]) / 2 + c2*Filt[1] + c3*Filt[2];
            //Fast Attack - Slow Decay Algorithm 
            //Peak = .991*Peak[1]; 
            //If AbsValue(Filt) > Peak Then Peak = AbsValue(Filt); 
            //Normalized Roofing Filter 
            //If Peak <> 0 Then X = Filt / Peak; 
            //Quotient = (X + K) / (K*X + 1); 
            //Plot1(Quotient); 
            //Plot2(0);
            List<decimal> peakList = new();
            List<decimal> quotientList = new();
            List<decimal> ratioList = new();
            List<decimal> superSmoothList = new();
            List<Signal> signalsList = new();
            decimal k = 0.85m;

            try
            {
                int smoothPeriod = days;
                int hpPeriod = MinOrMax((int)Math.Ceiling(smoothPeriod / 0.3));

                List<decimal> hpList = CalculateEhlersHighPassFilter(null, stockDataClass, hpPeriod, 1).Item1;
                superSmoothList = CalculateEhlersSuperSmootherFilter(hpList, stockDataClass, smoothPeriod).Item1;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal filter = superSmoothList.ElementAtOrDefault(i);

                    decimal prevPeak = peakList.LastOrDefault();
                    decimal peak = Math.Abs(filter) > 0.991m * prevPeak ? Math.Abs(filter) : 0.991m * prevPeak;
                    peakList.Add(peak);

                    decimal ratio = peak != 0 ? filter / peak : 0;
                    ratioList.Add(ratio);

                    decimal prevQuotient = quotientList.LastOrDefault();
                    decimal quotient = (k * ratio) + 1 != 0 ? (ratio + k) / ((k * ratio) + 1) : 0;
                    quotientList.Add(quotient);

                    var signal = GetCompareSignal(quotient, prevQuotient);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (superSmoothList, peakList, ratioList, quotientList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<decimal>, List<decimal>, List<Signal>) CalculateEhlersDiscreteFourierTransform(StockData stockDataClass, int days = 8)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Ehlers Discrete Fourier Transform script may be freely distributed under the MIT license.
            //study("Ehlers Discrete Fourier Transform", shorttitle = "EDFT", overlay = false)

            //minPeriod = input(title = "MinPeriod", type = input.integer, defval = 8, minval = 1)
            //maxPeriod = input(title = "MaxPeriod", type = input.integer, defval = 50, minval = 1)
            //hpPeriod = input(title = "HpPeriod", type = input.integer, defval = 40, minval = 1)
            //src = input(title = "Source", type = input.source, defval = hl2)

            //pi = 2 * asin(1)
            //alpha = (1 - sin(2 * pi / hpPeriod)) / cos(2 * pi / hpPeriod)
            //hp = 0.0
            //hp:= bar_index <= 5 ? src : (0.5 * (1 + alpha) * (src - src[1])) + (alpha * hp[1])
            //cleanedData = bar_index <= 5 ? src : (hp + (2 * hp[1]) + (3 * hp[2]) + (3 * hp[3]) + (2 * hp[4]) + hp[5]) / 12

            //pwr = 0.0
            //for i = minPeriod to maxPeriod
            //    cosinePart = 0.0, sinePart = 0.0
            //    for n = 0 to maxPeriod - 1
            //        cosinePart := cosinePart + (cleanedData[n] * cos(2 * pi * n / i))
            //        sinePart := sinePart + (cleanedData[n] * sin(2 * pi * n / i))
            //    pwr := (cosinePart * cosinePart) + (sinePart * sinePart)

            //maxPwr = pwr[minPeriod], db = 0.0, num = 0.0, denom = 0.0, dc = 0.0
            //for period = minPeriod to maxPeriod
            //    maxPwr := pwr[period] > maxPwr ? pwr[period] : maxPwr
            //    db := maxPwr > 0 and pwr[period] > 0 ? -10 * log(.01 / (1 - (0.99 * pwr[period] / maxPwr))) / log(10) : 0
            //    db := db > 20 ? 20 : db

            //    if db < 3
            //      num:= num + (period * (3 - db))
            //      denom:= denom + (3 - db)
            //dc:= denom != 0 ? num / denom : 0

            //plot(dc, title = "DC", color = color.blue, linewidth = 2, transp = 0)
            //plot(db, title = "DB", color = color.orange, linewidth = 2, transp = 0)
            //hpColor = hp > 0 ? color.green : hp < 0 ? color.red : color.black
            //plot(hp, title = "Hp", color = hpColor, linewidth = 2, transp = 0)
            List<decimal> cleanedDataList = new();
            List<decimal> hpList = new();
            List<decimal> cosPartList = new();
            List<decimal> sinPartList = new();
            List<decimal> powerList = new();
            List<decimal> maxPowerList = new();
            List<decimal> dbList = new();
            List<decimal> numList = new();
            List<decimal> denomList = new();
            List<decimal> dominantCycleList = new();
            List<decimal> dcSignalList = new();
            List<decimal> color1List = new();
            List<decimal> color2List = new();
            List<Signal> signalsList = new();

            try
            {
                int maxPeriod = (int)Math.Ceiling(days / 0.16);
                int hpPeriod = days * 5;
                decimal twoPiPrd = (decimal)MinOrMax(2 * Math.PI / hpPeriod, 0.99, 0.01);
                decimal alpha = (1 - Sin(twoPiPrd)) / Cos(twoPiPrd);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue1 = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevHp1 = i >= 1 ? hpList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevHp2 = i >= 2 ? hpList.ElementAtOrDefault(i - 2) : 0;
                    decimal prevHp3 = i >= 3 ? hpList.ElementAtOrDefault(i - 3) : 0;
                    decimal prevHp4 = i >= 4 ? hpList.ElementAtOrDefault(i - 4) : 0;
                    decimal prevHp5 = i >= 5 ? hpList.ElementAtOrDefault(i - 5) : 0;

                    decimal hp = i <= 5 ? currentValue : (0.5m * (1 + alpha) * (currentValue - prevValue1)) + (alpha * prevHp1);
                    hpList.Add(hp);

                    decimal cleanedData = i <= 5 ? currentValue : (hp + (2 * prevHp1) + (3 * prevHp2) + (3 * prevHp3) + (2 * prevHp4) + prevHp5) / 12;
                    cleanedDataList.Add(cleanedData);

                    decimal pwr = 0, cosPart = 0, sinPart = 0;
                    for (int j = days; j <= maxPeriod; j++)
                    {
                        for (int n = 0; n <= maxPeriod - 1; n++)
                        {
                            decimal prevCleanedData = i >= n ? cleanedDataList.ElementAtOrDefault(i - n) : 0;
                            cosPart += prevCleanedData * Cos(MinOrMax(2 * Math.PI * n / j, 0.99, 0.01));
                            sinPart += prevCleanedData * Sin(MinOrMax(2 * Math.PI * n / j, 0.99, 0.01));
                        }

                        pwr = (cosPart * cosPart) + (sinPart * sinPart);
                    }
                    cosPartList.Add(cosPart);
                    sinPartList.Add(sinPart);
                    powerList.Add(pwr);

                    decimal maxPwr = i >= days ? powerList.ElementAtOrDefault(i - days) : 0;
                    decimal db = 0, num = 0, denom = 0;
                    for (int period = days; period <= maxPeriod; period++)
                    {
                        decimal prevPwr = i >= period ? powerList.ElementAtOrDefault(i - period) : 0;
                        maxPwr = prevPwr > maxPwr ? prevPwr : maxPwr;
                        db = maxPwr > 0 && prevPwr > 0 ? -10 * Log(0.01m / (1 - (0.99m * prevPwr / maxPwr))) / Log((double)10) : 0;
                        db = db > 20 ? 20 : db;

                        num += db < 3 ? period * (3 - db) : 0;
                        denom += db < 3 ? 3 - db : 0;
                    }
                    maxPowerList.Add(maxPwr);
                    dbList.Add(db);
                    numList.Add(num);
                    denomList.Add(denom);

                    decimal dominantCycle = denom != 0 ? num / denom : 0;
                    dominantCycleList.Add(dominantCycle);

                    decimal color1 = db > 10 ? 255 * (2 - (db / 10)) : 255;
                    color1List.Add(color1);

                    decimal color2 = db > 10 ? 0 : 255 * (1 - (db / 10));
                    color2List.Add(color2);

                    decimal dcSignal = CalculateExponentialMovingAverage(dominantCycle, dcSignalList.LastOrDefault(), hpPeriod);
                    dcSignalList.Add(dcSignal);

                    var signal = GetCompareSignal(hp, prevHp1);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (hpList, cleanedDataList, cosPartList, sinPartList, powerList, maxPowerList, dbList, numList, denomList, dominantCycleList, color1List, color2List, dcSignalList,
                signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<Signal>) CalculateEhlersFourierSeriesAnalysis(StockData stockDataClass, int days = 20)
        {
            //{ Fourier Series Analysis(C) 2005 - 2018   John F. Ehlers }
            //Inputs: Fundamental(20);
            //Vars: Bandwidth(.1), G1(0), S1(0), L1(0), BP1(0), Q1(0), P1(0), G2(0), S2(0), L2(0), BP2(0), Q2(0), P2(0), G3(0), S3(0), L3(0), BP3(0), Q3(0), P3(0), count(0), 
            //Wave(0), ROC(0);

            //compute filter coefficients once 
            //If CurrentBar = 1 Then Begin 
            //L1 = Cosine(360 / Fundamental); 
            //G1 = Cosine(Bandwidth*360 / Fundamental); 
            //S1 = 1 / G1 - SquareRoot(1 / (G1*G1) - 1); 
            //L2 = Cosine(360 / (Fundamental / 2)); 
            //G2 = Cosine(Bandwidth*360 / (Fundamental / 2)); 
            //S2 = 1 / G2 - SquareRoot(1 / (G2*G2) - 1); 
            //L3 = Cosine(360 / (Fundamental / 3)); 
            //G3 = Cosine(Bandwidth*360 / (Fundamental / 3)); 
            //S3 = 1 / G3 - SquareRoot(1 / (G3*G3) - 1); 
            //End; 

            //Fundamental Band-Pass 
            //BP1 = .5*(1 - S1)*(Close - Close[2]) + L1*(1 + S1)*BP1[1] - S1*BP1[2]; 
            //If CurrentBar <= 3 Then BP1 = 0; 

            //Fundamental Quadrature 
            //Q1 = (Fundamental / 6.28)*(BP1 - BP1[1]); 
            //If CurrentBar <= 4 Then Q1 = 0;

            //Second Harmonic Band-Pass 
            //BP2 = .5*(1 - S2)*(Close - Close[2]) + L2*(1 + S2)*BP2[1] - S2* BP2[2]; 
            //If CurrentBar <= 3 Then BP2 = 0; 

            //Second Harmonic Quadrature 
            //Q2 = (Fundamental / 6.28)*(BP2 - BP2[1]); 
            //If CurrentBar <= 4 Then Q2 = 0;

            //Third Harmonic Band-Pass 
            //BP3 = .5*(1 - S3)*(Close - Close[2]) + L3*(1 + S3)*BP3[1] - S3*BP3[2]; 
            //If CurrentBar <= 3 Then BP3 = 0; 

            //Third Harmonic Quadrature 
            //Q3 = (Fundamental / 6.28)*(BP3 - BP3[1]); 
            //If CurrentBar <= 4 Then Q3 = 0;

            //Sum power of each harmonic at each bar over the Fundamental period 
            //P1 = 0; P2 = 0; P3 = 0; 
            //For count = 0 to Fundamental - 1 Begin 
            //P1 = P1 + BP1[count]*BP1[count] + Q1[count]*Q1[count];  
            //P2 = P2 + BP2[count]*BP2[count] + Q2[count]*Q2[count];  
            //P3 = P3 + BP3[count]*BP3[count] + Q3[count]*Q3[count]; 
            //End;

            //Add the three harmonics together using their relative amplitudes 
            //If P1 <> 0 Then Wave = BP1 + SquareRoot(P2 / P1)*BP2 + SquareRoot(P3 / P1)*BP3;

            //Plot1(Wave); Plot2(0);
            //{ //Optional cyclic trading signal 
            //Rate of change crosses zero at cyclic turning points 
            //ROC = (Fundamental / 12.57)*(Wave - Wave[2]); 
            //Plot3(ROC); }
            List<decimal> bp1List = new();
            List<decimal> bp2List = new();
            List<decimal> bp3List = new();
            List<decimal> q1List = new();
            List<decimal> q2List = new();
            List<decimal> q3List = new();
            List<decimal> p1List = new();
            List<decimal> p2List = new();
            List<decimal> p3List = new();
            List<decimal> waveList = new();
            List<decimal> rocList = new();
            List<Signal> signalsList = new();
            decimal bandwidth = 0.1m;

            try
            {
                decimal pi = (decimal)Math.PI;
                decimal l1 = Cos(2 * pi / days);
                decimal g1 = Cos(bandwidth * 2 * pi / days);
                decimal s1 = (1 / g1) - Sqrt((1 / (g1 * g1)) - 1);
                decimal l2 = Cos(2 * pi / ((decimal)days / 2));
                decimal g2 = Cos(bandwidth * 2 * pi / ((decimal)days / 2));
                decimal s2 = (1 / g2) - Sqrt((1 / (g2 * g2)) - 1);
                decimal l3 = Cos(2 * pi / ((decimal)days / 3));
                decimal g3 = Cos(bandwidth * 2 * pi / ((decimal)days / 3));
                decimal s3 = (1 / g3) - Sqrt((1 / (g3 * g3)) - 1);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevBp1_1 = bp1List.LastOrDefault();
                    decimal prevBp2_1 = bp2List.LastOrDefault();
                    decimal prevBp3_1 = bp3List.LastOrDefault();
                    decimal prevValue2 = i >= 2 ? stockDataClass.InputValues.ElementAtOrDefault(i - 2) : 0;
                    decimal prevBp1_2 = i >= 2 ? bp1List.ElementAtOrDefault(i - 2) : 0;
                    decimal prevBp2_2 = i >= 2 ? bp2List.ElementAtOrDefault(i - 2) : 0;
                    decimal prevBp3_2 = i >= 2 ? bp3List.ElementAtOrDefault(i - 2) : 0;
                    decimal prevWave2 = i >= 2 ? waveList.ElementAtOrDefault(i - 2) : 0;

                    decimal bp1 = i <= 3 ? 0 : (0.5m * (1 - s1) * (currentValue - prevValue2)) + (l1 * (1 + s1) * prevBp1_1) - (s1 * prevBp1_2);
                    bp1List.Add(bp1);

                    decimal q1 = i <= 4 ? 0 : (days / 6.28m) * (bp1 - prevBp1_1);
                    q1List.Add(q1);

                    decimal bp2 = i <= 3 ? 0 : (0.5m * (1 - s2) * (currentValue - prevValue2)) + (l2 * (1 + s2) * prevBp2_1) - (s2 * prevBp2_2);
                    bp2List.Add(bp2);

                    decimal q2 = i <= 4 ? 0 : (days / 6.28m) * (bp2 - prevBp2_1);
                    q2List.Add(q2);

                    decimal bp3 = i <= 3 ? 0 : (0.5m * (1 - s3) * (currentValue - prevValue2)) + (l3 * (1 + s3) * prevBp3_1) - (s3 * prevBp3_2);
                    bp3List.Add(bp3);

                    decimal q3 = i <= 4 ? 0 : (days / 6.28m) * (bp3 - prevBp3_1);
                    q3List.Add(q3);

                    decimal p1 = 0, p2 = 0, p3 = 0;
                    for (int count = 0; count <= days - 1; count++)
                    {
                        decimal prevBp1 = i >= count ? bp1List.ElementAtOrDefault(i - count) : 0;
                        decimal prevBp2 = i >= count ? bp2List.ElementAtOrDefault(i - count) : 0;
                        decimal prevBp3 = i >= count ? bp3List.ElementAtOrDefault(i - count) : 0;
                        decimal prevQ1 = i >= count ? q1List.ElementAtOrDefault(i - count) : 0;
                        decimal prevQ2 = i >= count ? q2List.ElementAtOrDefault(i - count) : 0;
                        decimal prevQ3 = i >= count ? q3List.ElementAtOrDefault(i - count) : 0;

                        p1 += (prevBp1 * prevBp1) + (prevQ1 * prevQ1);
                        p2 += (prevBp2 * prevBp2) + (prevQ2 * prevQ2);
                        p3 += (prevBp3 * prevBp3) + (prevQ3 * prevQ3);
                    }
                    p1List.Add(p1);
                    p2List.Add(p2);
                    p3List.Add(p3);

                    decimal prevWave = waveList.LastOrDefault();
                    decimal wave = p1 != 0 ? bp1 + (Sqrt(p2 / p1) * bp2) + (Sqrt(p3 / p1) * bp3) : 0;
                    waveList.Add(wave);

                    decimal roc = days / 12.57m * (wave - prevWave2);
                    rocList.Add(roc);

                    var signal = GetCompareSignal(wave, prevWave);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (bp1List, bp2List, bp3List, q1List, q2List, q3List, p1List, p2List, p3List, waveList, rocList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateEhlersVossPredictiveFilter(StockData stockDataClass, int days = 3)
        {
            // Voss Predictive Filter
            //Inputs: Period(20), Predict(3); 
            //Vars: Order(0), F1(0), G1(0), S1(0), Bandwidth(.25), count(0), SumC(0), Filt(0), Voss(0); 

            //If CurrentBar = 1 Then Begin Order = 3 * Predict; 
            //F1 = Cosine(360 / Period); 
            //G1 = Cosine(Bandwidth * 360 / Period); 
            //S1 = 1 / G1 - SquareRoot(1 / (G1 * G1) - 1); 
            //End;

            //Band Limit the input data with a wide band BandPass Filter 
            //Filt = .5*(1 - S1)*(Close - Close[2]) + F1*(1 + S1)*Filt[1] - S1*Filt[2]; 
            //If CurrentBar <= 5 Then Filt = 0; 

            //Compute Voss predictor 
            //SumC = 0; 
            //For count = 0 to Order - 1 Begin 
            //SumC = SumC + ((count + 1) / Order)*Voss[Order - count]; 
            //End; 
            //Voss = ((3 + Order) / 2)*Filt - SumC; 

            //Plot1(Filt); 
            //Plot2(Voss);
            List<decimal> filtList = new();
            List<decimal> sumCList = new();
            List<decimal> vossList = new();
            List<Signal> signalsList = new();
            decimal bandwidth = 0.25m;

            try
            {
                int period = days;
                int predict = MinOrMax((int)Math.Ceiling(period * 0.15));
                int order = MinOrMax(3 * predict);
                decimal pi = (decimal)Math.PI;
                decimal f1 = Cos(2 * pi / period);
                decimal g1 = Cos(bandwidth * 2 * pi / period);
                decimal s1 = (1 / g1) - Sqrt((1 / (g1 * g1)) - 1);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevFilt1 = i >= 1 ? filtList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevFilt2 = i >= 2 ? filtList.ElementAtOrDefault(i - 2) : 0;
                    decimal prevValue2 = i >= 2 ? stockDataClass.InputValues.ElementAtOrDefault(i - 2) : 0;

                    decimal filt = i <= 5 ? 0 : (0.5m * (1 - s1) * (currentValue - prevValue2)) + (f1 * (1 + s1) * prevFilt1) - (s1 * prevFilt2);
                    filtList.Add(filt);

                    decimal sumC = 0;
                    for (int count = 0; count <= order - 1; count++)
                    {
                        decimal prevVoss = i >= order - count ? vossList.ElementAtOrDefault(i - (order - count)) : 0;
                        sumC += ((decimal)(count + 1) / order) * prevVoss;
                    }
                    sumCList.Add(sumC);

                    decimal prevvoss = vossList.LastOrDefault();
                    decimal voss = ((decimal)(3 + order) / 2 * filt) - sumC;
                    vossList.Add(voss);

                    var signal = GetCompareSignal(voss - filt, prevvoss - prevFilt1);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (filtList, sumCList, vossList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateEhlersBetterExponentialMovingAverage(StockData stockDataClass, int days = 20)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Ehlers Better Exponential Moving Average [CC] script may be freely distributed under the MIT license.
            //study("Ehlers Better Exponential Moving Average [CC]", overlay = true)

            //inp = input(title = "Source", type = input.source, defval = close)
            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //src = security(syminfo.tickerid, res, inp[rep ? 0 : barstate.isrealtime ? 1 : 0])[rep ? 0 : barstate.isrealtime ? 0 : 1]
            //length = input(title = "Length", type = input.integer, defval = 20, minval = 1)

            //val = cos(2 * math.pi / length) + sin(2 * math.pi / length)
            //alpha = val != 0 ? (val - 1) / val : 0.01

            //ema = 0.0
            //ema:= (alpha * src) + ((1 - alpha) * nz(ema[1]))

            //bEma = 0.0
            //bEma:= (alpha * ((src + nz(src[1])) / 2)) + ((1 - alpha) * nz(ema[1]))

            //slo = src - bEma
            //sig = slo > 0 ? slo > nz(slo[1]) ? 2 : 1 : slo < 0 ? slo < nz(slo[1]) ? -2 : -1 : 0
            //alertcondition(crossover(sig, 1), "Strong Buy Signal", "Strong Bullish Change Detected")
            //alertcondition(crossunder(sig, -1), "Strong Sell Signal", "Strong Bearish Change Detected")
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //bemaColor = sig > 1 ? color.green : sig > 0 ? color.lime : sig < -1 ? color.maroon : sig < 0 ? color.red : color.black
            //barcolor(bar ? bemaColor : na)
            //plot(bEma, title = "BEMA", color = bemaColor, linewidth = 2)
            List<decimal> emaList = new();
            List<decimal> bEmaList = new();
            List<Signal> signalsList = new();

            try
            {
                decimal val = Cos(2 * Math.PI / days) + Sin(2 * Math.PI / days);
                decimal alpha = val != 0 ? MinOrMax((val - 1) / val, 0.99m, 0.01m) : 0.01m;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevEma1 = i >= 1 ? emaList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal ema = (alpha * currentValue) + ((1 - alpha) * prevEma1);
                    emaList.Add(ema);

                    decimal prevBEma = bEmaList.LastOrDefault();
                    decimal bEma = (alpha * ((currentValue + prevValue) / 2)) + ((1 - alpha) * prevEma1);
                    bEmaList.Add(bEma);

                    var signal = GetCompareSignal(currentValue - bEma, prevValue - prevBEma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (emaList, bEmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateEhlersKaufmanAdaptiveMovingAverage(StockData stockDataClass, int days = 20)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Ehlers Kaufman Adaptive Moving Average [CC] script may be freely distributed under the MIT license.
            //study("Ehlers Kaufman Adaptive Moving Average [CC]", overlay = true)

            //inp = input(title = "Source", type = input.source, defval = close)
            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //src = security(syminfo.tickerid, res, inp[rep ? 0 : barstate.isrealtime ? 1 : 0])[rep ? 0 : barstate.isrealtime ? 0 : 1]
            //length = input(title = "Length", type = input.integer, defval = 20, minval = 1)

            //deltaSum = 0.0
            //for int i = 0 to length - 1
            //    deltaSum := deltaSum + abs(nz(src[i]) - nz(src[i + 1]))
            //ef = deltaSum != 0 ? min(abs(src - nz(src[length - 1])) / deltaSum, 1) : 0
            //s = pow((0.6667 * ef) + 0.0645, 2)

            //kama = 0.0
            //kama := (s * src) + ((1 - s) * nz(kama[1]))

            //slo = src - kama
            //sig = slo > 0 ? slo > nz(slo[1]) ? 2 : 1 : slo < 0 ? slo < nz(slo[1]) ? -2 : -1 : 0
            //alertcondition(crossover(sig, 1), "Strong Buy Signal", "Strong Bullish Change Detected")
            //alertcondition(crossunder(sig, -1), "Strong Sell Signal", "Strong Bearish Change Detected")
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //kamaColor = sig > 1 ? color.green : sig > 0 ? color.lime : sig < -1 ? color.maroon : sig < 0 ? color.red : color.black
            //barcolor(bar ? kamaColor : na)
            //plot(kama, title = "Filter", color = kamaColor, linewidth = 2)
            List<decimal> kamaList = new();
            List<decimal> sList = new();
            List<Signal> signalsList = new();

            try
            {
                var efList = CalculateKaufmanAdaptiveMovingAverage(stockDataClass, days).Item3;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal ef = efList.ElementAtOrDefault(i);

                    decimal s = Pow((0.6667m * Math.Min(ef, 1)) + 0.0645m, 2);
                    sList.Add(s);

                    decimal prevKama = kamaList.LastOrDefault();
                    decimal kama = (s * currentValue) + ((1 - s) * prevKama);
                    kamaList.Add(kama);

                    var signal = GetCompareSignal(currentValue - kama, prevValue - prevKama);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (sList, kamaList, signalsList);
        }

        public static (List<decimal>, List<Signal>) CalculateEhlersAllpassPhaseShifter(StockData stockDataClass, int days = 20)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Ehlers Allpass Phase Shifter [CC] script may be freely distributed under the MIT license.
            //study("Ehlers Allpass Phase Shifter [CC]", overlay = true)

            //inp = input(title = "Source", type = input.source, defval = close)
            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //src = security(syminfo.tickerid, res, inp[rep ? 0 : barstate.isrealtime ? 1 : 0])[rep ? 0 : barstate.isrealtime ? 0 : 1]
            //length = input(title = "Length", type = input.integer, defval = 20, minval = 1)
            //qq = input(title = "QQ", type = input.float, defval = 0.5, minval = 0.01)

            //a1 = 1
            //a2 = -2 * cos(2 * math.pi / length) / qq
            //a3 = pow(1 / qq, 2)
            //b1 = 1
            //b2 = -2 * qq * cos(2 * math.pi / length)
            //b3 = qq * qq

            //phaser = 0.0
            //phaser:= (b3 * (src + (a2 * nz(src[1])) + (a3 * nz(src[2])))) - (b2 * nz(phaser[1])) - (b3 * nz(phaser[2]))

            //slo = phaser - nz(phaser[1])
            //sig = slo > 0 ? slo > nz(slo[1]) ? 2 : 1 : slo < 0 ? slo < nz(slo[1]) ? -2 : -1 : 0
            //alertcondition(crossover(sig, 1), "Strong Buy Signal", "Strong Bullish Change Detected")
            //alertcondition(crossunder(sig, -1), "Strong Sell Signal", "Strong Bearish Change Detected")
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //apsColor = sig > 1 ? color.green : sig > 0 ? color.lime : sig < -1 ? color.maroon : sig < 0 ? color.red : color.black
            //barcolor(bar ? apsColor : na)
            //plot(phaser, title = "Phaser", color = apsColor, linewidth = 2)
            List<decimal> phaserList = new();
            List<Signal> signalsList = new();

            try
            {
                decimal qq = 0.5m;
                decimal a1 = 1;
                decimal a2 = -2 * Cos(2 * Math.PI / days) / qq;
                decimal a3 = Pow(1 / qq, 2);
                decimal b1 = 1;
                decimal b2 = -2 * qq * Cos(2 * Math.PI / days);
                decimal b3 = Pow(qq, 2);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue1 = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevValue2 = i >= 2 ? stockDataClass.InputValues.ElementAtOrDefault(i - 2) : 0;
                    decimal prevPhaser1 = i >= 1 ? phaserList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevPhaser2 = i >= 2 ? phaserList.ElementAtOrDefault(i - 2) : 0;

                    decimal phaser = (b3 * (currentValue + (a2 * prevValue1) + (a3 * prevValue2))) - (b2 * prevPhaser1) - (b3 * prevPhaser2);
                    phaserList.Add(phaser);

                    var signal = GetCompareSignal(currentValue - phaser, prevValue1 - prevPhaser1);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (phaserList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>)
            CalculateEhlersChebyshevLowPassFilter(StockData stockDataClass)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Ehlers Chebyshev Low Pass Fiter [CC] script may be freely distributed under the MIT license.
            //study("Ehlers Chebyshev Low Pass Filter [CC]", overlay = true)

            //inp = input(title = "Source", type = input.source, defval = close)
            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //src = security(syminfo.tickerid, res, inp[rep ? 0 : barstate.isrealtime ? 1 : 0])[rep ? 0 : barstate.isrealtime ? 0 : 1]
            //waveNum = input(title = "WaveNum", type = input.integer, defval = -2, minval = -2, maxval = 6, step = 1)

            //v1 = 0.0, wave = 0.0
            //if waveNum == -2
            // 5 Bar Chebyshev = 10*1.414^WaveNum
            //v1:= (0.080778 * (src + (1.907 * nz(src[1])) + nz(src[2]))) + (0.293 * nz(v1[1])) - (0.063 * nz(v1[2]))
            //wave:= v1 + (0.513 * nz(v1[1])) + nz(v1[2]) + (0.451 * nz(wave[1])) - (0.481 * nz(wave[2]))

            //if waveNum == -1
            // 7 Bar Chebyshev = 10*1.414^WaveNum
            //v1:= (0.021394 * (src + (1.777 * nz(src[1])) + nz(src[2]))) + (0.731 * nz(v1[1])) - (0.166 * nz(v1[2]))
            //wave:= v1 + (0.977 * nz(v1[1])) + nz(v1[2]) + (1.008 * nz(wave[1])) - (0.561 * nz(wave[2]))

            //if waveNum == 0
            // 10 Bar Chebyshev = 10*1.414^WaveNum
            //v1:= (0.0095822 * (src + (1.572 * nz(src[1])) + nz(src[2]))) + (1.026 * nz(v1[1])) - (0.282 * nz(v1[2]))
            //wave:= v1 + (0.356 * nz(v1[1])) + nz(v1[2]) + (1.329 * nz(wave[1])) - (0.644 * nz(wave[2]))

            //if waveNum == 1
            // 14 Bar Chebyshev = 10*1.414^WaveNum
            //v1:= (0.00461 * (src + (1.192 * nz(src[1])) + nz(src[2]))) + (1.281 * nz(v1[1])) - (0.426 * nz(v1[2]))
            //wave:= v1 - (0.384 * nz(v1[1])) + nz(v1[2]) + (1.565 * nz(wave[1])) - (0.729 * nz(wave[2]))

            //if waveNum == 2
            // 20 Bar Chebyshev = 10*1.414^WaveNum 
            //v1:= (0.0026947 * (src + (0.681 * nz(src[1])) + nz(src[2]))) + (1.46 * nz(v1[1])) - (0.543 * nz(v1[2]))
            //wave:= v1 - (0.966 * nz(v1[1])) + nz(v1[2]) + (1.703 * nz(wave[1])) - (0.793 * nz(wave[2]))

            //if waveNum == 3
            // 28 Bar Chebyshev = 10*1.414^WaveNu)
            //v1:= (0.0017362 * (src + (0.012 * nz(src[1])) + nz(src[2]))) + (1.606 * nz(v1[1])) - (0.65 * nz(v1[2]))
            //wave:= v1 - (1.408 * nz(v1[1])) + nz(v1[2]) + (1.801 * nz(wave[1])) - (0.848 * nz(wave[2]))

            //if waveNum == 4
            // 40 Bar Chebyshev = 10*1.414^WaveNum
            //v1:= (0.0013738 * (src - (0.669 * nz(src[1])) + nz(src[2]))) + (1.716 * nz(v1[1])) - (0.74 * nz(v1[2]))
            //wave:= v1 - (1.685 * nz(v1[1])) + nz(v1[2]) + (1.866 * nz(wave[1])) - (0.89 * nz(wave[2]))

            //if waveNum == 5
            // 56 Bar Chebyshev = 10*1.414^WaveNum
            //v1:= (0.0010794 * (src - (1.226 * nz(src[1])) + nz(src[2]))) + (1.8 * nz(v1[1])) - (0.811 * nz(v1[2]))
            //wave:= v1 - (1.842 * nz(v1[1])) + nz(v1[2]) + (1.91 * nz(wave[1])) - (0.922 * nz(wave[2]))

            //if waveNum == 6
            //80 Bar Chebyshev = 10*1.414^WaveNum
            //v1:= (0.001705 * (src - (1.659 * nz(src[1])) + nz(src[2]))) + (1.873 * nz(v1[1])) - (0.878 * nz(v1[2]))
            //wave:= v1 - (1.957 * nz(v1[1])) + nz(v1[2]) + (1.946 * nz(wave[1])) - (0.951 * nz(wave[2]))

            //slo = wave - nz(wave[1])
            //sig = slo > 0 ? slo > nz(slo[1]) ? 2 : 1 : slo < 0 ? slo < nz(slo[1]) ? -2 : -1 : 0
            //alertcondition(crossover(sig, 1), "Strong Buy Signal", "Strong Bullish Change Detected")
            //alertcondition(crossunder(sig, -1), "Strong Sell Signal", "Strong Bearish Change Detected")
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //clpfColor = sig > 1 ? color.green : sig > 0 ? color.lime : sig < -1 ? color.maroon : sig < 0 ? color.red : color.black
            //barcolor(bar ? clpfColor : na)
            //plot(wave, title = "Wave", color = clpfColor, linewidth = 2)
            List<decimal> v1Neg2List = new();
            List<decimal> waveNeg2List = new();
            List<decimal> v1Neg1List = new();
            List<decimal> waveNeg1List = new();
            List<decimal> v10List = new();
            List<decimal> wave0List = new();
            List<decimal> v11List = new();
            List<decimal> wave1List = new();
            List<decimal> v12List = new();
            List<decimal> wave2List = new();
            List<decimal> v13List = new();
            List<decimal> wave3List = new();
            List<decimal> v14List = new();
            List<decimal> wave4List = new();
            List<decimal> v15List = new();
            List<decimal> wave5List = new();
            List<decimal> v16List = new();
            List<decimal> wave6List = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue1 = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevValue2 = i >= 2 ? stockDataClass.InputValues.ElementAtOrDefault(i - 2) : 0;
                    decimal prevV1Neg2_1 = i >= 1 ? v1Neg2List.ElementAtOrDefault(i - 1) : 0;
                    decimal prevV1Neg2_2 = i >= 2 ? v1Neg2List.ElementAtOrDefault(i - 2) : 0;
                    decimal prevWaveNeg2_1 = i >= 1 ? waveNeg2List.ElementAtOrDefault(i - 1) : 0;
                    decimal prevWaveNeg2_2 = i >= 2 ? waveNeg2List.ElementAtOrDefault(i - 2) : 0;
                    decimal prevV1Neg1_1 = i >= 1 ? v1Neg1List.ElementAtOrDefault(i - 1) : 0;
                    decimal prevV1Neg1_2 = i >= 2 ? v1Neg1List.ElementAtOrDefault(i - 2) : 0;
                    decimal prevWaveNeg1_1 = i >= 1 ? waveNeg1List.ElementAtOrDefault(i - 1) : 0;
                    decimal prevWaveNeg1_2 = i >= 2 ? waveNeg1List.ElementAtOrDefault(i - 2) : 0;
                    decimal prevV10_1 = i >= 1 ? v10List.ElementAtOrDefault(i - 1) : 0;
                    decimal prevV10_2 = i >= 2 ? v10List.ElementAtOrDefault(i - 2) : 0;
                    decimal prevWave0_1 = i >= 1 ? wave0List.ElementAtOrDefault(i - 1) : 0;
                    decimal prevWave0_2 = i >= 2 ? wave0List.ElementAtOrDefault(i - 2) : 0;
                    decimal prevV11_1 = i >= 1 ? v11List.ElementAtOrDefault(i - 1) : 0;
                    decimal prevV11_2 = i >= 2 ? v11List.ElementAtOrDefault(i - 2) : 0;
                    decimal prevWave1_1 = i >= 1 ? wave1List.ElementAtOrDefault(i - 1) : 0;
                    decimal prevWave1_2 = i >= 2 ? wave1List.ElementAtOrDefault(i - 2) : 0;
                    decimal prevV12_1 = i >= 1 ? v12List.ElementAtOrDefault(i - 1) : 0;
                    decimal prevV12_2 = i >= 2 ? v12List.ElementAtOrDefault(i - 2) : 0;
                    decimal prevWave2_1 = i >= 1 ? wave2List.ElementAtOrDefault(i - 1) : 0;
                    decimal prevWave2_2 = i >= 2 ? wave2List.ElementAtOrDefault(i - 2) : 0;
                    decimal prevV13_1 = i >= 1 ? v13List.ElementAtOrDefault(i - 1) : 0;
                    decimal prevV13_2 = i >= 2 ? v13List.ElementAtOrDefault(i - 2) : 0;
                    decimal prevWave3_1 = i >= 1 ? wave3List.ElementAtOrDefault(i - 1) : 0;
                    decimal prevWave3_2 = i >= 2 ? wave3List.ElementAtOrDefault(i - 2) : 0;
                    decimal prevV14_1 = i >= 1 ? v14List.ElementAtOrDefault(i - 1) : 0;
                    decimal prevV14_2 = i >= 2 ? v14List.ElementAtOrDefault(i - 2) : 0;
                    decimal prevWave4_1 = i >= 1 ? wave4List.ElementAtOrDefault(i - 1) : 0;
                    decimal prevWave4_2 = i >= 2 ? wave4List.ElementAtOrDefault(i - 2) : 0;
                    decimal prevV15_1 = i >= 1 ? v15List.ElementAtOrDefault(i - 1) : 0;
                    decimal prevV15_2 = i >= 2 ? v15List.ElementAtOrDefault(i - 2) : 0;
                    decimal prevWave5_1 = i >= 1 ? wave5List.ElementAtOrDefault(i - 1) : 0;
                    decimal prevWave5_2 = i >= 2 ? wave5List.ElementAtOrDefault(i - 2) : 0;
                    decimal prevV16_1 = i >= 1 ? v16List.ElementAtOrDefault(i - 1) : 0;
                    decimal prevV16_2 = i >= 2 ? v16List.ElementAtOrDefault(i - 2) : 0;
                    decimal prevWave6_1 = i >= 1 ? wave6List.ElementAtOrDefault(i - 1) : 0;
                    decimal prevWave6_2 = i >= 2 ? wave6List.ElementAtOrDefault(i - 2) : 0;

                    decimal v1Neg2 = (0.080778m * (currentValue + (1.907m * prevValue1) + prevValue2)) + (0.293m * prevV1Neg2_1) - (0.063m * prevV1Neg2_2);
                    v1Neg2List.Add(v1Neg2);

                    decimal waveNeg2 = v1Neg2 + (0.513m * prevV1Neg2_1) + prevV1Neg2_2 + (0.451m * prevWaveNeg2_1) - (0.481m * prevWaveNeg2_2);
                    waveNeg2List.Add(waveNeg2);

                    decimal v1Neg1 = (0.021394m * (currentValue + (1.777m * prevValue1) + prevValue2)) + (0.731m * prevV1Neg1_1) - (0.166m * prevV1Neg1_2);
                    v1Neg1List.Add(v1Neg1);

                    decimal waveNeg1 = v1Neg1 + (0.977m * prevV1Neg1_1) + prevV1Neg1_2 + (1.008m * prevWaveNeg1_1) - (0.561m * prevWaveNeg1_2);
                    waveNeg1List.Add(waveNeg1);

                    decimal v10 = (0.0095822m * (currentValue + (1.572m * prevValue1) + prevValue2)) + (1.026m * prevV10_1) - (0.282m * prevV10_2);
                    v10List.Add(v10);

                    decimal wave0 = v10 + (0.356m * prevV10_1) + prevV10_2 + (1.329m * prevWave0_1) - (0.644m * prevWave0_2);
                    wave0List.Add(wave0);

                    decimal v11 = (0.00461m * (currentValue + (1.192m * prevValue1) + prevValue2)) + (1.281m * prevV11_1) - (0.426m * prevV11_2);
                    v11List.Add(v11);

                    decimal wave1 = v11 - (0.384m * prevV11_1) + prevV11_2 + (1.565m * prevWave1_1) - (0.729m * prevWave1_2);
                    wave1List.Add(wave1);

                    decimal v12 = (0.0026947m * (currentValue + (0.681m * prevValue1) + prevValue2)) + (1.46m * prevV12_1) - (0.543m * prevV12_2);
                    v12List.Add(v12);

                    decimal wave2 = v12 - (0.966m * prevV12_1) + prevV12_2 + (1.703m * prevWave2_1) - (0.793m * prevWave2_2);
                    wave2List.Add(wave2);

                    decimal v13 = (0.0017362m * (currentValue + (0.012m * prevValue1) + prevValue2)) + (1.606m * prevV13_1) - (0.65m * prevV13_2);
                    v13List.Add(v13);

                    decimal wave3 = v13 - (1.408m * prevV13_1) + prevV13_2 + (1.801m * prevWave3_1) - (0.848m * prevWave3_2);
                    wave3List.Add(wave3);

                    decimal v14 = (0.0013738m * (currentValue - (0.669m * prevValue1) + prevValue2)) + (1.716m * prevV14_1) - (0.74m * prevV14_2);
                    v14List.Add(v14);

                    decimal wave4 = v14 - (1.685m * prevV14_1) + prevV14_2 + (1.866m * prevWave4_1) - (0.89m * prevWave4_2);
                    wave4List.Add(wave4);

                    decimal v15 = (0.0010794m * (currentValue - (1.226m * prevValue1) + prevValue2)) + (1.8m * prevV15_1) - (0.811m * prevV15_2);
                    v15List.Add(v15);

                    decimal wave5 = v15 - (1.842m * prevV15_1) + prevV15_2 + (1.91m * prevWave5_1) - (0.922m * prevWave5_2);
                    wave5List.Add(wave5);

                    decimal v16 = (0.001705m * (currentValue - (1.659m * prevValue1) + prevValue2)) + (1.873m * prevV16_1) - (0.878m * prevV16_2);
                    v16List.Add(v16);

                    decimal wave6 = v16 - (1.957m * prevV16_1) + prevV16_2 + (1.946m * prevWave6_1) - (0.951m * prevWave6_2);
                    wave6List.Add(wave6);

                    var signal = GetCompareSignal(currentValue - waveNeg2, prevValue1 - prevWaveNeg2_1);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                Program.ThrowExceptionInfo(ex, true, stockDataClass.Symbol, stockDataClass.Market, stockDataClass.InputName, 0).GetAwaiter().GetResult();
            }

            return (v1Neg2List, waveNeg2List, v1Neg1List, waveNeg1List, v10List, wave0List, v11List, wave1List, v12List, wave2List, v13List, wave3List, v14List,
                wave4List, v15List, wave5List, v16List, wave6List, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>)
            CalculateEhlersVariableIndexDynamicAverage(StockData stockDataClass, string maType, int days = 9)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Ehlers Variable Index Dynamic Average [CC] script may be freely distributed under the MIT license.
            //study("Ehlers Variable Index Dynamic Average [CC]", overlay = true)

            //inp = input(title = "Source", type = input.source, defval = close)
            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //src = security(syminfo.tickerid, res, inp[rep ? 0 : barstate.isrealtime ? 1 : 0])[rep ? 0 : barstate.isrealtime ? 0 : 1]
            //shortLength = input(title = "ShortLength", type = input.integer, defval = 9, minval = 1)
            //longLength = input(title = "LongLength", type = input.integer, defval = 30, minval = 1)

            //shortAvg = wma(src, shortLength)
            //shortMa = sum(pow(src - shortAvg, 2), shortLength) / shortLength
            //shortRms = shortMa > 0 ? sqrt(shortMa) : 0

            //longAvg = wma(src, longLength)
            //longMa = sum(pow(src - longAvg, 2), longLength) / longLength
            //longRms = longMa > 0 ? sqrt(longMa) : 0

            //kk = longRms != 0 ? 0.2 * shortRms / longRms : 0
            //vidya = 0.0
            //vidya:= (kk * src) + ((1 - kk) * nz(vidya[1]))

            //slo = src - vidya
            //sig = slo > 0 ? slo > nz(slo[1]) ? 2 : 1 : slo < 0 ? slo < nz(slo[1]) ? -2 : -1 : 0
            //alertcondition(crossover(sig, 1), "Strong Buy Signal", "Strong Bullish Change Detected")
            //alertcondition(crossunder(sig, -1), "Strong Sell Signal", "Strong Bearish Change Detected")
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //vidyaColor = sig > 1 ? color.green : sig > 0 ? color.lime : sig < -1 ? color.maroon : sig < 0 ? color.red : color.black
            //barcolor(bar ? vidyaColor : na)
            //plot(vidya, title = "Vidya", color = vidyaColor, linewidth = 2)
            List<decimal> vidyaList = new();
            List<decimal> kkList = new();
            List<decimal> longRmsList = new();
            List<decimal> shortRmsList = new();
            List<decimal> longPowList = new();
            List<decimal> shortPowList = new();
            List<decimal> longMaList = new();
            List<decimal> shortMaList = new();
            List<Signal> signalsList = new();

            try
            {
                int shortLength = days;
                int longLength = (int)Math.Ceiling(days / 0.3);

                var shortAvgList = GetMovingAverageList(maType, null, stockDataClass, shortLength);
                var longAvgList = GetMovingAverageList(maType, null, stockDataClass, longLength);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal shortAvg = shortAvgList.ElementAtOrDefault(i);
                    decimal longAvg = longAvgList.ElementAtOrDefault(i);

                    decimal shortPow = Pow(currentValue - shortAvg, 2);
                    shortPowList.Add(shortPow);

                    decimal shortMa = shortPowList.TakeLast(shortLength).Average();
                    shortMaList.Add(shortMa);

                    decimal shortRms = shortMa > 0 ? Sqrt(shortMa) : 0;
                    shortRmsList.Add(shortRms);

                    decimal longPow = Pow(currentValue - longAvg, 2);
                    longPowList.Add(longPow);

                    decimal longMa = longPowList.TakeLast(longLength).Average();
                    longMaList.Add(longMa);

                    decimal longRms = longMa > 0 ? Sqrt(longMa) : 0;
                    longRmsList.Add(longRms);

                    decimal kk = longRms != 0 ? MinOrMax(0.2m * shortRms / longRms, 0.99m, 0.01m) : 0;
                    kkList.Add(kk);

                    decimal prevVidya = vidyaList.LastOrDefault();
                    decimal vidya = (kk * currentValue) + ((1 - kk) * prevVidya);
                    vidyaList.Add(vidya);

                    var signal = GetCompareSignal(currentValue - vidya, prevValue - prevVidya);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (shortPowList, shortMaList, shortRmsList, longPowList, longMaList, longRmsList, kkList, vidyaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateGainLossMovingAverage(StockData stockDataClass, string maType, int days = 7)
        {
            //@version=3
            //author=cI8DH
            //study(title = "Gain/Loss Moving Average [cI8DH]", shorttitle = "GLMA [cI8DH]", precision = 4)

            //src = input(close, title = "Source")
            //MA_type = input(title = "Moving Average Type", defval = "Smoothed", options =["Simple", "Smoothed"])
            //len = input(14, minval = 1, title = "Length")

            // using avg(src[1], src) instead of src[1] makes the indicator symmetrical. Read my TRSI indicator for more info.
            //gain_loss = change(src) / nz(avg(src[1], src), 0.0000000001) * 100
            //gain_loss_MA = if MA_type == "Smoothed"
            //rma(gain_loss, len)
            //else
            //sma(gain_loss, len)
            //plot(gain_loss_MA, style = line, color = green, title = "Gain/Loss Moving Average")
            //hline(0, color =#00000033, linestyle=dotted, title="Neutral line")
            List<decimal> gainLossList = new();
            List<decimal> gainLossAvgList = new();
            List<decimal> gainLossAvgSmaList = new();
            List<Signal> signalsList = new();

            try
            {
                int signalLength = days;
                int length = days * 2;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal prevGainLoss = gainLossList.LastOrDefault();
                    decimal gainLoss = currentValue + prevValue != 0 ? (currentValue - prevValue) / ((currentValue + prevValue) / 2) * 100 : 0;
                    gainLossList.Add(gainLoss);

                    decimal factor = (decimal)1 / length;
                    decimal gainLossAvg = (gainLoss * factor) + (prevGainLoss * (1 - factor));
                    gainLossAvgList.Add(gainLossAvg);

                    decimal gainLossAvgSma = gainLossAvgList.TakeLast(signalLength).Average();
                    gainLossAvgSmaList.Add(gainLossAvgSma);
                }

                signalsList = CalculateBollingerBands(gainLossAvgList, stockDataClass, 2, maType, signalLength).Item10;
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (gainLossList, gainLossAvgList, gainLossAvgSmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateMedianAverageAdaptiveFilter(StockData stockDataClass, int days = 39)
        {
            //input = price, user defined, default is midpoint
            //th = threshold = user defined, default is .002
            //median = function, returns price at middle of period
            //prev = previous, index = current bar number

            //len = 39;
            //prevP1 = price[index - 1];
            //prevP2 = price[index - 2];
            //prevP3 = price[index - 3];
            //smth = (price + 2 * prevP1 + 2 * prevP2 + prevP3) / 6;
            //value3 = .2;
            //prevV2 = value2[index - 1];
            //while (value3 moreThan th AND len moreThan 0)
            //alpha = 2 / (len + 1);
            //value1 = median(len, smth);
            //value2 = alpha * smth + (1 - alpha) * prevV2;
            //if (value1 != 0) value3 = Math.abs(value1 - value2) / value1;
            //len = len - 2;
            //endWhile
            //if (len lessThan 3) len = 3;
            //alpha = 2 / (len + 1);
            //prevF = filt[index - 1];
            //Plot: filt = alpha * smth + (1 - alpha) * prevF;
            decimal threshold = 0.002m;
            List<decimal> filterList = new();
            List<decimal> value2List = new();
            List<decimal> value3List = new();
            List<decimal> smthList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentPrice = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevP1 = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevP2 = i >= 2 ? stockDataClass.InputValues.ElementAtOrDefault(i - 2) : 0;
                    decimal prevP3 = i >= 3 ? stockDataClass.InputValues.ElementAtOrDefault(i - 3) : 0;

                    decimal smth = (currentPrice + (2 * prevP1) + (2 * prevP2) + prevP3) / 6;
                    smthList.Add(smth);

                    int len = days;
                    decimal value3 = 0.2m, value2 = 0, prevV2 = value2List.LastOrDefault(), alpha = 0;
                    while (value3 > threshold && len > 0)
                    {
                        alpha = (decimal)2 / (len + 1);
                        decimal value1 = Median(smthList.TakeLast(len));
                        value2 = (alpha * smth) + ((1 - alpha) * prevV2);
                        value3 = value1 != 0 ? Math.Abs(value1 - value2) / value1 : 0;
                        len -= 2;
                    }
                    value2List.Add(value2);
                    value3List.Add(value3);

                    if (len < 3) len = 3;
                    alpha = (decimal)2 / (len + 1);

                    decimal prevFilter = filterList.LastOrDefault();
                    decimal filter = (alpha * smth) + ((1 - alpha) * prevFilter);
                    filterList.Add(filter);

                    var signal = GetCompareSignal(currentPrice - filter, prevP1 - prevFilter);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (value2List, value3List, filterList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>)
            CalculateEhlersSwissArmyKnifeIndicator(StockData stockDataClass, string maType, int days = 10)
        {
            //input = price, user defined, default is midpoint price
            //type = indicator, user defined, default is E-SMA
            //period = user defined, default is 20
            //delta1 = user defined, default is 0.1
            //E-EMA = indicator, type of exponential moving average
            //E-SMA = indicator, type of simple moving average
            //GAUSS = indicator, BUTTER = indicator
            //SMOOTH = indicator, HP = indicator
            //2PHP = indicator, BP = indicator
            //BS = indicator
            //index = current bar number

            //c0 = 1, c1 = 0, b0 = 1, b1 = 0, b2 = 0, a1 = 0;
            //a2 = 0, alpha = 0, beta1 = 0, gamma1 = 0;
            //n = 0;
            //if (type == "E-SMA") n = period;
            //filt = price;
            //prevP1 = price[index - 1];
            //prevP2 = price[index - 2];
            //priorP = price[index - n];
            //prevFilt1 = ifNull(price, filt[index - 1]); //feedback ingredent
            //Filt2 = ifNull(price, filt[index - 2]); //feedback ingredent
            //filt = 0;
            //twoPiPrd = (2 * Math.PI) / period;
            //if (type == "E-EMA")
            //alpha = (Math.cos(twoPiPrd) + Math.sin(twoPiPrd) - 1) / Math.cos(twoPiPrd);
            //b0 = alpha;
            //a1 = 1 - alpha;
            //endIf
            //if (type == "E-SMA")
            //c1 = 1 / n;
            //b0 = 1 / n;
            //a1 = 1;
            //endIf
            //if (type == "GAUSS")
            //beta1 = 2.451 * (1 - Math.cos(twoPiPrd));
            //alpha = -beta1 + Math.sqrt(beta1 * beta1 + 2 * beta1);
            //c0 = alpha * alpha;
            //a1 = 2 * (1 - alpha);
            //a2 = -(1 - alpha) * (1 - alpha);
            //endIf
            //if (type == "BUTTER")
            //beta1 = 2.451 * (1 - Math.cos(twoPiPrd));
            //alpha = -beta1 + Math.sqrt(beta1 * beta1 + 2 * beta1);
            //c0 = alpha * alpha / 4;
            //b1 = 2;
            //b2 = 1;
            //a1 = 2 * (1 - alpha);
            //a2 = -(1 - alpha) * (1 - alpha);
            //endif
            //if (type == "SMOOTH")
            //c0 = 1 / 4;
            //b1 = 2;
            //b2 = 1;
            //endIf
            //if (type == "HP")
            //alpha = (Math.cos(twoPiPrd) + Math.sin(twoPiPrd) - 1) / Math.cos(twoPiPrd);
            //c0 = 1 - alpha / 2;
            //b1 = -1;
            //a1 = 1 - alpha;
            //endIf
            //if (type == "2PHP")
            //beta1 = 2.451 * (1 - Math.cos(twoPiPrd));
            //alpha = -beta1 + Math.sqrt(beta1 * beta1 + 2 * beta1);
            //c0 = (1 - alpha / 2) * (1 - alpha / 2);
            //b1 = -2;
            //b2 = 1;
            //a1 = 2 * (1 - alpha);
            //a2 = -(1 - alpha) * (1 - alpha);
            //endIf
            //if (type == "BP")
            //beta1 = Math.cos(twoPiPrd);
            //gamma1 = 1 / Math.cos(720 * delta1 / period);
            //alpha = gamma1 + Math.sqrt(gamma1 * gamma1 - 1);
            //c0 = (1 - alpha) / 2;
            //b2 = -1;
            //a1 = beta1 * (1 + alpha);
            //a2 = -alpha;
            //endIf
            //if (type == "BS")
            //beta1 = Math.cos(twoPiPrd);
            //gamma1 = 1 / Math.cos(720 * delta1 / period);
            //alpha = gamma1 - Math.sqrt(gamma1 * gamma1 - 1);
            //c0 = (1 + alpha) / 2;
            //b1 = -2 * beta1;
            //b2 = 1;
            //a1 = beta1 * (1 + alpha);
            //a2 = -alpha;
            //endIf
            //Plot: filt = c0 * ((b0 * price) + (b1 * prevP1) + (b2 * prevP2) + (a1 * prevFilt1) + (a2 * prevFilt2) - (c1 * priorP));
            double delta1 = 0.1;
            List<decimal> emaFilterList = new();
            List<decimal> emaFilterSignalList = new();
            List<decimal> smaFilterList = new();
            List<decimal> smaFilterSignalList = new();
            List<decimal> gaussFilterList = new();
            List<decimal> gaussFilterSignalList = new();
            List<decimal> butterFilterList = new();
            List<decimal> butterFilterSignalList = new();
            List<decimal> smoothFilterList = new();
            List<decimal> smoothFilterSignalList = new();
            List<decimal> hpFilterList = new();
            List<decimal> hpFilterSignalList = new();
            List<decimal> php2FilterList = new();
            List<decimal> php2FilterSignalList = new();
            List<decimal> bpFilterList = new();
            List<decimal> bpFilterSignalList = new();
            List<decimal> bsFilterList = new();
            List<decimal> bsFilterSignalList = new();
            List<decimal> filterAvgList = new();
            List<decimal> filterSignalAvgList = new();
            List<Signal> signalsList = new();

            try
            {
                int signalPeriod = days;
                int length = days * 2;
                decimal twoPiPrd = (decimal)MinOrMax(2 * Math.PI / length, 0.99, 0.01);
                decimal deltaPrd = (decimal)MinOrMax(2 * Math.PI * 2 * delta1 / length, 0.99, 0.01);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevPrice1 = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevFilterAvg = i >= 1 ? filterAvgList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevPrice2 = i >= 2 ? stockDataClass.InputValues.ElementAtOrDefault(i - 2) : 0;
                    decimal prevPrice = i >= length ? stockDataClass.InputValues.ElementAtOrDefault(i - length) : 0;
                    decimal prevEmaFilter1 = emaFilterList.LastOrDefault();
                    decimal prevSmaFilter1 = smaFilterList.LastOrDefault();
                    decimal prevGaussFilter1 = gaussFilterList.LastOrDefault();
                    decimal prevButterFilter1 = butterFilterList.LastOrDefault();
                    decimal prevSmoothFilter1 = smoothFilterList.LastOrDefault();
                    decimal prevHpFilter1 = hpFilterList.LastOrDefault();
                    decimal prevPhp2Filter1 = php2FilterList.LastOrDefault();
                    decimal prevBpFilter1 = bpFilterList.LastOrDefault();
                    decimal prevBsFilter1 = bsFilterList.LastOrDefault();
                    decimal prevEmaFilter2 = i >= 2 ? emaFilterList.ElementAtOrDefault(i - 2) : 0;
                    decimal prevSmaFilter2 = i >= 2 ? smaFilterList.ElementAtOrDefault(i - 2) : 0;
                    decimal prevGaussFilter2 = i >= 2 ? gaussFilterList.ElementAtOrDefault(i - 2) : 0;
                    decimal prevButterFilter2 = i >= 2 ? butterFilterList.ElementAtOrDefault(i - 2) : 0;
                    decimal prevSmoothFilter2 = i >= 2 ? smoothFilterList.ElementAtOrDefault(i - 2) : 0;
                    decimal prevHpFilter2 = i >= 2 ? hpFilterList.ElementAtOrDefault(i - 2) : 0;
                    decimal prevPhp2Filter2 = i >= 2 ? php2FilterList.ElementAtOrDefault(i - 2) : 0;
                    decimal prevBpFilter2 = i >= 2 ? bpFilterList.ElementAtOrDefault(i - 2) : 0;
                    decimal prevBsFilter2 = i >= 2 ? bsFilterList.ElementAtOrDefault(i - 2) : 0;

                    //sma
                    //If CurrentBar <= N then Filt = Price;
                    int n = 0;
                    decimal alpha = (Cos(twoPiPrd) + Sin(twoPiPrd) - 1) / Cos(twoPiPrd), c0 = 1, c1 = 0, b0 = alpha, b1 = 0, b2 = 0, a1 = 1 - alpha, a2 = 0, beta = 0,
                        sqrtData = 0, sqrt = 0, gamma = 0;

                    decimal emaFilter = i <= length ? currentValue :
                        (c0 * ((b0 * currentValue) + (b1 * prevPrice1) + (b2 * prevPrice2))) + (a1 * prevEmaFilter1) + (a2 * prevEmaFilter2) - (c1 * prevPrice);
                    emaFilterList.Add(emaFilter);

                    //sma
                    //If CurrentBar <= N then Filt = Price;
                    n = length; c0 = 1; c1 = (decimal)1 / n; b0 = (decimal)1 / n; b1 = 0; b2 = 0; a1 = 1; a2 = 0;

                    decimal smaFilter = i <= length ? currentValue :
                        (c0 * ((b0 * currentValue) + (b1 * prevPrice1) + (b2 * prevPrice2))) + (a1 * prevSmaFilter1) + (a2 * prevSmaFilter2) - (c1 * prevPrice);
                    smaFilterList.Add(smaFilter);

                    //gauss
                    //If CurrentBar <= N then Filt = Price;
                    beta = 2.415m * (1 - Cos(twoPiPrd)); sqrtData = (beta * beta) + (2 * beta); sqrt = sqrtData >= 0 ? Sqrt(sqrtData) : 0; alpha = (-1 * beta) + sqrt;
                    c0 = alpha * alpha; c1 = 0; b0 = 1; b1 = 0; b2 = 0; a1 = 2 * (1 - alpha); a2 = -(1 - alpha) * (1 - alpha);

                    decimal gaussFilter = i <= length ? currentValue :
                        (c0 * ((b0 * currentValue) + (b1 * prevPrice1) + (b2 * prevPrice2))) + (a1 * prevGaussFilter1) + (a2 * prevGaussFilter2) - (c1 * prevPrice);
                    gaussFilterList.Add(gaussFilter);

                    //butter
                    //If CurrentBar <= N then Filt = Price;
                    beta = 2.415m * (1 - Cos(twoPiPrd)); sqrtData = (beta * beta) + (2 * beta); sqrt = sqrtData >= 0 ? Sqrt(sqrtData) : 0; alpha = (-1 * beta) + sqrt;
                    c0 = (alpha * alpha) / 4; c1 = 0; b0 = 1; b1 = 2; b2 = 1; a1 = 2 * (1 - alpha); a2 = -(1 - alpha) * (1 - alpha);

                    decimal butterFilter = i <= length ? currentValue :
                        (c0 * ((b0 * currentValue) + (b1 * prevPrice1) + (b2 * prevPrice2))) + (a1 * prevButterFilter1) + (a2 * prevButterFilter2) - (c1 * prevPrice);
                    butterFilterList.Add(butterFilter);

                    //smooth
                    c0 = (decimal)1 / 4; c1 = 0; b0 = 1; b1 = 2; b2 = 1; a1 = 0; a2 = 0;

                    decimal smoothFilter = (c0 * ((b0 * currentValue) + (b1 * prevPrice1) + (b2 * prevPrice2))) + (a1 * prevSmoothFilter1) + (a2 * prevSmoothFilter2) - (c1 * prevPrice);
                    smoothFilterList.Add(smoothFilter);

                    //hp
                    //If CurrentBar <= N then Filt = 0; 
                    alpha = (Cos(twoPiPrd) + Sin(twoPiPrd) - 1) / Cos(twoPiPrd); c0 = 1 - (alpha / 2); c1 = 0; b0 = 1; b1 = -1; b2 = 0; a1 = 1 - alpha; a2 = 0;

                    decimal hpFilter = i <= length ? 0 :
                        (c0 * ((b0 * currentValue) + (b1 * prevPrice1) + (b2 * prevPrice2))) + (a1 * prevHpFilter1) + (a2 * prevHpFilter2) - (c1 * prevPrice);
                    hpFilterList.Add(hpFilter);

                    //php2
                    //If CurrentBar <= N then Filt = 0;
                    beta = 2.415m * (1 - Cos(twoPiPrd)); sqrtData = Pow(beta, 2) + (2 * beta); sqrt = sqrtData >= 0 ? Sqrt(sqrtData) : 0;
                    alpha = (-1 * beta) + sqrt; c0 = (1 - (alpha / 2)) * (1 - (alpha / 2)); c1 = 0; b0 = 1; b1 = -2; b2 = 1; a1 = 2 * (1 - alpha); a2 = -(1 - alpha) * (1 - alpha);

                    decimal php2Filter = i <= length ? 0 :
                        (c0 * ((b0 * currentValue) + (b1 * prevPrice1) + (b2 * prevPrice2))) + (a1 * prevPhp2Filter1) + (a2 * prevPhp2Filter2) - (c1 * prevPrice);
                    php2FilterList.Add(php2Filter);

                    //bp
                    //If CurrentBar <= N then Filt = Price; 
                    beta = Cos(twoPiPrd); gamma = 1 / Cos(deltaPrd); sqrtData = Pow(gamma, 2) - 1; sqrt = sqrtData >= 0 ? Sqrt(sqrtData) : 0;
                    alpha = gamma - sqrt; c0 = (1 - alpha) / 2; c1 = 0; b0 = 1; b1 = 0; b2 = -1; a1 = beta * (1 + alpha); a2 = alpha * -1;

                    decimal bpFilter = i <= length ? currentValue :
                        (c0 * ((b0 * currentValue) + (b1 * prevPrice1) + (b2 * prevPrice2))) + (a1 * prevBpFilter1) + (a2 * prevBpFilter2) - (c1 * prevPrice);
                    bpFilterList.Add(bpFilter);

                    //bs
                    //If CurrentBar <= N then Filt = Price;
                    beta = Cos(twoPiPrd); gamma = 1 / Cos(deltaPrd); sqrtData = Pow(gamma, 2) - 1; sqrt = sqrtData >= 0 ? Sqrt(sqrtData) : 0;
                    alpha = gamma - sqrt; c0 = (1 + alpha) / 2; c1 = 0; b0 = 1; b1 = -2 * beta; b2 = 1; a1 = beta * (1 + alpha); a2 = alpha * -1;

                    decimal bsFilter = i <= length ? currentValue :
                        (c0 * ((b0 * currentValue) + (b1 * prevPrice1) + (b2 * prevPrice2))) + (a1 * prevBsFilter1) + (a2 * prevBsFilter2) - (c1 * prevPrice);
                    bsFilterList.Add(bsFilter);

                    decimal filterAvg = (emaFilter + smaFilter + gaussFilter + butterFilter + smoothFilter + hpFilter + php2Filter + bpFilter + bsFilter) / 9;
                    filterAvgList.Add(filterAvg);
                }

                emaFilterSignalList = GetMovingAverageList(maType, emaFilterList, stockDataClass, signalPeriod);
                smaFilterSignalList = GetMovingAverageList(maType, smaFilterList, stockDataClass, signalPeriod);
                gaussFilterSignalList = GetMovingAverageList(maType, gaussFilterList, stockDataClass, signalPeriod);
                butterFilterSignalList = GetMovingAverageList(maType, butterFilterList, stockDataClass, signalPeriod);
                smoothFilterSignalList = GetMovingAverageList(maType, smoothFilterList, stockDataClass, signalPeriod);
                hpFilterSignalList = GetMovingAverageList(maType, hpFilterList, stockDataClass, signalPeriod);
                php2FilterSignalList = GetMovingAverageList(maType, php2FilterList, stockDataClass, signalPeriod);
                bpFilterSignalList = GetMovingAverageList(maType, bpFilterList, stockDataClass, signalPeriod);
                bsFilterSignalList = GetMovingAverageList(maType, bsFilterList, stockDataClass, signalPeriod);
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal emaFilterSignal = emaFilterSignalList.ElementAtOrDefault(j);
                    decimal smaFilterSignal = smaFilterSignalList.ElementAtOrDefault(j);
                    decimal gaussFilterSignal = gaussFilterSignalList.ElementAtOrDefault(j);
                    decimal butterFilterSignal = butterFilterSignalList.ElementAtOrDefault(j);
                    decimal smoothFilterSignal = smoothFilterSignalList.ElementAtOrDefault(j);
                    decimal hpFilterSignal = hpFilterSignalList.ElementAtOrDefault(j);
                    decimal php2FilterSignal = php2FilterSignalList.ElementAtOrDefault(j);
                    decimal bpFilterSignal = bpFilterSignalList.ElementAtOrDefault(j);
                    decimal bsFilterSignal = bsFilterSignalList.ElementAtOrDefault(j);
                    decimal filterAvg = filterAvgList.ElementAtOrDefault(j);
                    decimal prevFilterAvg = j >= 1 ? filterAvgList.ElementAtOrDefault(j - 1) : 0;

                    decimal prevFilterSignalAvg = filterSignalAvgList.LastOrDefault();
                    decimal filterSignalAvg = (emaFilterSignal + smaFilterSignal + gaussFilterSignal + butterFilterSignal + smoothFilterSignal + hpFilterSignal + php2FilterSignal +
                        bpFilterSignal + bsFilterSignal) / 9;
                    filterSignalAvgList.Add(filterSignalAvg);

                    var signal = GetCompareSignal(filterAvg - filterSignalAvg, prevFilterAvg - prevFilterSignalAvg);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (emaFilterList, emaFilterSignalList, smaFilterList, smaFilterSignalList, gaussFilterList, gaussFilterSignalList, butterFilterList, butterFilterSignalList,
                smoothFilterList, smoothFilterSignalList, hpFilterList, hpFilterSignalList, php2FilterList, php2FilterSignalList, bpFilterList, bpFilterSignalList, bsFilterList,
                bsFilterSignalList, filterAvgList, filterSignalAvgList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateEhlersUniversalOscillator(StockData stockDataClass, int days = 9)
        {
            //
            // @author LazyBear 
            // List of all my indicators: 
            // https://docs.google.com/document/d/15AGCufJZ8CIUvwFJ9W-IKns88gkWOKBCvByMEvm5MLo/edit?usp=sharing
            //
            //study("Universal Oscillator [LazyBear]", shorttitle = "UNIOSC_LB")
            //bandedge = input(20, title = "BandEdge")
            //showHisto = input(true, type = bool, title = "Show Histogram?")
            //showMA = input(false, type = bool, title = "Show Signal?")
            //lengthMA = input(9, title = "EMA signal length")
            //enableBarColors = input(false, title = "Color Bars?")

            //whitenoise = (close - close[2]) / 2
            //a1 = exp(-1.414 * 3.14159 / bandedge)
            //b1 = 2.0 * a1 * cos(1.414 * 180 / bandedge)
            //c2 = b1
            //c3 = -a1 * a1
            //c1 = 1 - c2 - c3
            //filt = c1 * (whitenoise + nz(whitenoise[1])) / 2 + c2 * nz(filt[1]) + c3 * nz(filt[2])
            //filt1 = iff(cum(1) == 0, 0, iff(cum(1) == 2, c2 * nz(filt1[1]),
            //    iff(cum(1) == 3, c2 * nz(filt1[1]) + c3 * nz(filt1[2]), filt)))

            //pk = iff(cum(1) == 2, .0000001,
            //    iff(abs(filt1) > nz(pk[1]), abs(filt1), 0.991 * nz(pk[1])))
            //denom = iff(pk == 0, -1, pk)
            //euo = iff(denom == -1, nz(euo[1]), filt1 / pk)
            //euoMA = ema(euo, lengthMA)
            List<decimal> euoList = new();
            List<decimal> euoMaList = new();
            List<decimal> whitenoiseList = new();
            List<decimal> filtList = new();
            List<decimal> pkList = new();
            List<Signal> signalsList = new();

            try
            {
                int bandedge = MinOrMax((int)Math.Ceiling(days / 0.45));
                decimal a1 = Exp(-MinOrMax(1.414 * Math.PI / bandedge, 0.99, 0.01));
                decimal b1 = 2 * a1 * Cos(1.414 * 180 / bandedge);
                decimal c2 = b1;
                decimal c3 = (a1 * -1) * a1;
                decimal c1 = 1 - c2 - c3;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue2 = i >= 2 ? stockDataClass.InputValues.ElementAtOrDefault(i - 2) : 0;
                    decimal prevFilt2 = i >= 2 ? filtList.ElementAtOrDefault(i - 2) : 0;
                    decimal prevWhitenoise = whitenoiseList.LastOrDefault();
                    decimal prevPk = pkList.LastOrDefault();
                    decimal prevFilt1 = filtList.LastOrDefault();

                    decimal whitenoise = (currentValue - prevValue2) / 2;
                    whitenoiseList.Add(whitenoise);

                    decimal filt = (c1 * ((whitenoise + prevWhitenoise) / 2)) + (c2 * prevFilt1) + (c3 * prevFilt2);
                    filtList.Add(filt);

                    decimal pk = Math.Abs(filt) > prevPk ? Math.Abs(filt) : 0.991m * prevPk;
                    pkList.Add(pk);

                    decimal denom = pk == 0 ? -1 : pk;
                    decimal prevEuo = euoList.LastOrDefault();
                    decimal euo = denom == -1 ? prevEuo : pk != 0 ? filt / pk : 0;
                    euoList.Add(euo);

                    decimal euoMa = CalculateExponentialMovingAverage(euo, euoMaList.LastOrDefault(), days);
                    euoMaList.Add(euoMa);

                    var signal = GetCompareSignal(euo, prevEuo);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (whitenoiseList, filtList, pkList, euoList, euoMaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateDominantCycleTunedRelativeStrengthIndex(StockData stockDataClass, int days = 5)
        {
            //@version=2
            //study("Dominant Cycle Tuned Rsi")
            //----
            //Price = close
            //alpha = input(0.07, minval = 0, maxval = 1)
            //Smooth = (Price + 2 * Price[1] + 2 * Price[2] + Price[3]) / 6
            //Cycle = (1 - .5 * alpha) * (1 - .5 * alpha) * (Smooth - 2 * Smooth[1] + Smooth[2]) + 2 * (1 - alpha) * nz(Cycle[1]) - (1 - alpha) * (1 - alpha) * nz(Cycle[2])
            //Q1 = (.0962 * Cycle + .5769 * Cycle[2] - .5769 * Cycle[4] - .0962 * Cycle[6]) * (.5 + .08 * nz(InstPeriod[1]))
            //I1 = Cycle[3]
            //DeltaPhase = iff(Q1 != 0 and Q1[1] != 0, (I1 / Q1 - I1[1] / Q1[1]) / (1 + I1 * I1[1] / (Q1 * Q1[1])), na)
            //DeltaPhase:= iff(DeltaPhase < 0.1, 0.1, DeltaPhase)
            //DeltaPhase:= iff(DeltaPhase > 1.1, 1.1, DeltaPhase)
            //MedianDelta = percentile_nearest_rank(DeltaPhase, 5, 50)
            //DC = iff(MedianDelta == 0, 15, 6.28318 / MedianDelta + 0.5)
            //InstPeriod = .33 * DC + .67 * nz(InstPeriod[1])
            //Value1 = .15 * InstPeriod + .85 * nz(Value1[1])
            //----
            //P = 1 / Value1
            //ma(x)=>
            //    a = 0.
            //    a := P * x + (1 - P) * nz(a[1], x)
            //----
            //a = ma(Price > Price[1] ? abs(change(Price)) : 0)
            //b = ma(Price < Price[1] ? abs(change(Price)) : 0)
            //r = a / b
            //rsi = 100 - 100 / (r + 1)
            //----
            //css = fixnan(crossunder(rsi, 70) ? #FE2E64 : crossover(rsi,30) ? #0080FF : na)
            //plot(rsi, color = css, linewidth = 1, transp = 0)
            //hline(70, color = white)
            //hline(30, color = white)
            //bgcolor(css, transp = 75)
            List<decimal> aList = new();
            List<decimal> bList = new();
            List<decimal> rList = new();
            List<decimal> rsiList = new();
            List<Signal> signalsList = new();

            try
            {
                var v1List = CalculateEhlersAdaptiveCyberCycle(stockDataClass, days).Item10;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal v1 = v1List.ElementAtOrDefault(i);
                    decimal p = v1 != 0 ? 1 / v1 : 0.07m;
                    decimal price = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevPrice = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal aChg = price > prevPrice ? Math.Abs(price - prevPrice) : 0;
                    decimal bChg = price < prevPrice ? Math.Abs(price - prevPrice) : 0;
                    decimal prevRsi1 = i >= 1 ? rsiList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevRsi2 = i >= 2 ? rsiList.ElementAtOrDefault(i - 2) : 0;

                    decimal prevA = i >= 1 ? aList.ElementAtOrDefault(i - 1) : aChg;
                    decimal a = (p * aChg) + ((1 - p) * prevA);
                    aList.Add(a);

                    decimal prevB = i >= 1 ? bList.ElementAtOrDefault(i - 1) : bChg;
                    decimal b = (p * bChg) + ((1 - p) * prevB);
                    bList.Add(b);

                    decimal r = b != 0 ? a / b : 0;
                    rList.Add(r);

                    decimal rsi = b == 0 ? 100 : a == 0 ? 0 : MinOrMax(100 - (100 / (1 + r)), 100, 0);
                    rsiList.Add(rsi);

                    var signal = GetRsiSignal(rsi - prevRsi1, prevRsi1 - prevRsi2, rsi, prevRsi1, 70, 30);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (aList, bList, rList, rsiList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateEhlersDetrendedLeadingIndicator(StockData stockDataClass, int days = 14)
        {
            //period = user defined, default is 14
            //prev = previous, index = current bar number

            //prevHigh = high[index - 1];
            //prevLow = low[index - 1];
            //if (prevHigh moreThan high) high = prevHigh;
            //if (prevLow lessThan low) low = prevLow;
            //price = (high + low) / 2;
            //alpha = .67;
            //if (period moreThan 2) alpha = 2 / (period + 1);
            //prevEma1 = ifNull(price, ema1[index - 1]);  //returns price on first try
            //ema1 = (alpha * price) + ((1 - alpha) * prevEma1);
            //prevEma2 = ifNull(price, ema2[index - 1]);
            //ema2 = ((alpha / 2) * price) + ((1 - (alpha / 2)) * prevEma2);
            //Plot1: dsp = ema1 - ema2;
            //prevTemp = ifNull(0, temp[index - 1]);
            //temp = (alpha * dsnp) + ((1 - alpha) * prevTemp);
            //Plot2: deli = dsp - temp;
            List<decimal> deliList = new();
            List<decimal> ema1List = new();
            List<decimal> ema2List = new();
            List<decimal> dspList = new();
            List<decimal> tempList = new();
            List<Signal> signalsList = new();

            try
            {
                decimal alpha = days > 2 ? (decimal)2 / (days + 1) : 0.67m;
                decimal alpha2 = alpha / 2;

                for (int i = 0; i < stockDataClass.HighPrices.Count; i++)
                {
                    decimal prevHigh = i >= 1 ? stockDataClass.HighPrices.ElementAtOrDefault(i - 1) : 0;
                    decimal prevLow = i >= 1 ? stockDataClass.LowPrices.ElementAtOrDefault(i - 1) : 0;
                    decimal currentHigh = Math.Max(prevHigh, stockDataClass.HighPrices.ElementAtOrDefault(i));
                    decimal currentLow = Math.Min(prevLow, stockDataClass.LowPrices.ElementAtOrDefault(i));
                    decimal currentPrice = (currentHigh + currentLow) / 2;
                    decimal prevEma1 = i >= 1 ? ema1List.LastOrDefault() : currentPrice;
                    decimal prevEma2 = i >= 1 ? ema2List.LastOrDefault() : currentPrice;

                    decimal ema1 = (alpha * currentPrice) + ((1 - alpha) * prevEma1);
                    ema1List.Add(ema1);

                    decimal ema2 = (alpha2 * currentPrice) + ((1 - alpha2) * prevEma2);
                    ema2List.Add(ema2);

                    decimal dsp = ema1 - ema2;
                    dspList.Add(dsp);

                    decimal prevTemp = tempList.LastOrDefault();
                    decimal temp = (alpha * dsp) + ((1 - alpha) * prevTemp);
                    tempList.Add(temp);

                    decimal prevDeli = deliList.LastOrDefault();
                    decimal deli = dsp - temp;
                    deliList.Add(deli);

                    var signal = GetCompareSignal(deli, prevDeli);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (ema1List, ema2List, dspList, tempList, deliList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateEhlersAdaptiveCyberCycle(StockData stockDataClass, int days = 5)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Ehlers Adaptive Cyber Cycle [CC] script may be freely distributed under the MIT license.
            //study("Ehlers Adaptive Cyber Cycle [CC]", overlay = false)

            //inp = input(title = "Source", type = input.source, defval = hl2)
            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //src = security(syminfo.tickerid, res, inp[rep ? 0 : barstate.isrealtime ? 1 : 0])[rep ? 0 : barstate.isrealtime ? 0 : 1]
            //alpha = input(title = "Alpha", type = input.float, defval = 0.07, minval = 0.01, step = 0.01)
            //length = input(title = "Length", type = input.integer, defval = 5, minval = 1)

            //instPeriod = 0.0
            //smooth = (src + (2 * nz(src[1])) + (2 * nz(src[2])) + nz(src[3])) / 6
            //cycle = 0.0
            //cycle:= bar_index < 7 ? (src - (2 * nz(src[1])) + nz(src[2])) / 4 : (pow(1 - (0.5 * alpha), 2) * (smooth - (2 * nz(smooth[1])) + nz(smooth[2]))) +
            //        (2 * (1 - alpha) * nz(cycle[1])) - (pow(1 - alpha, 2) * nz(cycle[2]))

            //q1 = ((0.0962 * cycle) + (0.5769 * nz(cycle[2])) - (0.5769 * nz(cycle[4])) - (0.0962 * nz(cycle[6]))) * (0.5 + (0.08 * nz(instPeriod[1])))
            //i1 = nz(cycle[3])

            //deltaPhase = q1 != 0 and nz(q1[1]) != 0 ? ((i1 / q1) - (nz(i1[1]) / nz(q1[1]))) / (1 + ((i1 * nz(i1[1]) / (q1 * nz(q1[1]))))) : 0
            //deltaPhase:= min(max(deltaPhase, 0.1), 1.1)
            //medianDelta = percentile_nearest_rank(deltaPhase, length, 50)

            //dc = medianDelta != 0 ? (6.28318 / medianDelta) + 0.5 : 15
            //instPeriod:= (0.33 * dc) + (0.67 * nz(instPeriod[1]))

            //period = 0.0
            //period:= (0.15 * instPeriod) + (0.85 * nz(period[1]))

            //alpha2 = 2 / (period + 1)
            //adaptCycle = 0.0
            //adaptCycle:= bar_index < 7 ? (src - (2 * nz(src[1])) + nz(src[2])) / 4 : (pow(1 - (0.5 * alpha2), 2) * (smooth - (2 * nz(smooth[1])) + nz(smooth[2]))) +
            //        (2 * (1 - alpha2) * nz(adaptCycle[1])) - (pow(1 - alpha2, 2) * nz(adaptCycle[2]))
            //trigger = nz(adaptCycle[1])

            //sig = adaptCycle > trigger ? 1 : adaptCycle < trigger ? -1 : 0
            //accColor = sig > 0 ? color.green : sig < 0 ? color.red : color.black
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //barcolor(bar ? accColor : na)
            //plot(adaptCycle, title = "AdaptCycle", color = accColor, linewidth = 2)
            //plot(trigger, title = "Trigger", color = color.black, linewidth = 1)
            List<decimal> ipList = new();
            List<decimal> q1List = new();
            List<decimal> i1List = new();
            List<decimal> dp_List = new();
            List<decimal> dpList = new();
            List<decimal> md1List = new();
            List<decimal> md2List = new();
            List<decimal> dcList = new();
            List<decimal> pList = new();
            List<decimal> a1List = new();
            List<decimal> acList = new();
            List<decimal> iCycleList = new();
            List<decimal> medianDeltaList = new();
            List<Signal> signalsList = new();

            try
            {
                var ehlersCycle = CalculateEhlersCyberCycle(stockDataClass);
                var smoothList = ehlersCycle.Item1;
                var cycleList = ehlersCycle.Item2;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevCycle = i >= 1 ? cycleList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevSmooth = i >= 1 ? smoothList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevDp1 = i >= 1 ? dpList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevIp = i >= 1 ? ipList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevAc1 = i >= 1 ? acList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevI1 = i >= 1 ? i1List.ElementAtOrDefault(i - 1) : 0;
                    decimal prevQ1 = i >= 1 ? q1List.ElementAtOrDefault(i - 1) : 0;
                    decimal prevP = i >= 1 ? pList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevValue2 = i >= 2 ? stockDataClass.InputValues.ElementAtOrDefault(i - 2) : 0;
                    decimal prevSmooth2 = i >= 2 ? smoothList.ElementAtOrDefault(i - 2) : 0;
                    decimal prevCycle2 = i >= 2 ? cycleList.ElementAtOrDefault(i - 2) : 0;
                    decimal prevDp2 = i >= 2 ? dpList.ElementAtOrDefault(i - 2) : 0;
                    decimal prevAc2 = i >= 2 ? acList.ElementAtOrDefault(i - 2) : 0;
                    decimal prevValue3 = i >= 3 ? stockDataClass.InputValues.ElementAtOrDefault(i - 3) : 0;
                    decimal prevCycle3 = i >= 3 ? cycleList.ElementAtOrDefault(i - 3) : 0;
                    decimal prevDp3 = i >= 3 ? dpList.ElementAtOrDefault(i - 3) : 0;
                    decimal prevCycle4 = i >= 4 ? cycleList.ElementAtOrDefault(i - 4) : 0;
                    decimal prevDp4 = i >= 4 ? dpList.ElementAtOrDefault(i - 4) : 0;
                    decimal prevCycle6 = i >= 6 ? cycleList.ElementAtOrDefault(i - 6) : 0;
                    decimal cycle = cycleList.ElementAtOrDefault(i);
                    decimal smooth = smoothList.ElementAtOrDefault(i);

                    var exp = Math.Min(Exp(2 * cycle), decimal.MaxValue);
                    var bottom = Math.Min(exp + 1, decimal.MaxValue);
                    decimal iCycle = bottom != 0 ? (exp - 1) / bottom : 0;
                    iCycleList.Add(iCycle);

                    decimal q1 = ((0.0962m * cycle) + (0.5769m * prevCycle2) - (0.5769m * prevCycle4) - (0.0962m * prevCycle6)) * (0.5m + (0.08m * prevIp));
                    q1List.Add(q1);

                    decimal i1 = prevCycle3;
                    i1List.Add(i1);

                    decimal dp_ = q1 != 0 && prevQ1 != 0 ? ((i1 / q1) - (prevI1 / prevQ1)) / (1 + ((i1 * prevI1) / (q1 * prevQ1))) : 0;
                    dp_List.Add(dp_);

                    decimal dp = MinOrMax(dp_, 1.1m, 0.1m);
                    dpList.Add(dp);

                    decimal medianDelta = Median(dpList.TakeLast(days != 0 ? days : 5));
                    medianDeltaList.Add(medianDelta);

                    decimal md1 = (prevDp2 + prevDp3 + prevDp4) - Math.Min(prevDp2, Math.Min(prevDp3, prevDp4)) - Math.Max(prevDp2, Math.Max(prevDp2, prevDp4));
                    md1List.Add(md1);

                    decimal md2 = dp + prevDp1 + md1 - Math.Min(dp, Math.Min(prevDp1, md1)) - Math.Max(dp, Math.Max(prevDp1, md1));
                    md2List.Add(md2);

                    decimal dc = md2 == 0 ? 15 : (6.28318m / md2) + 0.5m;
                    dcList.Add(dc);

                    decimal ip = (0.33m * dc) + (0.67m * prevIp);
                    ipList.Add(ip);

                    decimal p = (0.15m * ip) + (0.85m * prevP);
                    pList.Add(p);

                    decimal a1 = 2 / (p + 1);
                    a1List.Add(a1);

                    decimal ac = i < 7 ? (currentValue - (2 * prevValue) + prevValue2) / 4 :
                        (Pow(1 - (0.5m * a1), 2) * (smooth - (2 * prevSmooth) + prevSmooth2)) + (2 * (1 - a1) * prevAc1) - (Pow(1 - a1, 2) * prevAc2);
                    acList.Add(ac);

                    var signal = GetCompareSignal(ac - prevAc1, prevAc1 - prevAc2);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (iCycleList, q1List, i1List, dp_List, dpList, md1List, md2List, dcList, ipList, pList, a1List, acList, medianDeltaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateEhlersBandPassFilter(StockData stockDataClass, int days = 20)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Ehlers BandPass Filter [CC] script may be freely distributed under the MIT license.
            //study("Ehlers BandPass Filter [CC]", overlay = false)

            //inp = input(title = "Source", type = input.source, defval = close)
            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "AllowRepainting?", type = input.bool, defval = false)
            //src = security(syminfo.tickerid, res, inp[rep ? 0 : barstate.isrealtime ? 1 : 0])[rep ? 0 : barstate.isrealtime ? 0 : 1]
            //length = input(title = "Length", type = input.integer, defval = 20, minval = 1)
            //bw = input(title = "Bandwidth", type = input.float, defval = 0.3, minval = 0.01, step = 0.01)

            //pi = 2 * asin(1)
            //twoPiPrd1 = 0.25 * bw * 2 * pi / length
            //twoPiPrd2 = 1.5 * bw * 2 * pi / length
            //beta = cos(2 * pi / length)
            //gamma = 1.0 / cos(2 * pi * bw / length)
            //alpha1 = gamma - sqrt((gamma * gamma) - 1)
            //alpha2 = (cos(twoPiPrd1) + sin(twoPiPrd1) - 1) / cos(twoPiPrd1)
            //alpha3 = (cos(twoPiPrd2) + sin(twoPiPrd2) - 1) / cos(twoPiPrd2)

            //hp = 0.0
            //hp:= ((1 + (alpha2 / 2)) * (src - nz(src[1]))) + ((1 - alpha2) * nz(hp[1]))

            //bp = 0.0
            //bp:= bar_index > 2 ? (0.5 * (1 - alpha1) * (hp - nz(hp[2]))) + (beta * (1 + alpha1) * nz(bp[1])) - (alpha1 * nz(bp[2])) : 0

            //peak = 0.0
            //peak:= 0.991 * nz(peak[1])
            //peak:= abs(bp) > peak ? abs(bp) : peak

            //signal = peak != 0 ? bp / peak : 0
            //trigger = 0.0
            //trigger:= ((1 + (alpha3 / 2)) * (signal - nz(signal[1]))) + ((1 - alpha3) * nz(trigger[1]))

            //sig = signal > 0 ? 1 : signal < 0 ? -1 : 0
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //sigColor = sig > 0 ? color.green : sig < 0 ? color.red : color.black
            //barcolor(sigColor)
            //plot(signal, title = "Signal", color = sigColor, linewidth = 2)
            //plot(trigger, title = "Trigger", color = color.black, linewidth = 1)
            double bw = 0.3;
            List<decimal> hpList = new();
            List<decimal> bpList = new();
            List<decimal> peakList = new();
            List<decimal> signalList = new();
            List<decimal> triggerList = new();
            List<Signal> signalsList = new();

            try
            {
                decimal twoPiPrd1 = (decimal)MinOrMax(0.25 * bw * 2 * Math.PI / days, 0.99, 0.01);
                decimal twoPiPrd2 = (decimal)MinOrMax(1.5 * bw * 2 * Math.PI / days, 0.99, 0.01);
                decimal beta = Cos(MinOrMax(2 * Math.PI / days, 0.99, 0.01));
                decimal gamma = 1 / Cos(MinOrMax(2 * Math.PI * bw / days, 0.99, 0.01));
                decimal alpha1 = gamma - Sqrt(Pow(gamma, 2) - 1);
                decimal alpha2 = (Cos(twoPiPrd1) + Sin(twoPiPrd1) - 1) / Cos(twoPiPrd1);
                decimal alpha3 = (Cos(twoPiPrd2) + Sin(twoPiPrd2) - 1) / Cos(twoPiPrd2);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevHp1 = i >= 1 ? hpList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevHp2 = i >= 2 ? hpList.ElementAtOrDefault(i - 2) : 0;
                    decimal prevBp1 = i >= 1 ? bpList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevBp2 = i >= 2 ? bpList.ElementAtOrDefault(i - 2) : 0;

                    decimal hp = ((1 + (alpha2 / 2)) * (currentValue - prevValue)) + ((1 - alpha2) * prevHp1);
                    hpList.Add(hp);

                    decimal bp = i > 2 ? (0.5m * (1 - alpha1) * (hp - prevHp2)) + (beta * (1 + alpha1) * prevBp1) - (alpha1 * prevBp2) : 0;
                    bpList.Add(bp);

                    decimal prevPeak = peakList.LastOrDefault();
                    decimal peak = Math.Max(0.991m * prevPeak, Math.Abs(bp));
                    peakList.Add(peak);

                    decimal prevSig = signalList.LastOrDefault();
                    decimal sig = peak != 0 ? bp / peak : 0;
                    signalList.Add(sig);

                    decimal prevTrigger = triggerList.LastOrDefault();
                    decimal trigger = ((1 + (alpha3 / 2)) * (sig - prevSig)) + ((1 - alpha3) * prevTrigger);
                    triggerList.Add(trigger);

                    var signal = GetCompareSignal(sig - trigger, prevSig - prevTrigger);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (hpList, bpList, peakList, signalList, triggerList, signalsList);
        }

        public static (List<decimal>, List<Signal>) CalculateEhlersBandPassFilterV2(StockData stockDataClass, int days = 20)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Ehlers BandPass Filter V2 [CC] script may be freely distributed under the MIT license.
            //study("Ehlers BandPass Filter V2 [CC]", overlay = false)

            //inp = input(title = "Source", type = input.source, defval = close)
            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //src = security(syminfo.tickerid, res, inp[rep ? 0 : barstate.isrealtime ? 1 : 0])[rep ? 0 : barstate.isrealtime ? 0 : 1]
            //length = input(title = "Length", type = input.integer, defval = 20, minval = 1)
            //bw = input(title = "Bandwidth", type = input.float, defval = 0.3, minval = 0.01, step = 0.01)

            //l1 = cos(2 * math.pi / length)
            //g1 = cos(bw * 2 * math.pi / length)
            //s1 = 1 / g1 - sqrt(1 / pow(g1, 2) - 1)

            //bp = 0.0
            //bp:= bar_index < 3 ? 0 : (0.5 * (1 - s1) * (src - nz(src[2]))) + (l1 * (1 + s1) * nz(bp[1])) - (s1 * nz(bp[2]))

            //sig = bp > 0 ? 1 : bp < 0 ? -1 : 0
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //bpColor = sig > 0 ? color.green : sig < 0 ? color.red : color.black
            //barcolor(bar ? bpColor : na)
            //hline(0)
            //plot(bp, title = "BP", color = bpColor, linewidth = 2)
            List<decimal> bpList = new();
            List<Signal> signalsList = new();

            try
            {
                double bw = 0.3;
                decimal l1 = Cos(MinOrMax(2 * Math.PI / days, 0.99, 0.01));
                decimal g1 = Cos(MinOrMax(bw * 2 * Math.PI / days, 0.99, 0.01));
                decimal s1 = (1 / g1) - Sqrt(1 / Pow(g1, 2) - 1);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue1 = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevValue2 = i >= 2 ? stockDataClass.InputValues.ElementAtOrDefault(i - 2) : 0;
                    decimal prevBp1 = i >= 1 ? bpList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevBp2 = i >= 2 ? bpList.ElementAtOrDefault(i - 2) : 0;

                    decimal bp = i < 3 ? 0 : (0.5m * (1 - s1) * (currentValue - prevValue2)) + (l1 * (1 + s1) * prevBp1) - (s1 * prevBp2);
                    bpList.Add(bp);

                    var signal = GetCompareSignal(bp - prevBp1, prevBp1 - prevBp2);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (bpList, signalsList);
        }

        public static (List<decimal>, List<Signal>) CalculateEhlersCycleBandPassFilter(StockData stockDataClass, int days = 20)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Ehlers Cycle BandPass Filter [CC] script may be freely distributed under the MIT license.
            //study("Ehlers Cycle BandPass Filter [CC]", overlay = false)

            //inp = input(title = "Source", type = input.source, defval = close)
            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //src = security(syminfo.tickerid, res, inp[rep ? 0 : barstate.isrealtime ? 1 : 0])[rep ? 0 : barstate.isrealtime ? 0 : 1]
            //length = input(title = "Length", type = input.integer, defval = 20, minval = 1)
            //delta = input(title = "Delta", type = input.float, defval = 0.1, minval = 0.01, step = 0.01)

            //pi = 2 * asin(1)
            //beta = cos(2 * pi / length)
            //gamma = 1 / cos(4 * pi * delta / length)
            //alpha = gamma - sqrt((gamma * gamma) - 1)

            //bp = 0.0
            //bp:= (0.5 * (1 - alpha) * (src - nz(src[2]))) + (beta * (1 + alpha) * nz(bp[1])) - (alpha * nz(bp[2]))

            //slo = bp - nz(bp[1])
            //sig = slo > 0 ? slo > nz(slo[1]) ? 2 : 1 : slo < 0 ? slo < nz(slo[1]) ? -2 : -1 : 0
            //alertcondition(crossover(sig, 1), "Strong Buy Signal", "Strong Bullish Change Detected")
            //alertcondition(crossunder(sig, -1), "Strong Sell Signal", "Strong Bearish Change Detected")
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //cbpColor = sig > 1 ? color.green : sig > 0 ? color.lime : sig < -1 ? color.maroon : sig < 0 ? color.red : color.white
            //barcolor(bar ? cbpColor : na)
            //hline(0)
            //plot(bp, title = "CBP", color = cbpColor, linewidth = 2)
            List<decimal> bpList = new();
            List<Signal> signalsList = new();

            try
            {
                double delta = 0.1;
                decimal beta = Cos(MinOrMax(2 * Math.PI / days, 0.99, 0.01));
                decimal gamma = 1 / Cos(MinOrMax(4 * Math.PI * delta / days, 0.99, 0.01));
                decimal alpha = gamma - Sqrt(Pow(gamma, 2) - 1);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue1 = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevValue2 = i >= 2 ? stockDataClass.InputValues.ElementAtOrDefault(i - 2) : 0;
                    decimal prevBp1 = i >= 1 ? bpList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevBp2 = i >= 2 ? bpList.ElementAtOrDefault(i - 2) : 0;

                    decimal bp = (0.5m * (1 - alpha) * (currentValue - prevValue2)) + (beta * (1 + alpha) * prevBp1) - (alpha * prevBp2);
                    bpList.Add(bp);

                    var signal = GetCompareSignal(bp - prevBp1, prevBp1 - prevBp2);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (bpList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateEhlersCycleAmplitude(StockData stockDataClass, int days = 5)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Ehlers Cycle Amplitude [CC] script may be freely distributed under the MIT license.
            //study("Ehlers Cycle Amplitude [CC]", overlay = false)

            //inp = input(title = "Source", type = input.source, defval = close)
            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //src = security(syminfo.tickerid, res, inp[rep ? 0 : barstate.isrealtime ? 1 : 0])[rep ? 0 : barstate.isrealtime ? 0 : 1]
            //length = input(title = "Length", type = input.integer, defval = 20, minval = 1)
            //delta = input(title = "Delta", type = input.float, defval = 0.1, minval = 0.01, step = 0.01)

            //pi = 2 * asin(1)
            //beta = cos(2 * pi / length)
            //gamma = 1 / cos(4 * pi * delta / length)
            //alpha = gamma - sqrt((gamma * gamma) - 1)

            //bp = 0.0
            //bp:= (0.5 * (1 - alpha) * (src - nz(src[2]))) + (beta * (1 + alpha) * nz(bp[1])) - (alpha * nz(bp[2]))

            //power = 0.0
            //for i = 0 to length - 1
            //    power := power + pow(nz(bp[i]), 2) + pow(nz(bp[i + (length / 4)]), 2)

            //rms = sqrt(power / length)
            //ptop = 2 * 1.414 * rms
            //trigger = nz(ptop[1])

            //sig = ptop < trigger ? 1 : ptop > trigger ? -1 : 0
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //ptopColor = sig > 0 ? color.green : sig < 0 ? color.red : color.black
            //barcolor(bar ? ptopColor : na)
            //plot(ptop, title = "PTOP", color = ptopColor, linewidth = 2)
            List<decimal> rmsList = new();
            List<decimal> powerList = new();
            List<decimal> ptopList = new();
            List<Signal> signalsList = new();

            try
            {
                int lbLength = days;
                int length = days * 4;

                var bpList = CalculateEhlersCycleBandPassFilter(stockDataClass, length).Item1;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal prevPtop1 = i >= 1 ? ptopList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevPtop2 = i >= 2 ? ptopList.ElementAtOrDefault(i - 2) : 0;

                    decimal power = 0;
                    for (int j = length; j < length; j++)
                    {
                        decimal prevBp1 = i >= j ? bpList.ElementAtOrDefault(i - j) : 0;
                        decimal prevBp2 = i >= j + lbLength ? bpList.ElementAtOrDefault(i - (j + lbLength)) : 0;
                        power += Pow(prevBp1, 2) + Pow(prevBp2, 2);
                    }
                    powerList.Add(power);

                    decimal rms = power / length >= 0 ? Sqrt(power / length) : 0;
                    rmsList.Add(rms);

                    decimal ptop = 2 * 1.414m * rms;
                    ptopList.Add(ptop);

                    var signal = GetCompareSignal(ptop - prevPtop1, prevPtop1 - prevPtop2);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (powerList, rmsList, ptopList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateEhlersZeroCrossingsDominantCycle(StockData stockDataClass, int days = 20)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Ehlers Zero Crossings Dominant Cycle [CC] script may be freely distributed under the MIT license.
            //study("Ehlers Zero Crossings Dominant Cycle [CC]", overlay = false)

            //inp = input(title = "Source", type = input.source, defval = close)
            //res = input(title = "Resolution", type = input.resolution, defval = "D")
            //rep = input(title = "AllowRepainting?", type = input.bool, defval = false)
            //src = security(syminfo.tickerid, res, inp[rep ? 0 : barstate.isrealtime ? 1 : 0])[rep ? 0 : barstate.isrealtime ? 0 : 1]
            //length = input(title = "Length", type = input.integer, defval = 20, minval = 1)
            //bw = input(title = "Bandwidth", type = input.float, defval = 0.7, minval = 0.01, step = 0.01)

            //pi = 2 * asin(1)
            //twoPiPrd1 = 0.25 * bw * 2 * pi / length
            //twoPiPrd2 = 1.5 * bw * 2 * pi / length
            //beta = cos(2 * pi / length)
            //gamma = 1.0 / cos(2 * pi * bw / length)
            //alpha1 = gamma - sqrt((gamma * gamma) - 1)
            //alpha2 = (cos(twoPiPrd1) + sin(twoPiPrd1) - 1) / cos(twoPiPrd1)
            //alpha3 = (cos(twoPiPrd2) + sin(twoPiPrd2) - 1) / cos(twoPiPrd2)

            //hp = 0.0
            //hp:= ((1 + (alpha2 / 2)) * (src - nz(src[1]))) + ((1 - alpha2) * nz(hp[1]))

            //bp = 0.0
            //bp:= bar_index > 2 ? (0.5 * (1 - alpha1) * (hp - nz(hp[2]))) + (beta * (1 + alpha1) * nz(bp[1])) - (alpha1 * nz(bp[2])) : 0

            //peak = 0.0
            //peak:= 0.991 * nz(peak[1])
            //peak:= abs(bp) > peak ? abs(bp) : peak

            //real = peak != 0 ? bp / peak : 0

            //dc = 0.0
            //dc:= nz(dc[1])
            //dc:= dc < 6 ? 6 : dc

            //counter = 0
            //counter:= counter + 1
            //if crossover(real, 0) or crossunder(real, 0)
            //    dc:= 2 * counter
            //    dc:= dc > 1.25 * nz(dc[1]) ? 1.25 * nz(dc[1]) : dc
            //    dc:= dc < 0.8 * nz(dc[1]) ? 0.8 * nz(dc[1]) : dc
            //    counter:= 0

            //sig = real > 0 ? 1 : real < 0 ? -1 : 0
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //sigColor = sig > 0 ? color.green : sig < 0 ? color.red : color.black
            //plot(real, title = "Signal", color = sigColor, linewidth = 2)
            //plot(dc, title = "DominantCycle", color = color.black, linewidth = 1)
            List<decimal> hpList = new();
            List<decimal> bpList = new();
            List<decimal> peakList = new();
            List<decimal> realList = new();
            List<decimal> dcList = new();
            List<decimal> triggerList = new();
            List<Signal> signalsList = new();

            try
            {
                double bw = 0.7;
                int counter = 0;
                decimal twoPiPrd1 = (decimal)MinOrMax(0.25 * bw * 2 * Math.PI / days, 0.99, 0.01);
                decimal twoPiPrd2 = (decimal)MinOrMax(1.5 * bw * 2 * Math.PI / days, 0.99, 0.01);
                decimal beta = Cos(MinOrMax(2 * Math.PI / days, 0.99, 0.01));
                decimal gamma = 1 / Cos(MinOrMax(2 * Math.PI * bw / days, 0.99, 0.01));
                decimal alpha1 = gamma - Sqrt(Pow(gamma, 2) - 1);
                decimal alpha2 = (Cos(twoPiPrd1) + Sin(twoPiPrd1) - 1) / Cos(twoPiPrd1);
                decimal alpha3 = (Cos(twoPiPrd2) + Sin(twoPiPrd2) - 1) / Cos(twoPiPrd2);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevHp1 = i >= 1 ? hpList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevHp2 = i >= 2 ? hpList.ElementAtOrDefault(i - 2) : 0;
                    decimal prevBp1 = i >= 1 ? bpList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevBp2 = i >= 2 ? bpList.ElementAtOrDefault(i - 2) : 0;

                    decimal hp = ((1 + (alpha2 / 2)) * (currentValue - prevValue)) + ((1 - alpha2) * prevHp1);
                    hpList.Add(hp);

                    decimal bp = i > 2 ? (0.5m * (1 - alpha1) * (hp - prevHp2)) + (beta * (1 + alpha1) * prevBp1) - (alpha1 * prevBp2) : 0;
                    bpList.Add(bp);

                    decimal prevPeak = peakList.LastOrDefault();
                    decimal peak = Math.Max(0.991m * prevPeak, Math.Abs(bp));
                    peakList.Add(peak);

                    decimal prevReal = realList.LastOrDefault();
                    decimal real = peak != 0 ? bp / peak : 0;
                    realList.Add(real);

                    decimal prevTrigger = triggerList.LastOrDefault();
                    decimal trigger = ((1 + (alpha3 / 2)) * (real - prevReal)) + ((1 - alpha3) * prevTrigger);
                    triggerList.Add(trigger);

                    decimal prevDc = dcList.LastOrDefault();
                    decimal dc = Math.Max(prevDc, 6);
                    counter += 1;
                    if ((real > 0 && prevReal <= 0) || (real < 0 && prevReal >= 0))
                    {
                        dc = MinOrMax(2 * counter, 1.25m * prevDc, 0.8m * prevDc);
                        counter = 0;
                    }
                    dcList.Add(dc);

                    var signal = GetCompareSignal(real - trigger, prevReal - prevTrigger);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (hpList, bpList, peakList, realList, triggerList, dcList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateEhlersAdaptiveBandPassFilter(StockData stockDataClass, int days = 3)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Ehlers Adaptive Bandpass Filter [CC] script may be freely distributed under the MIT license.
            //study("Ehlers Adaptive Bandpass Filter [CC]", overlay = false)

            //inp = input(title = "Source", type = input.source, defval = close)
            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //src = security(syminfo.tickerid, res, inp[rep ? 0 : barstate.isrealtime ? 1 : 0])[rep ? 0 : barstate.isrealtime ? 0 : 1]
            //hpLength = input(title = "HPLength", type = input.integer, defval = 48, minval = 1)
            //ssfLength = input(title = "SSFLength", type = input.integer, defval = 10, minval = 1)
            //avgLength = input(title = "AvgLength", type = input.integer, defval = 3, minval = 1)
            //bw = input(title = "Bandwidth", type = input.float, defval = 0.3, minval = 0.01, step = 0.01)
            //obLevel = input(title = "ObLevel", type = input.float, defval = 0.707, minval = 0.01, step = 0.01)
            //osLevel = input(title = "OsLevel", type = input.float, defval = -0.707, minval = 0.01, step = 0.01)

            //pi = 2 * asin(1)
            //twoPiPrd = 0.707 * 2 * pi / hpLength
            //a1 = (cos(twoPiPrd) + sin(twoPiPrd) - 1) / cos(twoPiPrd)
            //a2 = exp(-1.414 * pi / ssfLength)
            //b1 = 2 * a2 * cos(1.414 * pi / ssfLength)
            //c2 = b1
            //c3 = -a2 * a2
            //c1 = 1 - c2 - c3

            //hp = 0.0
            //hp:= (pow(1 - (a1 / 2), 2) * (src - (2 * nz(src[1])) + nz(src[2]))) + (2 * (1 - a1) * nz(hp[1])) - (pow(1 - a1, 2) * nz(hp[2]))

            //rfilt = 0.0
            //rfilt:= (c1 * ((hp + nz(hp[1])) / 2)) + (c2 * nz(rfilt[1])) + (c3 * nz(rfilt[2]))

            //corr = 0.0, sx = 0.0, sy = 0.0, sxx = 0.0, syy = 0.0, sxy = 0.0
            //for i = 0 to hpLength
            //    x = nz(rfilt[i])
            //    y = nz(rfilt[hpLength + i])
            //    sx := sx + x
            //    sy := sy + y
            //    sxx := sxx + (x * x)
            //    sxy := sxy + (x * y)
            //    syy := syy + (y * y)

            //    corr := ((i * sxx) - (sx * sx)) * ((i * syy) - (sy * sy)) > 0 ? ((i * sxy) - (sx * sy)) / sqrt(((i * sxx) - (sx * sx)) * ((i * syy) - (sy * sy))) : 0
            //    corr := 0.5 * (corr + 1)

            //sqSum = 0.0, r = 0.0, maxPwr = 0.0, pwr = 0.0, spx = 0.0, sp = 0.0
            //for i = ssfLength to hpLength

            //    cosPart = 0.0, sinPart = 0.0
            //    for n = avgLength to hpLength
            //        cosPart := cosPart + (nz(corr[n]) * cos(2 * pi * n / i))
            //        sinPart := sinPart + (nz(corr[n]) * sin(2 * pi * n / i))

            //    sqSum := pow(cosPart, 2) + pow(sinPart, 2)
            //    r := (0.2 * pow(sqSum, 2)) + (0.8 * nz(r[1]))
            //    maxPwr := r > maxPwr ? r : maxPwr
            //    pwr := r / maxPwr

            //    if pwr >= 0.5
            //        spx:= spx + (i * pwr)
            //        sp:= sp + pwr

            //domCyc = sp != 0 ? spx / sp : 0
            //domCyc:= min(max(domCyc, ssfLength), hpLength)

            //beta = cos(2 * pi / (0.9 * domCyc))
            //gamma = 1 / cos(2 * pi * bw / (0.9 * domCyc))
            //alpha = gamma - sqrt((gamma * gamma) - 1)

            //bp = 0.0
            //bp:= (0.5 * (1 - alpha) * (rfilt - nz(rfilt[2]))) + (beta * (1 + alpha) * nz(bp[1])) - (alpha * nz(bp[2]))

            //peak = 0.0
            //peak:= 0.991 * nz(peak[1])
            //peak:= abs(bp) > peak ? abs(bp) : peak
            //signal = peak != 0 ? bp / peak : 0

            //lead = 1.3 * ((signal + nz(signal[1]) - nz(signal[2]) - nz(signal[3])) / 4)
            //leadPeak = 0.0
            //leadPeak:= 0.93 * nz(leadPeak[1])
            //leadPeak:= abs(lead) > leadPeak ? abs(lead) : leadPeak
            //leadSignal = leadPeak != 0 ? (0.7 * lead) / leadPeak : 0
            //trigger = 0.9 * nz(leadSignal[1])

            //hline(obLevel, color = color.green)
            //hline(osLevel, color = color.red)
            //sig = leadSignal > trigger ? 1 : leadSignal < trigger ? -1 : 0
            //abpfColor = sig > 0 ? color.green : sig < 0 ? color.red : color.black
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //barcolor(bar ? abpfColor : na)
            //plot(leadSignal, title = "ABPF", color = abpfColor, linewidth = 2)
            //plot(trigger, title = "Signal", color = color.black, linewidth = 1)
            List<decimal> leadList = new();
            List<decimal> bpList = new();
            List<decimal> peakList = new();
            List<decimal> signalList = new();
            List<decimal> triggerList = new();
            List<decimal> leadPeakList = new();
            List<decimal> leadSignalList = new();
            List<Signal> signalsList = new();

            try
            {
                decimal bw = 0.3m;
                int length = (int)Math.Ceiling(days / 0.3);
                int hpLength = (int)Math.Ceiling(length / 0.2084);

                var domCycList = CalculateEhlersAutoCorrelationPeriodogram(stockDataClass, days).Item23;
                var roofingFilterList = CalculateEhlersRoofingFilter(stockDataClass, length).Item2;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal roofingFilter = roofingFilterList.ElementAtOrDefault(i);
                    decimal domCyc = MinOrMax(domCycList.ElementAtOrDefault(i), hpLength, length);
                    int cycLength = (int)Math.Ceiling(domCyc);
                    decimal beta = Cos(ToRadians(360 / 0.9m * domCyc));
                    decimal gamma = 1 / Cos(ToRadians(360 * bw / 0.9m * domCyc));
                    decimal alpha = MinOrMax(gamma - Sqrt((gamma * gamma) - 1), 0.99m, 0.01m);
                    decimal prevRoofingFilter2 = i >= 2 ? roofingFilterList.ElementAtOrDefault(i - 2) : 0;
                    decimal prevBp1 = i >= 1 ? bpList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevBp2 = i >= 2 ? bpList.ElementAtOrDefault(i - 2) : 0;
                    decimal prevSignal1 = i >= 1 ? signalList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevSignal2 = i >= 2 ? signalList.ElementAtOrDefault(i - 2) : 0;
                    decimal prevSignal3 = i >= 3 ? signalList.ElementAtOrDefault(i - 3) : 0;

                    decimal bp = i > 2 ? (0.5m * (1 - alpha) * (roofingFilter - prevRoofingFilter2)) + (beta * (1 + alpha) * prevBp1) - (alpha * prevBp2) : 0;
                    bpList.Add(bp);

                    decimal prevPeak = peakList.LastOrDefault();
                    decimal peak = Math.Max(0.991m * prevPeak, Math.Abs(bp));
                    peakList.Add(peak);

                    decimal sig = peak != 0 ? bp / peak : 0;
                    signalList.Add(sig);

                    decimal lead = 1.3m * (sig + prevSignal1 - prevSignal2 - prevSignal3) / 4;
                    leadList.Add(lead);

                    decimal prevLeadPeak = leadPeakList.LastOrDefault();
                    decimal leadPeak = Math.Max(0.93m * prevLeadPeak, Math.Abs(lead));
                    leadPeakList.Add(leadPeak);

                    decimal leadSignal = leadPeak != 0 ? 0.7m * lead / leadPeak : 0;
                    leadSignalList.Add(leadSignal);

                    decimal prevTrigger = triggerList.LastOrDefault();
                    decimal trigger = 0.9m * prevSignal1;
                    triggerList.Add(trigger);

                    var signal = GetRsiSignal(sig - trigger, prevSignal1 - prevTrigger, sig, prevSignal1, 0.707m, -0.707m);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (bpList, peakList, signalList, leadList, leadPeakList, leadSignalList, triggerList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateEhlersCyberCycle(StockData stockDataClass)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Ehlers Cyber Cycle [CC] script may be freely distributed under the MIT license.
            //study("Ehlers Cyber Cycle [CC]", overlay = false)

            //inp = input(title = "Source", type = input.source, defval = hl2)
            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //src = security(syminfo.tickerid, res, inp[rep ? 0 : barstate.isrealtime ? 1 : 0])[rep ? 0 : barstate.isrealtime ? 0 : 1]
            //alpha = input(title = "Alpha", type = input.float, defval = 0.07, minval = 0.01, step = 0.01)

            //smooth = (src + (2 * nz(src[1])) + (2 * nz(src[2])) + nz(src[3])) / 6
            //cycle = 0.0
            //cycle:= bar_index < 7 ? (src - (2 * nz(src[1])) + nz(src[2])) / 4 : (pow(1 - (0.5 * alpha), 2) * (smooth - (2 * nz(smooth[1])) + nz(smooth[2]))) +
            //        (2 * (1 - alpha) * nz(cycle[1])) - (pow(1 - alpha, 2) * nz(cycle[2]))
            //trigger = nz(cycle[1])

            //sig = cycle > trigger ? 1 : cycle < trigger ? -1 : 0
            //cciColor = sig > 0 ? color.green : sig < 0 ? color.red : color.black
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //barcolor(bar ? cciColor : na)
            //plot(cycle, title = "Cycle", color = cciColor, linewidth = 2)
            //plot(trigger, title = "Trigger", color = color.black, linewidth = 1)
            decimal alpha = 0.07m;
            List<decimal> smoothList = new();
            List<decimal> cycleList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue1 = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevValue2 = i >= 2 ? stockDataClass.InputValues.ElementAtOrDefault(i - 2) : 0;
                    decimal prevValue3 = i >= 3 ? stockDataClass.InputValues.ElementAtOrDefault(i - 3) : 0;
                    decimal prevSmooth1 = i >= 1 ? smoothList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevSmooth2 = i >= 2 ? smoothList.ElementAtOrDefault(i - 2) : 0;
                    decimal prevCycle1 = i >= 1 ? cycleList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevCycle2 = i >= 2 ? cycleList.ElementAtOrDefault(i - 2) : 0;

                    decimal smooth = (currentValue + (2 * prevValue1) + (2 * prevValue2) + prevValue3) / 6;
                    smoothList.Add(smooth);

                    decimal cycle = i < 7 ? (currentValue - (2 * prevValue1) + prevValue2) / 4 : (Pow(1 - (0.5m * alpha), 2) * (smooth - (2 * prevSmooth1) + prevSmooth2)) +
                        (2 * (1 - alpha) * prevCycle1) - (Pow(1 - alpha, 2) * prevCycle2);
                    cycleList.Add(cycle);

                    var signal = GetCompareSignal(cycle - prevCycle1, prevCycle1 - prevCycle2);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (smoothList, cycleList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateEhlersStochasticCyberCycle(StockData stockDataClass, int days = 14)
        {
            //@version=3
            // Copyright (c) 2018-present, Alex Orekhov (everget)
            // Ehlers Stochastic Cyber Cycle script may be freely distributed under the MIT license.
            //study("Ehlers Stochastic Cyber Cycle", shorttitle = "Stoch CC")

            //length = input(title = "Length", type = integer, defval = 14)
            //alpha = input(title = "Alpha", type = float, step = 0.1, defval = 0.7)
            //src = input(title = "Source", type = source, defval = close)
            //applyFilling = input(title = "Apply Ribbon Filling ?", type = bool, defval = true)

            //smooth = (src + 2 * nz(src[1]) + 2 * nz(src[2]) + nz(src[3])) / 6

            //cycle = 0.0
            //cycle:= pow(1 - alpha / 2, 2) * (smooth - 2 * nz(smooth[1]) + nz(smooth[2])) + 2 * (1 - alpha) * nz(cycle[1]) - pow(1 - alpha, 2) * nz(cycle[2])

            //maxCycle = highest(cycle, length)
            //minCycle = lowest(cycle, length)

            //stoch = maxCycle - minCycle != 0
            //     ? (cycle - minCycle) / (maxCycle - minCycle)
            //     : 0

            //stochcc = 2 * ((4 * stoch + 3 * nz(stoch[1]) + 2 * nz(stoch[2]) + nz(stoch[3])) / 10 - 0.5)
            //trigger = 0.96 * (stochcc[1] + 0.02)

            //trendColor = stochcc > trigger ? #0ebb23 : red

            //stochccColor = applyFilling ? trendColor : #3d85c6
            //triggerColor = applyFilling ? trendColor : #ff3e7d

            //stochccPlot = plot(stochcc, title = "Stoch CC", color = stochccColor, transp = 0)
            //triggerPlot = plot(trigger, title = "Trigger", color = triggerColor, transp = 0)

            //transparent = color(white, 100)

            //fillColor = applyFilling ? trendColor : transparent
            //fill(stochccPlot, triggerPlot, color = fillColor, transp = 70)

            //obosLevel = 0.5

            //hline(obosLevel, title = "Overbought Level", linestyle = dotted, color =#e69138)
            //hline(0, title = "Zero Level", linestyle = dotted)
            //hline(-obosLevel, title = "Oversold Level", linestyle = dotted, color =#e69138)
            List<decimal> maxCycleList = new();
            List<decimal> minCycleList = new();
            List<decimal> stochList = new();
            List<decimal> stochCCList = new();
            List<decimal> triggerList = new();
            List<Signal> signalsList = new();

            try
            {
                List<decimal> cyberCycleList = CalculateEhlersCyberCycle(stockDataClass).Item1;
                var minMaxList = GetMaxAndMinValuesList(cyberCycleList, days);
                maxCycleList = minMaxList.Item1;
                minCycleList = minMaxList.Item2;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal prevStoch1 = i >= 1 ? stochList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevStoch2 = i >= 2 ? stochList.ElementAtOrDefault(i - 2) : 0;
                    decimal prevStoch3 = i >= 3 ? stochList.ElementAtOrDefault(i - 3) : 0;
                    decimal cycle = cyberCycleList.ElementAtOrDefault(i);
                    decimal maxCycle = maxCycleList.ElementAtOrDefault(i);
                    decimal minCycle = minCycleList.ElementAtOrDefault(i);

                    decimal stoch = maxCycle - minCycle != 0 ? MinOrMax((cycle - minCycle) / (maxCycle - minCycle), 1, 0) : 0;
                    stochList.Add(stoch);

                    decimal prevStochCC = stochCCList.LastOrDefault();
                    decimal stochCC = MinOrMax(2 * ((((4 * stoch) + (3 * prevStoch1) + (2 * prevStoch2) + prevStoch3) / 10) - 0.5m), 1, -1);
                    stochCCList.Add(stochCC);

                    decimal prevTrigger = triggerList.LastOrDefault();
                    decimal trigger = MinOrMax(0.96m * (prevStochCC + 0.02m), 1, -1);
                    triggerList.Add(trigger);

                    var signal = GetRsiSignal(stochCC - trigger, prevStochCC - prevTrigger, stochCC, prevStochCC, 0.5m, -0.5m);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (maxCycleList, minCycleList, stochList, stochCCList, triggerList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateEhlersFMDemodulatorIndicator(StockData stockDataClass, string maType, int days = 10)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Ehlers FM Demodulator Indicator [CC] script may be freely distributed under the MIT license.
            //study("Ehlers FM Demodulator Indicator [CC]", shorttitle = "EFMDI", overlay = false)

            //f_security(_symbol, _res, _src, _repaint) => 
            //    security(_symbol, _res, _src[_repaint ? 0 : barstate.isrealtime ? 1 : 0])[_repaint ? 0 : barstate.isrealtime ? 0 : 1]

            //length1 = input(title = "Length1", type = input.integer, defval = 10, minval = 1)
            //length2 = input(title = "Length2", type = input.integer, defval = 30, minval = 1)
            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //c = f_security(syminfo.tickerid, res, close, rep)
            //o = f_security(syminfo.tickerid, res, open, rep)

            //der = c - o
            //hl = length1 * der
            //hl:= max(min(hl, 1), -1)

            //pi = 2 * asin(1)
            //a1 = exp(-1.414 * pi / length2)
            //b1 = 2 * a1 * cos(1.414 * pi / length2)
            //c2 = b1
            //c3 = -a1 * a1
            //c1 = 1 - c2 - c3

            //ss = 0.0
            //ss:= (c1 * (hl + nz(hl[1], hl) / 2)) + (c2 * nz(ss[1], ss)) + (c3 * nz(ss[2], ss))
            //ss:= bar_index < 3 ? der : ss

            //sig = ss > 0 ? 1 : ss < 0 ? -1 : 0
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //fmdiColor = sig > 0 ? color.green : sig < 0 ? color.red : color.black
            //barcolor(bar ? fmdiColor : na)
            //plot(ss, title = "EFMDI", color = fmdiColor, linewidth = 2)
            List<decimal> hlRawList = new();
            List<decimal> hlList = new();
            List<decimal> ssList = new();
            List<Signal> signalsList = new();

            try
            {
                int length1 = days;
                int length2 = days * 3;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentClose = stockDataClass.ClosePrices.ElementAtOrDefault(i);
                    decimal currentOpen = stockDataClass.OpenPrices.ElementAtOrDefault(i);
                    decimal der = currentClose - currentOpen;

                    decimal hlRaw = length1 * der;
                    hlRawList.Add(hlRaw);

                    decimal hl = MinOrMax(hlRaw, 1, -1);
                    hlList.Add(hl);
                }

                ssList = GetMovingAverageList(maType, hlList, stockDataClass, length2);
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal ss = ssList.ElementAtOrDefault(j);
                    decimal prevSs = j >= 1 ? ssList.ElementAtOrDefault(j - 1) : 0;

                    var signal = GetCompareSignal(ss, prevSs);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (hlRawList, hlList, ssList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateEhlersStochastic(StockData stockDataClass, string maType, int days = 10)
        {
            //@version=3
            // Copyright (c) 2018-present, Alex Orekhov (everget)
            // Ehlers Stochastic script may be freely distributed under the MIT license.
            //study("Ehlers Stochastic", shorttitle = "EStoch")

            //highpassLength = input(title = "High-Pass Filter Length", type = integer, defval = 48)
            //stochLength = input(title = "Stochastic Length", type = integer, defval = 20)
            //ssfLength = input(title = "Super Smoother Filter Length", type = integer, defval = 10)
            //numberOfPoles = input(title = "Super Smoother Filter Poles", type = integer, defval = 2, options =[2, 3])
            //obLevel = input(title = "Overbought Level", type = float, defval = 0.8, step = 0.1)
            //osLevel = input(title = "Oversold Level", type = float, defval = 0.2, step = 0.1)
            //src = input(title = "Source", type = source, defval = close)
            //highlightBreakouts = input(title = "Highlight Overbought/Oversold Breakouts ?", type = bool, defval = true)

            //PI = 2 * asin(1)

            //_ssf2(src, length) =>
            //    arg = sqrt(2) * PI / length
            //    a1 = exp(-arg)
            //    b1 = 2 * a1 * cos(arg)
            //    c2 = b1
            //    c3 = -pow(a1, 2)
            //    c1 = 1 - c2 - c3

            //    ssf = 0.0
            //    ssf:= c1 * src + c2 * nz(ssf[1]) + c3 * nz(ssf[2])

            //_ssf3(src, length) =>
            //    arg = PI / length
            //    a1 = exp(-arg)
            //    b1 = 2 * a1 * cos(1.738 * arg)
            //    c1 = pow(a1, 2)

            //    coef2 = b1 + c1
            //    coef3 = -(c1 + b1 * c1)
            //    coef4 = pow(c1, 2)
            //    coef1 = 1 - coef2 - coef3 - coef4

            //    ssf = 0.0
            //    ssf:= coef1 * src + coef2 * nz(ssf[1]) + coef3 * nz(ssf[2]) + coef4 * nz(ssf[3])

            //_rf(src, highpassLength, ssfLength, numberOfPoles) =>
            //    alphaArg = 2 * PI / (highpassLength * sqrt(2))

            //    alpha = 0.0
            //    alpha:= cos(alphaArg) != 0
            //        ? (cos(alphaArg) + sin(alphaArg) - 1) / cos(alphaArg)
            //        : nz(alpha[1])

            //    highpass = 0.0
            //    highpass:= pow(1 - (alpha / 2), 2) * (src - 2 * nz(src[1]) + nz(src[2])) + 2 * (1 - alpha) * nz(highpass[1]) - pow(1 - alpha, 2) * nz(highpass[2])
            //    arg = (highpass + nz(highpass[1])) / 2

            //    numberOfPoles == 2
            //         ? _ssf2(arg, ssfLength)
            //         : _ssf3(arg, ssfLength)

            //_stoch(rf, stochLength, ssfLength, numberOfPoles) =>
            //    estoch = fixnan(stoch(rf, rf, rf, stochLength) / 100)
            //    estoch:= na(estoch) ? 0 : estoch

            //    arg = (estoch + nz(estoch[1])) / 2

            //    numberOfPoles == 2
            //         ? _ssf2(arg, ssfLength)
            //         : _ssf3(arg, ssfLength)

            //erf = _rf(src, highpassLength, ssfLength, numberOfPoles)
            //estoch = _stoch(erf, stochLength, ssfLength, numberOfPoles)

            //estochColor = estoch > obLevel ? #0ebb23 : estoch < osLevel ? red : #f4b77d
            //plot(estoch, title = "EStoch", linewidth = 2, color = estochColor, transp = 0)

            //transparent = color(white, 100)

            //maxLevelPlot = hline(1, title = "Max Level", linestyle = dotted, color = transparent)
            //obLevelPlot = hline(obLevel, title = "Overbought Level", linestyle = dotted)
            //hline(0.5, title = "Middle Level", linestyle = dotted)
            //osLevelPlot = hline(osLevel, title = "Oversold Level", linestyle = dotted)
            //minLevelPlot = hline(0, title = "Min Level", linestyle = dotted, color = transparent)

            //fill(obLevelPlot, osLevelPlot, color = purple, transp = 95)

            //obFillColor = estoch > obLevel and highlightBreakouts ? green: transparent
            //osFillColor = estoch < osLevel and highlightBreakouts ? red: transparent

            //fill(maxLevelPlot, obLevelPlot, color = obFillColor, transp = 90)
            //fill(minLevelPlot, osLevelPlot, color = osFillColor, transp = 90)
            List<decimal> temp2PoleList = new();
            List<decimal> max2PoleList = new();
            List<decimal> min2PoleList = new();
            List<decimal> stoch2PoleList = new();
            List<decimal> arg2PoleList = new();
            List<decimal> estoch2PoleList = new();
            List<Signal> signalsList = new();

            try
            {
                int stochLength = MinOrMax(days * 2);

                List<decimal> roofingFilter2PoleList = CalculateEhlersRoofingFilterV2(stockDataClass, maType, days).Item3;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal rf2Pole = roofingFilter2PoleList.ElementAtOrDefault(i);
                    temp2PoleList.Add(rf2Pole);

                    var list = temp2PoleList.TakeLast(stochLength).ToList();
                    decimal max2Pole = list.Max();
                    max2PoleList.Add(max2Pole);

                    decimal min2Pole = list.Min();
                    min2PoleList.Add(min2Pole);

                    decimal prevStoch2Pole = stoch2PoleList.LastOrDefault();
                    decimal stoch2Pole = max2Pole - min2Pole != 0 ? MinOrMax((rf2Pole - min2Pole) / (max2Pole - min2Pole), 1, 0) : 0;
                    stoch2PoleList.Add(stoch2Pole);

                    decimal arg2Pole = (stoch2Pole + prevStoch2Pole) / 2;
                    arg2PoleList.Add(arg2Pole);
                }

                estoch2PoleList = GetMovingAverageList(maType, arg2PoleList, stockDataClass, days);
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal estoch2Pole = estoch2PoleList.ElementAtOrDefault(j);
                    decimal prevEstoch2Pole1 = j >= 1 ? estoch2PoleList.ElementAtOrDefault(j - 1) : 0;
                    decimal prevEstoch2Pole2 = j >= 2 ? estoch2PoleList.ElementAtOrDefault(j - 2) : 0;

                    var signal = GetRsiSignal(estoch2Pole - prevEstoch2Pole1, prevEstoch2Pole1 - prevEstoch2Pole2, estoch2Pole, prevEstoch2Pole1, 0.8m, 0.2m);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (max2PoleList, min2PoleList, stoch2PoleList, arg2PoleList, estoch2PoleList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateEhlersTripleDelayLineDetrender(StockData stockDataClass, string maType, int days)
        {
            //@version=3
            // Copyright (c) 2019-present, Alex Orekhov (everget)
            // Ehlers Triple Delay-Line Detrender script may be freely distributed under the MIT license.
            //study("Ehlers Triple Delay-Line Detrender", shorttitle = "TDLD")

            //src = input(title = "Source", type = source, defval = hl2)
            //showSignal = input(title = "Show Signal Line ?", type = bool, defval = true)
            //showHistogram = input(title = "Show Histogram ?", type = bool, defval = false)
            //highlightCrossovers = input(title = "Highlight Signal Crossovers ?", type = bool, defval = true)
            //highlightZeroCrossovers = input(title = "Highlight Zero Line Crossovers ?", type = bool, defval = false)
            //applyFilling = input(title = "Apply Ribbon Filling ?", type = bool, defval = false)

            //tmp1 = 0.0
            //tmp1:= src + .088 * nz(tmp1[6])

            //tmp2 = 0.0
            //tmp2:= tmp1 - nz(tmp1[6]) + 1.2 * nz(tmp2[6]) - 0.7 * nz(tmp2[12])

            //detrender = nz(tmp2[12]) - 2 * nz(tmp2[6]) + tmp2

            //_moef(src) =>
            //    src1 = nz(src[1], src)
            //    src2 = nz(src[2], src1)
            //    src3 = nz(src[3], src2)


            //    moef = src
            //    moef:= 0.13785 * (2 * src - src1) +
            //            0.0007 * (2 * src1 - src2) +
            //            0.13785 * (2 * src2 - src3) +
            //            1.2103 * nz(moef[1], moef) -
            //            0.4867 * nz(moef[2], moef)
            //    moef

            //tdld = _moef(detrender)
            //signal = _moef(tdld)

            //hist = tdld - signal
            //histColor = hist >= 0 ? (hist[1] < hist ? #26a69a : #b2dfdb) : (hist[1] < hist ? #ffcdd2 : #ef5350)
            //plot(showHistogram ? hist : na, title = "Histogram", style = columns, color = histColor, transp = 0)
            //hline(0, title = "Zero Level", linestyle = dotted)

            //trendColor = tdld > signal ? #0ebb23 : red

            //tdldColor = applyFilling ? trendColor : (tdld > 0 ? #0ebb23 : red)
            //signalColor = applyFilling ? trendColor : #ff9800

            //tdldPlot = plot(tdld, title = "TDLD", linewidth = 2, color = tdldColor, transp = 0)
            //signalPlot = plot(showSignal ? signal : na, title = "Signal", color = signalColor, transp = 0)

            //transparent = color(white, 100)

            //fillColor = applyFilling ? trendColor : transparent
            //fill(tdldPlot, signalPlot, color = fillColor, transp = 70)

            //zeroCrossBgColor = highlightZeroCrossovers ? (tdld > 0 ? green : red) : transparent
            //bgcolor(zeroCrossBgColor, transp = 80)

            //plotshape(highlightCrossovers and crossover(tdld, signal) ? avg(tdld, tdld[1]) : na, title = "Crossover", location = location.absolute, style = shape.circle, size = size.tiny, color = green, transp = 0)
            //plotshape(highlightCrossovers and crossunder(tdld, signal) ? avg(tdld, tdld[1]) : na, title = "Crossunder", location = location.absolute, style = shape.circle, size = size.tiny, color = red, transp = 0)
            List<decimal> tmp1List = new();
            List<decimal> tmp2List = new();
            List<decimal> detrenderList = new();
            List<decimal> tdldList = new();
            List<decimal> tdldSignalList = new();
            List<decimal> histList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevTmp1_6 = i >= 6 ? tmp1List.ElementAtOrDefault(i - 6) : 0;
                    decimal prevTmp2_6 = i >= 6 ? tmp2List.ElementAtOrDefault(i - 6) : 0;
                    decimal prevTmp2_12 = i >= 12 ? tmp2List.ElementAtOrDefault(i - 12) : 0;

                    decimal tmp1 = currentValue + (0.088m * prevTmp1_6);
                    tmp1List.Add(tmp1);

                    decimal tmp2 = tmp1 - prevTmp1_6 + (1.2m * prevTmp2_6) - (0.7m * prevTmp2_12);
                    tmp2List.Add(tmp2);

                    decimal detrender = prevTmp2_12 - (2 * prevTmp2_6) + tmp2;
                    detrenderList.Add(detrender);
                }

                tdldList = GetMovingAverageList(maType, detrenderList, stockDataClass, days);
                tdldSignalList = GetMovingAverageList(maType, tdldList, stockDataClass, days);
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal tdld = tdldList.ElementAtOrDefault(j);
                    decimal tdldSignal = tdldSignalList.ElementAtOrDefault(j);

                    decimal prevHist = histList.LastOrDefault();
                    decimal hist = tdld - tdldSignal;
                    histList.Add(hist);

                    var signal = GetCompareSignal(hist, prevHist);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (tmp1List, tmp2List, detrenderList, tdldList, tdldSignalList, histList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateEhlersAMDetector(StockData stockDataClass, string maType, int days = 4)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Ehlers AM Detector [CC] script may be freely distributed under the MIT license.
            //study("Ehlers AM Detector [CC]", shorttitle = "EAMD", overlay = false)

            //f_security(_symbol, _res, _src, _repaint) => 
            //    security(_symbol, _res, _src[_repaint ? 0 : barstate.isrealtime ? 1 : 0])[_repaint ? 0 : barstate.isrealtime ? 0 : 1]

            //length1 = input(title = "Length1", type = input.integer, defval = 4, minval = 1)
            //length2 = input(title = "Length2", type = input.integer, defval = 8, minval = 1)
            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //c = f_security(syminfo.tickerid, res, close, rep)
            //o = f_security(syminfo.tickerid, res, open, rep)

            //der = c - o
            //env = highest(abs(der), length1)
            //vol = sma(env, length2)
            //bSig = sma(c, length2)

            //sig = c > bSig ? 1 : c < bSig ? -1 : 0
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //amdColor = sig > 0 ? color.green : sig < 0 ? color.red : color.black
            //barcolor(bar ? amdColor : na)
            //plot(vol, title = "EAMD", color = amdColor, linewidth = 2)
            List<decimal> absDerList = new();
            List<decimal> envList = new();
            List<decimal> volList = new();
            List<decimal> volEmaList = new();
            List<Signal> signalsList = new();

            try
            {
                int length1 = days;
                int length2 = days * 2;

                for (int i = 0; i < stockDataClass.ClosePrices.Count; i++)
                {
                    decimal currentClose = stockDataClass.ClosePrices.ElementAtOrDefault(i);
                    decimal currentOpen = stockDataClass.OpenPrices.ElementAtOrDefault(i);
                    decimal der = currentClose - currentOpen;

                    decimal absDer = Math.Abs(der);
                    absDerList.Add(absDer);

                    decimal env = absDerList.TakeLast(length1).Max();
                    envList.Add(env);
                }

                volList = GetMovingAverageList(maType, envList, stockDataClass, length2);
                volEmaList = GetMovingAverageList(maType, volList, stockDataClass, length1);
                var emaList = GetMovingAverageList(maType, null, stockDataClass, length1);
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal vol = volList.ElementAtOrDefault(j);
                    decimal volEma = volEmaList.ElementAtOrDefault(j);
                    decimal ema = emaList.ElementAtOrDefault(j);
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(j);
                    decimal prevValue = j >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(j - 1) : 0;
                    decimal prevEma = j >= 1 ? emaList.ElementAtOrDefault(j - 1) : 0;

                    var signal = GetVolatilitySignal(currentValue - ema, prevValue - prevEma, vol, volEma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (envList, volList, volEmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateEhlersSineWaveIndicator(StockData stockDataClass)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Ehlers Sinewave Indicator V1 [CC] script may be freely distributed under the MIT license.
            //study("Ehlers Sinewave Indicator V1 [CC]", overlay = false)

            //inp = input(title = "Source", type = input.source, defval = hl2)
            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //src = security(syminfo.tickerid, res, inp[rep ? 0 : barstate.isrealtime ? 1 : 0])[rep ? 0 : barstate.isrealtime ? 0 : 1]

            //pi = 2 * asin(1)
            //period = 0.0
            //smooth = ((4 * src) + (3 * nz(src[1])) + (2 * nz(src[2])) + nz(src[3])) / 10
            //detrender = ((0.0962 * smooth) + (0.5769 * nz(smooth[2])) - (0.5769 * nz(smooth[4])) - (0.0962 * nz(smooth[6]))) * ((0.075 * nz(period[1])) + 0.54)

            //q1 = ((0.0962 * detrender) + (0.5769 * nz(detrender[2])) - (0.5769 * nz(detrender[4])) - (0.0962 * nz(detrender[6]))) * ((0.075 * nz(period[1])) + 0.54)
            //i1 = nz(detrender[3])

            //jI = ((0.0962 * i1) + (0.5769 * nz(i1[2])) - (0.5769 * nz(i1[4])) - (0.0962 * nz(i1[6]))) * ((0.075 * nz(period[1])) + 0.54)
            //jQ = ((0.0962 * q1) + (0.5769 * nz(q1[2])) - (0.5769 * nz(q1[4])) - (0.0962 * nz(q1[6]))) * ((0.075 * nz(period[1])) + 0.54)

            //i2 = i1 - jQ
            //i2:= (0.2 * i2) + (0.8 * nz(i2[1]))
            //q2 = q1 + jI
            //q2:= (0.2 * q2) + (0.8 * nz(q2[1]))

            //re = (i2 * nz(i2[1])) + (q2 * nz(q2[1]))
            //re:= (0.2 * re) + (0.8 * nz(re[1]))
            //im = (i2 * nz(q2[1])) - (q2 * nz(i2[1]))
            //im:= (0.2 * im) + (0.8 * nz(im[1]))

            //period:= im != 0 and re != 0 ? 2 * pi / atan(im / re) : 0
            //period:= min(max(period, 0.67 * nz(period[1])), 1.5 * nz(period[1]))
            //period:= min(max(period, 6), 50)
            //period:= (0.2 * period) + (0.8 * nz(period[1]))

            //smoothPeriod = 0.0
            //smoothPeriod:= (0.33 * period) + (0.67 * nz(smoothPeriod[1]))

            //dcPeriod = ceil(smoothPeriod + 0.5), real = 0.0, imag = 0.0
            //for i = 0 to dcPeriod - 1
            //    real := real + (sin(2 * pi * i / dcPeriod) * nz(smooth[i]))
            //    imag := imag + (cos(2 * pi * i / dcPeriod) * nz(smooth[i]))

            //dcPhase = abs(imag) > 0.001 ? atan(real / imag) : dcPhase + ((pi / 2) * sign(real))
            //dcPhase := dcPhase + (pi / 2)
            //dcPhase := dcPhase + (2 * pi / smoothPeriod)
            //dcPhase := imag < 0 ? dcPhase + pi : dcPhase
            //dcPhase := dcPhase > 5.498 ? dcPhase - (2 * pi) : dcPhase

            //sine = sin(dcPhase)
            //leadSine = sin(dcPhase + (pi / 4))

            //sig = src > smooth ? 1 : src < smooth ? -1 : 0
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //swColor = sig > 0 ? color.green : sig < 0 ? color.red : color.black
            //barcolor(bar ? swColor : na)
            //plot(0, title = "Signal", color = swColor, linewidth = 2)
            //plot(sine, title = "Sine", color = color.blue, linewidth = 2)
            //plot(leadSine, title = "LeadSine", color = color.red, linewidth = 2)
            List<decimal> imagPartList = new();
            List<decimal> realPartList = new();
            List<decimal> sineList = new();
            List<decimal> leadSineList = new();
            List<decimal> dcPhaseList = new();
            List<Signal> signalsList = new();

            try
            {
                var ehlersMamaList = CalculateEhlersMotherOfAdaptiveMovingAverages(stockDataClass);
                var spList = ehlersMamaList.Item12;
                var smoothList = ehlersMamaList.Item1;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal sp = spList.ElementAtOrDefault(i);
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);

                    int dcPeriod = (int)Math.Ceiling(sp + 0.5m);
                    decimal realPart = 0, imagPart = 0;
                    for (int j = 0; j <= dcPeriod - 1; j++)
                    {
                        decimal prevSmooth = i >= j ? smoothList.ElementAtOrDefault(i - j) : 0;

                        realPart += Sin(MinOrMax(2 * Math.PI * j / dcPeriod, 0.99, 0.01)) * prevSmooth;
                        imagPart += Cos(MinOrMax(2 * Math.PI * j / dcPeriod, 0.99, 0.01)) * prevSmooth;
                    }
                    realPartList.Add(realPart);
                    imagPartList.Add(imagPart);

                    decimal dcPhase = Math.Abs(imagPart) > 0.001m ? ToDegrees(Atan(realPart / imagPart)) : 90 * Math.Sign(realPart);
                    dcPhase += 90;
                    dcPhase += 360 / sp;
                    dcPhase += imagPart < 0 ? 180 : 0;
                    dcPhase -= dcPhase > 315 ? 360 : 0;
                    dcPhaseList.Add(dcPhase);

                    decimal prevSine = sineList.LastOrDefault();
                    decimal sine = Sin(ToRadians(dcPhase));
                    sineList.Add(sine);

                    decimal prevLeadSine = leadSineList.LastOrDefault();
                    decimal leadSine = Sin(ToRadians(dcPhase + 45));
                    leadSineList.Add(leadSine);

                    var signal = GetCompareSignal(sine - leadSine, prevSine - prevLeadSine);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (realPartList, imagPartList, dcPhaseList, sineList, leadSineList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateEhlersSineWaveIndicatorV2(StockData stockDataClass, int days = 5)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Ehlers Sinewave Indicator V2 [CC] script may be freely distributed under the MIT license.
            //study("Ehlers Sinewave Indicator V2 [CC]", overlay = false)

            //inp = input(title = "Source", type = input.source, defval = hl2)
            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //src = security(syminfo.tickerid, res, inp[rep ? 0 : barstate.isrealtime ? 1 : 0])[rep ? 0 : barstate.isrealtime ? 0 : 1]
            //alpha = input(title = "Alpha", type = input.float, defval = 0.07, minval = 0.01, step = 0.01)
            //length = input(title = "Length", type = input.integer, defval = 5, minval = 1)

            //pi = 2 * asin(1)
            //instPeriod = 0.0
            //smooth = (src + (2 * nz(src[1])) + (2 * nz(src[2])) + nz(src[3])) / 6
            //cycle = 0.0
            //cycle:= bar_index < 7 ? (src - (2 * nz(src[1])) + nz(src[2])) / 4 : (pow(1 - (0.5 * alpha), 2) * (smooth - (2 * nz(smooth[1])) + nz(smooth[2]))) +
            //        (2 * (1 - alpha) * nz(cycle[1])) - (pow(1 - alpha, 2) * nz(cycle[2]))

            //q1 = ((0.0962 * cycle) + (0.5769 * nz(cycle[2])) - (0.5769 * nz(cycle[4])) - (0.0962 * nz(cycle[6]))) * (0.5 + (0.08 * nz(instPeriod[1])))
            //i1 = nz(cycle[3])

            //deltaPhase = q1 != 0 and nz(q1[1]) != 0 ? ((i1 / q1) - (nz(i1[1]) / nz(q1[1]))) / (1 + ((i1 * nz(i1[1]) / (q1 * nz(q1[1]))))) : 0
            //deltaPhase:= min(max(deltaPhase, 0.1), 1.1)
            //medianDelta = percentile_nearest_rank(deltaPhase, length, 50)

            //dc = medianDelta != 0 ? (6.28318 / medianDelta) + 0.5 : 15
            //instPeriod:= (0.33 * dc) + (0.67 * nz(instPeriod[1]))

            //period = 0.0
            //period:= (0.15 * instPeriod) + (0.85 * nz(period[1]))

            //dcPeriod = ceil(period)
            //real = 0.0, imag = 0.0
            //for i = 0 to dcPeriod - 1
            //    real := real + (sin(2 * pi * i / dcPeriod) * nz(cycle[i]))
            //    imag := imag + (cos(2 * pi * i / dcPeriod) * nz(cycle[i]))

            //dcPhase = 0.0
            //dcPhase:= abs(imag) > 0.001 ? atan(real / imag) * 180 / pi : 90 * sign(real)
            //dcPhase:= dcPhase + 90
            //dcPhase:= imag < 0 ? dcPhase + 180 : dcPhase
            //dcPhase:= dcPhase > 315 ? dcPhase - 360 : dcPhase

            //sine = sin(dcPhase * pi / 180)
            //leadSine = sin((dcPhase + 45) * pi / 180)

            //sig = src > smooth ? 1 : src < smooth ? -1 : 0
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //swColor = sig > 0 ? color.green : sig < 0 ? color.red : color.black
            //barcolor(bar ? swColor : na)
            //plot(0, title = "Signal", color = swColor, linewidth = 2)
            //plot(sine, title = "Sine", color = color.blue, linewidth = 2)
            //plot(leadSine, title = "LeadSine", color = color.red, linewidth = 2)
            List<decimal> imagPartList = new();
            List<decimal> realPartList = new();
            List<decimal> sineList = new();
            List<decimal> leadSineList = new();
            List<decimal> dcPhaseList = new();
            List<Signal> signalsList = new();

            try
            {
                var periodList = CalculateEhlersAdaptiveCyberCycle(stockDataClass, days).Item10;
                var cycleList = CalculateEhlersCyberCycle(stockDataClass).Item2;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal period = periodList.ElementAtOrDefault(i);
                    decimal cycle = cycleList.ElementAtOrDefault(i);

                    int dcPeriod = (int)Math.Ceiling(period);
                    decimal realPart = 0, imagPart = 0;
                    for (int j = 0; j <= dcPeriod - 1; j++)
                    {
                        decimal prevCycle = i >= j ? cycleList.ElementAtOrDefault(i - j) : 0;

                        realPart += Sin(MinOrMax(2 * Math.PI * j / dcPeriod, 0.99, 0.01)) * prevCycle;
                        imagPart += Cos(MinOrMax(2 * Math.PI * j / dcPeriod, 0.99, 0.01)) * prevCycle;
                    }
                    realPartList.Add(realPart);
                    imagPartList.Add(imagPart);

                    decimal dcPhase = Math.Abs(imagPart) > 0.001m ? ToDegrees(Atan(realPart / imagPart)) : 90 * Math.Sign(realPart);
                    dcPhase += 90;
                    dcPhase += imagPart < 0 ? 180 : 0;
                    dcPhase -= dcPhase > 315 ? 360 : 0;
                    dcPhaseList.Add(dcPhase);

                    decimal prevSine = sineList.LastOrDefault();
                    decimal sine = Sin(ToRadians(dcPhase));
                    sineList.Add(sine);

                    decimal prevLeadSine = leadSineList.LastOrDefault();
                    decimal leadSine = Sin(ToRadians(dcPhase + 45));
                    leadSineList.Add(leadSine);

                    var signal = GetCompareSignal(sine - leadSine, prevSine - prevLeadSine);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (realPartList, imagPartList, dcPhaseList, sineList, leadSineList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateEhlersEvenBetterSineWaveIndicator(StockData stockDataClass, int days = 10)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Ehlers Even Better Sinewave Indicator [CC] script may be freely distributed under the MIT license.
            //study("Ehlers Even Better Sinewave Indicator [CC]", overlay = false)

            //inp = input(title = "Source", type = input.source, defval = close)
            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //src = security(syminfo.tickerid, res, inp[rep ? 0 : barstate.isrealtime ? 1 : 0])[rep ? 0 : barstate.isrealtime ? 0 : 1]
            //hpLength = input(title = "HPLength", type = input.integer, defval = 40, minval = 1)
            //ssfLength = input(title = "SSFLength", type = input.integer, defval = 10, minval = 1)

            //pi = 2 * asin(1)
            //alpha1 = (1 - sin(2 * pi / hpLength)) / cos(2 * pi / hpLength)
            //alpha2 = exp(-1.414 * pi / ssfLength)
            //beta = 2 * alpha2 * cos(1.414 * pi / ssfLength)
            //c2 = beta
            //c3 = -alpha2 * alpha2
            //c1 = 1 - c2 - c3

            //hp = 0.0
            //hp:= (0.5 * (1 + alpha1) * (src - nz(src[1]))) + (alpha1 * nz(hp[1]))

            //filt = 0.0
            //filt:= (c1 * ((hp + nz(hp[1])) / 2)) + (c2 * nz(filt[1])) + (c3 * nz(filt[2]))

            //wave = (filt + nz(filt[1]) + nz(filt[2])) / 3
            //pwr = (pow(filt, 2) + pow(nz(filt[1]), 2) + pow(nz(filt[2]), 2)) / 3
            //wave:= wave / sqrt(pwr)

            //sig = wave > 0 ? 1 : wave < 0 ? -1 : 0
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //ebsiColor = sig > 0 ? color.green : sig < 0 ? color.red : color.black
            //barcolor(bar ? ebsiColor : na)
            //plot(wave, title = "EBSI", color = ebsiColor, linewidth = 2)
            List<decimal> hpList = new();
            List<decimal> filtList = new();
            List<decimal> waveList = new();
            List<decimal> pwrList = new();
            List<decimal> ebsiList = new();
            List<Signal> signalsList = new();

            try
            {
                int hpLength = days * 4;

                decimal piHp = (decimal)MinOrMax(2 * Math.PI / hpLength, 0.99, 0.01);
                decimal a1 = (1 - Sin(piHp)) / Cos(piHp);
                decimal a2 = Exp(MinOrMax(-1.414 * Math.PI / days, -0.01, -0.99));
                decimal b = 2 * a2 * Cos(MinOrMax(1.414 * Math.PI / days, 0.99, 0.01));
                decimal c2 = b;
                decimal c3 = -a2 * a2;
                decimal c1 = 1 - c2 - c3;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevFilt1 = i >= 1 ? filtList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevFilt2 = i >= 2 ? filtList.ElementAtOrDefault(i - 2) : 0;

                    decimal prevHp = hpList.LastOrDefault();
                    decimal hp = ((0.5m * (1 + a1)) * (currentValue - prevValue)) + (a1 * prevHp);
                    hpList.Add(hp);

                    decimal filt = (c1 * ((hp + prevHp) / 2)) + (c2 * prevFilt1) + (c3 * prevFilt2);
                    filtList.Add(filt);

                    decimal wave = (filt + prevFilt1 + prevFilt2) / 3;
                    waveList.Add(wave);

                    decimal pwr = (Pow(filt, 2) + Pow(prevFilt1, 2) + Pow(prevFilt2, 2)) / 3;
                    pwrList.Add(pwr);

                    decimal prevEbsi = ebsiList.LastOrDefault();
                    decimal ebsi = pwr > 0 ? wave / Sqrt(pwr) : 0;
                    ebsiList.Add(ebsi);

                    var signal = GetCompareSignal(ebsi, prevEbsi);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (hpList, filtList, waveList, pwrList, ebsiList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateEhlersConvolutionIndicator(
            StockData stockDataClass, int days = 40)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Ehlers Convolution Indicator [CC] script may be freely distributed under the MIT license.
            //study("Ehlers Convolution Indicator [CC]", overlay = false)

            //inp = input(title = "Source", type = input.source, defval = close)
            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //src = security(syminfo.tickerid, res, inp[rep ? 0 : barstate.isrealtime ? 1 : 0])[rep ? 0 : barstate.isrealtime ? 0 : 1]
            //hpLength = input(title = "HPLength", type = input.integer, defval = 80, minval = 1)
            //ssfLength = input(title = "SSFLength", type = input.integer, defval = 40, minval = 1)
            //corrLength = input(title = "CorrLength", type = input.integer, defval = 48, minval = 1)

            //pi = 2 * asin(1)
            //twoPiPrd = 0.707 * 2 * pi / hpLength
            //a1 = (cos(twoPiPrd) + sin(twoPiPrd) - 1) / cos(twoPiPrd)
            //a2 = exp(-1.414 * pi / ssfLength)
            //b1 = 2 * a2 * cos(1.414 * pi / ssfLength)
            //c2 = b1
            //c3 = -a2 * a2
            //c1 = 1 - c2 - c3

            //hp = 0.0
            //hp:= ((1 - (a1 / 2)) * (1 - (a1 / 2)) * (src - (2 * nz(src[1])) + nz(src[2]))) + (2 * (1 - a1) * nz(hp[1])) - ((1 - a1) * (1 - a1) * nz(hp[2]))

            //rfilt = 0.0
            //rfilt:= (c1 * ((hp + nz(hp[1])) / 2)) + (c2 * nz(rfilt[1])) + (c3 * nz(rfilt[2]))

            //sx = 0.0, sy = 0.0, sxx = 0.0, syy = 0.0, sxy = 0.0, corr = 0.0, convolution = 0.0, slope = 0.0
            //for n = 1 to corrLength
            //    sx := 0.0, sy := 0.0, sxx := 0.0, syy := 0.0, sxy := 0.0
            //    for i = 1 to n
            //        x = nz(rfilt[i - 1])
            //        y = nz(rfilt[n - i])
            //        sx := sx + x
            //        sy := sy + y
            //        sxx := sxx + (x * x)
            //        sxy := sxy + (x * y)
            //        syy := syy + (y * y)
            //        corr := ((n * sxx) - (sx * sx)) * ((n * syy) - (sy * sy)) > 0 ? ((n * sxy) - (sx * sy)) / sqrt(((n * sxx) - (sx * sx)) * ((n * syy) - (sy * sy))) : 0
            //        convolution := ((1 + (exp(3 * corr) - 1)) / ((exp(3 * corr)) + 1)) / 2
            //        slope := nz(rfilt[round(.5 * n)]) < rfilt ? -1 : 1

            //sig = hp > 0 ? 1 : hp < 0 ? -1 : 0
            //convColor = sig > 0 ? color.green : sig < 0 ? color.red : color.black
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //barcolor(bar ? convColor : na)
            //plot(convolution, title = "Convolution", color = convColor, linewidth = 2)
            List<decimal> convList = new();
            List<decimal> hpList = new();
            List<decimal> roofingFilterList = new();
            List<decimal> sxList = new();
            List<decimal> syList = new();
            List<decimal> sxxList = new();
            List<decimal> sxyList = new();
            List<decimal> syyList = new();
            List<decimal> corrList = new();
            List<Signal> signalsList = new();

            try
            {
                int ssfLength = days;
                int hpLength = days * 2;
                int corrLength = (int)Math.Ceiling(days / 0.8334);
                decimal piPrd = ToRadians(0.707 * 360 / hpLength);
                decimal alpha = (Cos(piPrd) + Sin(piPrd) - 1) / Cos(piPrd);
                decimal a1 = Exp(-1.414 * Math.PI / ssfLength);
                decimal b1 = 2 * a1 * Cos(ToRadians(1.414 * 180 / ssfLength));
                decimal c2 = b1;
                decimal c3 = -a1 * a1;
                decimal c1 = 1 - c2 - c3;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue1 = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevValue2 = i >= 2 ? stockDataClass.InputValues.ElementAtOrDefault(i - 2) : 0;
                    decimal prevHp1 = i >= 1 ? hpList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevHp2 = i >= 2 ? hpList.ElementAtOrDefault(i - 2) : 0;
                    decimal prevRoofingFilter1 = i >= 1 ? roofingFilterList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevRoofingFilter2 = i >= 2 ? roofingFilterList.ElementAtOrDefault(i - 2) : 0;

                    decimal highPass = (Pow(1 - (alpha / 2), 2) * (currentValue - (2 * prevValue1) + prevValue2)) + (2 * (1 - alpha) * prevHp1) - (Pow(1 - alpha, 2) * prevHp2);
                    hpList.Add(highPass);

                    decimal roofingFilter = (c1 * ((highPass + prevHp1) / 2)) + (c2 * prevRoofingFilter1) + (c3 * prevRoofingFilter2);
                    roofingFilterList.Add(roofingFilter);

                    int n = i + 1;
                    decimal sx = 0, sy = 0, sxx = 0, syy = 0, sxy = 0, corr = 0, conv = 0, slope = 0;
                    for (int j = 1; j <= corrLength; j++)
                    {
                        decimal x = i >= j - 1 ? roofingFilterList.ElementAtOrDefault(i - (j - 1)) : 0;
                        decimal y = i >= j ? roofingFilterList.ElementAtOrDefault(i - j) : 0;
                        sx += x;
                        sy += y;
                        sxx += x * x;
                        sxy += x * y;
                        syy += y * y;
                        corr = corr = ((n * sxx) - (sx * sx)) * ((n * syy) - (sy * sy)) > 0 ? ((n * sxy) - (sx * sy)) /
                            Sqrt(((n * sxx) - (sx * sx)) * ((n * syy) - (sy * sy))) : 0;
                        conv = (1 + (Exp(3 * corr) - 1)) / (Exp(3 * corr) + 1) / 2;

                        int filtLength = (int)Math.Ceiling(0.5 * n);
                        decimal prevFilt = i >= filtLength ? roofingFilterList.ElementAtOrDefault(i - filtLength) : 0;
                        slope = prevFilt < roofingFilter ? -1 : 1;
                    }
                    sxList.Add(sx);
                    syList.Add(sy);
                    sxxList.Add(sxx);
                    syyList.Add(syy);
                    sxyList.Add(sxy);
                    corrList.Add(corr);
                    convList.Add(conv);

                    var signal = GetCompareSignal(roofingFilter - prevRoofingFilter1, prevRoofingFilter1 - prevRoofingFilter2);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (hpList, roofingFilterList, sxList, syList, sxxList, syyList, sxyList, corrList, convList, signalsList);
        }

        public static (List<decimal>, List<Signal>) CalculateChandeTrendScore(StockData stockDataClass, int days = 11)
        {
            //@version=3
            // Copyright (c) 2018-present, Alex Orekhov (everget)
            // Trendscore script may be freely distributed under the MIT license.
            //study("Trendscore", shorttitle = "Trendscore")

            //fromIndex = input(title = "From", type = integer, minval = 1, defval = 11)
            //toIndex = input(title = "To", type = integer, minval = 1, defval = 20)
            //src = input(title = "Source", type = source, defval = close)

            //trendscore(src, fromIndex, toIndex) =>
            //    sum = 0.0

            //    for i = fromIndex to toIndex
            //        sum := sum + (src >= nz(src[i]) ? 1 : -1)
            //    sum

            //ts = trendscore(src, fromIndex, toIndex)

            //plot(ts, title = "Trendscore", linewidth = 2, color =#e69138, transp=0)
            List<decimal> tsList = new();
            List<Signal> signalsList = new();

            try
            {
                int startLength = days;
                int endLength = MinOrMax((int)Math.Ceiling(startLength / 0.55));

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);

                    decimal prevTs = tsList.LastOrDefault();
                    decimal ts = 0;
                    for (int j = startLength; j <= endLength; j++)
                    {
                        decimal prevValue = i >= j ? stockDataClass.InputValues.ElementAtOrDefault(i - j) : 0;

                        ts += currentValue >= prevValue ? 1 : -1;
                    }
                    tsList.Add(ts);

                    var signal = GetCompareSignal(ts, prevTs);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (tsList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateEhlersFisherTransform(StockData stockDataClass, int days = 10)
        {
            ////////////////////////////////////////////////////////////
            //  Copyright by HPotter v1.0 01/07/2014
            // 	Market prices do not have a Gaussian probability density function
            // 	as many traders think. Their probability curve is not bell-shaped.
            // 	But trader can create a nearly Gaussian PDF for prices by normalizing
            // 	them or creating a normalized indicator such as the relative strength
            // 	index and applying the Fisher transform. Such a transformed output 
            // 	creates the peak swings as relatively rare events.
            // 	Fisher transform formula is: y = 0.5 * ln ((1+x)/(1-x))
            // 	The sharp turning points of these peak swings clearly and unambiguously
            // 	identify price reversals in a timely manner. 
            ////////////////////////////////////////////////////////////
            //study(title = "Fisher Transform Indicator by Ehlers Strategy", shorttitle = "Fisher Transform Indicator by Ehlers")
            //Length = input(10, minval = 1)
            //xHL2 = hl2
            //xMaxH = highest(xHL2, Length)
            //xMinL = lowest(xHL2, Length)
            //nValue1 = 0.33 * 2 * ((xHL2 - xMinL) / (xMaxH - xMinL) - 0.5) + 0.67 * nz(nValue1[1])
            //nValue2 = iff(nValue1 > .99, .999,
            //iff(nValue1 < -.99, -.999, nValue1))
            //nFish = 0.5 * log((1 + nValue2) / (1 - nValue2)) + 0.5 * nz(nFish[1])
            //pos = iff(nFish > nz(nFish[1]), 1,
            //iff(nFish < nz(nFish[1]), -1, nz(pos[1], 0)))
            //barcolor(pos == -1 ? red : pos == 1 ? green : blue)
            //plot(nFish, color = green, title = "Fisher")
            //plot(nz(nFish[1]), color = red, title = "Trigger")
            List<decimal> fisherTransformList = new();
            List<decimal> nValueList = new();
            List<decimal> fisherTransformRocList = new();
            List<Signal> signalsList = new();

            try
            {
                var list = GetMaxAndMinValuesList(stockDataClass.InputValues, days);
                var maxList = list.Item1;
                var minList = list.Item2;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal maxH = maxList.ElementAtOrDefault(i);
                    decimal minL = minList.ElementAtOrDefault(i);
                    decimal ratio = maxH - minL != 0 ? (currentValue - minL) / (maxH - minL) : 0;
                    decimal prevFisherTransform1 = i >= 1 ? fisherTransformList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevFisherTransform2 = i >= 2 ? fisherTransformList.ElementAtOrDefault(i - 2) : 0;

                    decimal prevNValue = nValueList.LastOrDefault();
                    decimal nValue = MinOrMax((0.33m * 2 * (ratio - 0.5m)) + (0.67m * prevNValue), 0.999m, -0.999m);
                    nValueList.Add(nValue);

                    decimal fisherTransform = (0.5m * Log((1 + nValue) / (1 - nValue))) + (0.5m * prevFisherTransform1);
                    fisherTransformList.Add(fisherTransform);

                    decimal fisherTransformRoc = prevFisherTransform1 != 0 ? (fisherTransform - prevFisherTransform1) / prevFisherTransform1 * 100 : 0;
                    fisherTransformRocList.Add(fisherTransformRoc);

                    var signal = GetCompareSignal(fisherTransform - prevFisherTransform1, prevFisherTransform1 - prevFisherTransform2);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (nValueList, fisherTransformList, fisherTransformRocList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>)
            CalculateFisherTransformStochasticOscillator(StockData stockDataClass, string maType, int days = 2)
        {
            //input = price, user defined, default is closing price
            //method = moving average (ma), user defined, default is WMA
            //averagePeriod = user defined, default is 2
            //stochasticPeriod = user defined, default is 30
            //smoothPeriod = user defined, default is 5
            //index = current bar number

            //ma1 = ma(method, index, averagePeriod, price);
            //rbw = ma1 * 5;
            //ma2 = ma(method, index, averagePeriod, MA1);
            //rbw = rbw + ma2 * 4;
            //ma3 = ma(method, index, averagePeriod, MA2);
            //rbw = rbw + ma3 * 3;
            //ma4 = ma(method, index, averagePeriod, MA3);
            //rbw = rbw + ma4 * 2;
            //ma5 = ma(method, index, averagePeriod, MA4);
            //rbw = rbw + ma5;
            //ma6 = ma(method, index, averagePeriod, MA5);
            //rbw = rbw + ma6;
            //ma7 = ma(method, index, averagePeriod, MA6);
            //rbw = rbw + ma7;
            //ma8 = ma(method, index, averagePeriod, MA7);
            //rbw = rbw + ma8;
            //ma9 = ma(method, index, averagePeriod, MA8);
            //rbw = rbw + ma9;
            //ma10 = ma(method, index, averagePeriod, MA9);
            //rbw = (rbw + ma10) / 20;

            //Stochastic Calculation
            //lowest = lowest(index, stochasticPeriod, RBW);
            //highest = highest(index, stochasticPeriod, RBW);
            //num = rbw - lowest;
            //den = highest - lowest;
            //num = sum(index, smoothPeriod, NUM);
            //den = sum(index, smoothPeriod, DEN);
            //Plot1: rbws = (num / (den + .0001)) * 100.0;
            //x = 0.1 * (rbws - 50);
            //Plor2: ftso = ((Math.exp(2 * x) - 1) / (Math.exp(2 * x) + 1) + 1) * 50;

            // Check for signal events 
            //prevFtso = FTSO[index - 1];
            //sell = prevFtso lessThan topGuide AND ftso moreThan topGuide;
            //buy = prevFtso moreThan bottomGuide AND ftso lessThan bottomGuide;
            List<decimal> rbwList = new();
            List<decimal> ftsoList = new();
            List<decimal> numList = new();
            List<decimal> denomList = new();
            List<decimal> lowestList = new();
            List<decimal> highestList = new();
            List<decimal> numSumList = new();
            List<decimal> denomSumList = new();
            List<decimal> rbwsList = new();
            List<decimal> xList = new();
            List<Signal> signalsList = new();

            try
            {
                int averagePeriod = days;
                int smoothPeriod = MinOrMax((int)Math.Ceiling(averagePeriod / 0.4));
                int stochasticPeriod = MinOrMax(averagePeriod * 15);

                var wmaList = GetMovingAverageList(maType, null, stockDataClass, averagePeriod);
                var wma2List = GetMovingAverageList(maType, wmaList, stockDataClass, averagePeriod);
                var wma3List = GetMovingAverageList(maType, wma2List, stockDataClass, averagePeriod);
                var wma4List = GetMovingAverageList(maType, wma3List, stockDataClass, averagePeriod);
                var wma5List = GetMovingAverageList(maType, wma4List, stockDataClass, averagePeriod);
                var wma6List = GetMovingAverageList(maType, wma5List, stockDataClass, averagePeriod);
                var wma7List = GetMovingAverageList(maType, wma6List, stockDataClass, averagePeriod);
                var wma8List = GetMovingAverageList(maType, wma7List, stockDataClass, averagePeriod);
                var wma9List = GetMovingAverageList(maType, wma8List, stockDataClass, averagePeriod);
                var wma10List = GetMovingAverageList(maType, wma9List, stockDataClass, averagePeriod);

                for (int i = 0; i < wmaList.Count; i++)
                {
                    decimal wma1 = wmaList.ElementAtOrDefault(i);
                    decimal wma2 = wma2List.ElementAtOrDefault(i);
                    decimal wma3 = wma3List.ElementAtOrDefault(i);
                    decimal wma4 = wma4List.ElementAtOrDefault(i);
                    decimal wma5 = wma5List.ElementAtOrDefault(i);
                    decimal wma6 = wma6List.ElementAtOrDefault(i);
                    decimal wma7 = wma7List.ElementAtOrDefault(i);
                    decimal wma8 = wma8List.ElementAtOrDefault(i);
                    decimal wma9 = wma9List.ElementAtOrDefault(i);
                    decimal wma10 = wma10List.ElementAtOrDefault(i);
                    decimal prevFtso1 = i >= 1 ? ftsoList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevFtso2 = i >= 2 ? ftsoList.ElementAtOrDefault(i - 2) : 0;

                    decimal rbw = ((wma1 * 5) + (wma2 * 4) + (wma3 * 3) + (wma4 * 2) + wma5 + wma6 + wma7 + wma8 + wma9 + wma10) / 20;
                    rbwList.Add(rbw);

                    decimal lowest = rbwList.TakeLast(stochasticPeriod).Min();
                    lowestList.Add(lowest);

                    decimal highest = rbwList.TakeLast(stochasticPeriod).Max();
                    highestList.Add(highest);

                    decimal num = rbw - lowest;
                    numList.Add(num);

                    decimal denom = highest - lowest;
                    denomList.Add(denom);

                    decimal numSum = numList.TakeLast(smoothPeriod).Sum();
                    numSumList.Add(numSum);

                    decimal denomSum = denomList.TakeLast(smoothPeriod).Sum();
                    denomSumList.Add(denomSum);

                    decimal rbws = denomSum + 0.0001m != 0 ? MinOrMax(numSum / (denomSum + 0.0001m) * 100, 100, 0) : 0;
                    rbwsList.Add(rbws);

                    decimal x = 0.1m * (rbws - 50);
                    xList.Add(x);

                    decimal ftso = MinOrMax((((Exp(2 * x) - 1) / (Exp(2 * x) + 1)) + 1) * 50, 100, 0);
                    ftsoList.Add(ftso);

                    var signal = GetRsiSignal(ftso - prevFtso1, prevFtso1 - prevFtso2, ftso, prevFtso1, 70, 30);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (lowestList, highestList, numList, denomList, numSumList, denomSumList, rbwsList, xList, ftsoList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateMovingAverageBands(StockData stockDataClass, string maType, int days = 10)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Moving Average Bands [CC] script may be freely distributed under the MIT license.
            //study("Moving Average Bands [CC]", overlay = true)

            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //inp = input(title = "Source", type = input.source, defval = close)
            //src = security(syminfo.tickerid, res, inp[rep ? 0 : barstate.isrealtime ? 1 : 0])[rep ? 0 : barstate.isrealtime ? 0 : 1]
            //fastLength = input(title = "FastLength", type = input.integer, defval = 10, minval = 1)
            //slowLength = input(title = "SlowLength", type = input.integer, defval = 50, minval = 1)
            //mult = input(title = "Multiple", type = input.integer, defval = 1, minval = 1)

            //fastEma = ema(src, fastLength)
            //slowEma = ema(src, slowLength)
            //sqAvg = sum(pow(slowEma - fastEma, 2), fastLength) / fastLength
            //dev = sqrt(sqAvg) * mult

            //upperBand = slowEma + dev
            //lowerBand = slowEma - dev
            //middleBand = fastEma

            //sig = (src > upperBand and nz(src[1]) <= nz(upperBand[1])) or(src > lowerBand and nz(src[1]) <= nz(lowerBand[1]))
            //      ? 1 : (src < lowerBand and nz(src[1]) >= nz(lowerBand[1])) or(src < upperBand and nz(src[1]) >= nz(upperBand[1]))
            //      ? -1 : src > middleBand ? 1 : src < middleBand ? -1 : 0
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //mabColor = sig > 0 ? color.green : sig < 0 ? color.red : color.black
            //barcolor(bar ? mabColor : na)
            //plot(upperBand, title = "MabUp", color = mabColor, linewidth = 2)
            //plot(middleBand, title = "MabMid", color = color.black, linewidth = 1)
            //plot(lowerBand, title = "MabLow", color = mabColor, linewidth = 2)
            List<decimal> sqList = new();
            List<decimal> sqAvgList = new();
            List<decimal> devList = new();
            List<decimal> upperBandList = new();
            List<decimal> lowerBandList = new();
            List<Signal> signalsList = new();

            try
            {
                int fastLength = days;
                int slowLength = days * 5;

                var fastMaList = GetMovingAverageList(maType, null, stockDataClass, fastLength);
                var slowMaList = GetMovingAverageList(maType, null, stockDataClass, slowLength);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal fastMa = fastMaList.ElementAtOrDefault(i);
                    decimal slowMa = slowMaList.ElementAtOrDefault(i);
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevFastMa = i >= 1 ? fastMaList.ElementAtOrDefault(i - 1) : 0;

                    decimal sq = Pow(slowMa - fastMa, 2);
                    sqList.Add(sq);

                    decimal sqAvg = sqList.TakeLast(fastLength).Average();
                    sqAvgList.Add(sqAvg);

                    decimal dev = sqAvg >= 0 ? Sqrt(sqAvg) : 0;
                    devList.Add(dev);

                    decimal prevUpperBand = upperBandList.LastOrDefault();
                    decimal upperBand = slowMa + dev;
                    upperBandList.Add(upperBand);

                    decimal prevLowerBand = lowerBandList.LastOrDefault();
                    decimal lowerBand = slowMa - dev;
                    lowerBandList.Add(lowerBand);

                    var signal = GetBollingerBandsSignal(currentValue - fastMa, prevValue - prevFastMa, currentValue, prevValue, upperBand, prevUpperBand, lowerBand, prevLowerBand);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (sqList, sqAvgList, devList, upperBandList, lowerBandList, signalsList);
        }

        public static (List<decimal>, List<Signal>) CalculateMovingAverageBandWidth(StockData stockDataClass, string maType, int days = 10)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Moving Average Band Width [CC] script may be freely distributed under the MIT license.
            //study("Moving Average Band Width [CC]", overlay = false)

            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //inp = input(title = "Source", type = input.source, defval = close)
            //src = security(syminfo.tickerid, res, inp[rep ? 0 : barstate.isrealtime ? 1 : 0])[rep ? 0 : barstate.isrealtime ? 0 : 1]
            //fastLength = input(title = "FastLength", type = input.integer, defval = 10, minval = 1)
            //slowLength = input(title = "SlowLength", type = input.integer, defval = 50, minval = 1)
            //mult = input(title = "Multiple", type = input.integer, defval = 1, minval = 1)

            //fastEma = ema(src, fastLength)
            //slowEma = ema(src, slowLength)
            //sqAvg = sum(pow(slowEma - fastEma, 2), fastLength) / fastLength
            //dev = sqrt(sqAvg) * mult

            //upperBand = slowEma + dev
            //lowerBand = slowEma - dev
            //middleBand = fastEma
            //mabw = middleBand != 0 ? (upperBand - lowerBand) / middleBand * 100 : 0

            //slo = src - fastEma
            //sig = slo > 0 ? slo > nz(slo[1]) ? 2 : 1 : slo < 0 ? slo < nz(slo[1]) ? -2 : -1 : 0
            //alertcondition(crossover(sig, 1), "Strong Buy Signal", "Strong Bullish Change Detected")
            //alertcondition(crossunder(sig, -1), "Strong Sell Signal", "Strong Bearish Change Detected")
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //mabwColor = sig > 1 ? color.green : sig > 0 ? color.lime : sig < -1 ? color.maroon : sig < 0 ? color.red : color.black
            //barcolor(bar ? mabwColor : na)
            //plot(mabw, title = "MABW", color = mabwColor, linewidth = 2)
            List<decimal> mabwList = new();
            List<Signal> signalsList = new();

            try
            {
                var mabList = CalculateMovingAverageBands(stockDataClass, maType, days);
                var ubList = mabList.Item4;
                var lbList = mabList.Item5;
                var maList = GetMovingAverageList(maType, null, stockDataClass, days);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal mb = maList.ElementAtOrDefault(i);
                    decimal ub = ubList.ElementAtOrDefault(i);
                    decimal lb = lbList.ElementAtOrDefault(i);
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevMb = i >= 1 ? maList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevUb = i >= 1 ? ubList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevLb = i >= 1 ? lbList.ElementAtOrDefault(i - 1) : 0;

                    decimal mabw = mb != 0 ? (ub - lb) / mb * 100 : 0;
                    mabwList.Add(mabw);

                    var signal = GetBollingerBandsSignal(currentValue - mb, prevValue - prevMb, currentValue, prevValue, ub, prevUb, lb, prevLb);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (mabwList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateEhlersInverseFisherTransform(StockData stockDataClass, string maType, int days = 5)
        {
            //input = price, user defined, default is closing price
            //method = moving average (ma), user defined, default is WMA
            //period1 = p1, user defined, default is 5
            //period2 = p2, user defined, default is 9
            //exp = function, returns Euler’s number (e) raised to power of its argument
            //av = average, index = current bar number

            //rsi = rsi(p1, input)[0];
            //wmalength=input(9, title="Smoothing length")
            //v1 = 0.1 * (rsi - 50)
            //av = ma(method, index, p2, VALUE1);
            //Plot: ifish = (Math.exp(2 * av) - 1) / (Math.exp(2 * av) + 1);
            //Signals
            //prevI = ifish[index - 1];
            //highSell = ifish for last sell signal, reset to max_negative at each  buy signal;
            //lowBuy = ifish for last buy signal, reset to max_positive at each sell signal;
            //sell = ifish moreThan topGuide  AND prevI moreThan ifish AND(ifish moreThan highSell);
            //buy = ifish lessThan bottGuide AND prevI lessThan ifish AND(ifish lessThan lowBuy);
            List<decimal> v1List = new();
            List<decimal> v2List = new();
            List<decimal> inverseFisherTransformList = new();
            List<Signal> signalsList = new();

            try
            {
                int period1 = days;
                int period2 = MinOrMax((int)Math.Ceiling(period1 / 0.555));

                List<decimal> rsiList = CalculateRelativeStrengthIndex(null, stockDataClass, maType, period1).Item4;
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentRsi = rsiList.ElementAtOrDefault(i);

                    decimal v1 = 0.1m * (currentRsi - 50);
                    v1List.Add(v1);
                }

                v2List = GetMovingAverageList("WeightedMovingAverage", v1List, stockDataClass, period2);
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal v2 = v2List.ElementAtOrDefault(j);
                    decimal prevIft1 = j >= 1 ? inverseFisherTransformList.ElementAtOrDefault(j - 1) : 0;
                    decimal prevIft2 = j >= 2 ? inverseFisherTransformList.ElementAtOrDefault(j - 2) : 0;
                    decimal bottom = Exp(2 * v2) + 1;

                    decimal inverseFisherTransform = bottom != 0 ? MinOrMax((Exp(2 * v2) - 1) / bottom, 1, -1) : 0;
                    inverseFisherTransformList.Add(inverseFisherTransform);

                    var signal = GetRsiSignal(inverseFisherTransform - prevIft1, prevIft1 - prevIft2, inverseFisherTransform, prevIft1, 0.5m, -0.5m);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (v1List, v2List, inverseFisherTransformList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateEhlersInstantaneousTrendline(StockData stockDataClass)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Ehlers Instantaneous Trendline V2 [CC] script may be freely distributed under the MIT license.
            //study("Ehlers Instantaneous Trendline V2 [CC]", overlay = true)

            //inp = input(title = "Source", type = input.source, defval = hl2)
            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //src = security(syminfo.tickerid, res, inp[rep ? 0 : barstate.isrealtime ? 1 : 0])[rep ? 0 : barstate.isrealtime ? 0 : 1]
            //alpha = input(title = "Alpha", type = input.float, defval = 0.07, minval = 0.01, step = 0.01)

            //itrend = 0.0
            //itrend:= bar_index < 7 ? (src + (2 * nz(src[1])) + nz(src[2])) / 4 : ((alpha - (pow(alpha, 2) / 4)) * src) + (0.5 * pow(alpha, 2) * nz(src[1])) -
            //        ((alpha - (0.75 * pow(alpha, 2))) * nz(src[2])) + (2 * (1 - alpha) * nz(itrend[1])) - (pow(1 - alpha, 2) * nz(itrend[2]))
            //trigger = (2 * itrend) - nz(itrend[2])

            //sig = trigger > itrend ? 1 : trigger < itrend ? -1 : 0
            //itColor = sig > 0 ? color.green : sig < 0 ? color.red : color.black
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //barcolor(bar ? itColor : na)
            //plot(itrend, title = "ITrend", color = itColor, linewidth = 2)
            //plot(trigger, title = "Signal", color = color.black, linewidth = 1)
            decimal a = 0.07m;
            List<decimal> itList = new();
            List<decimal> lagList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue1 = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevIt1 = i >= 1 ? itList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevValue2 = i >= 2 ? stockDataClass.InputValues.ElementAtOrDefault(i - 2) : 0;
                    decimal prevIt2 = i >= 2 ? itList.ElementAtOrDefault(i - 2) : 0;

                    decimal it = i < 7 ? (currentValue + (2 * prevValue1) + prevValue2) / 4 : ((a - (a * a / 4)) * currentValue) + (0.5m * a * a * prevValue1) -
                        ((a - (0.75m * a * a)) * prevValue2) + (2 * (1 - a) * prevIt1) - ((1 - a) * (1 - a) * prevIt2);
                    itList.Add(it);

                    decimal prevLag = lagList.LastOrDefault();
                    decimal lag = (2 * it) - prevIt2;
                    lagList.Add(lag);

                    var signal = GetCompareSignal(lag - it, prevLag - prevIt1);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (itList, lagList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateEhlersInstantaneousTrendlineV2(StockData stockDataClass)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Ehlers Instantaneous Trendline V1 [CC] script may be freely distributed under the MIT license.
            //study("Ehlers Instantaneous Trendline V1 [CC]", overlay = true)

            //inp = input(title = "Source", type = input.source, defval = hl2)
            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //src = security(syminfo.tickerid, res, inp[rep ? 0 : barstate.isrealtime ? 1 : 0])[rep ? 0 : barstate.isrealtime ? 0 : 1]

            //pi = 2 * asin(1)
            //period = 0.0
            //smooth = ((4 * src) + (3 * nz(src[1])) + (2 * nz(src[2])) + nz(src[3])) / 10
            //detrender = ((0.0962 * smooth) + (0.5769 * nz(smooth[2])) - (0.5769 * nz(smooth[4])) - (0.0962 * nz(smooth[6]))) * ((0.075 * nz(period[1])) + 0.54)

            //q1 = ((0.0962 * detrender) + (0.5769 * nz(detrender[2])) - (0.5769 * nz(detrender[4])) - (0.0962 * nz(detrender[6]))) * ((0.075 * nz(period[1])) + 0.54)
            //i1 = nz(detrender[3])

            //jI = ((0.0962 * i1) + (0.5769 * nz(i1[2])) - (0.5769 * nz(i1[4])) - (0.0962 * nz(i1[6]))) * ((0.075 * nz(period[1])) + 0.54)
            //jQ = ((0.0962 * q1) + (0.5769 * nz(q1[2])) - (0.5769 * nz(q1[4])) - (0.0962 * nz(q1[6]))) * ((0.075 * nz(period[1])) + 0.54)

            //i2 = i1 - jQ
            //i2:= (0.2 * i2) + (0.8 * nz(i2[1]))
            //q2 = q1 + jI
            //q2:= (0.2 * q2) + (0.8 * nz(q2[1]))

            //re = (i2 * nz(i2[1])) + (q2 * nz(q2[1]))
            //re:= (0.2 * re) + (0.8 * nz(re[1]))
            //im = (i2 * nz(q2[1])) - (q2 * nz(i2[1]))
            //im:= (0.2 * im) + (0.8 * nz(im[1]))

            //period:= im != 0 and re != 0 ? 2 * pi / atan(im / re) : 0
            //period:= min(max(period, 0.67 * nz(period[1])), 1.5 * nz(period[1]))
            //period:= min(max(period, 6), 50)
            //period:= (0.2 * period) + (0.8 * nz(period[1]))

            //smoothPeriod = 0.0
            //smoothPeriod:= (0.33 * period) + (0.67 * nz(smoothPeriod[1]))

            //dcPeriod = ceil(smoothPeriod + 0.5), iTrend = 0.0
            //for i = 0 to dcPeriod - 1
            //    iTrend := iTrend + nz(src[i])
            //iTrend := dcPeriod > 0 ? iTrend / dcPeriod : iTrend

            //trendline = ((4 * iTrend) + (3 * nz(iTrend[1])) + (2 * nz(iTrend[2])) + nz(iTrend[3])) / 10

            //sig = smooth > trendline ? 1 : smooth < trendline ? -1 : 0
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //tlColor = sig > 0 ? color.green : sig < 0 ? color.red : color.black
            //barcolor(bar ? tlColor : na)
            //plot(trendline, title = "Trendline", color = tlColor, linewidth = 2)
            List<decimal> itList = new();
            List<decimal> trendLineList = new();
            List<Signal> signalsList = new();

            try
            {
                var spList = CalculateEhlersMotherOfAdaptiveMovingAverages(stockDataClass).Item12;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal sp = spList.ElementAtOrDefault(i);
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevIt1 = i >= 1 ? itList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevIt2 = i >= 2 ? itList.ElementAtOrDefault(i - 2) : 0;
                    decimal prevIt3 = i >= 3 ? itList.ElementAtOrDefault(i - 3) : 0;
                    decimal prevVal = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    int dcPeriod = (int)Math.Ceiling(sp + 0.5m);
                    decimal iTrend = 0;
                    for (int j = 0; j <= dcPeriod - 1; j++)
                    {
                        decimal prevValue = i >= j ? stockDataClass.InputValues.ElementAtOrDefault(i - j) : 0;

                        iTrend += prevValue;
                    }
                    iTrend = dcPeriod != 0 ? iTrend / dcPeriod : iTrend;
                    itList.Add(iTrend);

                    decimal prevTrendLine = trendLineList.LastOrDefault();
                    decimal trendLine = ((4 * iTrend) + (3 * prevIt1) + (2 * prevIt2) + prevIt3) / 10;
                    trendLineList.Add(trendLine);

                    var signal = GetCompareSignal(currentValue - trendLine, prevVal - prevTrendLine);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (itList, trendLineList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateVolatilityQualityIndex(StockData stockDataClass, int days = 9)
        {
            //
            // @author LazyBear
            // @credits Thomas Stridsman - http://www.3pips.com/volatility-quality-index-vq/
            // If you use this code in its original/modified form, do drop me a note. 
            //
            //study("Volatility Quality Index [LazyBear]", shorttitle = "VQI_LB")
            //length_slow = input(9, title = "Fast EMA Length")
            //length_fast = input(200, title = "Slow EMA Length")
            //vqi_t = iff((tr != 0) and((high - low) != 0), (((close - close[1]) / tr) + ((close - open) / (high - low))) * 0.5, nz(vqi_t[1]))
            //vqi = abs(vqi_t) * ((close - close[1] + (close - open)) * 0.5)
            //vqi_sum = cum(vqi)
            //plot(vqi_sum, color = red, linewidth = 2)
            //plot(sma(vqi_sum, length_slow), color = green, linewidth = 2)
            //plot(sma(vqi_sum, length_fast), color = orange, linewidth = 2)
            List<decimal> vqiList = new();
            List<decimal> vqiSumList = new();
            List<decimal> vqiTList = new();
            List<decimal> vqiSumSlowSmaList = new();
            List<decimal> vqiSumFastSmaList = new();
            List<Signal> signalsList = new();

            try
            {
                decimal vqiSum = 0;
                int fastEmaLength = days;
                int slowEmaLength = MinOrMax((int)Math.Ceiling(fastEmaLength / 0.045));

                var trList = CalculateVortexIndicator(stockDataClass, days).Item5;

                for (int i = 0; i < stockDataClass.HighPrices.Count; i++)
                {
                    decimal currentHigh = stockDataClass.HighPrices.ElementAtOrDefault(i);
                    decimal currentLow = stockDataClass.LowPrices.ElementAtOrDefault(i);
                    decimal currentClose = stockDataClass.ClosePrices.ElementAtOrDefault(i);
                    decimal currentOpen = stockDataClass.OpenPrices.ElementAtOrDefault(i);
                    decimal prevClose = i >= 1 ? stockDataClass.ClosePrices.ElementAtOrDefault(i - 1) : 0;
                    decimal trueRange = trList.ElementAtOrDefault(i);

                    decimal prevVqiT = vqiTList.LastOrDefault();
                    decimal vqiT = trueRange != 0 && currentHigh - currentLow != 0 ?
                        (((currentClose - prevClose) / trueRange) + ((currentClose - currentOpen) / (currentHigh - currentLow))) * 0.5m : prevVqiT;
                    vqiTList.Add(vqiT);

                    decimal vqi = Math.Abs(vqiT) * ((currentClose - prevClose + (currentClose - currentOpen)) * 0.5m);
                    vqiList.Add(vqi);

                    decimal prevVqiSum = vqiSumList.LastOrDefault();
                    vqiSum += vqi;
                    vqiSumList.Add(vqiSum);

                    decimal prevVqiSumFastSma = vqiSumFastSmaList.LastOrDefault();
                    decimal vqiSumFastSma = vqiSumList.TakeLast(fastEmaLength).Average();
                    vqiSumFastSmaList.Add(vqiSumFastSma);

                    decimal vqiSumSlowSma = vqiSumList.TakeLast(slowEmaLength).Average();
                    vqiSumSlowSmaList.Add(vqiSumSlowSma);

                    var signal = GetCompareSignal(vqiSum - vqiSumFastSma, prevVqiSum - prevVqiSumFastSma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (vqiList, vqiTList, vqiSumList, vqiSumFastSmaList, vqiSumSlowSmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<Signal>) CalculateJrcFractalDimension(StockData stockDataClass, int days = 5)
        {
            //input = price, user defined, default is close
            //size = user defined, default is 20
            //count = user defined, default is 5
            //smoothP = user defined, default is 5
            //method = moving average (ma) = user defined, default is SMA
            //prev = previous, index = current bar number
            //log = natural logarithm

            //wind1 = (count - 1) * size;
            //wind2 = count * size;
            //nlog = Math.log(count);
            //highest = highest(index, size, high);
            //lowest = lowest(index, size, low);
            //priorC = price[index - size];
            //smallRange = Math.max(priorC, highest) - Math.min(priorC, lowest);
            //highest = highest(index, wind2, high);
            //lowest = lowest(index, wind2, low);
            //priorC = price[index - wind2];
            //bigRange = Math.max(priorC, highest) - Math.min(priorC, lowest);
            //prevSS = ifNull(smallRange, smallSum[index - 1]);   //returns smallRange on first try
            //priorSR = smallRange[index - wind1];
            //smallSum = prevSS + smallRange - priorSR;
            //if (smallSum lessThan 0) return;
            //temp = Math.log(bigRange / (smallSum / wind1));
            //fd = 2 - (temp / nlog);
            //Plot: jrcfd = ma(method, index, smoothP, fd);
            List<decimal> tempHighList = new();
            List<decimal> tempLowList = new();
            List<decimal> smallSumList = new();
            List<decimal> smallRangeList = new();
            List<decimal> tempList = new();
            List<decimal> bigRangeList = new();
            List<decimal> fdList = new();
            List<decimal> jrcfdList = new();
            List<decimal> jrcfdSignalList = new();
            List<Signal> signalsList = new();

            try
            {
                int count = days;
                int size = days * 4;
                int wind1 = MinOrMax((count - 1) * size);
                int wind2 = MinOrMax(count * size);
                int smoothP = count;
                decimal nLog = Log((double)count);

                var minMaxList = VolumeInputCheck(stockDataClass, size, true);
                var highestHighList = minMaxList.Item1;
                var lowestLowList = minMaxList.Item2;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal highest1 = highestHighList.ElementAtOrDefault(i);
                    tempHighList.Add(highest1);

                    decimal lowest1 = lowestLowList.ElementAtOrDefault(i);
                    tempLowList.Add(lowest1);

                    decimal prevValue1 = i >= size ? stockDataClass.InputValues.ElementAtOrDefault(i - size) : 0;

                    decimal smallRange = Math.Max(prevValue1, highest1) - Math.Min(prevValue1, lowest1);
                    smallRangeList.Add(smallRange);

                    decimal highest2 = tempHighList.TakeLast(wind2).Max();
                    decimal lowest2 = tempLowList.TakeLast(wind2).Min();
                    decimal prevValue2 = i >= wind2 ? stockDataClass.InputValues.ElementAtOrDefault(i - wind2) : 0;

                    decimal bigRange = Math.Max(prevValue2, highest2) - Math.Min(prevValue2, lowest2);
                    bigRangeList.Add(bigRange);

                    decimal prevSmallSum = i >= 1 ? smallSumList.LastOrDefault() : smallRange;
                    decimal prevSmallRange = i >= wind1 ? smallRangeList.ElementAtOrDefault(i - wind1) : 0;

                    decimal smallSum = prevSmallSum + smallRange - prevSmallRange;
                    smallSumList.Add(smallSum);

                    decimal value1 = wind1 != 0 ? smallSum / wind1 : 0;
                    decimal value2 = value1 != 0 ? bigRange / value1 : 0;

                    decimal temp = value2 > 0 ? Log(value2) : 0;
                    tempList.Add(temp);

                    decimal fd = nLog != 0 ? 2 - (temp / nLog) : 0;
                    fdList.Add(fd);

                    decimal prevJrcfd = jrcfdList.LastOrDefault();
                    decimal jrcfd = fdList.TakeLast(smoothP).Average();
                    jrcfdList.Add(jrcfd);

                    decimal prevJrcfdSignal = jrcfdSignalList.LastOrDefault();
                    decimal jrcfdSignal = jrcfdList.TakeLast(count).Average();
                    jrcfdSignalList.Add(jrcfdSignal);

                    var signal = GetCompareSignal(jrcfd - jrcfdSignal, prevJrcfd - prevJrcfdSignal, true);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (smallRangeList, bigRangeList, smallSumList, tempList, fdList, jrcfdList, jrcfdSignalList, signalsList);
        }

        public static (List<decimal>, List<Signal>) CalculateOCHistogram(StockData stockDataClass, string maType, int days = 10)
        {
            //input1 = price, user defined, default is closing price
            //input2 = price, user defined, default is opening price
            //method = moving average (ma), user defined, default is EMA
            //period1 = user defined, default is 10
            //period2 = user defined, default is 10
            //index = current bar number

            //ma1 = ma(method, index, period1, input1);
            //ma2 = ma(method, index, period2, input2);
            //PlotHist: oc = ma1 - ma2;
            List<decimal> ocHistogramList = new();
            List<Signal> signalsList = new();

            try
            {
                List<decimal> openEmaList = GetMovingAverageList(maType, stockDataClass.OpenPrices, stockDataClass, days);
                List<decimal> closeEmaList = GetMovingAverageList(maType, stockDataClass.ClosePrices, stockDataClass, days);

                for (int i = 0; i < stockDataClass.ClosePrices.Count; i++)
                {
                    decimal currentCloseEma = closeEmaList.ElementAtOrDefault(i);
                    decimal currentOpenEma = openEmaList.ElementAtOrDefault(i);

                    decimal prevOcHistogram = ocHistogramList.LastOrDefault();
                    decimal ocHistogram = currentCloseEma - currentOpenEma;
                    ocHistogramList.Add(ocHistogram);

                    var signal = GetCompareSignal(ocHistogram, prevOcHistogram);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (ocHistogramList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculatePercentChangeOscillator(StockData stockDataClass, int days)
        {
            //input = price, user defined, default is close
            //prev = previous, index = current bar number

            //prevP = price[index - 1];
            //prevPcc = pcc[index - 1];
            //if (prevP - 1 == 0) return;
            //Plot: pcc = prevPcc + price / (prevP - 1);
            List<decimal> percentChangeList = new();
            List<decimal> percentChangeEmaList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal prevPcc = percentChangeList.LastOrDefault();
                    decimal pcc = prevValue - 1 != 0 ? prevPcc + (currentValue / (prevValue - 1)) : 0;
                    percentChangeList.Add(pcc);

                    decimal prevPccEma = percentChangeEmaList.LastOrDefault();
                    decimal pccEma = CalculateExponentialMovingAverage(pcc, prevPccEma, days);
                    percentChangeEmaList.Add(pccEma);

                    var signal = GetCompareSignal(pcc - pccEma, prevPcc - prevPccEma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (percentChangeList, percentChangeEmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateSentimentZoneOscillator(StockData stockDataClass, int days = 14)
        {
            //input = price, user defined, default is closing price
            //method = moving average, user defined, default is TEMA
            //period = user defined, default is 14
            //longPeriod = user defined, default is 30
            //index = current bar number
            //fac = 95

            //factor = fac / 100;
            //prevPrice = price[index - 1];
            //if (price moreThan prevPrice) r = 1;
            //else r = -1;
            //sp = ma(method, index, period, R);
            //Plot1: szo = 100 * sp / period;
            //highest = highest(index, longPeriod, SZO);
            //lowest = lowest(index, longPeriod, SZO);
            //range = highest - lowest;
            //Plot2: ob = lowest + range * factor;
            //Plot3: os = highest - range * factor;
            //Signals
            //sell = szo moreThan ob OR szo moreThan topGuide;
            //buy = szo lessThan os OR szo lessThan bottG;
            decimal factor = 0.95m;
            List<decimal> rList = new();
            List<decimal> szoList = new();
            List<decimal> obList = new();
            List<decimal> osList = new();
            List<decimal> spList = new();
            List<decimal> firstEmaList = new();
            List<decimal> secondEmaList = new();
            List<decimal> thirdEmaList = new();
            List<Signal> signalsList = new();

            try
            {
                int period = days;
                int longPeriod = (int)Math.Ceiling(period / 0.4666);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevSzo1 = i >= 1 ? szoList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevSzo2 = i >= 2 ? szoList.ElementAtOrDefault(i - 2) : 0;

                    decimal r = currentValue > prevValue ? 1 : -1;
                    rList.Add(r);

                    decimal firstEma = CalculateExponentialMovingAverage(r, firstEmaList.LastOrDefault(), period);
                    firstEmaList.Add(firstEma);

                    decimal secondEma = CalculateExponentialMovingAverage(firstEma, secondEmaList.LastOrDefault(), period);
                    secondEmaList.Add(secondEma);

                    decimal thirdEma = CalculateExponentialMovingAverage(secondEma, thirdEmaList.LastOrDefault(), period);
                    thirdEmaList.Add(thirdEma);

                    decimal sp = (3 * firstEma) - (3 * secondEma) + thirdEma;
                    spList.Add(sp);

                    decimal szo = 100 * sp / days;
                    szoList.Add(szo);

                    var list = szoList.TakeLast(longPeriod).ToList();
                    decimal highest = list.Max();
                    decimal lowest = list.Min();
                    decimal range = highest - lowest;

                    decimal ob = lowest + (range * factor);
                    obList.Add(ob);

                    decimal os = highest - (range * factor);
                    osList.Add(os);

                    var signal = GetRsiSignal(szo - prevSzo1, prevSzo1 - prevSzo2, szo, prevSzo1, ob, os, true);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (rList, firstEmaList, secondEmaList, thirdEmaList, spList, szoList, obList, osList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateEhlersLaguerreRelativeStrengthIndex(StockData stockDataClass)
        {
            //input = price, user defined, default is close
            //gamma = user defined factor, default is 0.5
            //prev = previous, index = current bar number

            //prevL0 = ifNull(price, lo[index - 1]);  //feedback ingredent
            //prevL1 = ifNull(price, l1[index - 1]);  //feedback ingredent
            //prevL2 = ifNull(price, l2[index - 1]);  //feedback ingredent
            //prevL3 = ifNull(price, l3[index - 1]);  //feedback ingredent

            //l0 = (1 - gamma) * price + gamma * prevL0;
            //l1 = -gamma * l0 + prevL0 + gamma * prevL1;
            //l2 = -gamma * l1 + prevL1 + gamma * prevL2;
            //l3 = -gamma * l2 + prevL2 + gamma * prevL3;

            //if (l0 moreOrEqual l1) cu = l0 - l1;
            //else cd = l1 - l0;

            //if (l1 moreOrEqual l2) cu = cu + l1 - l2;
            //else cd = cd + l2 - l1;

            //if (l2 moreOrEqual l3) cu = cu + l2 - l3;
            //else cd = cd + l3 - l2;

            //if (cu + cd notEqual 0.0) rsi = cu / (cu + cd);
            //plot rsi;
            decimal gamma = 0.5m;
            List<decimal> laguerreRsiList = new();
            List<decimal> l0List = new();
            List<decimal> l1List = new();
            List<decimal> l2List = new();
            List<decimal> l3List = new();
            List<decimal> cuList = new();
            List<decimal> cdList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevL0 = i >= 1 ? l0List.LastOrDefault() : currentValue;
                    decimal prevL1 = i >= 1 ? l1List.LastOrDefault() : currentValue;
                    decimal prevL2 = i >= 1 ? l2List.LastOrDefault() : currentValue;
                    decimal prevL3 = i >= 1 ? l3List.LastOrDefault() : currentValue;
                    decimal prevRsi1 = i >= 1 ? laguerreRsiList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevRsi2 = i >= 2 ? laguerreRsiList.ElementAtOrDefault(i - 2) : 0;

                    decimal l0 = ((1 - gamma) * currentValue) + (gamma * prevL0);
                    l0List.Add(l0);

                    decimal l1 = (-1 * gamma * l0) + prevL0 + (gamma * prevL1);
                    l1List.Add(l1);

                    decimal l2 = (-1 * gamma * l1) + prevL1 + (gamma * prevL2);
                    l2List.Add(l2);

                    decimal l3 = (-1 * gamma * l2) + prevL2 + (gamma * prevL3);
                    l3List.Add(l3);

                    decimal cu = (l0 >= l1 ? l0 - l1 : 0) + (l1 >= l2 ? l1 - l2 : 0) + (l2 >= l3 ? l2 - l3 : 0);
                    cuList.Add(cu);

                    decimal cd = (l0 >= l1 ? 0 : l1 - l0) + (l1 >= l2 ? 0 : l2 - l1) + (l2 >= l3 ? 0 : l3 - l2);
                    cdList.Add(cd);

                    decimal laguerreRsi = cu + cd != 0 ? MinOrMax(cu / (cu + cd), 1, 0) : 0;
                    laguerreRsiList.Add(laguerreRsi);

                    var signal = GetRsiSignal(laguerreRsi - prevRsi1, prevRsi1 - prevRsi2, laguerreRsi, prevRsi1, 0.8m, 0.2m);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (l0List, l1List, l2List, l3List, cuList, cdList, laguerreRsiList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateEhlersLaguerreRelativeStrengthIndexWithSelfAdjustingAlpha(StockData stockDataClass, int days = 13)
        {
            //@version=3
            // Copyright (c) 2018-present, Alex Orekhov (everget)
            // Laguerre RSI (Self-Adjusting Alpha with Fractals Energy) script may be freely distributed under the MIT license.
            //study("Laguerre RSI (Self-Adjusting Alpha with Fractals Energy)", shorttitle = "LRSI")

            //alpha = input(title = "Alpha", type = float, defval = 0.7, minval = 0, step = 0.1)
            //highlightCrossovers = input(title = "Highlight Bands Crossovers ?", type = bool, defval = true)
            //applyFractalsEnergy = input(title = "Apply Fractals Energy ?", type = bool, defval = true)
            //feLength = input(title = "Fractals Energy Length", type = integer, defval = 13)
            //applyNormalization = input(title = "Apply Normalization to [0, 100] ?", type = bool, defval = false)
            //src = input(title = "Source", type = source, defval = close)

            //OC = (open + nz(close[1])) / 2
            //HC = max(high, nz(close[1]))
            //LC = min(low, nz(close[1]))

            //feSrc = (OC + HC + LC + close) / 4
            //feAlpha = log(sum((HC - LC) / (highest(feLength) - lowest(feLength)), feLength)) / log(feLength)

            //lrsiAlpha = applyFractalsEnergy ? feAlpha : alpha

            //L0 = 0.0
            //L0:= lrsiAlpha * (applyFractalsEnergy ? feSrc : src) + (1 - lrsiAlpha) * nz(L0[1])

            //L1 = 0.0
            //L1:= -(1 - lrsiAlpha) * L0 + nz(L0[1]) + (1 - lrsiAlpha) * nz(L1[1])

            //L2 = 0.0
            //L2:= -(1 - lrsiAlpha) * L1 + nz(L1[1]) + (1 - lrsiAlpha) * nz(L2[1])

            //L3 = 0.0
            //L3:= -(1 - lrsiAlpha) * L2 + nz(L2[1]) + (1 - lrsiAlpha) * nz(L3[1])

            //CU = 0.0
            //CU:= (L0 >= L1 ? L0 - L1 : 0) + (L1 >= L2 ? L1 - L2 : 0) + (L2 >= L3 ? L2 - L3 : 0)

            //CD = 0.0
            //CD:= (L0 >= L1 ? 0 : L1 - L0) + (L1 >= L2 ? 0 : L2 - L1) + (L2 >= L3 ? 0 : L3 - L2)

            //lrsi = CU + CD != 0
            //? applyNormalization ? 100 * CU / (CU + CD) : CU / (CU + CD)
            //: 0

            //mult = (applyNormalization ? 100 : 1)

            //ob = 0.8 * mult
            //middle = 0.5 * mult
            //os = 0.2 * mult

            //lrsiColor = lrsi > ob ? #3c78d8 : lrsi < os ? #ff3e7d : #93c47d
            //plot(lrsi, title = "LRSI", linewidth = 2, color = lrsiColor, transp = 0)
            //plot(applyFractalsEnergy ? (applyNormalization ? 100 * feAlpha : feAlpha) : na, title = "FE Alpha", linewidth = 2, color =#674ea7, transp=0)

            //obLevel = plot(ob, title = "OB", color =#686868)
            //plot(middle, title = "Middle", color =#686868)
            //osLevel = plot(os, title = "OS", color =#686868)

            //plotshape(crossunder(lrsi, ob) and highlightCrossovers ? ob : na, title = "Overbought Crossunder", location = location.absolute, style = shape.circle, size = size.tiny, color = red, transp = 20)
            //plotshape(crossover(lrsi, os) and highlightCrossovers ? os : na, title = "Oversold Crossover", location = location.absolute, style = shape.circle, size = size.tiny, color = green, transp = 20)
            List<decimal> laguerreRsiList = new();
            List<decimal> ocList = new();
            List<decimal> hcList = new();
            List<decimal> lcList = new();
            List<decimal> feValueList = new();
            List<decimal> alphaList = new();
            List<decimal> ratioList = new();
            List<decimal> ratioSumList = new();
            List<decimal> l0List = new();
            List<decimal> l1List = new();
            List<decimal> l2List = new();
            List<decimal> l3List = new();
            List<decimal> cuList = new();
            List<decimal> cdList = new();
            List<Signal> signalsList = new();

            try
            {
                var minMaxList = VolumeInputCheck(stockDataClass, days, true);
                var highestList = minMaxList.Item1;
                var lowestList = minMaxList.Item2;

                for (int i = 0; i < stockDataClass.HighPrices.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal currentHigh = stockDataClass.HighPrices.ElementAtOrDefault(i);
                    decimal currentLow = stockDataClass.LowPrices.ElementAtOrDefault(i);
                    decimal currentOpen = stockDataClass.OpenPrices.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal highestHigh = highestList.ElementAtOrDefault(i);
                    decimal lowestLow = lowestList.ElementAtOrDefault(i);
                    decimal prevRsi1 = i >= 1 ? laguerreRsiList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevRsi2 = i >= 2 ? laguerreRsiList.ElementAtOrDefault(i - 2) : 0;

                    decimal oc = (currentOpen + prevValue) / 2;
                    ocList.Add(oc);

                    decimal hc = Math.Max(currentHigh, prevValue);
                    hcList.Add(hc);

                    decimal lc = Math.Min(currentLow, prevValue);
                    lcList.Add(lc);

                    decimal feValue = (oc + hc + lc + currentValue) / 4;
                    feValueList.Add(feValue);

                    decimal ratio = highestHigh - lowestLow != 0 ? (hc - lc) / (highestHigh - lowestLow) : 0;
                    ratioList.Add(ratio);

                    decimal ratioSum = ratioList.TakeLast(days).Sum();
                    ratioSumList.Add(ratioSum);

                    decimal alpha = ratioSum > 0 ? MinOrMax(Log(ratioSum) / Log((double)days), 0.99m, 0.01m) : 0.01m;
                    alphaList.Add(alpha);

                    decimal prevL0 = l0List.LastOrDefault();
                    decimal l0 = (alpha * feValue) + ((1 - alpha) * prevL0);
                    l0List.Add(l0);

                    decimal prevL1 = l1List.LastOrDefault();
                    decimal l1 = (-(1 - alpha) * l0) + prevL0 + ((1 - alpha) * prevL1);
                    l1List.Add(l1);

                    decimal prevL2 = l2List.LastOrDefault();
                    decimal l2 = (-(1 - alpha) * l1) + prevL1 + ((1 - alpha) * prevL2);
                    l2List.Add(l2);

                    decimal prevL3 = l3List.LastOrDefault();
                    decimal l3 = (-(1 - alpha) * l2) + prevL2 + ((1 - alpha) * prevL3);
                    l3List.Add(l3);

                    decimal cu = (l0 >= l1 ? l0 - l1 : 0) + (l1 >= l2 ? l1 - l2 : 0) + (l2 >= l3 ? l2 - l3 : 0);
                    cuList.Add(cu);

                    decimal cd = (l0 >= l1 ? 0 : l1 - l0) + (l1 >= l2 ? 0 : l2 - l1) + (l2 >= l3 ? 0 : l3 - l2);
                    cdList.Add(cd);

                    decimal laguerreRsi = cu + cd != 0 ? MinOrMax(cu / (cu + cd), 1, 0) : 0;
                    laguerreRsiList.Add(laguerreRsi);

                    var signal = GetRsiSignal(laguerreRsi - prevRsi1, prevRsi1 - prevRsi2, laguerreRsi, prevRsi1, 0.8m, 0.2m);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (ocList, hcList, lcList, feValueList, ratioList, ratioSumList, alphaList, l0List, l1List, l2List, l3List, cuList, cdList, laguerreRsiList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateEhlersLaguerreFilter(StockData stockDataClass)
        {
            //input = price, user defined, default is midpoint
            //alpha = user defined factor, default is 0.2
            //prev = previous, index = current bar number

            //priorP1 = price[index - 1];
            //priorP2 = price[index - 2];
            //priorP3 = price[index - 3];
            //prevL0 = ifNull(price, lo[index - 1]);  //feedback ingredent
            //prevL1 = ifNull(price, l1[index - 1]);  //feedback ingredent
            //prevL2 = ifNull(price, l2[index - 1]);  //feedback ingredent
            //prevL3 = ifNull(price, l3[index - 1]);  //feedback ingredent
            //l0 = alpha * price + (1 - alpha) * prevL0;
            //l1 = -(1 - alpha) * l0 + prevL0 + (1 - alpha) * prevL1;
            //l2 = -(1 - alpha) * l1 + prevL1 + (1 - alpha) * prevL2;
            //l3 = -(1 - alpha) * l2 + prevL2 + (1 - alpha) * prevL3;
            //Plot1: filt = (l0 + 2 * l1 + 2 * l2 + l3) / 6;
            //Plot2: fir = (price + 2 * priorP1 + 2 * priorP2 + priorP3) / 6;
            decimal alpha = 0.2m;
            List<decimal> filterList = new();
            List<decimal> firList = new();
            List<decimal> l0List = new();
            List<decimal> l1List = new();
            List<decimal> l2List = new();
            List<decimal> l3List = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevP1 = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevP2 = i >= 2 ? stockDataClass.InputValues.ElementAtOrDefault(i - 2) : 0;
                    decimal prevP3 = i >= 3 ? stockDataClass.InputValues.ElementAtOrDefault(i - 3) : 0;
                    decimal prevL0 = i >= 1 ? l0List.LastOrDefault() : currentValue;
                    decimal prevL1 = i >= 1 ? l1List.LastOrDefault() : currentValue;
                    decimal prevL2 = i >= 1 ? l2List.LastOrDefault() : currentValue;
                    decimal prevL3 = i >= 1 ? l3List.LastOrDefault() : currentValue;

                    decimal l0 = (alpha * currentValue) + ((1 - alpha) * prevL0);
                    l0List.Add(l0);

                    decimal l1 = (-1 * (1 - alpha) * l0) + prevL0 + ((1 - alpha) * prevL1);
                    l1List.Add(l1);

                    decimal l2 = (-1 * (1 - alpha) * l1) + prevL1 + ((1 - alpha) * prevL2);
                    l2List.Add(l2);

                    decimal l3 = (-1 * (1 - alpha) * l2) + prevL2 + ((1 - alpha) * prevL3);
                    l3List.Add(l3);

                    decimal prevFilter = filterList.LastOrDefault();
                    decimal filter = (l0 + (2 * l1) + (2 * l2) + l3) / 6;
                    filterList.Add(filter);

                    decimal prevFir = firList.LastOrDefault();
                    decimal fir = (currentValue + (2 * prevP1) + (2 * prevP2) + prevP3) / 6;
                    firList.Add(fir);

                    var signal = GetCompareSignal(filter - fir, prevFilter - prevFir);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (l0List, l1List, l2List, l3List, filterList, firList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<decimal>, List<Signal>) CalculateEhlersAdaptiveLaguerreFilter(StockData stockDataClass, int days = 5)
        {
            //@version=3
            // Copyright (c) 2018-present, Alex Orekhov (everget)
            //study("Adaptive Laguerre Filter", shorttitle = "ALF", overlay = true)

            //length = input(title = "Length", type = integer, defval = 14)
            //medianLength = input(title = "Median Length", type = integer, defval = 5)
            //src = input(title = "Source", type = source, defval = close)
            //highlightMovements = input(title = "Highlight Movements ?", type = bool, defval = true)
            //awaitBarConfirmation = input(title = "Await Bar Confirmation ?", type = bool, defval = true)

            //_median(src, length) =>
            //    percentile_nearest_rank(src, length, 50)

            //alf = 0.0

            //diff = abs(src - nz(alf[1], src))

            //HH = 0.0
            //HH:= diff

            //LL = 0.0
            //LL:= diff

            //for i = 0 to length - 1
            //    if nz(diff[i]) > HH
            //        HH:= nz(diff[i])

            //    if  nz(diff[i]) < LL
            //        LL:= nz(diff[i])

            //alpha = 0.0
            //alpha:= HH - LL != 0.0 ? _median((diff - LL) / (HH - LL), medianLength) : nz(alpha[1], 2 / (length + 1))
            //alpha2 = (1 - alpha)

            //L0 = 0.0
            //L0:= alpha * src + alpha2 * nz(L0[1], src)

            //L1 = 0.0
            //L1:= nz(L0[1], src) + alpha2 * (nz(L1[1], src) - L0)

            //L2 = 0.0
            //L2:= nz(L1[1], src) + alpha2 * (nz(L2[1], src) - L1)

            //L3 = 0.0
            //L3:= nz(L2[1], src) + alpha2 * (nz(L3[1], src) - L2)

            //alf:= (L0 + 2 * L1 + 2 * L2 + L3) / 6

            //alfColor = highlightMovements ? (alf > alf[1] and(awaitBarConfirmation ? barstate.isconfirmed : true) ? green : red) : #6d1e7f
            //plot(alf, title = "ALF", linewidth = 2, color = alfColor, transp = 0)

            //alertCond = alfColor != alfColor[1] and(awaitBarConfirmation ? barstate.isconfirmed : true)
            //alertcondition(alertCond, title = "Alert On Color Change", message = "ALF has changed its color!")
            List<decimal> filterList = new();
            List<decimal> l0List = new();
            List<decimal> l1List = new();
            List<decimal> l2List = new();
            List<decimal> l3List = new();
            List<decimal> diffList = new();
            List<decimal> midList = new();
            List<decimal> alphaList = new();
            List<Signal> signalsList = new();

            try
            {
                int medianLength = days;
                int length = (int)Math.Ceiling(days / 0.3572);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevL0 = i >= 1 ? l0List.LastOrDefault() : currentValue;
                    decimal prevL1 = i >= 1 ? l1List.LastOrDefault() : currentValue;
                    decimal prevL2 = i >= 1 ? l2List.LastOrDefault() : currentValue;
                    decimal prevL3 = i >= 1 ? l3List.LastOrDefault() : currentValue;
                    decimal prevFilter = i >= 1 ? filterList.LastOrDefault() : currentValue;

                    decimal diff = Math.Abs(currentValue - prevFilter);
                    diffList.Add(diff);

                    var list = diffList.TakeLast(length).ToList();
                    decimal highestHigh = list.Max();
                    decimal lowestLow = list.Min();

                    decimal mid = highestHigh - lowestLow != 0 ? (diff - lowestLow) / (highestHigh - lowestLow) : 0;
                    midList.Add(mid);

                    decimal prevAlpha = i >= 1 ? alphaList.LastOrDefault() : (decimal)2 / (length + 1);
                    decimal alpha = mid != 0 ? Median(midList.TakeLast(medianLength)) : prevAlpha;
                    alphaList.Add(alpha);

                    decimal l0 = (alpha * currentValue) + ((1 - alpha) * prevL0);
                    l0List.Add(l0);

                    decimal l1 = (-1 * (1 - alpha) * l0) + prevL0 + ((1 - alpha) * prevL1);
                    l1List.Add(l1);

                    decimal l2 = (-1 * (1 - alpha) * l1) + prevL1 + ((1 - alpha) * prevL2);
                    l2List.Add(l2);

                    decimal l3 = (-1 * (1 - alpha) * l2) + prevL2 + ((1 - alpha) * prevL3);
                    l3List.Add(l3);

                    decimal filter = (l0 + (2 * l1) + (2 * l2) + l3) / 6;
                    filterList.Add(filter);

                    var signal = GetCompareSignal(currentValue - filter, prevValue - prevFilter);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (diffList, midList, alphaList, l0List, l1List, l2List, l3List, filterList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateEhlersMotherOfAdaptiveMovingAverages(StockData stockDataClass)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Ehlers Mother Of Adaptive Moving Averages [CC] script may be freely distributed under the MIT license.
            //study("Ehlers Mother Of Adaptive Moving Averages [CC]", overlay = true)

            //inp = input(title = "Source", type = input.source, defval = hl2)
            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //src = security(syminfo.tickerid, res, inp[rep ? 0 : barstate.isrealtime ? 1 : 0])[rep ? 0 : barstate.isrealtime ? 0 : 1]
            //fastLimit = input(title = "FastLimit", type = input.float, defval = 0.5, minval = 0.01, step = 0.01)
            //slowLimit = input(title = "SlowLimit", type = input.float, defval = 0.05, minval = 0.01, step = 0.01)

            //pi = 2 * asin(1)
            //period = 0.0
            //smooth = ((4 * src) + (3 * nz(src[1])) + (2 * nz(src[2])) + nz(src[3])) / 10
            //detrender = ((0.0962 * smooth) + (0.5769 * nz(smooth[2])) - (0.5769 * nz(smooth[4])) - (0.0962 * nz(smooth[6]))) * ((0.075 * nz(period[1])) + 0.54)

            //q1 = ((0.0962 * detrender) + (0.5769 * nz(detrender[2])) - (0.5769 * nz(detrender[4])) - (0.0962 * nz(detrender[6]))) * ((0.075 * nz(period[1])) + 0.54)
            //i1 = nz(detrender[3])

            //jI = ((0.0962 * i1) + (0.5769 * nz(i1[2])) - (0.5769 * nz(i1[4])) - (0.0962 * nz(i1[6]))) * ((0.075 * nz(period[1])) + 0.54)
            //jQ = ((0.0962 * q1) + (0.5769 * nz(q1[2])) - (0.5769 * nz(q1[4])) - (0.0962 * nz(q1[6]))) * ((0.075 * nz(period[1])) + 0.54)

            //i2 = i1 - jQ
            //i2:= (0.2 * i2) + (0.8 * nz(i2[1]))
            //q2 = q1 + jI
            //q2:= (0.2 * q2) + (0.8 * nz(q2[1]))

            //re = (i2 * nz(i2[1])) + (q2 * nz(q2[1]))
            //re:= (0.2 * re) + (0.8 * nz(re[1]))
            //im = (i2 * nz(q2[1])) - (q2 * nz(i2[1]))
            //im:= (0.2 * im) + (0.8 * nz(im[1]))

            //period:= im != 0 and re != 0 ? 2 * pi / atan(im / re) : 0
            //period:= min(max(period, 0.67 * nz(period[1])), 1.5 * nz(period[1]))
            //period:= min(max(period, 6), 50)
            //period:= (0.2 * period) + (0.8 * nz(period[1]))

            //smoothPeriod = 0.0
            //smoothPeriod:= (0.33 * period) + (0.67 * nz(smoothPeriod[1]))

            //phase = i1 != 0 ? atan(q1 / i1) : 0
            //deltaPhase = nz(phase[1]) - phase
            //deltaPhase:= deltaPhase < 1 ? 1 : deltaPhase

            //alpha = fastLimit / deltaPhase
            //alpha:= alpha < slowLimit ? slowLimit : alpha

            //mama = 0.0
            //mama:= (alpha * src) + ((1 - alpha) * nz(mama[1]))

            //fama = 0.0
            //fama:= (0.5 * alpha * mama) + ((1 - (0.5 * alpha)) * nz(fama[1]))

            //sig = mama > fama ? 1 : mama < fama ? -1 : 0
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //mamaColor = sig > 0 ? color.green : sig < 0 ? color.red : color.black
            //barcolor(bar ? mamaColor : na)
            //plot(mama, title = "MAMA", color = mamaColor, linewidth = 2)
            //plot(fama, title = "FAMA", color = color.black, linewidth = 1)
            decimal fast = 0.5m, slow = 0.05m;
            List<decimal> famaList = new();
            List<decimal> mamaList = new();
            List<decimal> i2List = new();
            List<decimal> q2List = new();
            List<decimal> reList = new();
            List<decimal> imList = new();
            List<decimal> sPrdList = new();
            List<decimal> phaseList = new();
            List<decimal> periodList = new();
            List<decimal> smoothList = new();
            List<decimal> detList = new();
            List<decimal> q1List = new();
            List<decimal> i1List = new();
            List<decimal> j1List = new();
            List<decimal> jqList = new();
            List<decimal> deltaPhaseList = new();
            List<decimal> alphaList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevPrice1 = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal previ2 = i >= 1 ? i2List.ElementAtOrDefault(i - 1) : 0;
                    decimal prevq2 = i >= 1 ? q2List.ElementAtOrDefault(i - 1) : 0;
                    decimal prevRe = i >= 1 ? reList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevIm = i >= 1 ? imList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevSprd = i >= 1 ? sPrdList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevPhase = i >= 1 ? phaseList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevPeriod = i >= 1 ? periodList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevPrice2 = i >= 2 ? stockDataClass.InputValues.ElementAtOrDefault(i - 2) : 0;
                    decimal prevPrice3 = i >= 3 ? stockDataClass.InputValues.ElementAtOrDefault(i - 3) : 0;
                    decimal prevs2 = i >= 2 ? smoothList.ElementAtOrDefault(i - 2) : 0;
                    decimal prevd2 = i >= 2 ? detList.ElementAtOrDefault(i - 2) : 0;
                    decimal prevq1x2 = i >= 2 ? q1List.ElementAtOrDefault(i - 2) : 0;
                    decimal previ1x2 = i >= 2 ? i1List.ElementAtOrDefault(i - 2) : 0;
                    decimal prevd3 = i >= 3 ? detList.ElementAtOrDefault(i - 3) : 0;
                    decimal prevs4 = i >= 4 ? smoothList.ElementAtOrDefault(i - 4) : 0;
                    decimal prevd4 = i >= 4 ? detList.ElementAtOrDefault(i - 4) : 0;
                    decimal prevq1x4 = i >= 4 ? q1List.ElementAtOrDefault(i - 4) : 0;
                    decimal previ1x4 = i >= 4 ? i1List.ElementAtOrDefault(i - 4) : 0;
                    decimal prevs6 = i >= 6 ? smoothList.ElementAtOrDefault(i - 6) : 0;
                    decimal prevd6 = i >= 6 ? detList.ElementAtOrDefault(i - 6) : 0;
                    decimal prevq1x6 = i >= 6 ? q1List.ElementAtOrDefault(i - 6) : 0;
                    decimal previ1x6 = i >= 6 ? i1List.ElementAtOrDefault(i - 6) : 0;
                    decimal prevMama = i >= 1 ? mamaList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevFama = i >= 1 ? famaList.ElementAtOrDefault(i - 1) : 0;

                    decimal smooth = ((4 * currentValue) + (3 * prevPrice1) + (2 * prevPrice2) + prevPrice3) / 10;
                    smoothList.Add(smooth);

                    decimal det = ((0.0962m * smooth) + (0.5769m * prevs2) - (0.5769m * prevs4) - (0.0962m * prevs6)) * ((0.075m * prevPeriod) + 0.54m);
                    detList.Add(det);

                    decimal q1 = ((0.0962m * det) + (0.5769m * prevd2) - (0.5769m * prevd4) - (0.0962m * prevd6)) * ((0.075m * prevPeriod) + 0.54m);
                    q1List.Add(q1);

                    decimal i1 = prevd3;
                    i1List.Add(i1);

                    decimal j1 = ((0.0962m * i1) + (0.5769m * previ1x2) - (0.5769m * previ1x4) - (0.0962m * previ1x6)) * ((0.075m * prevPeriod) + 0.54m);
                    j1List.Add(j1);

                    decimal jq = ((0.0962m * q1) + (0.5769m * prevq1x2) - (0.5769m * prevq1x4) - (0.0962m * prevq1x6)) * ((0.075m * prevPeriod) + 0.54m);
                    jqList.Add(jq);

                    decimal i2 = i1 - jq;
                    i2 = (0.2m * i2) + (0.8m * previ2);
                    i2List.Add(i2);

                    decimal q2 = q1 + j1;
                    q2 = (0.2m * q2) + (0.8m * prevq2);
                    q2List.Add(q2);

                    decimal re = (i2 * previ2) + (q2 * prevq2);
                    re = (0.2m * re) + (0.8m * prevRe);
                    reList.Add(re);

                    decimal im = (i2 * prevq2) - (q2 * previ2);
                    im = (0.2m * im) + (0.8m * prevIm);
                    imList.Add(im);

                    var atan = re != 0 ? Atan(im / re) : 0;
                    decimal period = atan != 0 ? 2 * (decimal)Math.PI / atan : 0;
                    period = MinOrMax(period, 1.5m * prevPeriod, 0.67m * prevPeriod);
                    period = MinOrMax(period, 50, 6);
                    period = (0.2m * period) + (0.8m * prevPeriod);
                    periodList.Add(period);

                    decimal sPrd = (0.33m * period) + (0.67m * prevSprd);
                    sPrdList.Add(sPrd);

                    decimal phase = i1 != 0 ? 180 / (decimal)Math.PI * Atan(q1 / i1) : 0;
                    phaseList.Add(phase);

                    decimal deltaPhase = prevPhase - phase < 1 ? 1 : prevPhase - phase;
                    deltaPhaseList.Add(deltaPhase);

                    decimal alpha = deltaPhase != 0 ? fast / deltaPhase : 0;
                    alpha = alpha < slow ? slow : alpha;
                    alphaList.Add(alpha);

                    decimal mama = (alpha * currentValue) + ((1 - alpha) * prevMama);
                    mamaList.Add(mama);

                    decimal fama = (0.5m * alpha * mama) + ((1 - (0.5m * alpha)) * prevFama);
                    famaList.Add(fama);

                    var signal = GetCompareSignal(mama - fama, prevMama - prevFama);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (smoothList, detList, q1List, i1List, j1List, jqList, i2List, q2List, reList, imList, periodList, sPrdList, phaseList, deltaPhaseList, alphaList,
                famaList, mamaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateEhlersAdaptiveRelativeStrengthIndexV1(StockData stockDataClass)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Ehlers Adaptive Relative Strength Index V1 [CC] script may be freely distributed under the MIT license.
            //study("Ehlers Adaptive Relative Strength Index V1 [CC]", overlay = false)

            //inp = input(title = "Source", type = input.source, defval = hl2)
            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //src = security(syminfo.tickerid, res, inp[rep ? 0 : barstate.isrealtime ? 1 : 0])[rep ? 0 : barstate.isrealtime ? 0 : 1]
            //cycPart = input(title = "CycPart", type = input.float, defval = 0.5, minval = 0.01, step = 0.01)
            //obLevel = input(title = "ObLevel", type = input.integer, defval = 70, minval = 1)
            //osLevel = input(title = "OsLevel", type = input.integer, defval = 30, minval = 1)

            //pi = 2 * asin(1)
            //period = 0.0
            //smooth = ((4 * src) + (3 * nz(src[1])) + (2 * nz(src[2])) + nz(src[3])) / 10
            //detrender = ((0.0962 * smooth) + (0.5769 * nz(smooth[2])) - (0.5769 * nz(smooth[4])) - (0.0962 * nz(smooth[6]))) * ((0.075 * nz(period[1])) + 0.54)

            //q1 = ((0.0962 * detrender) + (0.5769 * nz(detrender[2])) - (0.5769 * nz(detrender[4])) - (0.0962 * nz(detrender[6]))) * ((0.075 * nz(period[1])) + 0.54)
            //i1 = nz(detrender[3])

            //jI = ((0.0962 * i1) + (0.5769 * nz(i1[2])) - (0.5769 * nz(i1[4])) - (0.0962 * nz(i1[6]))) * ((0.075 * nz(period[1])) + 0.54)
            //jQ = ((0.0962 * q1) + (0.5769 * nz(q1[2])) - (0.5769 * nz(q1[4])) - (0.0962 * nz(q1[6]))) * ((0.075 * nz(period[1])) + 0.54)

            //i2 = i1 - jQ
            //i2:= (0.2 * i2) + (0.8 * nz(i2[1]))
            //q2 = q1 + jI
            //q2:= (0.2 * q2) + (0.8 * nz(q2[1]))

            //re = (i2 * nz(i2[1])) + (q2 * nz(q2[1]))
            //re:= (0.2 * re) + (0.8 * nz(re[1]))
            //im = (i2 * nz(q2[1])) - (q2 * nz(i2[1]))
            //im:= (0.2 * im) + (0.8 * nz(im[1]))

            //period:= im != 0 and re != 0 ? 2 * pi / atan(im / re) : 0
            //period:= min(max(period, 0.67 * nz(period[1])), 1.5 * nz(period[1]))
            //period:= min(max(period, 6), 50)
            //period:= (0.2 * period) + (0.8 * nz(period[1]))

            //smoothPeriod = 0.0
            //smoothPeriod:= (0.33 * period) + (0.67 * nz(smoothPeriod[1]))

            //cu = 0.0, cd = 0.0
            //for i = 0 to ceil(cycPart * smoothPeriod) - 1
            //    price = nz(src[i])
            //    pPrice = nz(src[i + 1])

            //    cu := cu + (price - pPrice > 0 ? price - pPrice : 0)
            //    cd := cd + (price - pPrice < 0 ? pPrice - price : 0)

            //k = 2 / (smoothPeriod + 1)
            //arsi = cu + cd != 0 ? 100 * cu / (cu + cd) : 0
            //arsi := (arsi * k) + (nz(arsi[1]) * (1 - k))

            //hline(obLevel, color = color.green)
            //hline(osLevel, color = color.red)
            //slo = arsi - nz(arsi[1])
            //sig = slo > 0 or(nz(arsi[1]) < osLevel and arsi > osLevel) ? slo > nz(slo[1]) ? 2 : 1 :
            //      slo < 0 or(nz(arsi[1]) > obLevel and arsi < obLevel) ? slo < nz(slo[1]) ? -2 : -1 : 0
            //alertcondition(crossover(sig, 1), "Strong Buy Signal", "Strong Bullish Change Detected")
            //alertcondition(crossunder(sig, -1), "Strong Sell Signal", "Strong Bearish Change Detected")
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //arsiColor = sig > 1 ? color.green : sig > 0 ? color.lime : sig < -1 ? color.maroon : sig < 0 ? color.red : color.black
            //barcolor(bar ? arsiColor : na)
            //plot(arsi, title = "ARSI", color = arsiColor, linewidth = 2)
            List<decimal> arsiList = new();
            List<decimal> arsiEmaList = new();
            List<decimal> cuList = new();
            List<decimal> cdList = new();
            List<Signal> signalsList = new();

            try
            {
                decimal cycPart = 0.5m;

                var spList = CalculateEhlersMotherOfAdaptiveMovingAverages(stockDataClass).Item12;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal sp = spList.ElementAtOrDefault(i);
                    decimal prevArsi1 = i >= 1 ? arsiEmaList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevArsi2 = i >= 2 ? arsiEmaList.ElementAtOrDefault(i - 2) : 0;

                    decimal cu = 0, cd = 0;
                    for (int j = 0; j < (int)Math.Ceiling(cycPart * sp); j++)
                    {
                        var price = i >= j ? stockDataClass.InputValues.ElementAtOrDefault(i - j) : 0;
                        var pPrice = i >= j + 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - (j + 1)) : 0;

                        cu += price - pPrice > 0 ? price - pPrice : 0;
                        cd += price - pPrice < 0 ? pPrice - price : 0;
                    }
                    cuList.Add(cu);
                    cdList.Add(cd);

                    decimal arsi = cu + cd != 0 ? 100 * cu / (cu + cd) : 0;
                    arsiList.Add(arsi);

                    decimal arsiEma = CalculateExponentialMovingAverage(arsi, prevArsi1, (int)Math.Ceiling(sp));
                    arsiEmaList.Add(arsiEma);

                    var signal = GetRsiSignal(arsiEma - prevArsi1, prevArsi1 - prevArsi2, arsiEma, prevArsi1, 70, 30);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (cuList, cdList, arsiList, arsiEmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateEhlersAdaptiveRsiV1FisherTransform(StockData stockDataClass)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Ehlers Adaptive Rsi V1 Fisher Transform [CC] script may be freely distributed under the MIT license.
            //study("Ehlers Adaptive Rsi V1 Fisher Transform [CC]", overlay = false)

            //inp = input(title = "Source", type = input.source, defval = hl2)
            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //src = security(syminfo.tickerid, res, inp[rep ? 0 : barstate.isrealtime ? 1 : 0])[rep ? 0 : barstate.isrealtime ? 0 : 1]
            //cycPart = input(title = "CycPart", type = input.float, defval = 0.5, minval = 0.01, step = 0.01)
            //obLevel = input(title = "ObLevel", type = input.integer, defval = 70, minval = 1)
            //osLevel = input(title = "OsLevel", type = input.integer, defval = 30, minval = 1)

            //pi = 2 * asin(1)
            //period = 0.0
            //smooth = ((4 * src) + (3 * nz(src[1])) + (2 * nz(src[2])) + nz(src[3])) / 10
            //detrender = ((0.0962 * smooth) + (0.5769 * nz(smooth[2])) - (0.5769 * nz(smooth[4])) - (0.0962 * nz(smooth[6]))) * ((0.075 * nz(period[1])) + 0.54)

            //q1 = ((0.0962 * detrender) + (0.5769 * nz(detrender[2])) - (0.5769 * nz(detrender[4])) - (0.0962 * nz(detrender[6]))) * ((0.075 * nz(period[1])) + 0.54)
            //i1 = nz(detrender[3])

            //jI = ((0.0962 * i1) + (0.5769 * nz(i1[2])) - (0.5769 * nz(i1[4])) - (0.0962 * nz(i1[6]))) * ((0.075 * nz(period[1])) + 0.54)
            //jQ = ((0.0962 * q1) + (0.5769 * nz(q1[2])) - (0.5769 * nz(q1[4])) - (0.0962 * nz(q1[6]))) * ((0.075 * nz(period[1])) + 0.54)

            //i2 = i1 - jQ
            //i2:= (0.2 * i2) + (0.8 * nz(i2[1]))
            //q2 = q1 + jI
            //q2:= (0.2 * q2) + (0.8 * nz(q2[1]))

            //re = (i2 * nz(i2[1])) + (q2 * nz(q2[1]))
            //re:= (0.2 * re) + (0.8 * nz(re[1]))
            //im = (i2 * nz(q2[1])) - (q2 * nz(i2[1]))
            //im:= (0.2 * im) + (0.8 * nz(im[1]))

            //period:= im != 0 and re != 0 ? 2 * pi / atan(im / re) : 0
            //period:= min(max(period, 0.67 * nz(period[1])), 1.5 * nz(period[1]))
            //period:= min(max(period, 6), 50)
            //period:= (0.2 * period) + (0.8 * nz(period[1]))

            //smoothPeriod = 0.0
            //smoothPeriod:= (0.33 * period) + (0.67 * nz(smoothPeriod[1]))

            //cu = 0.0, cd = 0.0
            //for i = 0 to ceil(cycPart * smoothPeriod) - 1
            //    price = nz(src[i])
            //    pPrice = nz(src[i + 1])

            //    cu := cu + (price - pPrice > 0 ? price - pPrice : 0)
            //    cd := cd + (price - pPrice < 0 ? pPrice - price : 0)

            //k = 2 / (smoothPeriod + 1)
            //arsi = cu + cd != 0 ? cu / (cu + cd) : 0
            //arsi := (arsi * k) + (nz(arsi[1]) * (1 - k))

            //tranRsi = 2 * (arsi - 0.5)
            //ampRsi = 1.5 * tranRsi
            //ampRsi := min(max(ampRsi, -0.999), 0.999)
            //fish = 0.5 * log((1 + ampRsi) / (1 - ampRsi))

            //slo = fish - nz(fish[1])
            //sig = slo > 0 or(nz(fish[1]) < osLevel and fish > osLevel) ? slo > nz(slo[1]) ? 2 : 1 :
            //      slo < 0 or(nz(fish[1]) > obLevel and fish < obLevel) ? slo < nz(slo[1]) ? -2 : -1 : 0
            //alertcondition(crossover(sig, 1), "Strong Buy Signal", "Strong Bullish Change Detected")
            //alertcondition(crossunder(sig, -1), "Strong Sell Signal", "Strong Bearish Change Detected")
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //arsiftColor = sig > 1 ? color.green : sig > 0 ? color.lime : sig < -1 ? color.maroon : sig < 0 ? color.red : color.black
            //barcolor(bar ? arsiftColor : na)
            //plot(fish, title = "FISH", color = arsiftColor, linewidth = 2)
            List<decimal> tranRsiList = new();
            List<decimal> ampRsiList = new();
            List<decimal> fishList = new();
            List<Signal> signalsList = new();

            try
            {
                var arsiList = CalculateEhlersAdaptiveRelativeStrengthIndexV1(stockDataClass).Item4;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal arsi = arsiList.ElementAtOrDefault(i) / 100;
                    decimal prevFish1 = i >= 1 ? fishList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevFish2 = i >= 2 ? fishList.ElementAtOrDefault(i - 2) : 0;

                    decimal tranRsi = 2 * (arsi - 0.5m);
                    tranRsiList.Add(tranRsi);

                    decimal ampRsi = MinOrMax(1.5m * tranRsi, 0.999m, -0.999m);
                    ampRsiList.Add(ampRsi);

                    decimal fish = 0.5m * Log((1 + ampRsi) / (1 - ampRsi));
                    fishList.Add(fish);

                    var signal = GetCompareSignal(fish - prevFish1, prevFish1 - prevFish2);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (tranRsiList, ampRsiList, fishList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateEhlersAdaptiveStochasticIndicatorV1(StockData stockDataClass)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Ehlers Adaptive Stochastic Indicator V1 [CC] script may be freely distributed under the MIT license.
            //study("Ehlers Adaptive Stochastic Indicator V1 [CC]", overlay = false)

            //f_security(_symbol, _res, _src, _repaint) => 
            //    security(_symbol, _res, _src[_repaint ? 0 : barstate.isrealtime ? 1 : 0])[_repaint ? 0 : barstate.isrealtime ? 0 : 1]


            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //c = f_security(syminfo.tickerid, res, close, rep)
            //h = f_security(syminfo.tickerid, res, high, rep)
            //l = f_security(syminfo.tickerid, res, low, rep)
            //src = f_security(syminfo.tickerid, res, hl2, rep)
            //cycPart = input(title = "CycPart", type = input.float, defval = 0.5, minval = 0.01, step = 0.01)
            //obLevel = input(title = "ObLevel", type = input.integer, defval = 70, minval = 1)
            //osLevel = input(title = "OsLevel", type = input.integer, defval = 30, minval = 1)

            //pi = 2 * asin(1)
            //period = 0.0
            //smooth = ((4 * src) + (3 * nz(src[1])) + (2 * nz(src[2])) + nz(src[3])) / 10
            //detrender = ((0.0962 * smooth) + (0.5769 * nz(smooth[2])) - (0.5769 * nz(smooth[4])) - (0.0962 * nz(smooth[6]))) * ((0.075 * nz(period[1])) + 0.54)

            //q1 = ((0.0962 * detrender) + (0.5769 * nz(detrender[2])) - (0.5769 * nz(detrender[4])) - (0.0962 * nz(detrender[6]))) * ((0.075 * nz(period[1])) + 0.54)
            //i1 = nz(detrender[3])

            //jI = ((0.0962 * i1) + (0.5769 * nz(i1[2])) - (0.5769 * nz(i1[4])) - (0.0962 * nz(i1[6]))) * ((0.075 * nz(period[1])) + 0.54)
            //jQ = ((0.0962 * q1) + (0.5769 * nz(q1[2])) - (0.5769 * nz(q1[4])) - (0.0962 * nz(q1[6]))) * ((0.075 * nz(period[1])) + 0.54)

            //i2 = i1 - jQ
            //i2:= (0.2 * i2) + (0.8 * nz(i2[1]))
            //q2 = q1 + jI
            //q2:= (0.2 * q2) + (0.8 * nz(q2[1]))

            //re = (i2 * nz(i2[1])) + (q2 * nz(q2[1]))
            //re:= (0.2 * re) + (0.8 * nz(re[1]))
            //im = (i2 * nz(q2[1])) - (q2 * nz(i2[1]))
            //im:= (0.2 * im) + (0.8 * nz(im[1]))

            //period:= im != 0 and re != 0 ? 2 * pi / atan(im / re) : 0
            //period:= min(max(period, 0.67 * nz(period[1])), 1.5 * nz(period[1]))
            //period:= min(max(period, 6), 50)
            //period:= (0.2 * period) + (0.8 * nz(period[1]))

            //smoothPeriod = 0.0
            //smoothPeriod:= (0.33 * period) + (0.67 * nz(smoothPeriod[1]))

            //hh = h, ll = l
            //for i = 0 to ceil(cycPart * smoothPeriod) - 1
            //    hh := nz(h[i]) > hh ? nz(h[i]) : hh
            //    ll := nz(l[i]) < ll ? nz(l[i]) : ll
            //astoc = hh - ll != 0 ? 100 * (c - ll) / (hh - ll) : 0

            //hline(obLevel, color = color.green)
            //hline(osLevel, color = color.red)
            //sig = nz(astoc[1]) < osLevel and astoc > osLevel ? 1 : nz(astoc[1]) > obLevel and astoc < obLevel ? -1 : 0
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //astocColor = sig > 0 ? color.green : sig < 0 ? color.red : color.black
            //barcolor(bar ? astocColor : na)
            //plot(astoc, title = "ASTOC", color = astocColor, linewidth = 2)
            List<decimal> astocList = new();
            List<decimal> astocEmaList = new();
            List<decimal> hhList = new();
            List<decimal> llList = new();
            List<Signal> signalsList = new();

            try
            {
                decimal cycPart = 0.5m;

                var spList = CalculateEhlersMotherOfAdaptiveMovingAverages(stockDataClass).Item12;
                var minMaxList = VolumeInputCheck(stockDataClass, 0, false);
                var highList = minMaxList.Item1;
                var lowList = minMaxList.Item2;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal sp = spList.ElementAtOrDefault(i);
                    decimal high = highList.ElementAtOrDefault(i);
                    decimal low = lowList.ElementAtOrDefault(i);
                    decimal close = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevAstoc1 = i >= 1 ? astocEmaList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevAstoc2 = i >= 2 ? astocEmaList.ElementAtOrDefault(i - 2) : 0;

                    int length = (int)Math.Ceiling(cycPart * sp);
                    decimal hh = high, ll = low;
                    for (int j = 0; j < length; j++)
                    {
                        var h = i >= j ? highList.ElementAtOrDefault(i - j) : 0;
                        var l = i >= j ? lowList.ElementAtOrDefault(i - j) : 0;

                        hh = h > hh ? h : hh;
                        ll = l < ll ? l : ll;
                    }
                    hhList.Add(hh);
                    llList.Add(ll);

                    decimal prevAstoc = astocList.LastOrDefault();
                    decimal astoc = hh - ll != 0 ? 100 * (close - ll) / (hh - ll) : 0;
                    astocList.Add(astoc);

                    decimal astocEma = CalculateExponentialMovingAverage(astoc, prevAstoc1, length);
                    astocEmaList.Add(astocEma);

                    var signal = GetRsiSignal(astocEma - prevAstoc1, prevAstoc1 - prevAstoc2, astocEma, prevAstoc1, 70, 30);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (hhList, llList, astocList, astocEmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateEhlersAdaptiveCommodityChannelIndexV1(StockData stockDataClass)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Ehlers Adaptive Commodity Channel Index V1 [CC] script may be freely distributed under the MIT license.
            //study("Ehlers Adaptive Commodity Channel Index V1 [CC]", overlay = false)

            //f_security(_symbol, _res, _src, _repaint) => 
            //    security(_symbol, _res, _src[_repaint ? 0 : barstate.isrealtime ? 1 : 0])[_repaint ? 0 : barstate.isrealtime ? 0 : 1]

            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //cycPart = input(title = "CycPart", type = input.float, defval = 1.0, minval = 0.01, step = 0.01)
            //c = f_security(syminfo.tickerid, res, close, rep)
            //h = f_security(syminfo.tickerid, res, high, rep)
            //l = f_security(syminfo.tickerid, res, low, rep)
            //src = f_security(syminfo.tickerid, res, hl2, rep)
            //obLevel = input(title = "ObLevel", type = input.integer, defval = 100, minval = 1)
            //osLevel = input(title = "OsLevel", type = input.integer, defval = -100, minval = 1)

            //pi = 2 * asin(1)
            //period = 0.0
            //smooth = ((4 * src) + (3 * nz(src[1])) + (2 * nz(src[2])) + nz(src[3])) / 10
            //detrender = ((0.0962 * smooth) + (0.5769 * nz(smooth[2])) - (0.5769 * nz(smooth[4])) - (0.0962 * nz(smooth[6]))) * ((0.075 * nz(period[1])) + 0.54)

            //q1 = ((0.0962 * detrender) + (0.5769 * nz(detrender[2])) - (0.5769 * nz(detrender[4])) - (0.0962 * nz(detrender[6]))) * ((0.075 * nz(period[1])) + 0.54)
            //i1 = nz(detrender[3])

            //jI = ((0.0962 * i1) + (0.5769 * nz(i1[2])) - (0.5769 * nz(i1[4])) - (0.0962 * nz(i1[6]))) * ((0.075 * nz(period[1])) + 0.54)
            //jQ = ((0.0962 * q1) + (0.5769 * nz(q1[2])) - (0.5769 * nz(q1[4])) - (0.0962 * nz(q1[6]))) * ((0.075 * nz(period[1])) + 0.54)

            //i2 = i1 - jQ
            //i2:= (0.2 * i2) + (0.8 * nz(i2[1]))
            //q2 = q1 + jI
            //q2:= (0.2 * q2) + (0.8 * nz(q2[1]))

            //re = (i2 * nz(i2[1])) + (q2 * nz(q2[1]))
            //re:= (0.2 * re) + (0.8 * nz(re[1]))
            //im = (i2 * nz(q2[1])) - (q2 * nz(i2[1]))
            //im:= (0.2 * im) + (0.8 * nz(im[1]))

            //period:= im != 0 and re != 0 ? 360 / atan(im / re) : 0
            //period:= min(max(period, 0.67 * nz(period[1])), 1.5 * nz(period[1]))
            //period:= min(max(period, 6), 50)
            //period:= (0.2 * period) + (0.8 * nz(period[1]))

            //smoothPeriod = 0.0
            //smoothPeriod:= (0.33 * period) + (0.67 * nz(smoothPeriod[1]))

            //length = ceil(cycPart * smoothPeriod)
            //medianPrice = (h + l + c) / 3
            //avg = 0.0
            //for i = 0 to length - 1
            //    avg := avg + nz(medianPrice[i])
            //    avg := avg / length

            //md = 0.0
            //for i = 0 to length - 1
            //    md := md + abs(nz(medianPrice[i]) - avg)
            //md := md / length
            //acci = md != 0 ? (medianPrice - avg) / (0.015 * md) : 0

            //hline(obLevel, color = color.green)
            //hline(osLevel, color = color.red)
            //sig = (nz(acci[1]) < osLevel and acci > osLevel) or(nz(acci[1]) < obLevel and acci > obLevel) ? 1 :
            //      (nz(acci[1]) > obLevel and acci<obLevel) or(nz(acci[1]) > osLevel and acci < osLevel) ? -1 : 0
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //acciColor = acci > 0 ? color.green : acci < 0 ? color.red : color.black
            //barcolor(bar ? acciColor : na)
            //plotshape(crossover(sig, 0), "Buy", shape.labelup, location.bottom, color.green, text = "Buy", textcolor = color.white)
            //plotshape(crossunder(sig, 0), "Sell", shape.labeldown, location.top, color = color.red, text = "Sell", textcolor = color.white)
            //plot(acci, title = "ACCI", color = acciColor, linewidth = 2)
            List<decimal> acciList = new();
            List<decimal> tempList = new();
            List<decimal> tpAvgList = new();
            List<decimal> mdAvgList = new();
            List<decimal> mdList = new();
            List<decimal> acciEmaList = new();
            List<Signal> signalsList = new();

            try
            {
                decimal cycPart = 0.5m;

                var spList = CalculateEhlersMotherOfAdaptiveMovingAverages(stockDataClass).Item12;
                var tpList = CalculateTypicalPrice(stockDataClass).Item1;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal sp = spList.ElementAtOrDefault(i);
                    int length = (int)Math.Ceiling(cycPart * sp);
                    decimal prevAcci1 = i >= 1 ? acciEmaList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevAcci2 = i >= 2 ? acciEmaList.ElementAtOrDefault(i - 2) : 0;

                    decimal tp = tpList.ElementAtOrDefault(i);
                    tempList.Add(tp);

                    decimal avg = tempList.TakeLast(length).Average();
                    tpAvgList.Add(avg);

                    decimal md = Math.Abs(tp) - avg;
                    mdList.Add(md);

                    decimal mdAvg = mdList.TakeLast(length).Average();
                    mdAvgList.Add(mdAvg);

                    decimal acci = mdAvg != 0 ? (tp - avg) / (0.015m * mdAvg) : 0;
                    acciList.Add(acci);

                    decimal acciEma = CalculateExponentialMovingAverage(acci, prevAcci1, (int)Math.Ceiling(sp));
                    acciEmaList.Add(acciEma);

                    var signal = GetRsiSignal(acciEma - prevAcci1, prevAcci1 - prevAcci2, acciEma, prevAcci1, 100, -100);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (tpAvgList, mdList, mdAvgList, acciList, acciEmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateMomentumOscillator(StockData stockDataClass, int days = 7)
        {
            //input = price, user defined, default is close
            //period = user defined, default is 14
            //index = current bar number

            //curVal = price[index];
            //prevVal = price[index - period];
            //Plot: val = (curVal / prevVal) * 100;
            List<decimal> momentumOscillatorList = new();
            List<decimal> emaList = new();
            List<Signal> signalsList = new();

            try
            {
                int signalPeriod = days;
                int length = days * 2;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentPrice = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevPrice = i >= length ? stockDataClass.InputValues.ElementAtOrDefault(i - length) : 0;

                    decimal prevMomentumOsc = momentumOscillatorList.LastOrDefault();
                    decimal momentumOscillator = prevPrice != 0 ? currentPrice / prevPrice * 100 : 0;
                    momentumOscillatorList.Add(momentumOscillator);

                    decimal prevMomentumEma = emaList.LastOrDefault();
                    decimal momentumEma = CalculateExponentialMovingAverage(momentumOscillator, prevMomentumEma, signalPeriod);
                    emaList.Add(momentumEma);

                    var signal = GetCompareSignal(momentumOscillator - momentumEma, prevMomentumOsc - prevMomentumEma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (momentumOscillatorList, emaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateKalmanSmoother(StockData stockDataClass, int days = 200)
        {
            //@version=2
            //study("Kalman Smoother", overlay = true)
            //Gain = input(200, type = float)
            //
            //src = input(close)
            //dk = src - nz(kf[1], src)
            //smooth = nz(kf[1], src) + dk * sqrt((Gain / 10000) * 2)
            //velo = nz(velo[1], 0) + ((Gain / 10000) * dk)
            //kf = smooth + velo
            //
            //plot(kf, color = red, transp = 0)
            List<decimal> dkList = new();
            List<decimal> smoothList = new();
            List<decimal> veloList = new();
            List<decimal> kfList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevKf = i >= 1 ? kfList.ElementAtOrDefault(i - 1) : currentValue;
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal dk = currentValue - prevKf;
                    dkList.Add(dk);

                    decimal smooth = prevKf + (dk * Sqrt(((decimal)days / 10000) * 2));
                    smoothList.Add(smooth);

                    decimal prevVelo = i >= 1 ? veloList.ElementAtOrDefault(i - 1) : 0;
                    decimal velo = prevVelo + (((decimal)days / 10000) * dk);
                    veloList.Add(velo);

                    decimal kf = smooth + velo;
                    kfList.Add(kf);

                    var signal = GetCompareSignal(currentValue - kf, prevValue - prevKf);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (dkList, smoothList, veloList, kfList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateParametricKalmanFilter(StockData stockDataClass, int days = 50)
        {
            //@version=2
            //study("Parametric Kalman Filter", overlay = true)
            //length = input(50)
            //
            //MEA = close
            //ERRmea = abs(nz(EST[length], MEA[1]) - MEA)
            //ERRprv = abs(change(MEA) * -1)
            //KG = nz(ERR[1], ERRprv) / (nz(ERR[1], ERRprv) + ERRmea)
            //EST = nz(EST[1], MEA[1]) + KG * (MEA - nz(EST[1], MEA[1]))
            //ERR = (1 - KG) * ERRprv
            //
            //plot(EST, color = red, transp = 0)
            List<decimal> errList = new();
            List<decimal> estList = new();
            List<decimal> kgList = new();
            List<decimal> errPrvList = new();
            List<decimal> errMeaList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal priorEst = i >= days ? estList.ElementAtOrDefault(i - days) : prevValue;

                    decimal errMea = Math.Abs(priorEst - currentValue);
                    errMeaList.Add(errMea);

                    decimal errPrv = Math.Abs((currentValue - prevValue) * -1);
                    errPrvList.Add(errPrv);

                    decimal prevErr = i >= 1 ? errList.ElementAtOrDefault(i - 1) : errPrv;
                    decimal kg = prevErr != 0 ? prevErr / (prevErr + errMea) : 0;
                    kgList.Add(kg);

                    decimal prevEst = i >= 1 ? estList.ElementAtOrDefault(i - 1) : prevValue;
                    decimal est = prevEst + (kg * (currentValue - prevEst));
                    estList.Add(est);

                    decimal err = (1 - kg) * errPrv;
                    errList.Add(err);

                    var signal = GetCompareSignal(currentValue - est, prevValue - prevEst);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (errMeaList, errPrvList, kgList, estList, errList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateAutoLineWithDrift(StockData stockDataClass, int days = 500)
        {
            //@version=2
            //study("Auto-Line With Drift", overlay = true)
            //length = input(500),round = input(1)
            //
            //r = round(close / round) * round
            //dev = stdev(close, length)
            //er = abs(change(close, length)) / sum(abs(change(close)), length)
            //a = close > nz(a[1], r) + dev ? close : close < nz(a[1], r) - dev ? close : a[1] + 1 / (length * 2) * change(nz(a[1], r), length)
            //
            //plot(a, color = orange, transp = 0, linewidth = 1)
            List<decimal> aList = new();
            List<decimal> rList = new();
            List<Signal> signalsList = new();

            try
            {
                var erList = CalculateKaufmanAdaptiveMovingAverage(stockDataClass, days).Item3;
                var stdDevList = CalculateStandardDeviationVolatility(null, stockDataClass, days).Item4;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal er = erList.ElementAtOrDefault(i);
                    decimal dev = stdDevList.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal r = Math.Round(currentValue);
                    rList.Add(r);

                    decimal prevA = i >= 1 ? aList.ElementAtOrDefault(i - 1) : r;
                    decimal priorA = i >= days + 1 ? aList.ElementAtOrDefault(i - (days + 1)) : r;
                    decimal a = currentValue > prevA + dev ? currentValue : currentValue < prevA - dev ? currentValue : prevA + ((decimal)1 / (days * 2) * (prevA - priorA));
                    aList.Add(a);

                    var signal = GetCompareSignal(currentValue - a, prevValue - prevA);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (rList, aList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<decimal>, List<Signal>) CalculateUltimateOscillator(StockData stockDataClass, int days = 7)
        {
            //period = user defined, default is 7
            //period2 = user defined, default is 14
            //period3 = user defined, default is 28
            //TL = true low, BP = buying pressure
            //TR = true range, prev = previous
            //index = current bar number, sig = signal

            //prevClose = close[index - 1];
            //TL = Math.min(low, prevClose);
            //BP = close - TL;
            //TR = getTrueRange(index);
            // Calculate BPSum1 and TRSum1
            //sumBP1 = sum(index, period, BP);
            //umTR1 = sum(index, period, TR);
            //DIV1 = sumBP1 / sumTR1;
            // Calculate BPSum2 and TRSum2
            //sumBP2 = sum(index, period2, BP);
            //sumTR2 = sum(index, period2, TR);
            //DIV2 = sumBP2 / sumTR2;
            // Calculate BPSum2 and TRSum2
            //sumBP3 = sum(index, period3, BP);
            //sumTR3 = sum(index, period3, TR);
            //DIV3 = sumBP3 / sumTR3);
            // Now we have enough data to calculate the Ultimate Osc
            //RawUO = 4 * DIV1) +2 * DIV2 + Values.DIV3;
            //Plot: UO = (RawUO / (4 + 2 + 1)) * 100;
            // Signals
            //buy = crossedAbove(UO, topGuide);
            //sell = crossedBelow(UO, bottomGuide);
            List<decimal> ultimateOscillatorList = new();
            List<decimal> buyingPressureList = new();
            List<decimal> buyingPressure7SumList = new();
            List<decimal> buyingPressure14SumList = new();
            List<decimal> buyingPressure28SumList = new();
            List<decimal> trueRangeList = new();
            List<decimal> trueRange7SumList = new();
            List<decimal> trueRange14SumList = new();
            List<decimal> trueRange28SumList = new();
            List<decimal> avg7List = new();
            List<decimal> avg14List = new();
            List<decimal> avg28List = new();
            List<Signal> signalsList = new();

            try
            {
                int period2 = MinOrMax(days * 2);
                int period3 = MinOrMax(days * 4);

                var list = VolumeInputCheck(stockDataClass, days, false);
                var highList = list.Item1;
                var lowList = list.Item2;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentHigh = highList.ElementAtOrDefault(i);
                    decimal currentLow = lowList.ElementAtOrDefault(i);
                    decimal currentClose = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevClose = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal minValue = Math.Min(currentLow, prevClose);
                    decimal maxValue = Math.Max(currentHigh, prevClose);
                    decimal prevUo1 = i >= 1 ? ultimateOscillatorList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevUo2 = i >= 2 ? ultimateOscillatorList.ElementAtOrDefault(i - 2) : 0;

                    decimal buyingPressure = currentClose - minValue;
                    buyingPressureList.Add(buyingPressure);

                    decimal trueRange = maxValue - minValue;
                    trueRangeList.Add(trueRange);

                    decimal bp7Sum = buyingPressureList.TakeLast(days).Sum();
                    buyingPressure7SumList.Add(bp7Sum);

                    decimal tr7Sum = trueRangeList.TakeLast(days).Sum();
                    trueRange7SumList.Add(tr7Sum);

                    decimal avg7 = tr7Sum != 0 ? bp7Sum / tr7Sum : 0;
                    avg7List.Add(avg7);

                    decimal bp14Sum = buyingPressureList.TakeLast(period2).Sum();
                    buyingPressure14SumList.Add(bp14Sum);

                    decimal tr14Sum = trueRangeList.TakeLast(period2).Sum();
                    trueRange14SumList.Add(tr14Sum);

                    decimal avg14 = tr14Sum != 0 ? bp14Sum / tr14Sum : 0;
                    avg14List.Add(avg14);

                    decimal bp28Sum = buyingPressureList.TakeLast(period3).Sum();
                    buyingPressure28SumList.Add(bp28Sum);

                    decimal tr28Sum = trueRangeList.TakeLast(period3).Sum();
                    trueRange28SumList.Add(tr28Sum);

                    decimal avg28 = tr28Sum != 0 ? bp28Sum / tr28Sum : 0;
                    avg28List.Add(avg28);

                    decimal ultimateOscillator = MinOrMax(100 * (((4 * avg7) + (2 * avg14) + avg28) / (4 + 2 + 1)), 100, 0);
                    ultimateOscillatorList.Add(ultimateOscillator);

                    var signal = GetRsiSignal(ultimateOscillator - prevUo1, prevUo1 - prevUo2, ultimateOscillator, prevUo1, 70, 30);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (buyingPressureList, trueRangeList, buyingPressure7SumList, trueRange7SumList, buyingPressure14SumList, trueRange14SumList, buyingPressure28SumList,
                trueRange28SumList, avg7List, avg14List, avg28List, ultimateOscillatorList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateDeltaMovingAverage(StockData stockDataClass, int days = 5)
        {
            //input1 = price, user defined, default is close
            //input2 = price, user defined, default is open
            //method = moving average (ma), user defined, default is SMA
            //period = user defined, default is 10
            //deltaRange = user defined, default is 5
            //index = current bar number

            //price1 = getPrice(index, input1);
            //price2 = getPrice(index - deltaRange, input2);
            //DELTA = price1 - price2;
            //ma = ma(method, index, period, DELTA);
            //delta abs = Math.abs(iclose - iopen);
            List<decimal> deltaList = new();
            List<decimal> deltaSmaList = new();
            List<decimal> deltaAbsList = new();
            List<decimal> deltaHistogramList = new();
            List<Signal> signalsList = new();

            try
            {
                int period = MinOrMax(days * 2);

                for (int i = 0; i < stockDataClass.OpenPrices.Count; i++)
                {
                    decimal currentClose = stockDataClass.ClosePrices.ElementAtOrDefault(i);
                    decimal currentOpen = stockDataClass.OpenPrices.ElementAtOrDefault(i);
                    decimal prevOpen = i >= days ? stockDataClass.OpenPrices.ElementAtOrDefault(i - days) : 0;

                    decimal deltaAbs = Math.Abs(currentClose - currentOpen);
                    deltaAbsList.Add(deltaAbs);

                    decimal delta = currentClose - prevOpen;
                    deltaList.Add(delta);

                    decimal deltaSma = deltaList.TakeLast(period).Average();
                    deltaSmaList.Add(deltaSma);

                    decimal prevDeltaHistogram = deltaHistogramList.LastOrDefault();
                    decimal deltaHistogram = delta - deltaSma;
                    deltaHistogramList.Add(deltaHistogram);

                    var signal = GetCompareSignal(deltaHistogram, prevDeltaHistogram);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (deltaList, deltaSmaList, deltaHistogramList, deltaAbsList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculatePriceCycleOscillator(StockData stockDataClass, string maType, int days = 22)
        {
            //input1 = price, user defined, default is closing price
            //input2 = price, user defined, default is low price
            //method = moving average (ma), user defined, default is SMA
            //avPeriod = user defined, default is 22
            //atrPeriod = user defined, default is 22
            //index = current bar number

            //price1 = input1[index];
            //price2 = input2[index];
            //cl = price1 - price2;
            //avg = ma(method, index, avPeriod, CL);
            //Average True Range (atr)
            //atr = sma(index, atrPeriod, TR);
            //Plot: pco = (avg / atr) * 100.0;
            List<decimal> pcoList = new();
            List<decimal> diffList = new();
            List<decimal> diffSmaList = new();
            List<Signal> signalsList = new();

            try
            {
                var atrList = CalculateAverageTrueRange(stockDataClass, maType, days).Item1;

                for (int i = 0; i < stockDataClass.ClosePrices.Count; i++)
                {
                    decimal currentClose = stockDataClass.ClosePrices.ElementAtOrDefault(i);
                    decimal currentLow = stockDataClass.LowPrices.ElementAtOrDefault(i);
                    decimal currentAtr = atrList.ElementAtOrDefault(i);
                    decimal prevPco1 = i >= 1 ? pcoList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevPco2 = i >= 2 ? pcoList.ElementAtOrDefault(i - 2) : 0;

                    decimal diff = currentClose - currentLow;
                    diffList.Add(diff);

                    decimal diffSma = diffList.TakeLast(days).Average();
                    diffSmaList.Add(diffSma);

                    decimal pco = currentAtr != 0 ? diffSma / currentAtr * 100 : 0;
                    pcoList.Add(pco);

                    var signal = GetCompareSignal(pco - prevPco1, prevPco1 - prevPco2);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (diffList, diffSmaList, pcoList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateDAPDIndicator(StockData stockDataClass, string maType, int days = 21)
        {
            ////////////////////////////////////////////////////////////
            //  Copyright by HPotter v1.0 04/07/2014
            // This indicator is similar to Bollinger Bands. It based on DAPD - Daily
            // Average Price Delta. DAPD is based upon a summation for each of the
            // highs (hod) for the 21 days prior to today minus the summation for
            // each of the lows (lod) for the last 21 days prior to today. The result
            // of this calculation would then be divided by 21.
            // It will be buy when high above previos DAPD high and sell if low below previos DAPD low
            ////////////////////////////////////////////////////////////
            //study(title = "DAPD - Strategy", shorttitle = "DAPD - Strategy", overlay = true)
            //Length = input(21, minval = 1)
            //xHighSMA = sma(high, Length)
            //xLowSMA = sma(low, Length)
            //nDAPD = xHighSMA - xLowSMA
            //nTop = high + nDAPD
            //nBottom = low - nDAPD
            //pos = iff(high > nTop[1], 1,
            //        iff(low < nBottom[1], -1, nz(pos[1], 0)))
            //barcolor(pos == -1 ? red : pos == 1 ? green : blue)
            //plot(nTop, color = blue, title = "Top DAPD")
            //plot(nBottom, color = blue, title = "Bottom DAPD")
            List<decimal> topList = new();
            List<decimal> bottomList = new();
            List<decimal> dapdList = new();
            List<Signal> signalsList = new();

            try
            {
                var smaHighList = GetMovingAverageList(maType, stockDataClass.HighPrices, stockDataClass, days);
                var smaLowList = GetMovingAverageList(maType, stockDataClass.LowPrices, stockDataClass, days);

                for (int i = 0; i < stockDataClass.HighPrices.Count; i++)
                {
                    decimal high = stockDataClass.HighPrices.ElementAtOrDefault(i);
                    decimal low = stockDataClass.LowPrices.ElementAtOrDefault(i);
                    decimal highSma = smaHighList.ElementAtOrDefault(i);
                    decimal lowSma = smaLowList.ElementAtOrDefault(i);

                    decimal dapd = highSma - lowSma;
                    dapdList.Add(dapd);

                    decimal prevTop = topList.LastOrDefault();
                    decimal top = high + dapd;
                    topList.Add(top);

                    decimal prevBottom = bottomList.LastOrDefault();
                    decimal bottom = low - dapd;
                    bottomList.Add(bottom);

                    var signal = GetConditionSignal(high > prevTop, low < prevBottom);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (dapdList, topList, bottomList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateAverageDirectionalIndex(StockData stockDataClass, string maType, int days = 14)
        {
            //period = user defined, default is 14
            //index = current bar number
            //smma = smoothed moving average
            //abs = absolute value

            // Calculate the +DM, -DM and TR
            //pDM = getPositiveDM(index);
            //nDM = getNegativeDM(index);
            //tr = getTrueRange(index);
            // Calculate the Average +DM, -DM and TR
            //PDMa = smma(index, period, PDM);
            //NDMa = smma(index, period, NDM);
            //TRa = smma(index, period, TR);
            // Determine the +DI, -DI and DX
            //Plot1: PDI = PDMa / TRa * 100;
            //Plot2: NDI = NDMa / TRa * 100;
            //DX = Math.abs((PDMa - NDMa)) / (PDMa + NDMa) * 100;
            // Calculate the Average DX
            //Plot3: ADX = smma(index, period, DX);
            List<decimal> dmPlusList = new();
            List<decimal> dmMinusList = new();
            List<decimal> diPlus14List = new();
            List<decimal> diMinus14List = new();
            List<decimal> dmPlus14List = new();
            List<decimal> dmMinus14List = new();
            List<decimal> directionalIndexList = new();
            List<decimal> diDiffList = new();
            List<decimal> diSumList = new();
            List<decimal> averageDirectionalIndexList = new();
            List<decimal> averageDirectionalIndexRatingList = new();
            List<Signal> signalsList = new();

            try
            {
                var trList = CalculateVortexIndicator(stockDataClass, days).Item5;

                for (int i = 0; i < stockDataClass.HighPrices.Count; i++)
                {
                    decimal currentHigh = stockDataClass.HighPrices.ElementAtOrDefault(i);
                    decimal currentLow = stockDataClass.LowPrices.ElementAtOrDefault(i);
                    decimal prevHigh = i >= 1 ? stockDataClass.HighPrices.ElementAtOrDefault(i - 1) : 0;
                    decimal prevLow = i >= 1 ? stockDataClass.LowPrices.ElementAtOrDefault(i - 1) : 0;
                    decimal highDiff = currentHigh - prevHigh;
                    decimal lowDiff = prevLow - currentLow;

                    decimal dmPlus = highDiff > lowDiff ? Math.Max(highDiff, 0) : 0;
                    dmPlusList.Add(dmPlus);

                    decimal dmMinus = highDiff < lowDiff ? Math.Max(lowDiff, 0) : 0;
                    dmMinusList.Add(dmMinus);
                }

                dmPlus14List = GetMovingAverageList(maType, dmPlusList, stockDataClass, days);
                dmMinus14List = GetMovingAverageList(maType, dmMinusList, stockDataClass, days);
                var trueRange14List = GetMovingAverageList(maType, trList, stockDataClass, days);
                for (int j = 0; j < stockDataClass.ClosePrices.Count; j++)
                {
                    decimal dmPlus14 = dmPlus14List.ElementAtOrDefault(j);
                    decimal dmMinus14 = dmMinus14List.ElementAtOrDefault(j);
                    decimal trueRange14 = trueRange14List.ElementAtOrDefault(j);

                    decimal diPlus = trueRange14 != 0 ? MinOrMax(100 * dmPlus14 / trueRange14, 100, 0) : 0;
                    diPlus14List.Add(diPlus);

                    decimal diMinus = trueRange14 != 0 ? MinOrMax(100 * dmMinus14 / trueRange14, 100, 0) : 0;
                    diMinus14List.Add(diMinus);

                    decimal diDiff = Math.Abs(diPlus - diMinus);
                    diDiffList.Add(diDiff);

                    decimal diSum = diPlus + diMinus;
                    diSumList.Add(diSum);

                    decimal directionalIndex = diSum != 0 ? MinOrMax(100 * diDiff / diSum, 100, 0) : 0;
                    directionalIndexList.Add(directionalIndex);
                }

                averageDirectionalIndexList = GetMovingAverageList(maType, directionalIndexList, stockDataClass, days);
                for (int k = 0; k < stockDataClass.ClosePrices.Count; k++)
                {
                    decimal diPlus = diPlus14List.ElementAtOrDefault(k);
                    decimal diMinus = diMinus14List.ElementAtOrDefault(k);
                    decimal adx = averageDirectionalIndexList.ElementAtOrDefault(k);
                    decimal priorAdx = k >= days ? averageDirectionalIndexList.ElementAtOrDefault(k - days) : 0;
                    decimal prevDiPlus = k >= 1 ? diPlus14List.ElementAtOrDefault(k - 1) : 0;
                    decimal prevDiMinus = k >= 1 ? diMinus14List.ElementAtOrDefault(k - 1) : 0;

                    decimal adxRating = (adx + priorAdx) / 2;
                    averageDirectionalIndexRatingList.Add(adxRating);

                    var signal = GetCompareSignal(diPlus - diMinus, prevDiPlus - prevDiMinus);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (dmPlusList, dmMinusList, dmPlus14List, dmMinus14List, diPlus14List, diMinus14List, diDiffList, diSumList, directionalIndexList,
                averageDirectionalIndexList, averageDirectionalIndexRatingList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateTheRangeIndicator(StockData stockDataClass, string maType, int days = 3)
        {
            //@version=4
            //study("TRI - The Range Indicator by Jack Weinberg ", title = "TRI", overlay = false)
            //stochper = input(10, title = "Stochastic Period")
            //smoothper = input(3, title = "Smooth Period")

            // StochRange - first step in constructing the TRI
            // StochRange - an oscillator of the ratio of the daily true range with the intraday range
            // Value1 - Today's True Range divided by today's close minus yesterday's close unless C-Ref(C,-1) < 0 then Value1 = True Range
            // Value2 - the lowest value of Value1, over the last q days
            // Value3 - the highest value of Value1, over the last q days

            //a = atr(1)
            //Value1 = iff(close > close[1], a / ((close - close[1]) + 0.00001), a)
            //Value2 = lowest(Value1, stochper)
            //Value3 = highest(Value1, stochper)
            //StochRange = iff((Value3 - Value2) > 0, 100 * (Value1 - Value2) / ((Value3 - Value2) + 0.00001), 100 * (Value1 - Value2))

            // The Range Indicator - TRI by J.L Weinberg
            // The Range Indicator - smooth StochRange using an exponential moving average of m periods */

            //TRI = ema(StochRange, smoothper)

            //band1 = hline(100, color = color.red)
            //band2 = hline(80, color = color.red)
            //hline(50, color = color.black)
            //band3 = hline(20, color = color.green)
            //band4 = hline(0, color = color.green)

            //fill(band1, band2, color = color.red, transp = 90)
            //fill(band3, band4, color = color.green, transp = 90)

            //col1 = crossover(TRI, 20)
            //col2 = crossunder(TRI, 80)
            //col = col1 ? #00ff00 : col2 ? #ff0000 : #0000ff
            //plot(TRI, color = col, title = "TRI", linewidth = 2)
            List<decimal> v1List = new();
            List<decimal> v2List = new();
            List<decimal> v3List = new();
            List<decimal> stochList = new();
            List<decimal> triList = new();
            List<Signal> signalsList = new();

            try
            {
                int stochPeriod = (int)Math.Ceiling(days / 0.3);

                var trList = CalculateVortexIndicator(stockDataClass, days).Item5;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal tr = trList.ElementAtOrDefault(i);

                    decimal v1 = currentValue - prevValue > 0 ? v1 = tr / (currentValue - prevValue) : tr;
                    v1List.Add(v1);

                    var lbList = v1List.TakeLast(stochPeriod).ToList();
                    decimal v2 = lbList.Min();
                    v2List.Add(v2);

                    decimal v3 = lbList.Max();
                    v3List.Add(v3);

                    decimal stoch = v3 - v2 > 0 ? MinOrMax(100 * (v1 - v2) / (v3 - v2), 100, 0) : MinOrMax(100 * (v1 - v2), 100, 0);
                    stochList.Add(stoch);
                }

                triList = GetMovingAverageList(maType, stochList, stockDataClass, days);
                for (int j = 0; j < stockDataClass.ClosePrices.Count; j++)
                {
                    decimal tri = triList.ElementAtOrDefault(j);
                    decimal prevTri1 = j >= 1 ? triList.ElementAtOrDefault(j - 1) : 0;
                    decimal prevTri2 = j >= 2 ? triList.ElementAtOrDefault(j - 2) : 0;

                    var signal = GetRsiSignal(tri - prevTri1, prevTri1 - prevTri2, tri, prevTri1, 80, 20);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (v1List, v2List, v3List, stochList, triList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateVortexIndicator(StockData stockDataClass, int days = 14)
        {
            //Positive and negative trend movement:
            //+VM = Current High less Prior Low(absolute value)
            //-VM = Current Low less Prior High(absolute value)
            //+VM14 = 14 - period Sum of +VM
            //- VM14 = 14 - period Sum of -VM
            //True Range(TR) is the greatest of:
            //Current High less current Low
            //Current High less previous Close(absolute value)
            //Current Low less previous Close(absolute value)
            //TR14 = 14 - period Sum of TR
            //Normalize the positive and negative trend movements:
            //+VI14 = +VM14 / TR14
            //- VI14 = -VM14 / TR14
            List<decimal> vmPlusList = new();
            List<decimal> trueRangeList = new();
            List<decimal> vmMinusList = new();
            List<decimal> trueRange14List = new();
            List<decimal> viPlus14List = new();
            List<decimal> viMinus14List = new();
            List<decimal> vmPlus14List = new();
            List<decimal> vmMinus14List = new();
            List<Signal> signalsList = new();

            try
            {
                var list = VolumeInputCheck(stockDataClass, days, false);
                var highList = list.Item1;
                var lowList = list.Item2;

                for (int i = 0; i < stockDataClass.HighPrices.Count; i++)
                {
                    decimal currentHigh = highList.ElementAtOrDefault(i);
                    decimal currentLow = lowList.ElementAtOrDefault(i);
                    decimal prevClose = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevLow = i >= 1 ? lowList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevHigh = i >= 1 ? highList.ElementAtOrDefault(i - 1) : 0;

                    decimal vmPlus = Math.Abs(currentHigh - prevLow);
                    vmPlusList.Add(vmPlus);

                    decimal vmMinus = Math.Abs(currentLow - prevHigh);
                    vmMinusList.Add(vmMinus);

                    decimal trueRange = Math.Max(currentHigh - currentLow, Math.Max(Math.Abs(currentHigh - prevClose), Math.Abs(currentLow - prevClose)));
                    trueRangeList.Add(trueRange);

                    decimal vmPlus14 = vmPlusList.TakeLast(days).Sum();
                    vmPlus14List.Add(vmPlus14);

                    decimal vmMinus14 = vmMinusList.TakeLast(days).Sum();
                    vmMinus14List.Add(vmMinus14);

                    decimal trueRange14 = trueRangeList.TakeLast(days).Sum();
                    trueRange14List.Add(trueRange14);

                    decimal prevViPlus14 = viPlus14List.LastOrDefault();
                    decimal viPlus14 = trueRange14 != 0 ? vmPlus14 / trueRange14 : 0;
                    viPlus14List.Add(viPlus14);

                    decimal prevViMinus14 = viMinus14List.LastOrDefault();
                    decimal viMinus14 = trueRange14 != 0 ? vmMinus14 / trueRange14 : 0;
                    viMinus14List.Add(viMinus14);

                    var signal = GetCompareSignal(viPlus14 - viMinus14, prevViPlus14 - prevViMinus14);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (vmPlusList, vmMinusList, vmPlus14List, vmMinus14List, trueRangeList, trueRange14List, viPlus14List, viMinus14List, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<Signal>) CalculatePringSpecialK(StockData stockDataClass, string maType, int days = 10)
        {
            //@version=2
            ////////////////////////////////////////////////////////////
            //  Copyright by HPotter 07/08/2017
            // Pring's Special K is a cyclical indicator created by Martin Pring. 
            // His method combines short-term, intermediate and long-term velocity 
            // into one complete series. Useful tool for Long Term Investors
            //
            // Source from: https://www.tradingview.com/script/ijM9W11O-UCS-I-Martin-Pring-s-Special-K/
            // Modified for any source.
            ////////////////////////////////////////////////////////////
            //study(title = "Martin Pring's Special K", shorttitle = "UCS_Pring_sK")
            //a = input(10, title = "Smooth")
            //sources = input(title = "Source", type = source, defval = close)
            //roc1 = (sma(roc(sources, 10), 10) * 1)
            //roc2 = (sma(roc(sources, 15), 10) * 2)
            //roc3 = (sma(roc(sources, 20), 10) * 3)
            //roc4 = (sma(roc(sources, 30), 15) * 4)
            //roc5 = (sma(roc(sources, 40), 50) * 1)
            //roc6 = (sma(roc(sources, 65), 65) * 2)
            //roc7 = (sma(roc(sources, 75), 75) * 3)
            //roc8 = (sma(roc(sources, 100), 100) * 4)
            //roc9 = (sma(roc(sources, 195), 130) * 1)
            //roc10 = (sma(roc(sources, 265), 130) * 2)
            //roc11 = (sma(roc(sources, 390), 130) * 3)
            //roc12 = (sma(roc(sources, 530), 195) * 4)
            //osc = roc1 + roc2 + roc3 + roc4 + roc5 + roc6 + roc7 + roc8 + roc9 + roc10 + roc11 + roc12
            //plot(osc, color = blue, title = "Martin Pring's Special K")
            //plot(sma(osc, a), color = red, title = "Smooth")
            //hline(0, title = "Zero Line")
            List<decimal> specialKList = new();
            List<decimal> roc10SmaList = new();
            List<decimal> roc15SmaList = new();
            List<decimal> roc20SmaList = new();
            List<decimal> roc30SmaList = new();
            List<decimal> roc40SmaList = new();
            List<decimal> roc65SmaList = new();
            List<decimal> roc75SmaList = new();
            List<decimal> roc100SmaList = new();
            List<decimal> roc195SmaList = new();
            List<decimal> roc265SmaList = new();
            List<decimal> roc390SmaList = new();
            List<decimal> roc530SmaList = new();
            List<decimal> specialKSignalList = new();
            List<Signal> signalsList = new();

            try
            {
                int roc10Period = days;
                int roc15Period = MinOrMax((int)Math.Ceiling(roc10Period * 1.5));
                int roc20Period = MinOrMax(roc10Period * 2);
                int roc30Period = MinOrMax(roc10Period * 3);
                int roc40Period = MinOrMax(roc10Period * 4);
                int roc50Period = MinOrMax(roc10Period * 5);
                int roc65Period = MinOrMax((int)Math.Ceiling(roc10Period * 6.5));
                int roc75Period = MinOrMax((int)Math.Ceiling(roc10Period * 7.5));
                int roc100Period = MinOrMax(roc10Period * 10);
                int roc130Period = MinOrMax(roc10Period * 13);
                int roc195Period = MinOrMax((int)Math.Ceiling(roc10Period * 19.5));
                int roc265Period = MinOrMax((int)Math.Ceiling(roc10Period * 26.5));
                int roc390Period = MinOrMax(roc10Period * 39);
                int roc530Period = MinOrMax(roc10Period * 53);

                List<decimal> rocList = CalculateRateOfChange(null, stockDataClass, roc10Period).Item1;
                List<decimal> roc15List = CalculateRateOfChange(null, stockDataClass, roc15Period).Item1;
                List<decimal> roc20List = CalculateRateOfChange(null, stockDataClass, roc20Period).Item1;
                List<decimal> roc30List = CalculateRateOfChange(null, stockDataClass, roc30Period).Item1;
                List<decimal> roc40List = CalculateRateOfChange(null, stockDataClass, roc40Period).Item1;
                List<decimal> roc65List = CalculateRateOfChange(null, stockDataClass, roc65Period).Item1;
                List<decimal> roc75List = CalculateRateOfChange(null, stockDataClass, roc75Period).Item1;
                List<decimal> roc100List = CalculateRateOfChange(null, stockDataClass, roc100Period).Item1;
                List<decimal> roc195List = CalculateRateOfChange(null, stockDataClass, roc195Period).Item1;
                List<decimal> roc265List = CalculateRateOfChange(null, stockDataClass, roc265Period).Item1;
                List<decimal> roc390List = CalculateRateOfChange(null, stockDataClass, roc390Period).Item1;
                List<decimal> roc530List = CalculateRateOfChange(null, stockDataClass, roc530Period).Item1;
                roc10SmaList = GetMovingAverageList(maType, rocList, stockDataClass, roc10Period);
                roc15SmaList = GetMovingAverageList(maType, roc15List, stockDataClass, roc10Period);
                roc20SmaList = GetMovingAverageList(maType, roc20List, stockDataClass, roc10Period);
                roc30SmaList = GetMovingAverageList(maType, roc30List, stockDataClass, roc15Period);
                roc40SmaList = GetMovingAverageList(maType, roc40List, stockDataClass, roc50Period);
                roc65SmaList = GetMovingAverageList(maType, roc65List, stockDataClass, roc65Period);
                roc75SmaList = GetMovingAverageList(maType, roc75List, stockDataClass, roc75Period);
                roc100SmaList = GetMovingAverageList(maType, roc100List, stockDataClass, roc100Period);
                roc195SmaList = GetMovingAverageList(maType, roc195List, stockDataClass, roc130Period);
                roc265SmaList = GetMovingAverageList(maType, roc265List, stockDataClass, roc130Period);
                roc390SmaList = GetMovingAverageList(maType, roc390List, stockDataClass, roc130Period);
                roc530SmaList = GetMovingAverageList(maType, roc530List, stockDataClass, roc195Period);

                for (int i = 0; i < rocList.Count; i++)
                {
                    decimal roc10Sma = roc10SmaList.ElementAtOrDefault(i);
                    decimal roc15Sma = roc15SmaList.ElementAtOrDefault(i);
                    decimal roc20Sma = roc20SmaList.ElementAtOrDefault(i);
                    decimal roc30Sma = roc30SmaList.ElementAtOrDefault(i);
                    decimal roc40Sma = roc40SmaList.ElementAtOrDefault(i);
                    decimal roc65Sma = roc65SmaList.ElementAtOrDefault(i);
                    decimal roc75Sma = roc75SmaList.ElementAtOrDefault(i);
                    decimal roc100Sma = roc100SmaList.ElementAtOrDefault(i);
                    decimal roc195Sma = roc195SmaList.ElementAtOrDefault(i);
                    decimal roc265Sma = roc265SmaList.ElementAtOrDefault(i);
                    decimal roc390Sma = roc390SmaList.ElementAtOrDefault(i);
                    decimal roc530Sma = roc530SmaList.ElementAtOrDefault(i);

                    // special k calculation here
                    decimal specialK = (roc10Sma * 1) + (roc15Sma * 2) + (roc20Sma * 3) + (roc30Sma * 4) + (roc40Sma * 1) + (roc65Sma * 2) + (roc75Sma * 3) +
                        (roc100Sma * 4) + (roc195Sma * 1) + (roc265Sma * 2) + (roc390Sma * 3) + (roc530Sma * 4);
                    specialKList.Add(specialK);
                }

                specialKSignalList = GetMovingAverageList(maType, specialKList, stockDataClass, roc10Period);
                for (int j = 0; j < rocList.Count; j++)
                {
                    decimal specialK = specialKList.ElementAtOrDefault(j);
                    decimal specialKSignal = specialKSignalList.ElementAtOrDefault(j);
                    decimal prevSpecialK = j >= 1 ? specialKList.ElementAtOrDefault(j - 1) : 0;
                    decimal prevSpecialKSignal = j >= 1 ? specialKSignalList.ElementAtOrDefault(j - 1) : 0;

                    var signal = GetCompareSignal(specialK - specialKSignal, prevSpecialK - prevSpecialKSignal);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (roc10SmaList, roc15SmaList, roc20SmaList, roc30SmaList, roc40SmaList, roc65SmaList, roc75SmaList, roc100SmaList, roc195SmaList,
                roc265SmaList, roc390SmaList, roc530SmaList, specialKList, specialKSignalList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateKarobeinOscillator(StockData stockDataClass, string maType, int days = 50)
        {
            //@version=2
            //study("Karobein Oscillator")
            //length = input(50)
            //
            //source = input(close)
            //src = ema(source, length)
            //a = ema(src < src[1] ? src / src[1] : 0, length)
            //b = ema(src > src[1] ? src / src[1] : 0, length)
            //c = (src / src[1]) / (src / src[1] + b)
            //d = 2 * ((src / src[1]) / (src / src[1] + c * a)) - 1
            //
            //plot(d, color = orange, transp = 0)
            //hline(0.8)
            //hline(0.2)
            List<decimal> aList = new();
            List<decimal> bList = new();
            List<decimal> cList = new();
            List<decimal> dList = new();
            List<decimal> aEmaList = new();
            List<decimal> bEmaList = new();
            List<Signal> signalsList = new();

            try
            {
                var emaList = GetMovingAverageList(maType, null, stockDataClass, days);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal ema = emaList.ElementAtOrDefault(i);
                    decimal prevEma = i >= 1 ? emaList.ElementAtOrDefault(i - 1) : 0;

                    decimal a = ema < prevEma && prevEma != 0 ? ema / prevEma : 0;
                    aList.Add(a);

                    decimal b = ema > prevEma && prevEma != 0 ? ema / prevEma : 0;
                    bList.Add(b);
                }

                aEmaList = GetMovingAverageList(maType, aList, stockDataClass, days);
                bEmaList = GetMovingAverageList(maType, bList, stockDataClass, days);
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal ema = emaList.ElementAtOrDefault(j);
                    decimal prevEma = j >= 1 ? emaList.ElementAtOrDefault(j - 1) : 0;
                    decimal a = aEmaList.ElementAtOrDefault(j);
                    decimal b = bEmaList.ElementAtOrDefault(j);
                    decimal prevD1 = j >= 1 ? dList.ElementAtOrDefault(j - 1) : 0;
                    decimal prevD2 = j >= 2 ? dList.ElementAtOrDefault(j - 2) : 0;

                    decimal c = prevEma != 0 && ema != 0 ? MinOrMax(ema / prevEma / ((ema / prevEma) + b), 1, 0) : 0;
                    cList.Add(c);

                    decimal d = prevEma != 0 && ema != 0 ? MinOrMax((2 * (ema / prevEma / ((ema / prevEma) + (c * a)))) - 1, 1, 0) : 0;
                    dList.Add(d);

                    var signal = GetRsiSignal(d - prevD1, prevD1 - prevD2, d, prevD1, 0.8m, 0.2m);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (aList, aEmaList, bList, bEmaList, cList, dList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateVolatilityMovingAverage(StockData stockDataClass,
            string maType, int days = 3)
        {
            // This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
            // © RedKTrader

            //@version=4
            //study("Volatility Ribbon", precision = 2)

            // =============================================================
            //f_rescale(_value, _oMin, _oMax, _nMin, _nMax, _reverse) =>
            //_d = _reverse ? (_oMax - _value) : (_value - _oMin)
            //_dratio = _d / (_oMax - _oMin)
            //rescaled = _dratio * (_nMax - _nMin) + _nMin
            // ============================================================================

            //length = input(20, "MA Base Length")
            //lookback = input(10, "Volatility Lookbak")
            //src = input(close, "Source")
            //mult = input(2.0, "StdDev", minval = 0.1, maxval = 5)
            //s1 = input(3, "pre_smooth", minval = 1)
            //s2 = input(3, "post_smooth", minval = 1)
            //calc = input("StDev", "Calc Method", options =["StDev", "Donchian"])

            //basis = 0.0, dev = 0.0, upper = 0.0, lower = 0.0
            //if calc == "StDev"
            //    basis:= sma(src, lookback)
            //    dev:= mult * stdev(src, lookback)
            //    upper:= basis + dev
            //    lower:= basis - dev
            //else
            //    upper:= highest(lookback)
            //    lower:= lowest(lookback)
            //    basis:= avg(upper, lower)

            //bands = 10                                              //this is a "granularity" value. how many bands do we split volatility into
            //k = (src - basis) / (upper - lower) * 100 * 2
            //kpres = wma(k, s1)                                      //apply pre-smoothing
            //k_norm = min(max(kpres, -100), 100)                       //normalize since we have cases that may exceed 100
            //kn_abs_b = round(abs(k_norm) / bands)                   //take absolute value and assign bands
            //plot(kn_abs_b, "k_band", color.orange)
            //k_rescaled = f_rescale(kn_abs_b, 0, 10, 0, length, true)    //apply scales to price, in reverse correlation
            //plot(k_rescaled)
            //vlength = round(max(k_rescaled, 1))                      //ensure we don't get a zero length

            //plots ====================
            //plot(vlength)
            //vline = wma(wma(src, vlength), s2)
            //w = wma(src, length)
            //v_up = vline > w
            //base = plot(vline, "Vola_Line", color = color.blue, linewidth = 3)
            //rib = plot(w, "WMA", color = color.silver)
            //fill(rib, base, color = v_up ? color.green : color.red)
            List<decimal> kList = new();
            List<decimal> kMaList = new();
            List<decimal> kNormList = new();
            List<decimal> kAbsList = new();
            List<decimal> kRescaledList = new();
            List<decimal> vma1List = new();
            List<decimal> vma2List = new();
            List<decimal> sumList = new();
            List<decimal> weightedSumList = new();
            List<Signal> signalsList = new();

            try
            {
                int smoothLength = days;
                int lbLength = (int)Math.Ceiling(days / 0.3);
                int length = lbLength * 2;

                var smaList = GetMovingAverageList(maType, null, stockDataClass, lbLength);
                var stdDevList = CalculateStandardDeviationVolatility(null, stockDataClass, lbLength).Item4;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal sma = smaList.ElementAtOrDefault(i);
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal dev = stdDevList.ElementAtOrDefault(i);
                    decimal upper = sma + dev;
                    decimal lower = sma - dev;

                    decimal k = upper - lower != 0 ? (currentValue - sma) / (upper - lower) * 100 * 2 : 0;
                    kList.Add(k);
                }

                kMaList = GetMovingAverageList(maType, kList, stockDataClass, smoothLength);
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal kMa = kMaList.ElementAtOrDefault(j);

                    decimal kNorm = Math.Min(Math.Max(kMa, -100), 100);
                    kNormList.Add(kNorm);

                    decimal kAbs = Math.Round(Math.Abs(kNorm) / lbLength);
                    kAbsList.Add(kAbs);

                    decimal kRescaled = RescaleValue(kAbs, 10, 0, length, 0, true);
                    kRescaledList.Add(kRescaled);

                    int vLength = (int)Math.Round(Math.Max(kRescaled, 1));
                    decimal sum = 0, weightedSum = 0;
                    for (int k = 0; j <= vLength - 1; j++)
                    {
                        decimal weight = vLength - k;
                        decimal prevValue = j >= k ? stockDataClass.InputValues.ElementAtOrDefault(j - k) : 0;

                        sum += prevValue * weight;
                        weightedSum += weight;
                    }
                    sumList.Add(sum);
                    weightedSumList.Add(weightedSum);

                    decimal vma1 = weightedSum != 0 ? sum / weightedSum : 0;
                    vma1List.Add(vma1);
                }

                vma2List = GetMovingAverageList(maType, vma1List, stockDataClass, smoothLength);
                for (int k = 0; k < stockDataClass.InputValues.Count; k++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(k);
                    decimal prevValue = k >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(k - 1) : 0;
                    decimal vma = vma2List.ElementAtOrDefault(k);
                    decimal prevVma = k >= 1 ? vma2List.ElementAtOrDefault(k - 1) : 0;

                    var signal = GetCompareSignal(currentValue - vma, prevValue - prevVma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (kList, kMaList, kNormList, kAbsList, kRescaledList, sumList, weightedSumList, vma1List, vma2List, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateKnowSureThing(StockData stockDataClass, string maType, int days = 8)
        {
            //input = price, user defined, default is closing price
            //method1 = moving average (ma), user defined, default is SMA
            //method2 = moving average (ma), user defined, default is EMA
            //signalPeriod = user defined, default is 8
            //ma1 default = 10, r1 default = 10, w1 default = 1
            //ma2 default = 10, r2 default = 15, w1 default = 2
            //ma3 default = 10, r3 default = 20, w1 default = 3
            //ma4 default = 15, r4 default = 30, w1 default = 4
            //index = current bar number, roc = rate of change

            //roc1 = roc(index, r1, input) * 100);
            //roc2 = roc(index, r2, input) * 100);
            //roc3 = roc(index, r3, input) * 100);
            //roc4 = roc(index, r4, input) * 100);
            //KST = ma(method1, index, ma1, ROC1) * w1 + ma(method1, index, ma2, ROC2) * w2 +
            //          ma(method1, index, ma3, ROC3) * w3 + ma(method1, index, ma4, ROC4) * w4;
            //SIGNAL = ma(method2, index, signalPeriod, KST);
            //Signals
            //buy = crossedAbove(KST, SIGNAL);
            //sell = crossedBelow(KST, SIGNAL);
            List<decimal> kstList = new();
            List<decimal> kstSignalList = new();
            List<Signal> signalsList = new();

            try
            {
                int w1 = 1;
                int w2 = 2;
                int w3 = 3;
                int w4 = 4;
                int r1 = (int)Math.Ceiling(days / 0.8);
                int r2 = (int)Math.Ceiling(days / 0.5334);
                int r3 = (int)Math.Ceiling(days / 0.4);
                int r4 = (int)Math.Ceiling(days / 0.2667);
                int ma1 = r1;
                int ma2 = r1;
                int ma3 = r1;
                int ma4 = r2;
                int signalPeriod = days;

                List<decimal> roc1List = CalculateRateOfChange(null, stockDataClass, r1).Item1;
                List<decimal> roc1SmaList = GetMovingAverageList(maType, roc1List, stockDataClass, ma1);
                List<decimal> roc2List = CalculateRateOfChange(null, stockDataClass, r2).Item1;
                List<decimal> roc2SmaList = GetMovingAverageList(maType, roc2List, stockDataClass, ma2);
                List<decimal> roc3List = CalculateRateOfChange(null, stockDataClass, r3).Item1;
                List<decimal> roc3SmaList = GetMovingAverageList(maType, roc3List, stockDataClass, ma3);
                List<decimal> roc4List = CalculateRateOfChange(null, stockDataClass, r4).Item1;
                List<decimal> roc4SmaList = GetMovingAverageList(maType, roc4List, stockDataClass, ma4);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal roc1 = roc1SmaList.ElementAtOrDefault(i);
                    decimal roc2 = roc2SmaList.ElementAtOrDefault(i);
                    decimal roc3 = roc3SmaList.ElementAtOrDefault(i);
                    decimal roc4 = roc4SmaList.ElementAtOrDefault(i);

                    decimal prevKst = kstList.LastOrDefault();
                    decimal kst = (roc1 * w1) + (roc2 * w2) + (roc3 * w3) + (roc4 * w4);
                    kstList.Add(kst);

                    decimal prevKstSignal = kstSignalList.LastOrDefault();
                    decimal kstSignal = CalculateExponentialMovingAverage(kst, prevKstSignal, signalPeriod);
                    kstSignalList.Add(kstSignal);

                    var signal = GetCompareSignal(kst - kstSignal, prevKst - prevKstSignal);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (kstList, kstSignalList, signalsList);
        }

        public static (List<decimal>, List<Signal>) CalculateTypicalPrice(StockData stockDataClass)
        {
            //Typical Price(TP) = (High + Low + Close) / 3
            List<decimal> typicalPriceList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.HighPrices.Count; i++)
                {
                    decimal currentHigh = stockDataClass.HighPrices.ElementAtOrDefault(i);
                    decimal currentLow = stockDataClass.LowPrices.ElementAtOrDefault(i);
                    decimal currentClose = stockDataClass.ClosePrices.ElementAtOrDefault(i);
                    decimal prevTypicalPrice1 = i >= 1 ? typicalPriceList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevTypicalPrice2 = i >= 2 ? typicalPriceList.ElementAtOrDefault(i - 2) : 0;

                    decimal typicalPrice = (currentHigh + currentLow + currentClose) / 3;
                    typicalPriceList.Add(typicalPrice);

                    var signal = GetCompareSignal(typicalPrice - prevTypicalPrice1, prevTypicalPrice1 - prevTypicalPrice2);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (typicalPriceList, signalsList);
        }

        public static (List<decimal>, List<Signal>) CalculateFullTypicalPrice(StockData stockDataClass)
        {
            //Full Typical Price(TP) = (High + Low + Close + Open) / 4
            List<decimal> typicalPriceList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.HighPrices.Count; i++)
                {
                    decimal currentHigh = stockDataClass.HighPrices.ElementAtOrDefault(i);
                    decimal currentLow = stockDataClass.LowPrices.ElementAtOrDefault(i);
                    decimal currentClose = stockDataClass.ClosePrices.ElementAtOrDefault(i);
                    decimal currentOpen = stockDataClass.OpenPrices.ElementAtOrDefault(i);
                    decimal prevTypicalPrice1 = i >= 1 ? typicalPriceList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevTypicalPrice2 = i >= 2 ? typicalPriceList.ElementAtOrDefault(i - 2) : 0;

                    decimal typicalPrice = (currentHigh + currentLow + currentClose + currentOpen) / 4;
                    typicalPriceList.Add(typicalPrice);

                    var signal = GetCompareSignal(typicalPrice - prevTypicalPrice1, prevTypicalPrice1 - prevTypicalPrice2);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (typicalPriceList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateCommodityChannelIndex(StockData stockDataClass, int days = 20)
        {
            //period = user defined, default is 20
            //LT = less than, LOR= = less or equal
            //index = current bar number

            //TP[] = new[period];
            //j = 0;
            //sum = 0;
            //for (int i = index - period + 1; i LOR = index; i++)
            //TP[j] = getTypicalPrice(i);
            //sum += TP[j];
            //j++;
            //endFor
            //SMATP = sum / period;
            // Calculate the Mean Deviation
            //sum = 0;
            //for (int i = 0; i LT TP.length; i++) 
            //sum += Math.abs(TP[i] - SMATP);
            //endFor
            //MD = sum / period;
            //Plot: CCI = (TP[period - 1] - SMATP) / (.015 * MD);
            //Signals
            //buy = crossedAbove(CCI, topGuide);
            //sell = crossedBelow(CCI, bottomGuide);
            decimal constant = .015m;
            List<decimal> cciList = new();
            List<decimal> typicalPriceSMAList = new();
            List<decimal> typicalPriceDeviationList = new();
            List<decimal> tempTypicalPriceList = new();
            List<decimal> typicalPriceDeviationDiffList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal prevCci1 = i >= 1 ? cciList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevCci2 = i >= 2 ? cciList.ElementAtOrDefault(i - 2) : 0;

                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    tempTypicalPriceList.Add(currentValue);

                    decimal typicalPriceSMA = tempTypicalPriceList.TakeLast(days).Average();
                    typicalPriceSMAList.Add(typicalPriceSMA);

                    decimal typicalPriceDeviationDiff = Math.Abs(currentValue - typicalPriceSMA);
                    typicalPriceDeviationDiffList.Add(typicalPriceDeviationDiff);

                    decimal typicalPriceDeviation = typicalPriceDeviationDiffList.TakeLast(days).Average();
                    typicalPriceDeviationList.Add(typicalPriceDeviation);

                    decimal cci = typicalPriceDeviation != 0 ? (currentValue - typicalPriceSMA) / (constant * typicalPriceDeviation) : 0;
                    cciList.Add(cci);

                    var signal = GetRsiSignal(cci - prevCci1, prevCci1 - prevCci2, cci, prevCci1, 100, -100);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (typicalPriceSMAList, typicalPriceDeviationDiffList, typicalPriceDeviationList, cciList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateFXSniperIndicator(StockData stockDataClass, int days = 5)
        {
            ////////////////////////////////////////////////////////////
            //  Copyright by HPotter v1.0 25/07/2014
            // This simple indicator gives you a lot of useful information - when to enter, when to exit
            // and how to reduce risks by entering a trade on a decimal confirmed signal.
            // You can use in the xPrice any series: Open, High, Low, Close, HL2, HLC3, OHLC4 and ect...
            ////////////////////////////////////////////////////////////
            //study(title = "FX Sniper:  T3-CCI Strategy", shorttitle = "T3-CCI")
            //CCI_Period = input(14, minval = 1)
            //T3_Period = input(5, minval = 1)
            //b = input(0.618)
            //hline(0, color = purple, linestyle = line)
            //xPrice = close
            //b2 = b * b
            //b3 = b2 * b
            //c1 = -b3
            //c2 = (3 * (b2 + b3))
            //c3 = -3 * (2 * b2 + b + b3)
            //c4 = (1 + 3 * b + b3 + 3 * b2)
            //nn = iff(T3_Period < 1, 1, T3_Period)
            //nr = 1 + 0.5 * (nn - 1)
            //w1 = 2 / (nr + 1)
            //w2 = 1 - w1
            //xcci = cci(xPrice, CCI_Period)
            //e1 = w1 * xcci + w2 * nz(e1[1])
            //e2 = w1 * e1 + w2 * nz(e2[1])
            //e3 = w1 * e2 + w2 * nz(e3[1])
            //e4 = w1 * e3 + w2 * nz(e4[1])
            //e5 = w1 * e4 + w2 * nz(e5[1])
            //e6 = w1 * e5 + w2 * nz(e6[1])
            //xccir = c1 * e6 + c2 * e5 + c3 * e4 + c4 * e3
            //cciHcolor = iff(xccir >= 0, green,
            //        iff(xccir < 0, red, black))
            //pos = iff(xccir > 0, 1,
            //        iff(xccir < 0, -1, nz(pos[1], 0)))
            //barcolor(pos == -1 ? red : pos == 1 ? green : blue)
            //plot(xccir, color = blue, title = "T3-CCI")
            //plot(xccir, color = cciHcolor, title = "CCIH", style = histogram)
            List<decimal> e1List = new();
            List<decimal> e2List = new();
            List<decimal> e3List = new();
            List<decimal> e4List = new();
            List<decimal> e5List = new();
            List<decimal> e6List = new();
            List<decimal> fxSniperList = new();
            List<Signal> signalsList = new();
            decimal b = 0.618m;

            try
            {
                int cciPeriod = (int)Math.Ceiling(days / 0.3572);
                decimal b2 = b * b;
                decimal b3 = b2 * b;
                decimal c1 = -b3;
                decimal c2 = 3 * (b2 + b3);
                decimal c3 = -3 * ((2 * b2) + b + b3);
                decimal c4 = (1 + (3 * b) + b3 + (3 * b2));
                decimal nr = 1 + (0.5m * (days - 1));
                decimal w1 = 2 / (nr + 1);
                decimal w2 = 1 - w1;

                var cciList = CalculateCommodityChannelIndex(stockDataClass, cciPeriod).Item4;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal cci = cciList.ElementAtOrDefault(i);

                    decimal prevE1 = e1List.LastOrDefault();
                    decimal e1 = (w1 * cci) + (w2 * prevE1);
                    e1List.Add(e1);

                    decimal prevE2 = e2List.LastOrDefault();
                    decimal e2 = (w1 * e1) + (w2 * prevE2);
                    e2List.Add(e2);

                    decimal prevE3 = e3List.LastOrDefault();
                    decimal e3 = (w1 * e2) + (w2 * prevE3);
                    e3List.Add(e3);

                    decimal prevE4 = e4List.LastOrDefault();
                    decimal e4 = (w1 * e3) + (w2 * prevE4);
                    e4List.Add(e4);

                    decimal prevE5 = e5List.LastOrDefault();
                    decimal e5 = (w1 * e4) + (w2 * prevE5);
                    e5List.Add(e5);

                    decimal prevE6 = e6List.LastOrDefault();
                    decimal e6 = (w1 * e5) + (w2 * prevE6);
                    e6List.Add(e6);

                    decimal prevFxSniper = fxSniperList.LastOrDefault();
                    decimal fxsniper = (c1 * e6) + (c2 * e5) + (c3 * e4) + (c4 * e3);
                    fxSniperList.Add(fxsniper);

                    var signal = GetCompareSignal(fxsniper, prevFxSniper);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (e1List, e2List, e3List, e4List, e5List, e6List, fxSniperList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateEhlersInverseFisherTransformCommodityChannelIndex(StockData stockDataClass, string maType, int days = 9)
        {
            //
            // @author LazyBear
            // If you use this code in its orignal/modified form, do drop me a note. 
            // 
            //study("Inverse Fisher Transform CCI [LazyBear]", shorttitle = "IFTCCI_LB")
            //length = input(title = "CCI Length", type = integer, defval = 20)
            //src = close
            //cc = cci(src, length)

            // Calculate IFT on CCI
            //lengthwma = input(9, title = "Smoothing length")
            //calc_ifish(series, lengthwma) =>
            //    v1 = 0.1 * (series - 50)
            //    v2 = wma(v1, lengthwma)
            //    ifish = (exp(2 * v2) - 1) / (exp(2 * v2) + 1)
            //    ifish

            //plot(calc_ifish(cc, lengthwma), color = teal, linewidth = 1)
            //hline(0.5, color = red)
            //hline(-0.5, color = green)
            //hline(0)
            List<decimal> v1List = new();
            List<decimal> v2List = new();
            List<decimal> iFishList = new();
            List<Signal> signalsList = new();

            try
            {
                int wmaLength = days;
                int length = (int)Math.Ceiling(days / 0.45);

                var cciList = CalculateCommodityChannelIndex(stockDataClass, length).Item4;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal cci = cciList.ElementAtOrDefault(i);

                    decimal v1 = 0.1m * (cci - 50);
                    v1List.Add(v1);
                }

                v2List = GetMovingAverageList(maType, v1List, stockDataClass, wmaLength);
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal v2 = v2List.ElementAtOrDefault(j);
                    decimal expValue = Exp(2 * v2);
                    decimal prevIFish1 = j >= 1 ? iFishList.ElementAtOrDefault(j - 1) : 0;
                    decimal prevIFish2 = j >= 2 ? iFishList.ElementAtOrDefault(j - 2) : 0;

                    decimal iFish = expValue + 1 != 0 ? (expValue - 1) / (expValue + 1) : 0;
                    iFishList.Add(iFish);

                    var signal = GetRsiSignal(iFish - prevIFish1, prevIFish1 - prevIFish2, iFish, prevIFish1, 0.5m, -0.5m);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (v1List, v2List, iFishList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateEhlersInverseFisherTransformRelativeStrengthIndex(StockData stockDataClass, string maType, int days = 9)
        {
            //
            // @author LazyBear
            // If you use this code in its orignal/modified form, do drop me a note. 
            // 
            //study("Inverse Fisher Transform RSI [LazyBear]", shorttitle = "IFTRSI_LB")
            //s = close
            //length = input(14, "RSI length")
            //lengthwma = input(9, title = "Smoothing length")

            //calc_ifish(series, lengthwma) =>
            //    v1 = 0.1 * (series - 50)
            //    v2 = wma(v1, lengthwma)
            //    ifish = (exp(2 * v2) - 1) / (exp(2 * v2) + 1)
            //    ifish

            //plot(calc_ifish(rsi(s, length), lengthwma), color = orange, linewidth = 2)
            //hline(0.5, color = red)
            //hline(-0.5, color = green)
            List<decimal> v1List = new();
            List<decimal> v2List = new();
            List<decimal> iFishList = new();
            List<Signal> signalsList = new();

            try
            {
                int wmaLength = days;
                int length = (int)Math.Ceiling(days / 0.643);

                List<decimal> rsiList = CalculateRelativeStrengthIndex(null, stockDataClass, maType, length).Item4;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal rsi = rsiList.ElementAtOrDefault(i);

                    decimal v1 = 0.1m * (rsi - 50);
                    v1List.Add(v1);
                }

                v2List = GetMovingAverageList("WeightedMovingAverage", v1List, stockDataClass, wmaLength);
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal v2 = v2List.ElementAtOrDefault(j);
                    decimal expValue = Exp(2 * v2);
                    decimal prevIfish1 = j >= 1 ? iFishList.ElementAtOrDefault(j - 1) : 0;
                    decimal prevIfish2 = j >= 2 ? iFishList.ElementAtOrDefault(j - 2) : 0;

                    decimal iFish = expValue + 1 != 0 ? MinOrMax((expValue - 1) / (expValue + 1), 1, -1) : 0;
                    iFishList.Add(iFish);

                    var signal = GetRsiSignal(iFish - prevIfish1, prevIfish1 - prevIfish2, iFish, prevIfish1, 0.5m, -0.5m);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (v2List, iFishList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateCoppockCurve(StockData stockDataClass, string maType, int days = 10)
        {
            //@version=3
            // Copyright (c) 2018-present, Alex Orekhov (everget)
            // Coppock Curve script may be freely distributed under the MIT license.
            //study("Coppock Curve")

            //length = input(title = "Smoothing Length", type = integer, defval = 10)
            //longRocLength = input(title = "Long ROC Length", type = integer, defval = 14)
            //shortRocLength = input(title = "Short ROC Length", type = integer, defval = 11)
            //src = input(title = "Source", type = source, defval = close)

            //coppock = wma(roc(src, longRocLength) + roc(src, shortRocLength), length)

            //coppockColor = coppock > 0 ? #0ebb23 : red

            //plot(coppock, title = "Coppock", linewidth = 2, color = coppockColor, transp = 0)
            //hline(0, title = "Zero Level", linestyle = dotted)
            List<decimal> coppockCurveList = new();
            List<decimal> rocTotalList = new();
            List<Signal> signalsList = new();

            try
            {
                int longRocLength = MinOrMax((int)Math.Ceiling(days / 0.7143));
                int shortRocLength = MinOrMax((int)Math.Ceiling(days / 0.9098));

                List<decimal> roc11List = CalculateRateOfChange(null, stockDataClass, shortRocLength).Item1;
                List<decimal> roc14List = CalculateRateOfChange(null, stockDataClass, longRocLength).Item1;

                for (int i = 0; i < roc11List.Count; i++)
                {
                    decimal currentRoc11 = roc11List.ElementAtOrDefault(i);
                    decimal currentRoc14 = roc14List.ElementAtOrDefault(i);

                    decimal rocTotal = currentRoc11 + currentRoc14;
                    rocTotalList.Add(rocTotal);
                }

                coppockCurveList = GetMovingAverageList(maType, rocTotalList, stockDataClass, days);
                for (int j = 0; j < roc11List.Count; j++)
                {
                    decimal coppockCurve = coppockCurveList.ElementAtOrDefault(j);
                    decimal prevCoppockCurve = j >= 1 ? coppockCurveList.ElementAtOrDefault(j - 1) : 0;

                    var signal = GetCompareSignal(coppockCurve, prevCoppockCurve);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (rocTotalList, coppockCurveList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateDemarker(StockData stockDataClass, string maType, int days = 20)
        {
            ////period = user defined, default is 20
            //LT = less than, MT= = more than
            //index = current bar number

            //dmax = 0;
            //dmin = 0;
            //prevH = high[index - 1];
            //prevL = low[index - 1];
            //if (high MT prevH ) dmax = high - prevH;
            //if (low LT prevL) dmin = prevL - low;
            //maxMA = sma(index, period, DMAX);
            //minMA = sma(index, period, DMIN);
            //Plot: DM = (maxMA / (maxMA + minMA)) * 100;
            // Signals
            //buy = crossedAbove(DM, topGuide);
            //sell = crossedBelow(DM, bottGuide);
            List<decimal> demarkerList = new();
            List<decimal> dMaxList = new();
            List<decimal> dMinList = new();
            List<decimal> maxMaList = new();
            List<decimal> minMaList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.LowPrices.Count; i++)
                {
                    decimal currentLow = stockDataClass.LowPrices.ElementAtOrDefault(i);
                    decimal currentHigh = stockDataClass.HighPrices.ElementAtOrDefault(i);
                    decimal prevHigh = i >= 1 ? stockDataClass.HighPrices.ElementAtOrDefault(i - 1) : 0;
                    decimal prevLow = i >= 1 ? stockDataClass.LowPrices.ElementAtOrDefault(i - 1) : 0;

                    decimal dMax = currentHigh > prevHigh ? currentHigh - prevHigh : 0;
                    dMaxList.Add(dMax);

                    decimal dMin = currentLow < prevLow ? prevLow - currentLow : 0;
                    dMinList.Add(dMin);
                }

                maxMaList = GetMovingAverageList(maType, dMaxList, stockDataClass, days);
                minMaList = GetMovingAverageList(maType, dMinList, stockDataClass, days);
                for (int j = 0; j < stockDataClass.LowPrices.Count; j++)
                {
                    decimal maxMa = maxMaList.ElementAtOrDefault(j);
                    decimal minMa = minMaList.ElementAtOrDefault(j);
                    decimal prevDemarker1 = j >= 1 ? demarkerList.ElementAtOrDefault(j - 1) : 0;
                    decimal prevDemarker2 = j >= 2 ? demarkerList.ElementAtOrDefault(j - 2) : 0;

                    decimal demarker = maxMa + minMa != 0 ? MinOrMax(maxMa / (maxMa + minMa) * 100, 100, 0) : 0;
                    demarkerList.Add(demarker);

                    var signal = GetRsiSignal(demarker - prevDemarker1, prevDemarker1 - prevDemarker2, demarker, prevDemarker1, 70, 30);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (dMaxList, maxMaList, dMinList, minMaList, demarkerList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateDemarkPressureRatio(StockData stockDataClass, int days = 13)
        {
            /*
            _SECTION_BEGIN("TD Pressure Ratio");
            SetChartBkColor(16);
            Periods = Param("Periods", 13, 1, 50, 1);
            function TDPressure(Periods)
            {
                for (i = 2; i < BarCount; i++)

                {
                    if ((O - C[i - 1]) / C[i - 1] > 0.15) // gapup
                    {
                        BP = (H - C[i - 1] + C - L) * V;
                    }
                    else if ((C[i - 1] - O) / O > 0.15)// gapdown
                    {
                        SP = (C[i - 1] - L + H - C) * V;
                    }
                    else
                    {
                        BP = IIf(C > O, C - O, 0) * V;
                        SP = IIf(C < O, C - O, 0) * V;
                    }
                }
                Result = 100 * Sum(BP, Periods) / (Sum(BP, Periods) -
                Sum(SP, Periods));
                Result = IIf(Result < 0, 0, Result);
                Result = IIf(Result > 100, 100, Result);
                return Result;
            }
            */
            List<decimal> gapUpList = new();
            List<decimal> gapDnList = new();
            List<decimal> bpList = new();
            List<decimal> spList = new();
            List<decimal> bpSumList = new();
            List<decimal> spSumList = new();
            List<decimal> pressureRatioList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.HighPrices.Count; i++)
                {
                    decimal currentHigh = stockDataClass.HighPrices.ElementAtOrDefault(i);
                    decimal currentLow = stockDataClass.LowPrices.ElementAtOrDefault(i);
                    decimal currentOpen = stockDataClass.OpenPrices.ElementAtOrDefault(i);
                    decimal currentClose = stockDataClass.ClosePrices.ElementAtOrDefault(i);
                    decimal currentVolume = stockDataClass.Volumes.ElementAtOrDefault(i);
                    decimal prevClose = i >= 1 ? stockDataClass.ClosePrices.ElementAtOrDefault(i - 1) : 0;
                    decimal prevPr1 = i >= 1 ? pressureRatioList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevPr2 = i >= 2 ? pressureRatioList.ElementAtOrDefault(i - 2) : 0;

                    decimal gapup = prevClose != 0 ? (currentOpen - prevClose) / prevClose : 0;
                    gapUpList.Add(gapup);

                    decimal gapdown = currentOpen != 0 ? (prevClose - currentOpen) / currentOpen : 0;
                    gapDnList.Add(gapdown);

                    decimal bp = gapup > 0.15m ? (currentHigh - prevClose + currentClose - currentLow) * currentVolume :
                        currentClose > currentOpen ? (currentClose - currentOpen) * currentVolume : 0;
                    bpList.Add(bp);

                    decimal sp = gapdown > 0.15m ? (prevClose - currentLow + currentHigh - currentClose) * currentVolume :
                        currentClose < currentOpen ? (currentClose - currentOpen) * currentVolume : 0;
                    spList.Add(sp);

                    decimal bpSum = bpList.TakeLast(days).Sum();
                    bpSumList.Add(bpSum);

                    decimal spSum = spList.TakeLast(days).Sum();
                    spSumList.Add(spSum);

                    decimal pressureRatio = bpSum - spSum != 0 ? MinOrMax(100 * bpSum / (bpSum - spSum), 100, 0) : 0;
                    pressureRatioList.Add(pressureRatio);

                    var signal = GetRsiSignal(pressureRatio - prevPr1, prevPr1 - prevPr2, pressureRatio, prevPr1, 75, 25);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (gapUpList, gapDnList, bpList, spList, bpSumList, spSumList, pressureRatioList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateDemarkPressureRatioV2(StockData stockDataClass, int days = 10)
        {
            //@version=3
            //author tlewis334
            //study("Tom Denmark pressure ratio", "TDPR")
            //found the indi on lazybears account but the code was no longer accessible
            //I think what I have made is correct but I could be wrong so drop me a message

            //buypres = 0.0
            //sellpres = 0.0
            //delta = 0.0
            //truerange = 0.0
            //pres = 0.0
            //dom = 0.0
            //len = input(10)
            //for i = 0 to len
            //delta := close[i] - open[i]
            //truerange := high[i] - low[i]

            //if delta > 0
            //buypres:= buypres + (delta / truerange) * volume[i]

            //if delta < 0
            //sellpres:= sellpres + (delta / truerange) * volume[i]

            //dom:= buypres + abs(sellpres)
            //if dom != 0.0
            //pres:= 100 * (buypres / dom)
            //else
            //pres:= 50

            //hline(75, color = red)
            //hline(50)
            //hline(25, color = green)
            //plot(pres, color = yellow)
            List<decimal> bpList = new();
            List<decimal> spList = new();
            List<decimal> bpSumList = new();
            List<decimal> spSumList = new();
            List<decimal> denomList = new();
            List<decimal> pressureRatioList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.HighPrices.Count; i++)
                {
                    decimal currentHigh = stockDataClass.HighPrices.ElementAtOrDefault(i);
                    decimal currentLow = stockDataClass.LowPrices.ElementAtOrDefault(i);
                    decimal currentOpen = stockDataClass.OpenPrices.ElementAtOrDefault(i);
                    decimal currentClose = stockDataClass.ClosePrices.ElementAtOrDefault(i);
                    decimal currentVolume = stockDataClass.Volumes.ElementAtOrDefault(i);
                    decimal delta = currentClose - currentOpen;
                    decimal trueRange = currentHigh - currentLow;
                    decimal ratio = trueRange != 0 ? delta / trueRange : 0;
                    decimal prevPr1 = i >= 1 ? pressureRatioList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevPr2 = i >= 2 ? pressureRatioList.ElementAtOrDefault(i - 2) : 0;

                    decimal buyingPressure = delta > 0 ? ratio * currentVolume : 0;
                    bpList.Add(buyingPressure);

                    decimal sellingPressure = delta < 0 ? ratio * currentVolume : 0;
                    spList.Add(sellingPressure);

                    decimal bpSum = bpList.TakeLast(days).Sum();
                    bpSumList.Add(bpSum);

                    decimal spSum = spList.TakeLast(days).Sum();
                    spSumList.Add(spSum);

                    decimal denom = bpSum + Math.Abs(spSum);
                    denomList.Add(denom);

                    decimal pressureRatio = denom != 0 ? MinOrMax(100 * bpSum / denom, 100, 0) : 50;
                    pressureRatioList.Add(pressureRatio);

                    var signal = GetRsiSignal(pressureRatio - prevPr1, prevPr1 - prevPr2, pressureRatio, prevPr1, 75, 25);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (bpList, spList, bpSumList, spSumList, denomList, pressureRatioList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateRelativeVolumeIndicator(StockData stockDataClass, string maType, int days = 60)
        {
            //
            // @author LazyBear
            //
            // If you use this code in its orignal/modified form, do drop me a note. 
            // 
            //study("Relative Volume Indicator [LazyBear]", shorttitle = "RVI_LB")
            //x = input(60, "Standard deviation length")
            //y = input(2, "Number of deviations")
            //allowNegativePlots = input(false, type = bool)
            //matchVolumeColor = input(false, type = bool)

            //aMove = abs((C - C[1]) / C[1])  
            //'percent move   'normalize to 1 to 10, so no divides by a zero or forex problems 
            //theMin = LLV(aMove, period)   
            //theMax = HHV(aMove, period)   
            //if (theMax - theMin)> 0 thentheMove = 1 + ((aMove - theMin) * (10 - 1)) / (theMax - theMin)   
            //end if

            //av = sma(volume, x)
            //sd = stdev(volume, x)
            //relVol = iff(sd != 0, (volume - av) / sd, 0)
            List<decimal> relVolList = new();
            List<decimal> dplList = new();
            List<Signal> signalsList = new();

            try
            {
                List<decimal> smaVolumeList = GetMovingAverageList(maType, stockDataClass.Volumes, stockDataClass, days);
                List<decimal> stdDevVolumeList = CalculateStandardDeviationVolatility(stockDataClass.Volumes, stockDataClass, days).Item4;

                for (int i = 0; i < smaVolumeList.Count; i++)
                {
                    decimal currentVolume = stockDataClass.Volumes.ElementAtOrDefault(i);
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal av = smaVolumeList.ElementAtOrDefault(i);
                    decimal sd = stdDevVolumeList.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal relVol = sd != 0 ? (currentVolume - av) / sd : 0;
                    relVolList.Add(relVol);

                    decimal prevDpl = dplList.LastOrDefault();
                    decimal dpl = relVol >= 2 ? prevValue : i >= 1 ? prevDpl : currentValue;
                    dplList.Add(dpl);

                    var signal = GetCompareSignal(currentValue - dpl, prevValue - prevDpl);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (relVolList, dplList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<decimal>, List<Signal>) CalculateFreedomOfMovement(StockData stockDataClass, string maType, int days = 60)
        {
            //
            // @author LazyBear
            //
            // If you use this code in its orignal/modified form, do drop me a note. 
            // 
            //study("Relative Volume Indicator [LazyBear]", shorttitle = "RVI_LB")
            //x = input(60, "Standard deviation length")
            //y = input(2, "Number of deviations")
            //allowNegativePlots = input(false, type = bool)
            //matchVolumeColor = input(false, type = bool)

            //av = sma(volume, x)
            //sd = stdev(volume, x)
            //relVol = iff(sd != 0, (volume - av) / sd, 0)

            //aMove = abs((C - C[1]) / C[1])  
            //'percent move   'normalize to 1 to 10, so no divides by a zero or forex problems 
            //theMin = LLV(aMove, period)   
            //theMax = HHV(aMove, period)   
            //if (theMax - theMin)> 0 thentheMove = 1 + ((aMove - theMin) * (10 - 1)) / (theMax - theMin)   
            //end if

            //Normalize the relative volume to range of 1 to 10 to get   'rid of negatives   
            //theMinV = LLV(relVol,period)   
            //theMaxV = HHV(relVol,period)   
            //if (theMaxV-theMinV)>0 thentheVol = 1 + ((relVol-theMinV)*(10-1))/(theMaxV-theMinV)   
            //end 
            //if'compute the Freedom of Movement in stDevs from the average   
            //vByM = theVol / theMove    
            //'effort divided by effect   
            //avF = sma(vByM,period)   
            //sdF = std(vByM,period)   
            //theFoM = (vByM-avF)/sdF
            List<decimal> theVolList = new();
            List<decimal> aMoveList = new();
            List<decimal> vBymList = new();
            List<decimal> theMoveList = new();
            List<decimal> theFomList = new();
            List<decimal> avfList = new();
            List<decimal> dplList = new();
            List<decimal> sdfList = new();
            List<decimal> tempList = new();
            List<Signal> signalsList = new();

            try
            {
                List<decimal> relVolList = CalculateRelativeVolumeIndicator(stockDataClass, maType, days).Item1;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal currentRelVol = relVolList.ElementAtOrDefault(i);
                    tempList.Add(currentRelVol);

                    decimal aMove = prevValue != 0 ? Math.Abs((currentValue - prevValue) / prevValue) : 0;
                    aMoveList.Add(aMove);

                    var list = aMoveList.TakeLast(days).ToList();
                    decimal aMoveMax = list.Max();
                    decimal aMoveMin = list.Min();

                    decimal theMove = aMoveMax - aMoveMin != 0 ? (1 + ((aMove - aMoveMin) * (10 - 1))) / (aMoveMax - aMoveMin) : 0;
                    theMoveList.Add(theMove);

                    var tList = tempList.TakeLast(days).ToList();
                    decimal relVolMax = tList.Max();
                    decimal relVolMin = tList.Min();

                    decimal theVol = relVolMax - relVolMin != 0 ? (1 + ((currentRelVol - relVolMin) * (10 - 1))) / (relVolMax - relVolMin) : 0;
                    theVolList.Add(theVol);

                    decimal vBym = theMove != 0 ? theVol / theMove : 0;
                    vBymList.Add(vBym);

                    decimal avf = vBymList.TakeLast(days).Average();
                    avfList.Add(avf);
                }

                sdfList = CalculateStandardDeviationVolatility(vBymList, stockDataClass, days).Item4;
                for (int j = 0; j < sdfList.Count; j++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(j);
                    decimal vBym = vBymList.ElementAtOrDefault(j);
                    decimal avf = avfList.ElementAtOrDefault(j);
                    decimal sdf = sdfList.ElementAtOrDefault(j);
                    decimal prevValue = j >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(j - 1) : 0;

                    decimal theFom = sdf != 0 ? (vBym - avf) / sdf : 0;
                    theFomList.Add(theFom);

                    decimal prevDpl = dplList.LastOrDefault();
                    decimal dpl = theFom >= 2 ? prevValue : j >= 1 ? prevDpl : currentValue;
                    dplList.Add(dpl);

                    var signal = GetCompareSignal(currentValue - dpl, prevValue - prevDpl);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (theVolList, aMoveList, theMoveList, vBymList, avfList, sdfList, theFomList, dplList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<decimal>, List<Signal>) CalculateVolumeFlowIndicator(StockData stockDataClass, string maType, int days = 3)
        {
            //
            // @author LazyBear
            //
            // If you use this code in its original/modified form, do drop me a note. 
            //

            //study(title = "Volume Flow Indicator [LazyBear]", shorttitle = "VFI_LB")
            //length = input(130, title = "VFI length")
            //coef = input(0.2)
            //vcoef = input(2.5, title = "Max. vol. cutoff")
            //signalLength = input(5)
            //smoothVFI = input(false, type = bool)
            //ma(x, y) => smoothVFI? sma(x, y) : x

            //typical = hlc3
            //inter = log(typical) - log(typical[1])
            //vinter = stdev(inter, 30)
            //cutoff = coef * vinter * close
            //vave = sma(volume, length)[1]
            //vmax = vave * vcoef
            //vc = iff(volume < vmax, volume, vmax) //min( volume, vmax )
            //mf = typical - typical[1]
            //vcp = iff(mf > cutoff, vc, iff(mf < -cutoff, -vc, 0))

            //vfi = ma(sum(vcp, length) / vave, 3)
            //vfima = ema(vfi, signalLength)
            //d = vfi - vfima
            decimal vcoef = 2.5m, coef = 0.2m;
            List<decimal> interList = new();
            List<decimal> cutoffList = new();
            List<decimal> tempList = new();
            List<decimal> vmaxList = new();
            List<decimal> vcpList = new();
            List<decimal> vcpVaveSumList = new();
            List<decimal> vfiList = new();
            List<decimal> vfiEmaList = new();
            List<decimal> dList = new();
            List<Signal> signalsList = new();

            try
            {
                int stdDevLength = days * 10;
                int length = (int)Math.Ceiling(days / 0.0231);
                int signalLength = (int)Math.Ceiling(days / 0.6);
                int vfiSmaLength = days;

                List<decimal> smaVolumeList = GetMovingAverageList(maType, stockDataClass.Volumes, stockDataClass, length);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal inter = currentValue > 0 && prevValue > 0 ? Log(currentValue) - Log(prevValue) : 0;
                    interList.Add(inter);
                }

                var vinterList = CalculateStandardDeviationVolatility(interList, stockDataClass, stdDevLength).Item4;
                for (int j = 0; j < vinterList.Count; j++)
                {
                    decimal vinter = vinterList.ElementAtOrDefault(j);
                    decimal currentVolume = stockDataClass.Volumes.ElementAtOrDefault(j);
                    decimal currentClose = stockDataClass.ClosePrices.ElementAtOrDefault(j);
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(j);
                    decimal prevValue = j >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(j - 1) : 0;

                    decimal prevVave = tempList.LastOrDefault();
                    decimal vave = smaVolumeList.ElementAtOrDefault(j);
                    tempList.Add(vave);

                    decimal cutoff = currentClose * vinter * coef;
                    cutoffList.Add(cutoff);

                    decimal vmax = prevVave * vcoef;
                    vmaxList.Add(vmax);

                    decimal vc = Math.Min(currentVolume, vmax);
                    decimal mf = currentValue - prevValue;

                    decimal vcp = mf > cutoff ? vc : mf < cutoff * -1 ? vc * -1 : mf > 0 ? vc : mf < 0 ? vc * -1 : 0;
                    vcpList.Add(vcp);
                    decimal vcpSum = vcpList.TakeLast(length).Sum();

                    decimal vcpVaveSum = vave != 0 ? vcpSum / vave : 0;
                    vcpVaveSumList.Add(vcpVaveSum);

                    decimal vfi = vcpVaveSumList.TakeLast(vfiSmaLength).Average();
                    vfiList.Add(vfi);

                    decimal vfima = CalculateExponentialMovingAverage(vfi, vfiEmaList.LastOrDefault(), signalLength);
                    vfiEmaList.Add(vfima);

                    decimal prevD = dList.LastOrDefault();
                    decimal d = vfi - vfima;
                    dList.Add(d);

                    var signal = GetCompareSignal(d, prevD);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (interList, cutoffList, vmaxList, vcpList, vcpVaveSumList, vfiList, vfiEmaList, dList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateValueChartIndicator(StockData stockDataClass, int days = 5)
        {
            //
            // @author LazyBear
            //
            // If you use this code in its original/modified form, do drop me a note. 
            //
            //study("ValueChart Indicator [LazyBear]", shorttitle = "ValueChart_LB")

            //prev(s, i) => 
            //    y = abs(round(i))
            //    s[y]

            //length = input(5, title = "Number of bars")
            //extTop = input(12, title = "Extreme Level Top")
            //extBot = input(-12, title = "Extreme Level Bottom")
            //sigTop = input(8, title = "Significant Level Top")
            //sigBot = input(-8, title = "Significant Level Bottom")
            //fairTop = input(4, title = "Fair Value Top")
            //fairBot = input(-4, title = "Fair Value Bottom")

            //varp = round(length / 5)
            //h_f = length > 7

            //vara = h_f ? highest(high, varp) - lowest(low, varp) : 0
            //varr1 = h_f ? iff(vara == 0 and varp == 1, abs(close - prev(close, -varp)), vara) : 0
            //varb = h_f ? prev(highest(high, varp), -varp * 1) - prev(lowest(low, varp), -varp) : 0
            //varr2 = h_f ? iff(varb == 0 and varp == 1, abs(prev(close, -varp) - prev(close, -varp * 2)), varb) : 0
            //varc = h_f ? prev(highest(high, varp), -varp * 2) - prev(lowest(low, varp), -varp * 2) : 0
            //varr3 = h_f ? iff(varc == 0 and varp == 1, abs(prev(close, -varp * 2) - prev(close, -varp * 3)), varc) : 0
            //vard = h_f ? prev(highest(high, varp), -varp * 3) - prev(lowest(low, varp), -varp * 3) : 0
            //varr4 = h_f ? iff(vard == 0 and varp == 1, abs(prev(close, -varp * 3) - prev(close, -varp * 4)), vard) : 0
            //vare = h_f ? prev(highest(high, varp), -varp * 4) - prev(lowest(low, varp), -varp * 4) : 0
            //varr5 = h_f ? iff(vare == 0 and varp == 1, abs(prev(close, -varp * 4) - prev(close, -varp * 5)), vare) : 0
            //cdelta = abs(close - prev(close, -1))
            //var0 = (not h_f) ? iff((cdelta > (high - low)) or(high == low), cdelta, (high - low)) : 0
            //lrange = h_f ? ((varr1 + varr2 + varr3 + varr4 + varr5) / 5) * .2 : sma(var0, 5) * .2

            //mba = sma((high + low) / 2, length)
            //vopen = (open - mba) / lrange
            //vhigh = (high - mba) / lrange
            //vlow = (low - mba) / lrange
            //vclose = (close - mba) / lrange

            //plot(vhigh, color = maroon, linewidth = 1)
            //plot(vopen, linewidth = 2, color = green)
            //plot(vclose, linewidth = 2, color = vclose > vopen ? blue : red, style = 3)
            //plot(vlow, color = maroon, linewidth = 1)
            List<decimal> tempHighList = new();
            List<decimal> tempLowList = new();
            List<decimal> highestHighList = new();
            List<decimal> lowestLowList = new();
            List<decimal> varaList = new();
            List<decimal> varbList = new();
            List<decimal> varcList = new();
            List<decimal> vardList = new();
            List<decimal> vareList = new();
            List<decimal> varr1List = new();
            List<decimal> varr2List = new();
            List<decimal> varr3List = new();
            List<decimal> varr4List = new();
            List<decimal> varr5List = new();
            List<decimal> vValueList = new();
            List<decimal> lRangeList = new();
            List<decimal> vValueEmaList = new();
            List<Signal> signalsList = new();

            try
            {
                int varp = MinOrMax((int)Math.Ceiling((decimal)days / 5));

                List<decimal> smaList = CalculateSimpleMovingAverage(stockDataClass, days).Item1;

                for (int i = 0; i < stockDataClass.HighPrices.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal currentClose = stockDataClass.ClosePrices.ElementAtOrDefault(i);
                    decimal prevClose1 = i >= 1 ? stockDataClass.ClosePrices.ElementAtOrDefault(i - 1) : 0;
                    decimal prevHighest1 = i >= 1 ? highestHighList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevLowest1 = i >= 1 ? lowestLowList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevClose2 = i >= 2 ? stockDataClass.ClosePrices.ElementAtOrDefault(i - 2) : 0;
                    decimal prevHighest2 = i >= 2 ? highestHighList.ElementAtOrDefault(i - 2) : 0;
                    decimal prevLowest2 = i >= 2 ? lowestLowList.ElementAtOrDefault(i - 2) : 0;
                    decimal prevClose3 = i >= 3 ? stockDataClass.ClosePrices.ElementAtOrDefault(i - 3) : 0;
                    decimal prevHighest3 = i >= 3 ? highestHighList.ElementAtOrDefault(i - 3) : 0;
                    decimal prevLowest3 = i >= 3 ? lowestLowList.ElementAtOrDefault(i - 3) : 0;
                    decimal prevClose4 = i >= 4 ? stockDataClass.ClosePrices.ElementAtOrDefault(i - 4) : 0;
                    decimal prevHighest4 = i >= 4 ? highestHighList.ElementAtOrDefault(i - 4) : 0;
                    decimal prevLowest4 = i >= 4 ? lowestLowList.ElementAtOrDefault(i - 4) : 0;
                    decimal prevClose5 = i >= 5 ? stockDataClass.ClosePrices.ElementAtOrDefault(i - 5) : 0;
                    decimal mba = smaList.ElementAtOrDefault(i);

                    decimal currentHigh = stockDataClass.HighPrices.ElementAtOrDefault(i);
                    tempHighList.Add(currentHigh);

                    decimal currentLow = stockDataClass.LowPrices.ElementAtOrDefault(i);
                    tempLowList.Add(currentLow);

                    decimal highest = tempHighList.TakeLast(varp).Max();
                    highestHighList.Add(highest);

                    decimal lowest = tempLowList.TakeLast(varp).Min();
                    lowestLowList.Add(lowest);

                    decimal vara = highest - lowest;
                    varaList.Add(vara);

                    decimal varr1 = vara == 0 && varp == 1 ? Math.Abs(currentClose - prevClose1) : vara;
                    varr1List.Add(varr1);

                    decimal varb = prevHighest1 - prevLowest1;
                    varbList.Add(varb);

                    decimal varr2 = varb == 0 && varp == 1 ? Math.Abs(prevClose1 - prevClose2) : varb;
                    varr2List.Add(varr2);

                    decimal varc = prevHighest2 - prevLowest2;
                    varcList.Add(varc);

                    decimal varr3 = varc == 0 && varp == 1 ? Math.Abs(prevClose2 - prevClose3) : varc;
                    varr3List.Add(varr3);

                    decimal vard = prevHighest3 - prevLowest3;
                    vardList.Add(vard);

                    decimal varr4 = vard == 0 && varp == 1 ? Math.Abs(prevClose3 - prevClose4) : vard;
                    varr4List.Add(varr4);

                    decimal vare = prevHighest4 - prevLowest4;
                    vareList.Add(vare);

                    decimal varr5 = vare == 0 && varp == 1 ? Math.Abs(prevClose4 - prevClose5) : vare;
                    varr5List.Add(varr5);

                    decimal cdelta = Math.Abs(currentClose - prevClose1);
                    decimal var0 = cdelta > currentHigh - currentLow || currentHigh == currentLow ? cdelta : currentHigh - currentLow;

                    decimal lRange = (varr1 + varr2 + varr3 + varr4 + varr5) / 5 * 0.2m;
                    lRangeList.Add(lRange);

                    decimal prevVvalue = vValueList.LastOrDefault();
                    decimal vValue = lRange != 0 ? (currentValue - mba) / lRange : 0;
                    vValueList.Add(vValue);

                    decimal prevVValueEma = vValueEmaList.LastOrDefault();
                    decimal vValueEma = CalculateExponentialMovingAverage(vValue, prevVValueEma, days);
                    vValueEmaList.Add(vValueEma);

                    var signal = GetRsiSignal(vValue - vValueEma, prevVvalue - prevVValueEma, vValue, prevVvalue, 4, -4);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (varr1List, varr2List, varr3List, varr4List, varr5List, varaList, varbList, varcList, vardList, vareList, lRangeList, vValueList, vValueEmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateDemarkRangeExpansionIndex(StockData stockDataClass, int days = 8)
        {
            //s1 = sum of first condition (n) * second condition (m) * price change parameter (s)
            //n = if ((High[j – 2] < Close[j - 7]) && (High[j - 2] < Close[j - 8]) && (High[j] < High[j - 5]) && (High[j] < High[j - 6]))
            // n = 0
            // else
            // n = 1
            //m = if ((Low[j – 2] > Close[j – 7]) && (Low[j – 2] > Close[j – 8]) && (Low[j] > Low[j – 5]) && (Low[j] > Low[j – 6]))
            // m = 0
            // else
            // m = 1
            //s = High[j] - High[j - 2] + Low[j] - Low[j - 2]
            //s2 = sum of s
            //rei = (s1 / s2) * 100
            List<decimal> nList = new();
            List<decimal> mList = new();
            List<decimal> sList = new();
            List<decimal> s2List = new();
            List<decimal> nmsList = new();
            List<decimal> sum1List = new();
            List<decimal> sum2List = new();
            List<decimal> reiList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.LowPrices.Count; i++)
                {
                    decimal high = stockDataClass.HighPrices.ElementAtOrDefault(i);
                    decimal prevHigh2 = i >= 2 ? stockDataClass.HighPrices.ElementAtOrDefault(i - 2) : 0;
                    decimal prevHigh5 = i >= 5 ? stockDataClass.HighPrices.ElementAtOrDefault(i - 5) : 0;
                    decimal prevHigh6 = i >= 6 ? stockDataClass.HighPrices.ElementAtOrDefault(i - 6) : 0;
                    decimal low = stockDataClass.LowPrices.ElementAtOrDefault(i);
                    decimal prevLow2 = i >= 2 ? stockDataClass.LowPrices.ElementAtOrDefault(i - 2) : 0;
                    decimal prevLow5 = i >= 5 ? stockDataClass.LowPrices.ElementAtOrDefault(i - 5) : 0;
                    decimal prevLow6 = i >= 6 ? stockDataClass.LowPrices.ElementAtOrDefault(i - 6) : 0;
                    decimal close = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevClose7 = i >= 7 ? stockDataClass.InputValues.ElementAtOrDefault(i - 7) : 0;
                    decimal prevClose8 = i >= 8 ? stockDataClass.InputValues.ElementAtOrDefault(i - 8) : 0;
                    decimal prevRei1 = i >= 1 ? reiList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevRei2 = i >= 2 ? reiList.ElementAtOrDefault(i - 2) : 0;

                    decimal n = prevHigh2 < prevClose7 && prevHigh2 < prevClose8 && high < prevHigh5 && high < prevHigh6 ? 0 : 1;
                    nList.Add(n);

                    decimal m = prevLow2 < prevClose7 && prevLow2 > prevClose8 && low > prevLow5 && low > prevLow6 ? 0 : 1;
                    mList.Add(m);

                    decimal s = (high - prevHigh2) + (low - prevLow2);
                    sList.Add(s);

                    decimal s1 = n + m + s;
                    nmsList.Add(s1);

                    decimal s2 = Math.Abs(high - prevHigh2) + Math.Abs(low - prevLow2);
                    s2List.Add(s2);

                    decimal s1Sum = nmsList.TakeLast(days).Sum();
                    sum1List.Add(s1Sum);

                    decimal s2Sum = s2List.TakeLast(days).Sum();
                    sum2List.Add(s2Sum);

                    decimal rei = s2Sum != 0 ? s1Sum / s2Sum * 100 : 0;
                    reiList.Add(rei);

                    var signal = GetRsiSignal(rei - prevRei1, prevRei1 - prevRei2, rei, prevRei1, 60, -60);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (nList, mList, sList, nmsList, s2List, sum1List, sum2List, reiList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateAccumulationDistributionLine(StockData stockDataClass, int days = 14)
        {
            //1. Money Flow Multiplier = [(Close  -  Low) - (High - Close)] /(High - Low)
            //2.Money Flow Volume = Money Flow Multiplier x Volume for the Period
            //3.ADL = Previous ADL + Current Period's Money Flow Volume	
            List<decimal> adlList = new();
            List<decimal> moneyFlowMultiplierList = new();
            List<decimal> moneyFlowVolumeList = new();
            List<decimal> adlSignalList = new();
            List<Signal> signalsList = new();

            try
            {
                var list = VolumeInputCheck(stockDataClass, days, false);
                var highList = list.Item1;
                var lowList = list.Item2;

                for (int i = 0; i < stockDataClass.LowPrices.Count; i++)
                {
                    decimal currentLow = lowList.ElementAtOrDefault(i);
                    decimal currentHigh = highList.ElementAtOrDefault(i);
                    decimal currentClose = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal currentVolume = stockDataClass.Volumes.ElementAtOrDefault(i);

                    decimal moneyFlowMultiplier = currentHigh - currentLow != 0 ? (currentClose - currentLow - (currentHigh - currentClose)) / (currentHigh - currentLow) : 0;
                    moneyFlowMultiplierList.Add(moneyFlowMultiplier);

                    decimal moneyFlowVolume = moneyFlowMultiplier * currentVolume;
                    moneyFlowVolumeList.Add(moneyFlowVolume);

                    decimal prevAdl = adlList.LastOrDefault();
                    decimal adl = prevAdl + moneyFlowVolume;
                    adlList.Add(adl);

                    decimal prevAdlSignal = adlSignalList.LastOrDefault();
                    decimal adlSignal = CalculateExponentialMovingAverage(adl, prevAdlSignal, days);
                    adlSignalList.Add(adlSignal);

                    var signal = GetCompareSignal(adl - adlSignal, prevAdl - prevAdlSignal);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (moneyFlowMultiplierList, moneyFlowVolumeList, adlList, adlSignalList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateVolumeAccumulationOscillator(StockData stockDataClass, int days = 14)
        {
            //input = price, user defined, default is closing price
            //Plot: vao = volume * (price - (high + low) / 2);
            List<decimal> vaoList = new();
            List<decimal> vaoSumList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal currentHigh = stockDataClass.HighPrices.ElementAtOrDefault(i);
                    decimal currentLow = stockDataClass.LowPrices.ElementAtOrDefault(i);
                    decimal currentVolume = stockDataClass.Volumes.ElementAtOrDefault(i);

                    decimal medianValue = (currentHigh + currentLow) / 2;
                    decimal vao = currentValue != medianValue ? currentVolume * (currentValue - medianValue) : currentVolume;
                    vaoList.Add(vao);

                    decimal prevVaoSum = vaoSumList.LastOrDefault();
                    decimal vaoSum = vaoList.TakeLast(days).Average();
                    vaoSumList.Add(vaoSum);

                    var signal = GetCompareSignal(vaoSum, prevVaoSum);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (vaoList, vaoSumList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateVolumeAccumulationPercent(StockData stockDataClass, int days = 10)
        {
            // @author LazyBear 
            // List of my public indicators: http://bit.ly/1LQaPK8
            // List of my app-store indicators: http://blog.tradingview.com/?p=970 
            //
            //study("Volume Accumulation Percentage Indicator [LazyBear]", shorttitle = "VAPI_LB", overlay = false)
            //length = input(10, title = "Time Periods")
            //x = (2 * close - high - low) / (high - low)
            //tva = sum(volume * x, length)
            //tv = sum(volume, length)
            //va = 100 * tva / tv
            //zl = plot(0, color = gray, title = "ZeroLine")
            //vac = gray
            //val = plot(va, color = vac, style = histogram, title = "VAPI Histogram")
            //us = va < 0 ? 0 : (va == 0 ? va[1] : va), ls = va > 0 ? 0 : (va == 0 ? va[1] : va)
            //ux = plot(us, color = gray, style = circles, title = "DummyU"), lx = plot(ls, color = gray, style = circles, title = "DummyL")
            //fill(ux, val, color = red, transp = 50, title = "NegativeFill"), fill(lx, val, color = lime, transp = 50, title = "PositiveFill")
            //plot(va, color = gray, linewidth = 2, title = "VAPI Osc")
            List<decimal> vapcList = new();
            List<decimal> xtList = new();
            List<decimal> tvaList = new();
            List<decimal> tempVolumeList = new();
            List<Signal> signalsList = new();

            try
            {
                var list = VolumeInputCheck(stockDataClass, days, false);
                var highList = list.Item1;
                var lowList = list.Item2;

                for (int i = 0; i < stockDataClass.HighPrices.Count; i++)
                {
                    decimal currentHigh = highList.ElementAtOrDefault(i);
                    decimal currentLow = lowList.ElementAtOrDefault(i);
                    decimal currentClose = stockDataClass.InputValues.ElementAtOrDefault(i);

                    decimal currentVolume = stockDataClass.Volumes.ElementAtOrDefault(i);
                    tempVolumeList.Add(currentVolume);

                    decimal xt = currentHigh - currentLow != 0 ? ((2 * currentClose) - currentHigh - currentLow) / (currentHigh - currentLow) : 0;
                    xtList.Add(xt);

                    decimal tva = currentVolume * xt;
                    tvaList.Add(tva);

                    decimal volumeSum = tempVolumeList.TakeLast(days).Sum();
                    decimal tvaSum = tvaList.TakeLast(days).Sum();

                    decimal prevVapc = vapcList.LastOrDefault();
                    decimal vapc = volumeSum != 0 ? MinOrMax(100 * tvaSum / volumeSum, 100, 0) : 0;
                    vapcList.Add(vapc);

                    var signal = GetCompareSignal(vapc, prevVapc);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (xtList, tvaList, vapcList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateBelkhayateTiming(StockData stockDataClass)
        {
            //
            // @author LazyBear
            //
            // List of my public indicators: http://bit.ly/1LQaPK8
            // List of my app-store indicators: http://blog.tradingview.com/?p=970
            //
            // v02 - support for osc candles (@TheMightyChicken)
            //
            //study("Belkhayate Timing [LazyBear]", shorttitle = "BT_LB", overlay = false)
            //showHLC = input(true, title = "Smooth Osc?"), showHisto = input(false, title = "Show Histogram?")
            //showCandles = input(false), colorCandles = input(true, title = "Color Osc Candles (valid only if ShowCandles is enabled)")
            //Range1 = input(4), Range2 = input(8), ebc = input(false, title = "Enable Barcolors")
            //middle = (((high + low) / 2) + ((high[1] + low[1]) / 2) + ((high[2] + low[2]) / 2) + ((high[3] + low[3]) / 2) + ((high[4] + low[4]) / 2)) / 5
            //scale = (((high - low) + (high[1] - low[1]) + (high[2] - low[2]) + (high[3] - low[3]) + (high[4] - low[4])) / 5) * 0.2
            //h = (high - middle) / scale
            //l = (low - middle) / scale
            //o = (open - middle) / scale
            //c = (close - middle) / scale
            //ht = showHLC ? avg(h, l, c) : c
            //plot(0, title = "ZeroLine", color = gray)
            //l1 = plot(Range1, title = "SellLine1", color = gray)
            //l2 = plot(Range2, title = "SellLine2", color = gray)
            //l3 = plot(-Range1, title = "BuyLine1", color = gray)
            //l4 = plot(-Range2, title = "BuyLine2", color = gray)
            //fill(l1, l2, red, title = "OBZone"), fill(l3, l4, lime, title = "OSZone")
            //plot(showHisto ? ht : na, style = histogram, title = "BTOscHistogram", linewidth = 1, color = ht > 0 ? green : red)
            //plot(ht, style = line, title = "BTOsc", linewidth = 3, color = gray)
            //bc = ht > 0 ? (ht >= Range2 ? blue : (ht >= Range1 ? green : lime)) : (ht <= -Range2 ? blue : (ht <= -Range1 ? maroon : red))
            //barcolor(ebc ? bc : na)
            //plot(ht, style = linebr, title = "BTOsc", linewidth = 3, color = gray)
            List<decimal> middleList = new();
            List<decimal> scaleList = new();
            List<decimal> bList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.HighPrices.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal currentHigh = stockDataClass.HighPrices.ElementAtOrDefault(i);
                    decimal currentLow = stockDataClass.LowPrices.ElementAtOrDefault(i);
                    decimal prevHigh1 = i >= 1 ? stockDataClass.HighPrices.ElementAtOrDefault(i - 1) : 0;
                    decimal prevLow1 = i >= 1 ? stockDataClass.LowPrices.ElementAtOrDefault(i - 1) : 0;
                    decimal prevHigh2 = i >= 2 ? stockDataClass.HighPrices.ElementAtOrDefault(i - 2) : 0;
                    decimal prevLow2 = i >= 2 ? stockDataClass.LowPrices.ElementAtOrDefault(i - 2) : 0;
                    decimal prevHigh3 = i >= 3 ? stockDataClass.HighPrices.ElementAtOrDefault(i - 3) : 0;
                    decimal prevLow3 = i >= 3 ? stockDataClass.LowPrices.ElementAtOrDefault(i - 3) : 0;
                    decimal prevHigh4 = i >= 4 ? stockDataClass.HighPrices.ElementAtOrDefault(i - 4) : 0;
                    decimal prevLow4 = i >= 4 ? stockDataClass.LowPrices.ElementAtOrDefault(i - 4) : 0;
                    decimal prevB1 = i >= 1 ? bList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevB2 = i >= 2 ? bList.ElementAtOrDefault(i - 2) : 0;

                    decimal middle = (((currentHigh + currentLow) / 2) + ((prevHigh1 + prevLow1) / 2) + ((prevHigh2 + prevLow2) / 2) + ((prevHigh3 + prevLow3) / 2) +
                        ((prevHigh4 + prevLow4) / 2)) / 5;
                    middleList.Add(middle);

                    decimal scale = (((currentHigh - currentLow) + (prevHigh1 - prevLow1) + (prevHigh2 - prevLow2) + (prevHigh3 - prevLow3) + (prevHigh4 - prevLow4)) / 5) * 0.2m;
                    scaleList.Add(scale);

                    decimal b = scale != 0 ? (currentValue - middle) / scale : 0;
                    bList.Add(b);

                    var signal = GetRsiSignal(b - prevB1, prevB1 - prevB2, b, prevB1, 4, -4);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (middleList, scaleList, bList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateJmaRsxClone(StockData stockDataClass, int days = 14)
        {
            //@version=3
            // Copyright (c) 2019-present, Alex Orekhov (everget)
            // Jurik RSX script may be freely distributed under the MIT license.
            //study("Jurik RSX", shorttitle = "RSX")

            //length = input(title = "Length", type = integer, defval = 14)
            //src = input(title = "Source", type = source, defval = hlc3)
            //obLevel = input(title = "OB Level", type = integer, defval = 70)
            //osLevel = input(title = "OS Level", type = integer, defval = 30)
            //highlightBreakouts = input(title = "Highlight Overbought/Oversold Breakouts ?", type = bool, defval = true)

            //f8 = 100 * src
            //f10 = nz(f8[1])
            //v8 = f8 - f10

            //f18 = 3 / (length + 2)
            //f20 = 1 - f18

            //f28 = 0.0
            //f28:= f20 * nz(f28[1]) + f18 * v8

            //f30 = 0.0
            //f30:= f18 * f28 + f20 * nz(f30[1])
            //vC = f28 * 1.5 - f30 * 0.5

            //f38 = 0.0
            //f38:= f20 * nz(f38[1]) + f18 * vC

            //f40 = 0.0
            //f40:= f18 * f38 + f20 * nz(f40[1])
            //v10 = f38 * 1.5 - f40 * 0.5

            //f48 = 0.0
            //f48:= f20 * nz(f48[1]) + f18 * v10

            //f50 = 0.0
            //f50:= f18 * f48 + f20 * nz(f50[1])
            //v14 = f48 * 1.5 - f50 * 0.5

            //f58 = 0.0
            //f58:= f20 * nz(f58[1]) + f18 * abs(v8)

            //f60 = 0.0
            //f60:= f18 * f58 + f20 * nz(f60[1])
            //v18 = f58 * 1.5 - f60 * 0.5

            //f68 = 0.0
            //f68:= f20 * nz(f68[1]) + f18 * v18

            //f70 = 0.0
            //f70:= f18 * f68 + f20 * nz(f70[1])
            //v1C = f68 * 1.5 - f70 * 0.5

            //f78 = 0.0
            //f78:= f20 * nz(f78[1]) + f18 * v1C

            //f80 = 0.0
            //f80:= f18 * f78 + f20 * nz(f80[1])
            //v20 = f78 * 1.5 - f80 * 0.5

            //f88_ = 0.0
            //f90_ = 0.0

            //f88 = 0.0
            //f90_:= nz(f90_[1]) == 0 ? 1 : nz(f88[1]) <= nz(f90_[1]) ? nz(f88[1]) + 1 : nz(f90_[1]) + 1
            //f88:= nz(f90_[1]) == 0 and(length - 1 >= 5) ? length - 1 : 5

            //f0 = f88 >= f90_ and f8 != f10 ? 1 : 0
            //f90 = f88 == f90_ and f0 == 0 ? 0 : f90_

            //v4_ = f88 < f90 and v20 > 0 ? (v14 / v20 + 1) * 50 : 50
            //rsx = v4_ > 100 ? 100 : v4_ < 0 ? 0 : v4_

            //rsxColor = rsx > obLevel ? #0ebb23 : rsx < osLevel ? #ff0000 : #f4b77d
            //plot(rsx, title = "RSX", linewidth = 2, color = rsxColor, transp = 0)

            //transparent = color(white, 100)

            //maxLevelPlot = hline(100, title = "Max Level", linestyle = dotted, color = transparent)
            //obLevelPlot = hline(obLevel, title = "Overbought Level", linestyle = dotted)
            //hline(50, title = "Middle Level", linestyle = dotted)
            //osLevelPlot = hline(osLevel, title = "Oversold Level", linestyle = dotted)
            //minLevelPlot = hline(0, title = "Min Level", linestyle = dotted, color = transparent)

            //fill(obLevelPlot, osLevelPlot, color = purple, transp = 95)

            //obFillColor = rsx > obLevel and highlightBreakouts ? green: transparent
            //osFillColor = rsx < osLevel and highlightBreakouts ? red: transparent

            //fill(maxLevelPlot, obLevelPlot, color = obFillColor, transp = 90)
            //fill(minLevelPlot, osLevelPlot, color = osFillColor, transp = 90)
            List<decimal> rsxList = new();
            List<decimal> f8List = new();
            List<decimal> f28List = new();
            List<decimal> f30List = new();
            List<decimal> f38List = new();
            List<decimal> f40List = new();
            List<decimal> f48List = new();
            List<decimal> f50List = new();
            List<decimal> f58List = new();
            List<decimal> f60List = new();
            List<decimal> f68List = new();
            List<decimal> f70List = new();
            List<decimal> f78List = new();
            List<decimal> f80List = new();
            List<decimal> f88List = new();
            List<decimal> f90_List = new();
            List<decimal> v4_List = new();
            List<decimal> vcList = new();
            List<decimal> v1cList = new();
            List<decimal> v20List = new();
            List<decimal> v8List = new();
            List<decimal> v10List = new();
            List<decimal> v14List = new();
            List<decimal> v18List = new();
            List<decimal> f90List = new();
            List<decimal> f10List = new();
            List<decimal> f0List = new();
            List<Signal> signalsList = new();

            try
            {
                decimal f18 = (decimal)3 / (days + 2);
                decimal f20 = 1 - f18;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevRsx1 = i >= 1 ? rsxList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevRsx2 = i >= 2 ? rsxList.ElementAtOrDefault(i - 2) : 0;

                    decimal prevF8 = f8List.LastOrDefault();
                    decimal f8 = 100 * currentValue;
                    f8List.Add(f8);

                    decimal f10 = prevF8;
                    f10List.Add(f10);

                    decimal v8 = f8 - f10;
                    v8List.Add(v8);

                    decimal prevF28 = f28List.LastOrDefault();
                    decimal f28 = (f20 * prevF28) + (f18 * v8);
                    f28List.Add(f28);

                    decimal prevF30 = f30List.LastOrDefault();
                    decimal f30 = (f18 * f28) + (f20 * prevF30);
                    f30List.Add(f30);

                    decimal vC = (f28 * 1.5m) - (f30 * 0.5m);
                    vcList.Add(vC);

                    decimal prevF38 = f38List.LastOrDefault();
                    decimal f38 = (f20 * prevF38) + (f18 * vC);
                    f38List.Add(f38);

                    decimal prevF40 = f40List.LastOrDefault();
                    decimal f40 = (f18 * f38) + (f20 * prevF40);
                    f40List.Add(f40);

                    decimal v10 = (f38 * 1.5m) - (f40 * 0.5m);
                    v10List.Add(v10);

                    decimal prevF48 = f48List.LastOrDefault();
                    decimal f48 = (f20 * prevF48) + (f18 * v10);
                    f48List.Add(f48);

                    decimal prevF50 = f50List.LastOrDefault();
                    decimal f50 = (f18 * f48) + (f20 * prevF50);
                    f50List.Add(f50);

                    decimal v14 = (f48 * 1.5m) - (f50 * 0.5m);
                    v14List.Add(v14);

                    decimal prevF58 = f58List.LastOrDefault();
                    decimal f58 = (f20 * prevF58) + (f18 * Math.Abs(v8));
                    f58List.Add(f58);

                    decimal prevF60 = f60List.LastOrDefault();
                    decimal f60 = (f18 * f58) + (f20 * prevF60);
                    f60List.Add(f60);

                    decimal v18 = (f58 * 1.5m) - (f60 * 0.5m);
                    v18List.Add(v18);

                    decimal prevF68 = f68List.LastOrDefault();
                    decimal f68 = (f20 * prevF68) + (f18 * v18);
                    f68List.Add(f68);

                    decimal prevF70 = f70List.LastOrDefault();
                    decimal f70 = (f18 * f68) + (f20 * prevF70);
                    f70List.Add(f70);

                    decimal v1C = (f68 * 1.5m) - (f70 * 0.5m);
                    v1cList.Add(v1C);

                    decimal prevF78 = f78List.LastOrDefault();
                    decimal f78 = (f20 * prevF78) + (f18 * v1C);
                    f78List.Add(f78);

                    decimal prevF80 = f80List.LastOrDefault();
                    decimal f80 = (f18 * f78) + (f20 * prevF80);
                    f80List.Add(f80);

                    decimal v20 = (f78 * 1.5m) - (f80 * 0.5m);
                    v20List.Add(v20);

                    decimal prevF88 = f88List.LastOrDefault();
                    decimal prevF90_ = f90_List.LastOrDefault();
                    decimal f90_ = prevF90_ == 0 ? 1 : prevF88 <= prevF90_ ? prevF88 + 1 : prevF90_ + 1;
                    f90_List.Add(f90_);

                    decimal f88 = prevF90_ == 0 && days - 1 >= 5 ? days - 1 : 5;
                    f88List.Add(f88);

                    decimal f0 = f88 >= f90_ && f8 != f10 ? 1 : 0;
                    f0List.Add(f0);

                    decimal f90 = f88 == f90_ && f0 == 0 ? 0 : f90_;
                    f90List.Add(f90);

                    decimal v4_ = f88 < f90 && v20 > 0 ? MinOrMax(((v14 / v20) + 1) * 50, 100, 0) : 50;
                    v4_List.Add(v4_);

                    decimal rsx = v4_ > 100 ? 100 : v4_ < 0 ? 0 : v4_;
                    rsxList.Add(rsx);

                    var signal = GetRsiSignal(rsx - prevRsx1, prevRsx1 - prevRsx2, rsx, prevRsx1, 70, 30);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (f90_List, f88List, f8List, f10List, v8List, f28List, f30List, vcList, f38List, f40List, v10List, f48List, f50List, v14List, f58List, f60List,
                v18List, f68List, f70List, v1cList, f78List, f80List, v20List, f0List, f90List, v4_List, rsxList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateRangeIdentifier(StockData stockDataClass, int days = 34)
        {
            //
            // @author LazyBear
            //
            // List of my public indicators: http://bit.ly/1LQaPK8
            // List of my app-store indicators: http://blog.tradingview.com/?p=970
            //
            // v2 - Made midline connected based on connectRanges option
            //
            //study("Range Identifier [LazyBear]", shorttitle = "RID_LB", overlay = true)
            //connectRanges = input(false, title = "Connect Ranges")
            //showMidLine = input(false, title = "Show MidLine")
            //lengthEMA = input(34, title = "EMA Length")
            //showEMA = input(true, title = "Show EMA")
            //hc = input(true, title = "Highlight Consolidation")
            //e = ema(close, lengthEMA)
            //up = close < nz(up[1]) and close> down[1] ? nz(up[1]) : high
            //down = close < nz(up[1]) and close> down[1] ? nz(down[1]) : low
            //mid = avg(up, down)
            //ul = plot(connectRanges ? up : up == nz(up[1]) ? up : na, color = gray, linewidth = 2, style = linebr, title = "Up")
            //ll = plot(connectRanges ? down : down == nz(down[1]) ? down : na, color = gray, linewidth = 2, style = linebr, title = "Down")
            //dummy = plot(hc ? close > e ? down : up : na, color = gray, style = circles, linewidth = 0, title = "Dummy")
            //fill(ul, dummy, color = lime)
            //fill(dummy, ll, color = red)
            //plot(showMidLine ? mid : na, color = gray, linewidth = 1, title = "Mid")
            //plot(showEMA ? e : na, title = "EMA", color = black, linewidth = 2)
            List<decimal> upList = new();
            List<decimal> downList = new();
            List<decimal> midList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.HighPrices.Count; i++)
                {
                    decimal currentHigh = stockDataClass.HighPrices.ElementAtOrDefault(i);
                    decimal currentLow = stockDataClass.LowPrices.ElementAtOrDefault(i);
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevUp = upList.LastOrDefault();
                    decimal prevDown = downList.LastOrDefault();
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal up = currentValue < prevUp && currentValue > prevDown ? prevUp : currentHigh;
                    upList.Add(up);

                    decimal down = currentValue < prevUp && currentValue > prevDown ? prevDown : currentLow;
                    downList.Add(down);

                    decimal prevMid = midList.LastOrDefault();
                    decimal mid = (up + down) / 2;
                    midList.Add(mid);

                    var signal = GetCompareSignal(currentValue - mid, prevValue - prevMid);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (upList, downList, midList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateMobilityOscillator(StockData stockDataClass, int days = 10)
        {
            //period = user defined, default is 14
            //m = user defined, default is 10
            //pdf = price distrubition function
            //index = current bar number, LOE = less or equal
            //MOE = more or equal

            //Plot: mo = -mo(m, index, period);
            //Method mo(m, index, period)
            //hMax = highest(index, period, high);
            //lMin = lowest(index, period, low);
            //rX = (hMax - lMin) / m;
            //bL = 0, bU = 0, pdfI = 0, pdfC = 0, pdfMx = 0;
            //imX = 1, priorClose = 0, x = 0;
            //for (i = index - m + 1; i LOE index; i++)
            //bU = lMin + ((x + 1) * rX);
            //bL = bU - rX;
            //pdfI = pdf(i, (x + 1), m, period);
            //if (x == 0) pdfMx = pdfI;
            //if (pdfI moreThan pdfMx) imX = x + 1; pdfMx = pdfI;
            //if (x == 0) pdfC = pdfI;
            //priorClose = close[period - 1];
            //if (priorClose moreThan bL AND priorClose LOE bU) pdfC = pdfI;
            //x++;
            //endFor
            //pmo = lMin + (imX - .5) * rX;
            //moVar = 100 * (1 - pdfC / pdfMx);
            //if (priorClose lessThan pmo) moVar = -moVar;
            //return moVar;
            //endMethod
            //....
            //Method pdf(index, value1, m, period)
            //hMax = highest(index, period, high);
            //lMin = lowest(index, period, low);
            //hi = 0;
            //lo = 0;
            //pdf = 0;
            //rX = (hMax - lMin) / m;
            //bL = lMin + ((value1 - 1) * rX);
            //bU = lMin + (value1* rX);
            //for(i=index-period+1; i LOE index; i++) 
            //hi = high[i];
            //lo = low[i];
            //if (hi LOE lo) continue;
            //if (hi LOE bU) pdf++;
            //if (!(hi LOE bU OR lo MOE bU)) pdf = pdf + (bU - low) / (hi - lo);
            //if (hi lessOr= bL) pdf--;
            //if (!(hi LOE bL OR lo MOE bL)) pdf = pdf - (bL - low) / (hi - lo);
            //return pdf / period;
            //endMethod
            List<decimal> rxList = new();
            List<decimal> pmoList = new();
            List<decimal> moVarList = new();
            List<decimal> pdfList = new();
            List<Signal> signalsList = new();

            try
            {
                int period = (int)Math.Ceiling(days / 0.7143);
                int m = days;

                var minMaxList = VolumeInputCheck(stockDataClass, period, true);
                List<decimal> highestHighList = minMaxList.Item1;
                List<decimal> lowestLowList = minMaxList.Item2;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal hMax = highestHighList.ElementAtOrDefault(i);
                    decimal lMin = lowestLowList.ElementAtOrDefault(i);

                    decimal rx = (hMax - lMin) / m;
                    rxList.Add(rx);

                    decimal bl = 0, bu = 0, pdfi = 0, pdfc = 0, pdfmx = 0, imx = 1, prevPrice = 0;
                    int x = 0;
                    for (int j = i - (m + 1); j <= i; j++)
                    {
                        decimal v1 = x + 1;
                        bu = lMin + (v1 * rx);
                        bl = bu - rx;

                        if (j >= 0)
                        {
                            hMax = highestHighList.ElementAtOrDefault(j);
                            lMin = lowestLowList.ElementAtOrDefault(j);
                            rx = (hMax - lMin) / m;
                            bl = lMin + ((v1 - 1) * rx);
                            bu = lMin + (v1 * rx);
                        }

                        decimal pdf = 0, currentHigh = 0, currentLow = 0;
                        for (int k = j - (period + 1); k <= j; k++)
                        {
                            if (k >= 0)
                            {
                                currentHigh = stockDataClass.HighPrices.ElementAtOrDefault(k);
                                currentLow = stockDataClass.LowPrices.ElementAtOrDefault(k);

                                if (currentHigh <= currentLow)
                                {
                                    continue;
                                }
                                if (currentHigh <= bu)
                                {
                                    pdf++;
                                }
                                if (!(currentHigh <= bu || currentLow >= bu))
                                {
                                    pdf += (bu - currentLow) / (currentHigh - currentLow);
                                }
                                if (currentHigh <= bl)
                                {
                                    pdf--;
                                }
                                if (!(currentHigh <= bl || currentLow >= bl))
                                {
                                    pdf -= (bl - currentLow) / (currentHigh - currentLow);
                                }
                            }
                        }
                        pdfi = pdf / period;

                        if (x == 0)
                        {
                            pdfmx = pdfi;
                        }
                        if (pdfi > pdfmx)
                        {
                            imx = x + 1;
                            pdfmx = pdfi;
                        }
                        if (x == 0)
                        {
                            pdfc = pdfi;
                        }

                        prevPrice = j >= period - 1 ? stockDataClass.InputValues.ElementAtOrDefault(j - (period - 1)) : 0;

                        if (prevPrice > bl && prevPrice <= bu)
                        {
                            pdfc = pdfi;
                        }
                        x++;
                    }
                    pdfList.Add(pdfc);

                    lMin = stockDataClass.LowPrices.ElementAtOrDefault(i);
                    decimal pmo = lMin + ((imx - 0.5m) * rx);
                    pmoList.Add(pmo);

                    decimal prevMovar = moVarList.LastOrDefault();
                    decimal moVar = pdfmx != 0 ? 100 * (1 - (pdfc / pdfmx)) : 0;
                    moVar = prevPrice < pmo ? -1 * moVar : moVar;
                    moVarList.Add(moVar);

                    var signal = GetCompareSignal(moVar, prevMovar);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (rxList, pdfList, pmoList, moVarList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateProjectionBandwith(StockData stockDataClass, int days = 3)
        {
            ////period = user defined, default is 14
            //prev = previous, index = current bar number
            //LOE = less or equal

            //mLow = linRegLine(period, low)[1]; //returns the slope (m) of Linear Regression line
            //mHigh = linRegLine(period, high)[1];
            //count = 0;
            //pbw = 0, pu = 0, pl = decimal.MAX_VALUE;
            //for (i = (index - period + 1); i LOE index; i++) //move back 1 period
            //prevHigh = high[i - 1];
            //prevLow = low[i - 1];
            //vHigh = prevHigh + (mHigh * (count));
            //vLow = prevLow + (mLow * (count));
            //if (vHigh moreThan pu) pu = vHigh;
            //if (vLow lessThan pl) pl = vLow;
            //count++;
            //endFor
            //Plot: pbw = 200 * (pu - pl) / (pu + pl);
            List<decimal> pbwList = new();
            List<decimal> puList = new();
            List<decimal> plList = new();
            List<decimal> pbwSignalList = new();
            List<Signal> signalsList = new();

            try
            {
                int sigPeriod = days;
                int length = (int)Math.Ceiling(days / 0.2143);

                List<decimal> lowSlopeList = CalculateLinearRegression(stockDataClass.LowPrices, stockDataClass, length).Item11;
                List<decimal> highSlopeList = CalculateLinearRegression(stockDataClass.HighPrices, stockDataClass, length).Item11;

                for (int i = 0; i < lowSlopeList.Count; i++)
                {
                    decimal currentLowSlope = lowSlopeList.ElementAtOrDefault(i);
                    decimal currentHighSlope = highSlopeList.ElementAtOrDefault(i);
                    decimal currentLow = stockDataClass.LowPrices.ElementAtOrDefault(i);
                    decimal currentHigh = stockDataClass.HighPrices.ElementAtOrDefault(i);

                    decimal pu = 0;
                    decimal pl = decimal.MaxValue;
                    int count = 0;
                    decimal vHigh, vLow, prevHigh, prevLow;
                    for (int j = i - (length + 1); j <= i; j++)
                    {
                        if (j >= 1)
                        {
                            prevHigh = stockDataClass.HighPrices.ElementAtOrDefault(j - 1);
                            prevLow = stockDataClass.LowPrices.ElementAtOrDefault(j - 1);
                            vHigh = prevHigh + (currentHighSlope * count);
                            vLow = prevLow + (currentLowSlope * count);
                            pu = vHigh > pu ? vHigh : pu;
                            pl = vLow < pl ? vLow : pl;
                            count++;
                        }
                    }
                    if (pl == decimal.MaxValue)
                    {
                        // if pl is still max then set to 0
                        pl = 0;
                    }
                    puList.Add(pu);
                    plList.Add(pl);

                    decimal prevPbw = pbwList.LastOrDefault();
                    decimal pbw = pu + pl != 0 ? 200 * (pu - pl) / (pu + pl) : 0;
                    pbwList.Add(pbw);

                    decimal prevPbwSignal = pbwSignalList.LastOrDefault();
                    decimal pbwSignal = CalculateExponentialMovingAverage(pbw, pbwSignalList.LastOrDefault(), sigPeriod);
                    pbwSignalList.Add(pbwSignal);

                    var signal = GetCompareSignal(pbw - pbwSignal, prevPbw - prevPbwSignal, true);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (puList, plList, pbwList, pbwSignalList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateProjectionBandUL(StockData stockDataClass, int days = 14)
        {
            //period = user defined, default is 14
            //prev = previous
            //index = current bar number
            //m = slope in line equation, y = a + mx
            //LOE = less or equal, MOE = more or equal

            //pu = 0, pl = MAX_VALUE;
            //mHigh = linRegLine(index, period, high, 0)[1];
            //mLow = linRegLine(index, period, low, 0)[1];
            //count = 0;
            //for (int i = (index - period + 1); i LOE index; i++)  //move back 1 period
            //prevHigh = high[i - 1];
            //prevLow = low[i - 1];
            //vHigh = prevHigh + (mHigh * (count));
            //vLow = prevLow + (mLow * (count));
            //if (vHigh moreThan pu) pu = vHigh;
            //if (vLow lessThan pl) pl = vLow;
            //count++;
            //end;
            //Plot1: pl;
            //Plot2: pu;
            //Signals
            //sell = high moreThan pu;
            //buy = low lessThan pl;
            List<decimal> puList = new();
            List<decimal> plList = new();
            List<decimal> innerPuList = new();
            List<decimal> innerPlList = new();
            List<decimal> middleBandList = new();
            List<Signal> signalsList = new();

            try
            {
                List<decimal> lowSlopeList = CalculateLinearRegression(stockDataClass.LowPrices, stockDataClass, days).Item11;
                List<decimal> highSlopeList = CalculateLinearRegression(stockDataClass.HighPrices, stockDataClass, days).Item11;

                for (int i = 0; i < lowSlopeList.Count; i++)
                {
                    decimal currentLowSlope = lowSlopeList.ElementAtOrDefault(i);
                    decimal currentHighSlope = highSlopeList.ElementAtOrDefault(i);
                    decimal currentLow = stockDataClass.LowPrices.ElementAtOrDefault(i);
                    decimal currentHigh = stockDataClass.HighPrices.ElementAtOrDefault(i);
                    decimal priorHigh = i >= 1 ? stockDataClass.HighPrices.ElementAtOrDefault(i - 1) : 0;
                    decimal priorLow = i >= 1 ? stockDataClass.LowPrices.ElementAtOrDefault(i - 1) : 0;
                    decimal prevPu = puList.LastOrDefault();
                    decimal prevPl = plList.LastOrDefault();

                    decimal pu = 0, pl = decimal.MaxValue, vHigh = 0, vLow = 0, innerPu = 0, innerPl = 0;
                    int count = 0;
                    for (int j = i - (days + 1); j <= i; j++)
                    {
                        decimal prevHigh = j >= 1 ? stockDataClass.HighPrices.ElementAtOrDefault(j - 1) : 0;
                        decimal prevLow = j >= 1 ? stockDataClass.LowPrices.ElementAtOrDefault(j - 1) : 0;
                        vHigh = prevHigh + (currentHighSlope * count);
                        vLow = prevLow + (currentLowSlope * count);
                        pu = vHigh > pu ? vHigh : pu;
                        pl = vLow < pl ? vLow : pl;
                        innerPu = vHigh > pu ? prevHigh + (currentHighSlope * ((decimal)count / 2)) : innerPu;
                        innerPl = vLow < pl ? prevLow + (currentLowSlope * ((decimal)count / 2)) : innerPl;
                        count++;
                    }
                    if (pl == decimal.MaxValue)
                    {
                        // if pl is still max then set to 0
                        pl = 0;
                    }
                    puList.Add(pu);
                    plList.Add(pl);
                    innerPuList.Add(innerPu);
                    innerPlList.Add(innerPl);

                    decimal prevMiddleBand = middleBandList.LastOrDefault();
                    decimal middleBand = (pu + pl) / 2;
                    middleBandList.Add(middleBand);

                    decimal currentValue = (currentHigh + currentLow) / 2;
                    decimal prevValue = (priorHigh + priorLow) / 2;

                    var signal = GetBollingerBandsSignal(currentValue - middleBand, prevValue - prevMiddleBand, currentValue, prevValue, pu, prevPu, pl, prevPl);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (puList, plList, middleBandList, innerPuList, innerPlList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateProjectionOscillator(StockData stockDataClass, int days = 3)
        {
            ////method = user defined, default is EMA
            //pboPeriod = user defined, default is 14
            //sigPeriod = user defined, default is 3
            //index = current bar number, LOE = less or equal

            //mHigh = linRegLine(period, high)[1];   //returns the slope (m) of Linear Regresion line
            //mLow = linRegLine(period, low)[1];
            //count = 0;
            //pbw = 0, pu = 0, pl = decimal.MAX_VALUE;
            //for (i = (index - pboPeriod + 1); i LOE index; i++)   //move back 1 period
            //high = high[i];
            //low = low[i];
            //vHigh = high + (mHigh * (count));
            //vLow = low + (mLow * (count));
            //if (vHigh moreThan pu) pu = vHigh;
            //if (vLow lessThan pl) pl = vLow;
            //count++;
            //endFor
            //Plot1: PBO = 100 * (price - pl) / (pu - pl);
            //Plot2: SIG = ma(method, sigPeriod, pbo);
            //buy = crossedAbove(PBO, SIG);
            //sell = crossedBelow(PBO, SIG);
            List<decimal> puList = new();
            List<decimal> plList = new();
            List<decimal> pboList = new();
            List<decimal> pboSignalList = new();
            List<Signal> signalsList = new();

            try
            {
                int sigPeriod = days;
                int length = (int)Math.Ceiling(days / 0.2143);

                List<decimal> lowSlopeList = CalculateLinearRegression(stockDataClass.LowPrices, stockDataClass, length).Item11;
                List<decimal> highSlopeList = CalculateLinearRegression(stockDataClass.HighPrices, stockDataClass, length).Item11;

                for (int i = 0; i < lowSlopeList.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal currentLowSlope = lowSlopeList.ElementAtOrDefault(i);
                    decimal currentHighSlope = highSlopeList.ElementAtOrDefault(i);

                    decimal pu = 0;
                    decimal pl = decimal.MaxValue;
                    int count = 0;
                    decimal vHigh, vLow;
                    for (int j = i - (length + 1); j <= i; j++)
                    {
                        if (j >= 0)
                        {
                            decimal currentHigh = stockDataClass.HighPrices.ElementAtOrDefault(j);
                            decimal currentLow = stockDataClass.LowPrices.ElementAtOrDefault(j);
                            vHigh = currentHigh + (currentHighSlope * count);
                            vLow = currentLow + (currentLowSlope * count);

                            if (vHigh > pu)
                            {
                                pu = vHigh;
                            }
                            if (vLow < pl)
                            {
                                pl = vLow;
                            }
                            count++;
                        }
                    }
                    if (pl == decimal.MaxValue)
                    {
                        // if pl is still max then set to 0
                        pl = 0;
                    }
                    puList.Add(pu);
                    plList.Add(pl);

                    decimal prevPbo = pboList.LastOrDefault();
                    decimal pbo = pu - pl != 0 ? 100 * (currentValue - pl) / (pu - pl) : 0;
                    pboList.Add(pbo);

                    decimal prevPboSignal = pboSignalList.LastOrDefault();
                    decimal pboSignal = CalculateExponentialMovingAverage(pbo, prevPboSignal, sigPeriod);
                    pboSignalList.Add(pboSignal);

                    var signal = GetCompareSignal(pbo - pboSignal, prevPbo - prevPboSignal);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (puList, plList, pboList, pboSignalList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateHurstBands(StockData stockDataClass, int days = 10)
        {
            //
            // @author LazyBear
            //
            // If you use this code in its original/modified form, do drop me a note. 
            //
            //study("Hurst Bands [LazyBear]", shorttitle = "H%Bands_LB", overlay = true)
            //price = hl2
            //length = input(10, title = "Displacement length")
            //InnerValue = input(1.6, title = "Innerbands %")
            //OuterValue = input(2.6, title = "Outerbands %")
            //ExtremeValue = input(4.2, title = "Extremebands %")
            //showExtremeBands = input(false, type = bool, title = "Display Extreme Bands?")
            //showClosingPriceLine = input(false, type = bool, title = "Plot Close price?")
            //smooth = input(1, title = "EMA Length for Close")

            //displacement = (length / 2) + 1
            //dPrice = price[displacement]

            //CMA = not na(dPrice) ? sma(dPrice, abs(length)) : nz(CMA[1]) + (nz(CMA[1]) - nz(CMA[2]))

            //CenteredMA = plot(not na(dPrice) ? CMA : na, color = blue, linewidth = 2)
            //CenterLine = plot(not na(price) ? CMA : na, linewidth = 2, color = aqua)

            //ExtremeBand = CMA * ExtremeValue / 100
            //OuterBand = CMA * OuterValue / 100
            //InnerBand = CMA * InnerValue / 100

            //UpperExtremeBand = plot(showExtremeBands and(not na(price)) ? CMA + ExtremeBand : na)
            //LowerExtremeBand = plot(showExtremeBands and(not na(price)) ? CMA - ExtremeBand : na)
            //UpperOuterBand = plot(not na(price) ? CMA + OuterBand : na)
            //LowerOuterBand = plot(not na(price) ? CMA - OuterBand : na)
            //UpperInnerBand = plot(not na(price) ? CMA + InnerBand : na)
            //LowerInnerBand = plot(not na(price) ? CMA - InnerBand : na)
            decimal innerValue = 1.6m, outerValue = 2.6m, extremeValue = 4.2m;
            List<decimal> cmaList = new();
            List<decimal> extremeBandList = new();
            List<decimal> outerBandList = new();
            List<decimal> innerBandList = new();
            List<decimal> upperExtremeBandList = new();
            List<decimal> lowerExtremeBandList = new();
            List<decimal> upperOuterBandList = new();
            List<decimal> lowerOuterBandList = new();
            List<decimal> upperInnerBandList = new();
            List<decimal> lowerInnerBandList = new();
            List<decimal> dPriceList = new();
            List<Signal> signalsList = new();

            try
            {
                int displacement = MinOrMax((int)Math.Ceiling((decimal)days / 2) + 1);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevCma1 = i >= 1 ? cmaList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevCma2 = i >= 2 ? cmaList.ElementAtOrDefault(i - 2) : 0;

                    decimal dPrice = i >= displacement ? stockDataClass.InputValues.ElementAtOrDefault(i - displacement) : 0;
                    dPriceList.Add(dPrice);

                    decimal cma = dPrice == 0 ? prevCma1 + (prevCma1 - prevCma2) : dPriceList.TakeLast(days).Average();
                    cmaList.Add(cma);

                    decimal extremeBand = cma * extremeValue / 100;
                    extremeBandList.Add(extremeBand);

                    decimal outerBand = cma * outerValue / 100;
                    outerBandList.Add(outerBand);

                    decimal innerBand = cma * innerValue / 100;
                    innerBandList.Add(innerBand);

                    decimal upperExtremeBand = cma + extremeBand;
                    upperExtremeBandList.Add(upperExtremeBand);

                    decimal lowerExtremeBand = cma - extremeBand;
                    lowerExtremeBandList.Add(lowerExtremeBand);

                    decimal upperInnerBand = cma + innerBand;
                    upperInnerBandList.Add(upperInnerBand);

                    decimal lowerInnerBand = cma - innerBand;
                    lowerInnerBandList.Add(lowerInnerBand);

                    decimal upperOuterBand = cma + outerBand;
                    upperOuterBandList.Add(upperOuterBand);

                    decimal lowerOuterBand = cma - outerBand;
                    lowerOuterBandList.Add(lowerOuterBand);

                    var signal = GetCompareSignal(currentValue - cma, prevValue - prevCma1);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (cmaList, extremeBandList, outerBandList, innerBandList, upperExtremeBandList, lowerExtremeBandList, upperInnerBandList, lowerInnerBandList,
                upperOuterBandList, lowerOuterBandList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>)
            CalculateHurstCycleChannel(StockData stockDataClass, string maType, int days = 10)
        {
            //
            // @author LazyBear 
            // List of all my indicators: http://bit.ly/1LQaPK8
            // 
            //study("Hurst Cycle Channel Clone [LazyBear]", shorttitle = "HCCC_LB", overlay = true)
            //scl_t = input(10, title = "Short Cycle Length?")
            //mcl_t = input(30, title = "Medium Cycle Length?")
            //scm = input(1.0, title = "Short Cycle Multiplier?")
            //mcm = input(3.0, title = "Medium Cycle Multiplier?")
            //src = input(close, title = "Source")
            //scl = scl_t / 2, mcl = mcl_t / 2
            //ma_scl = rma(src, scl)
            //ma_mcl = rma(src, mcl)
            //scm_off = scm * atr(scl)
            //mcm_off = mcm * atr(mcl)
            //scl_2 = scl / 2, mcl_2 = mcl / 2
            //sct = nz(ma_scl[scl_2], src) + scm_off
            //scb = nz(ma_scl[scl_2], src) - scm_off
            //mct = nz(ma_mcl[mcl_2], src) + mcm_off
            //mcb = nz(ma_mcl[mcl_2], src) - mcm_off
            //scc =#E8E8E8, mcc=#E8E8E8 
            //sccm = gray, mccm = black
            //sccf = red, mccf = green
            //sctl = plot(sct, color = scc, title = "ShortCycleTop")
            //scbl = plot(scb, color = scc, title = "ShortCycleBottom")
            //plot(avg(sct, scb), title = "ShortCycleMedian", color = sccm, style = line)
            //mctl = plot(mct, color = mcc, title = "MediumCycleTop", style = line, linewidth = 0)
            //mcbl = plot(mcb, color = mcc, title = "MediumCycleBottom", style = line, linewidth = 0)
            //plot(avg(mct, mcb), title = "MediumCycleMedian", color = mccm, style = line)
            //fill(sctl, scbl, sccf)
            //fill(mctl, mcbl, mccf)
            //scmm=avg(sct,scb)
            //omed=(scmm-mcb)/(mct-mcb)
            //oshort = (src - mcb) / (mct - mcb)
            decimal scm = 1, mcm = 3;
            List<decimal> mclAtrList = new();
            List<decimal> mclRmaList = new();
            List<decimal> scm_offList = new();
            List<decimal> mcm_offList = new();
            List<decimal> sctList = new();
            List<decimal> scbList = new();
            List<decimal> mctList = new();
            List<decimal> mcbList = new();
            List<decimal> scmmList = new();
            List<decimal> omedList = new();
            List<decimal> oshortList = new();
            List<Signal> signalsList = new();

            try
            {
                int scl_t = days;
                int mcl_t = MinOrMax(scl_t * 3);
                int scl = MinOrMax((int)Math.Ceiling((decimal)scl_t / 2));
                int mcl = MinOrMax((int)Math.Ceiling((decimal)mcl_t / 2));
                int scl_2 = MinOrMax((int)Math.Ceiling((decimal)scl / 2));
                int mcl_2 = MinOrMax((int)Math.Ceiling((decimal)mcl / 2));

                var sclAtrList = CalculateAverageTrueRange(stockDataClass, maType, scl).Item1;
                mclAtrList = CalculateAverageTrueRange(stockDataClass, maType, mcl).Item1;
                var sclRmaList = GetMovingAverageList(maType, null, stockDataClass, scl);
                mclRmaList = GetMovingAverageList(maType, null, stockDataClass, mcl);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal sclRma = sclRmaList.ElementAtOrDefault(i);
                    decimal mclRma = mclRmaList.ElementAtOrDefault(i);
                    decimal sclAtr = sclAtrList.ElementAtOrDefault(i);
                    decimal mclAtr = mclAtrList.ElementAtOrDefault(i);
                    decimal prevSclRma = i >= scl_2 ? sclRmaList.ElementAtOrDefault(i - scl_2) : currentValue;
                    decimal prevMclRma = i >= mcl_2 ? mclRmaList.ElementAtOrDefault(i - mcl_2) : currentValue;
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal scm_off = scm * sclAtr;
                    scm_offList.Add(scm_off);

                    decimal mcm_off = mcm * mclAtr;
                    mcm_offList.Add(mcm_off);

                    decimal prevSct = sctList.LastOrDefault();
                    decimal sct = prevSclRma + scm_off;
                    sctList.Add(sct);

                    decimal prevScb = scbList.LastOrDefault();
                    decimal scb = prevSclRma - scm_off;
                    scbList.Add(scb);

                    decimal mct = prevMclRma + mcm_off;
                    mctList.Add(mct);

                    decimal mcb = prevMclRma - mcm_off;
                    mcbList.Add(mcb);

                    decimal scmm = (sct + scb) / 2;
                    scmmList.Add(scmm);

                    decimal omed = mct - mcb != 0 ? (scmm - mcb) / (mct - mcb) : 0;
                    omedList.Add(omed);

                    decimal oshort = mct - mcb != 0 ? (currentValue - mcb) / (mct - mcb) : 0;
                    oshortList.Add(oshort);

                    var signal = GetBullishBearishSignal(currentValue - sct, prevValue - prevSct, currentValue - scb, prevValue - prevScb);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (mclAtrList, mclRmaList, mcm_offList, sctList, scbList, mctList, mcbList, scmmList, omedList, oshortList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateGuppyMultipleMovingAverage(StockData stockDataClass, string maType, int days = 3)
        {
            //https://www.tradingview.com/script/YESRunMr-GMMA-Oscillator-v1-by-JustUncleL/
            //smoothLen = input(1, minval = 1, title = "Oscillator Smoothing Length (1=none)")
            //signalLen = input(13, minval = 1, title = "GMMA Oscillator Signal Length")

            //Fast Guppy Avg EMA
            //GMMAFast(src, mult) => 
            //ema1 = ema(src, 3 * mult)
            //ema2 = ema(src, 5 * mult)
            //ema3 = ema(src, 8 * mult)
            //ema4 = ema(src, 10 * mult)
            //ema5 = ema(src, 12 * mult)
            //ema6 = ema(src, 15 * mult)
            //return = (ema1 + ema2 + ema3 + ema4 + ema5 + ema6)
            //return

            //Slow Guppy Avg EMA
            //GMMASlow(src, mult) => 
            //ema7 = ema(src, 30 * mult)
            //ema8 = ema(src, 35 * mult)
            //ema9 = ema(src, 40 * mult)
            //ema10 = ema(src, 45 * mult)
            //ema11 = ema(src, 50 * mult)
            //ema12 = ema(src, 60 * mult)
            //return = (ema7 + ema8 + ema9 + ema10 + ema11 + ema12)
            //return

            //Fast SuperGuppy Avg EMA
            //superGMMAFast(src, mult) => 
            //emaF1 = ema(src, 3 * mult)
            //emaF2 = ema(src, 5 * mult)
            //emaF3 = ema(src, 7 * mult)
            //emaF4 = ema(src, 9 * mult)
            //emaF5 = ema(src, 11 * mult)
            //emaF6 = ema(src, 13 * mult)
            //emaF7 = ema(src, 15 * mult)
            //emaF8 = ema(src, 17 * mult)
            //emaF9 = ema(src, 19 * mult)
            //emaF10 = ema(src, 21 * mult)
            //emaF11 = ema(src, 23 * mult)
            //return = (emaF1 + emaF2 + emaF3 + emaF4 + emaF5 + emaF6 + emaF7 + emaF8 + emaF9 + emaF10 + emaF11) / 11
            //return

            //Slow SuperGuppy Avg EMA
            //superGMMASlow(src, mult) => 
            //emaS1 = ema(src, 25 * mult)
            //emaS2 = ema(src, 28 * mult)
            //emaS3 = ema(src, 31 * mult)
            //emaS4 = ema(src, 34 * mult)
            //emaS5 = ema(src, 37 * mult)
            //emaS6 = ema(src, 40 * mult)
            //emaS7 = ema(src, 43 * mult)
            //emaS8 = ema(src, 46 * mult)
            //emaS9 = ema(src, 49 * mult)
            //emaS10 = ema(src, 52 * mult)
            //emaS11 = ema(src, 55 * mult)
            //emaS12 = ema(src, 58 * mult)
            //emaS13 = ema(src, 61 * mult)
            //emaS14 = ema(src, 64 * mult)
            //emaS15 = ema(src, 67 * mult)
            //emaS16 = ema(src, 70 * mult)
            // average
            //return = (emaS1 + emaS2 + emaS3 + emaS4 + emaS5 + emaS6 + emaS7 + emaS8 + emaS9 + emaS10 + emaS11 + emaS12 + emaS13 + emaS14 + emaS15 + emaS16) / 16
            //return

            // Calculate Oscillator, Smoothed Osc and signal line
            //gmmaOscRaw = ((gmmaFast - gmmaSlow) / gmmaSlow) * 100
            //gmmaOsc = sma(gmmaOscRaw, smoothLen)
            //gmmaSignal = ema(gmmaOscRaw, signalLen)
            int mult = 1;
            List<decimal> gmmaFastList = new();
            List<decimal> gmmaSlowList = new();
            List<decimal> superGmmaFastList = new();
            List<decimal> superGmmaSlowList = new();
            List<decimal> gmmaOscRawList = new();
            List<decimal> gmmaSignalList = new();
            List<decimal> superGmmaOscRawList = new();
            List<decimal> superGmmaSignalList = new();
            List<decimal> gmmaOscList = new();
            List<decimal> superGmmaOscList = new();
            List<Signal> signalsList = new();

            try
            {
                int ema5Period = (int)Math.Ceiling(days / 0.6) * mult;
                int ema7Period = (int)Math.Ceiling(days / 0.429) * mult;
                int ema8Period = (int)Math.Ceiling(days / 0.375) * mult;
                int ema9Period = (int)Math.Ceiling(days / 0.333) * mult;
                int ema10Period = (int)Math.Ceiling(days / 0.3) * mult;
                int ema11Period = (int)Math.Ceiling(days / 0.273) * mult;
                int ema12Period = (int)Math.Ceiling(days / 0.25) * mult;
                int ema13Period = (int)Math.Ceiling(days / 0.231) * mult;
                int ema15Period = (int)Math.Ceiling(days / 0.2) * mult;
                int ema17Period = (int)Math.Ceiling(days / 0.176) * mult;
                int ema19Period = (int)Math.Ceiling(days / 0.158) * mult;
                int ema21Period = (int)Math.Ceiling(days / 0.143) * mult;
                int ema23Period = (int)Math.Ceiling(days / 0.13) * mult;
                int ema25Period = (int)Math.Ceiling(days / 0.12) * mult;
                int ema28Period = (int)Math.Ceiling(days / 0.107) * mult;
                int ema30Period = (int)Math.Ceiling(days / 0.1) * mult;
                int ema31Period = (int)Math.Ceiling(days / 0.097) * mult;
                int ema34Period = (int)Math.Ceiling(days / 0.088) * mult;
                int ema35Period = (int)Math.Ceiling(days / 0.086) * mult;
                int ema37Period = (int)Math.Ceiling(days / 0.081) * mult;
                int ema40Period = (int)Math.Ceiling(days / 0.075) * mult;
                int ema43Period = (int)Math.Ceiling(days / 0.07) * mult;
                int ema45Period = (int)Math.Ceiling(days / 0.067) * mult;
                int ema46Period = (int)Math.Ceiling(days / 0.065) * mult;
                int ema49Period = (int)Math.Ceiling(days / 0.0612) * mult;
                int ema50Period = (int)Math.Ceiling(days / 0.06) * mult;
                int ema52Period = (int)Math.Ceiling(days / 0.058) * mult;
                int ema55Period = (int)Math.Ceiling(days / 0.055) * mult;
                int ema58Period = (int)Math.Ceiling(days / 0.052) * mult;
                int ema60Period = (int)Math.Ceiling(days / 0.05) * mult;
                int ema61Period = (int)Math.Ceiling(days / 0.049) * mult;
                int ema64Period = (int)Math.Ceiling(days / 0.047) * mult;
                int ema67Period = (int)Math.Ceiling(days / 0.045) * mult;
                int ema70Period = (int)Math.Ceiling(days / 0.043) * mult;
                int signalPeriod = (int)Math.Ceiling(days / 0.231);

                List<decimal> ema3List = GetMovingAverageList(maType, null, stockDataClass, days);
                List<decimal> ema5List = GetMovingAverageList(maType, null, stockDataClass, ema5Period);
                List<decimal> ema7List = GetMovingAverageList(maType, null, stockDataClass, ema7Period);
                List<decimal> ema8List = GetMovingAverageList(maType, null, stockDataClass, ema8Period);
                List<decimal> ema9List = GetMovingAverageList(maType, null, stockDataClass, ema9Period);
                List<decimal> ema10List = GetMovingAverageList(maType, null, stockDataClass, ema10Period);
                List<decimal> ema11List = GetMovingAverageList(maType, null, stockDataClass, ema11Period);
                List<decimal> ema12List = GetMovingAverageList(maType, null, stockDataClass, ema12Period);
                List<decimal> ema13List = GetMovingAverageList(maType, null, stockDataClass, ema13Period);
                List<decimal> ema15List = GetMovingAverageList(maType, null, stockDataClass, ema15Period);
                List<decimal> ema17List = GetMovingAverageList(maType, null, stockDataClass, ema17Period);
                List<decimal> ema19List = GetMovingAverageList(maType, null, stockDataClass, ema19Period);
                List<decimal> ema21List = GetMovingAverageList(maType, null, stockDataClass, ema21Period);
                List<decimal> ema23List = GetMovingAverageList(maType, null, stockDataClass, ema23Period);
                List<decimal> ema25List = GetMovingAverageList(maType, null, stockDataClass, ema25Period);
                List<decimal> ema28List = GetMovingAverageList(maType, null, stockDataClass, ema28Period);
                List<decimal> ema30List = GetMovingAverageList(maType, null, stockDataClass, ema30Period);
                List<decimal> ema31List = GetMovingAverageList(maType, null, stockDataClass, ema31Period);
                List<decimal> ema34List = GetMovingAverageList(maType, null, stockDataClass, ema34Period);
                List<decimal> ema35List = GetMovingAverageList(maType, null, stockDataClass, ema35Period);
                List<decimal> ema37List = GetMovingAverageList(maType, null, stockDataClass, ema37Period);
                List<decimal> ema40List = GetMovingAverageList(maType, null, stockDataClass, ema40Period);
                List<decimal> ema43List = GetMovingAverageList(maType, null, stockDataClass, ema43Period);
                List<decimal> ema45List = GetMovingAverageList(maType, null, stockDataClass, ema45Period);
                List<decimal> ema46List = GetMovingAverageList(maType, null, stockDataClass, ema46Period);
                List<decimal> ema49List = GetMovingAverageList(maType, null, stockDataClass, ema49Period);
                List<decimal> ema50List = GetMovingAverageList(maType, null, stockDataClass, ema50Period);
                List<decimal> ema52List = GetMovingAverageList(maType, null, stockDataClass, ema52Period);
                List<decimal> ema55List = GetMovingAverageList(maType, null, stockDataClass, ema55Period);
                List<decimal> ema58List = GetMovingAverageList(maType, null, stockDataClass, ema58Period);
                List<decimal> ema60List = GetMovingAverageList(maType, null, stockDataClass, ema60Period);
                List<decimal> ema61List = GetMovingAverageList(maType, null, stockDataClass, ema61Period);
                List<decimal> ema64List = GetMovingAverageList(maType, null, stockDataClass, ema64Period);
                List<decimal> ema67List = GetMovingAverageList(maType, null, stockDataClass, ema67Period);
                List<decimal> ema70List = GetMovingAverageList(maType, null, stockDataClass, ema70Period);

                for (int i = 0; i < ema3List.Count; i++)
                {
                    decimal ema1 = ema3List.ElementAtOrDefault(i);
                    decimal ema2 = ema5List.ElementAtOrDefault(i);
                    decimal ema3 = ema8List.ElementAtOrDefault(i);
                    decimal ema4 = ema10List.ElementAtOrDefault(i);
                    decimal ema5 = ema12List.ElementAtOrDefault(i);
                    decimal ema6 = ema15List.ElementAtOrDefault(i);

                    decimal gmmaFast = (ema1 + ema2 + ema3 + ema4 + ema5 + ema6) / 6;
                    gmmaFastList.Add(gmmaFast);

                    decimal ema7 = ema30List.ElementAtOrDefault(i);
                    decimal ema8 = ema35List.ElementAtOrDefault(i);
                    decimal ema9 = ema40List.ElementAtOrDefault(i);
                    decimal ema10 = ema45List.ElementAtOrDefault(i);
                    decimal ema11 = ema50List.ElementAtOrDefault(i);
                    decimal ema12 = ema60List.ElementAtOrDefault(i);

                    decimal gmmaSlow = (ema7 + ema8 + ema9 + ema10 + ema11 + ema12) / 6;
                    gmmaSlowList.Add(gmmaSlow);

                    decimal emaF1 = ema3List.ElementAtOrDefault(i);
                    decimal emaF2 = ema5List.ElementAtOrDefault(i);
                    decimal emaF3 = ema7List.ElementAtOrDefault(i);
                    decimal emaF4 = ema9List.ElementAtOrDefault(i);
                    decimal emaF5 = ema11List.ElementAtOrDefault(i);
                    decimal emaF6 = ema13List.ElementAtOrDefault(i);
                    decimal emaF7 = ema15List.ElementAtOrDefault(i);
                    decimal emaF8 = ema17List.ElementAtOrDefault(i);
                    decimal emaF9 = ema19List.ElementAtOrDefault(i);
                    decimal emaF10 = ema21List.ElementAtOrDefault(i);
                    decimal emaF11 = ema23List.ElementAtOrDefault(i);

                    decimal superGmmaFast = (emaF1 + emaF2 + emaF3 + emaF4 + emaF5 + emaF6 + emaF7 + emaF8 + emaF9 + emaF10 + emaF11) / 11;
                    superGmmaFastList.Add(superGmmaFast);

                    decimal emaS1 = ema25List.ElementAtOrDefault(i);
                    decimal emaS2 = ema28List.ElementAtOrDefault(i);
                    decimal emaS3 = ema31List.ElementAtOrDefault(i);
                    decimal emaS4 = ema34List.ElementAtOrDefault(i);
                    decimal emaS5 = ema37List.ElementAtOrDefault(i);
                    decimal emaS6 = ema40List.ElementAtOrDefault(i);
                    decimal emaS7 = ema43List.ElementAtOrDefault(i);
                    decimal emaS8 = ema46List.ElementAtOrDefault(i);
                    decimal emaS9 = ema49List.ElementAtOrDefault(i);
                    decimal emaS10 = ema52List.ElementAtOrDefault(i);
                    decimal emaS11 = ema55List.ElementAtOrDefault(i);
                    decimal emaS12 = ema58List.ElementAtOrDefault(i);
                    decimal emaS13 = ema61List.ElementAtOrDefault(i);
                    decimal emaS14 = ema64List.ElementAtOrDefault(i);
                    decimal emaS15 = ema67List.ElementAtOrDefault(i);
                    decimal emaS16 = ema70List.ElementAtOrDefault(i);

                    decimal superGmmaSlow = (emaS1 + emaS2 + emaS3 + emaS4 + emaS5 + emaS6 + emaS7 + emaS8 + emaS9 + emaS10 + emaS11 + emaS12 + emaS13 + emaS14 + emaS15 + emaS16) / 16;
                    superGmmaSlowList.Add(superGmmaSlow);

                    decimal gmmaOscRaw = gmmaSlow != 0 ? (gmmaFast - gmmaSlow) / gmmaSlow * 100 : 0;
                    gmmaOscRawList.Add(gmmaOscRaw);

                    decimal gmmaOsc = gmmaOscRawList.TakeLast(days).Average();
                    gmmaOscList.Add(gmmaOsc);

                    decimal superGmmaOscRaw = superGmmaSlow != 0 ? (superGmmaFast - superGmmaSlow) / superGmmaSlow * 100 : 0;
                    superGmmaOscRawList.Add(superGmmaOscRaw);

                    decimal prevSuperGmmaOsc = superGmmaOscList.LastOrDefault();
                    decimal superGmmaOsc = superGmmaOscRawList.TakeLast(days).Average();
                    superGmmaOscList.Add(superGmmaOsc);

                    decimal gmmaSignal = CalculateExponentialMovingAverage(gmmaOscRaw, gmmaSignalList.LastOrDefault(), signalPeriod);
                    gmmaSignalList.Add(gmmaSignal);

                    decimal prevSuperGmmaSignal = superGmmaSignalList.LastOrDefault();
                    decimal superGmmaSignal = CalculateExponentialMovingAverage(superGmmaOscRaw, prevSuperGmmaSignal, signalPeriod);
                    superGmmaSignalList.Add(superGmmaSignal);

                    var signal = GetCompareSignal(superGmmaOsc - superGmmaSignal, prevSuperGmmaOsc - prevSuperGmmaSignal);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (gmmaFastList, gmmaSlowList, superGmmaFastList, superGmmaSlowList, gmmaOscRawList, superGmmaOscRawList, gmmaOscList, superGmmaOscList, gmmaSignalList,
                superGmmaSignalList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateGuppyDistanceIndicator(StockData stockDataClass, string maType, int days = 3)
        {
            //@version=3
            //Guppy Created By ChrisMoody on 8/10/2014 by Request for 2use
            //Daryl Guppy EMA's
            //Code developed by invsto with contribution from xkavalis

            //study(title = "IO_GuppyDistance", shorttitle = "IO_GuppyDist", overlay = false)
            //src = close, 
            //len1 = input(3, minval = 1, title = "Fast EMA 1")
            //len2 = input(5, minval = 1, title = "Fast EMA 2")
            //len3 = input(8, minval = 1, title = "Fast EMA 3")
            //len4 = input(10, minval = 1, title = "Fast EMA 4")
            //len5 = input(12, minval = 1, title = "Fast EMA 5")
            //len6 = input(15, minval = 1, title = "Fast EMA 6")
            //Slow EMA
            //len7 = input(30, minval = 1, title = "Slow EMA 7")
            //len8 = input(35, minval = 1, title = "Slow EMA 8")
            //len9 = input(40, minval = 1, title = "Slow EMA 9")
            //len10 = input(45, minval = 1, title = "Slow EMA 10")
            //len11 = input(50, minval = 1, title = "Slow EMA 11")
            //len12 = input(60, minval = 1, title = "Slow EMA 12")

            //BarsBack   = input(defval=7, minval=1, title="MA Slope Look Back Length",type=integer)
            //SlopeLimit = input(1.2,type=float,minval=0.0,step=0.1,title="MA Slope Limit")

            //Fast EMA
            //ema1 = ema(src, len1)
            //ema2 = ema(src, len2)
            //ema3 = ema(src, len3)
            //ema4 = ema(src, len4)
            //ema5 = ema(src, len5)
            //ema6 = ema(src, len6)
            //Slow EMA
            //ema7 = ema(src, len7)
            //ema8 = ema(src, len8)
            //ema9 = ema(src, len9)
            //ema10 = ema(src, len10)
            //ema11 = ema(src, len11)
            //ema12 = ema(src, len12)

            //distance_fast = abs(ema1 - ema2) + abs(ema2 - ema3) + abs(ema3 - ema4) + abs(ema4 - ema5) + abs(ema5 - ema6)
            //distance_slow = abs(ema7 - ema8) + abs(ema8 - ema9) + abs(ema9 - ema10) + abs(ema10 - ema11) + abs(ema11 - ema12)

            //Fast EMA Color Rules
            //colfastL = (ema1 > ema2 and ema2 > ema3 and ema3 > ema4 and ema4 > ema5 and ema5 > ema6)
            //colfastS = (ema1 < ema2 and ema2<ema3 and ema3 < ema4 and ema4<ema5 and ema5 < ema6)
            //Slow EMA Color Rules
            //colslowL = ema7 > ema8 and ema8 > ema9 and ema9 > ema10 and ema10 > ema11 and ema11 > ema12
            //colslowS = ema7 < ema8 and ema8<ema9 and ema9 < ema10 and ema10<ema11 and ema11 < ema12
            //Fast EMA Final Color Rules
            //colFinal = colfastL and colslowL? aqua: colfastS and colslowS? orange : gray
            //Slow EMA Final Color Rules
            //colFinal2 = colslowL ? lime : colslowS ? red : gray
            //Fast EMA Plots
            //plot(distance_fast, title = "Fast EMA Distance", style = line, linewidth = 2, color = colFinal)
            //plot(distance_slow, title = "Slow EMA Distance", style = line, linewidth = 2, color = colFinal2)
            List<decimal> fastDistanceList = new();
            List<decimal> slowDistanceList = new();
            List<decimal> diff12List = new();
            List<decimal> diff23List = new();
            List<decimal> diff34List = new();
            List<decimal> diff45List = new();
            List<decimal> diff56List = new();
            List<decimal> diff78List = new();
            List<decimal> diff89List = new();
            List<decimal> diff910List = new();
            List<decimal> diff1011List = new();
            List<decimal> diff1112List = new();
            List<Signal> signalsList = new();

            try
            {
                int ema5Period = (int)Math.Ceiling(days / 0.6);
                int ema8Period = (int)Math.Ceiling(days / 0.375);
                int ema10Period = (int)Math.Ceiling(days / 0.3);
                int ema12Period = (int)Math.Ceiling(days / 0.25);
                int ema15Period = (int)Math.Ceiling(days / 0.2);
                int ema30Period = (int)Math.Ceiling(days / 0.1);
                int ema35Period = (int)Math.Ceiling(days / 0.086);
                int ema40Period = (int)Math.Ceiling(days / 0.075);
                int ema45Period = (int)Math.Ceiling(days / 0.067);
                int ema50Period = (int)Math.Ceiling(days / 0.06);
                int ema60Period = (int)Math.Ceiling(days / 0.05);

                List<decimal> ema3List = GetMovingAverageList(maType, null, stockDataClass, days);
                List<decimal> ema5List = GetMovingAverageList(maType, null, stockDataClass, ema5Period);
                List<decimal> ema8List = GetMovingAverageList(maType, null, stockDataClass, ema8Period);
                List<decimal> ema10List = GetMovingAverageList(maType, null, stockDataClass, ema10Period);
                List<decimal> ema12List = GetMovingAverageList(maType, null, stockDataClass, ema12Period);
                List<decimal> ema15List = GetMovingAverageList(maType, null, stockDataClass, ema15Period);
                List<decimal> ema30List = GetMovingAverageList(maType, null, stockDataClass, ema30Period);
                List<decimal> ema35List = GetMovingAverageList(maType, null, stockDataClass, ema35Period);
                List<decimal> ema40List = GetMovingAverageList(maType, null, stockDataClass, ema40Period);
                List<decimal> ema45List = GetMovingAverageList(maType, null, stockDataClass, ema45Period);
                List<decimal> ema50List = GetMovingAverageList(maType, null, stockDataClass, ema50Period);
                List<decimal> ema60List = GetMovingAverageList(maType, null, stockDataClass, ema60Period);

                for (int i = 0; i < ema3List.Count; i++)
                {
                    decimal ema1 = ema3List.ElementAtOrDefault(i);
                    decimal ema2 = ema5List.ElementAtOrDefault(i);
                    decimal ema3 = ema8List.ElementAtOrDefault(i);
                    decimal ema4 = ema10List.ElementAtOrDefault(i);
                    decimal ema5 = ema12List.ElementAtOrDefault(i);
                    decimal ema6 = ema15List.ElementAtOrDefault(i);
                    decimal ema7 = ema30List.ElementAtOrDefault(i);
                    decimal ema8 = ema35List.ElementAtOrDefault(i);
                    decimal ema9 = ema40List.ElementAtOrDefault(i);
                    decimal ema10 = ema45List.ElementAtOrDefault(i);
                    decimal ema11 = ema50List.ElementAtOrDefault(i);
                    decimal ema12 = ema60List.ElementAtOrDefault(i);

                    decimal diff12 = Math.Abs(ema1 - ema2);
                    diff12List.Add(diff12);

                    decimal diff23 = Math.Abs(ema2 - ema3);
                    diff23List.Add(diff23);

                    decimal diff34 = Math.Abs(ema3 - ema4);
                    diff34List.Add(diff34);

                    decimal diff45 = Math.Abs(ema4 - ema5);
                    diff45List.Add(diff45);

                    decimal diff56 = Math.Abs(ema5 - ema6);
                    diff56List.Add(diff56);

                    decimal diff78 = Math.Abs(ema7 - ema8);
                    diff78List.Add(diff78);

                    decimal diff89 = Math.Abs(ema8 - ema9);
                    diff89List.Add(diff89);

                    decimal diff910 = Math.Abs(ema9 - ema10);
                    diff910List.Add(diff910);

                    decimal diff1011 = Math.Abs(ema10 - ema11);
                    diff1011List.Add(diff1011);

                    decimal diff1112 = Math.Abs(ema11 - ema12);
                    diff1112List.Add(diff1112);

                    decimal fastDistance = diff12 + diff23 + diff34 + diff45 + diff56;
                    fastDistanceList.Add(fastDistance);

                    decimal slowDistance = diff78 + diff89 + diff910 + diff1011 + diff1112;
                    slowDistanceList.Add(slowDistance);

                    bool colFastL = ema1 > ema2 && ema2 > ema3 && ema3 > ema4 && ema4 > ema5 && ema5 > ema6;
                    bool colFastS = ema1 < ema2 && ema2 < ema3 && ema3 < ema4 && ema4 < ema5 && ema5 < ema6;
                    bool colSlowL = ema7 > ema8 && ema8 > ema9 && ema9 > ema10 && ema10 > ema11 && ema11 > ema12;
                    bool colSlowS = ema7 < ema8 && ema8 < ema9 && ema9 < ema10 && ema10 < ema11 && ema11 < ema12;

                    var signal = GetConditionSignal(colSlowL || colFastL && colSlowL, colSlowS || colFastS && colSlowS);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (diff12List, diff23List, diff34List, diff45List, diff56List, diff78List, diff89List, diff910List, diff1011List,
                diff1112List, fastDistanceList, slowDistanceList, signalsList);
        }

        public static (List<decimal>, List<Signal>) CalculateWilliamsAccumulationDistribution(StockData stockDataClass)
        {
            //@version=2
            ////////////////////////////////////////////////////////////
            //  Copyright by HPotter v1.0 17/01/2018
            // Accumulation is a term used to describe a market controlled by buyers;
            // whereas distribution is defined by a market controlled by sellers.
            // Williams recommends trading this indicator based on divergences:
            //
            //  Distribution of the security is indicated when the security is making 
            //  a new high and the A/D indicator is failing to make a new high. Sell.
            //
            //  Accumulation of the security is indicated when the security is making 
            //  a new low and the A/D indicator is failing to make a new low. Buy.
            //
            // WARNING:
            // - This script to change bars colors.
            ////////////////////////////////////////////////////////////
            //study(title = "Williams Accumulation/Distribution (Williams AD)", shorttitle = "Williams AD")
            //hline(0, color = blue, linestyle = line)
            //xPrice = close
            //xWAD = iff(close > nz(close[1], 0), nz(xWAD[1], 0) + close - low[1],
            //       iff(close < nz(close[1], 0), nz(xWAD[1], 0) + close - high[1], 0))
            //pos = iff(xWAD > 0, 1,
            //      iff(xWAD < 0, -1, nz(pos[1], 0)))
            //barcolor(pos == -1 ? red : pos == 1 ? green : blue)
            //plot(xWAD, color = green, title = "Williams AD")
            List<decimal> wadList = new();
            List<Signal> signalsList = new();

            try
            {
                var minMaxList = VolumeInputCheck(stockDataClass, 0, false);
                var highList = minMaxList.Item1;
                var lowList = minMaxList.Item2;

                for (int i = 0; i < stockDataClass.HighPrices.Count; i++)
                {
                    decimal close = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevClose = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevLow = i >= 1 ? lowList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevHigh = i >= 1 ? highList.ElementAtOrDefault(i - 1) : 0;

                    decimal prevWad = wadList.LastOrDefault();
                    decimal wad = close > prevClose ? prevWad + close - prevLow : close < prevClose ? prevWad + close - prevHigh : 0;
                    wadList.Add(wad);

                    var signal = GetCompareSignal(wad, prevWad);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (wadList, signalsList);
        }

        public static (List<decimal>, List<Signal>) CalculateSmoothedWilliamsAccumulationDistribution(StockData stockDataClass, string maType, int days = 14)
        {
            //@version=2
            ////////////////////////////////////////////////////////////
            //  Copyright by HPotter v1.0 19/01/2018
            // Accumulation is a term used to describe a market controlled by buyers;
            // whereas distribution is defined by a market controlled by sellers.
            // Williams recommends trading this indicator based on divergences:
            //
            //  Distribution of the security is indicated when the security is making 
            //  a new high and the A/D indicator is failing to make a new high. Sell.
            //
            //  Accumulation of the security is indicated when the security is making 
            //  a new low and the A/D indicator is failing to make a new low. Buy.
            //
            // WARNING:
            // - This script to change bars colors.
            ////////////////////////////////////////////////////////////
            //study(title = "Smoothened Williams Accumulation/Distribution (Williams AD)", shorttitle = "Williams AD")
            //Length = input(14, step = 1)
            //hline(0, color = blue, linestyle = line)
            //xPrice = close
            //xWAD = iff(close > nz(close[1], 0), nz(xWAD[1], 0) + close - low[1],
            //       iff(close < nz(close[1], 0), nz(xWAD[1], 0) + close - high[1], 0))
            //xWADMA = sma(xWAD, Length)
            //pos = iff(xWAD > xWADMA, 1,
            //      iff(xWAD < xWADMA, -1, nz(pos[1], 0)))
            //barcolor(pos == -1 ? red : pos == 1 ? green : blue)
            //plot(xWAD, color = green, title = "Williams AD")
            //plot(xWADMA, color = red, title = "MA(AD)")
            List<decimal> wadSignalList = new();
            List<Signal> signalsList = new();

            try
            {
                var wadList = CalculateWilliamsAccumulationDistribution(stockDataClass).Item1;
                wadSignalList = GetMovingAverageList(maType, wadList, stockDataClass, days);

                for (int i = 0; i < stockDataClass.HighPrices.Count; i++)
                {
                    decimal wad = wadList.ElementAtOrDefault(i);
                    decimal wadSma = wadSignalList.ElementAtOrDefault(i);
                    decimal prevWad = i >= 1 ? wadList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevWadSma = i >= 1 ? wadSignalList.ElementAtOrDefault(i - 1) : 0;

                    var signal = GetCompareSignal(wad - wadSma, prevWad - prevWadSma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (wadSignalList, signalsList);
        }

        public static (List<decimal>, List<Signal>) CalculateChaikinOscillator(StockData stockDataClass, string maType, int days = 3)
        {
            //1. Money Flow Multiplier = [(Close  -  Low) - (High - Close)] /(High - Low)
            //2.Money Flow Volume = Money Flow Multiplier x Volume for the Period
            //3.ADL = Previous ADL + Current Period's Money Flow Volume
            //4. Chaikin Oscillator = (3-day EMA of ADL)  -  (10-day EMA of ADL)
            List<decimal> chaikinOscillatorList = new();
            List<Signal> signalsList = new();

            try
            {
                int adl10EmaCount = MinOrMax((int)Math.Ceiling(days / 0.3));

                List<decimal> adlList = CalculateAccumulationDistributionLine(stockDataClass, days).Item3;
                var adl3EmaList = GetMovingAverageList(maType, adlList, stockDataClass, days);
                var adl10EmaList = GetMovingAverageList(maType, adlList, stockDataClass, adl10EmaCount);

                for (int i = 0; i < adl3EmaList.Count; i++)
                {
                    decimal adl3Ema = adl3EmaList.ElementAtOrDefault(i);
                    decimal adl10Ema = adl10EmaList.ElementAtOrDefault(i);

                    decimal prevChaikinOscillator = chaikinOscillatorList.LastOrDefault();
                    decimal chaikinOscillator = adl3Ema - adl10Ema;
                    chaikinOscillatorList.Add(chaikinOscillator);

                    var signal = GetCompareSignal(chaikinOscillator, prevChaikinOscillator);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (chaikinOscillatorList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateChaikinMoneyFlow(StockData stockDataClass, int days = 20)
        {
            //1. Money Flow Multiplier = [(Close  -  Low) - (High - Close)] /(High - Low)
            //2.Money Flow Volume = Money Flow Multiplier x Volume for the Period
            //3. 20 - period CMF = 20 - period Sum of Money Flow Volume / 20 period Sum of Volume
            List<decimal> chaikinMoneyFlowList = new();
            List<decimal> moneyFlowVolumeSumList = new();
            List<decimal> volumeSumList = new();
            List<decimal> tempVolumeList = new();
            List<decimal> tempMoneyFlowVolumeList = new();
            List<Signal> signalsList = new();

            try
            {
                List<decimal> moneyFlowVolumeList = CalculateAccumulationDistributionLine(stockDataClass, days).Item2;

                for (int i = 0; i < moneyFlowVolumeList.Count; i++)
                {
                    decimal currentVolume = stockDataClass.Volumes.ElementAtOrDefault(i);
                    tempVolumeList.Add(currentVolume);

                    decimal moneyFlowVolume = moneyFlowVolumeList.ElementAtOrDefault(i);
                    tempMoneyFlowVolumeList.Add(moneyFlowVolume);

                    decimal moneyFlowVolumeSum = tempMoneyFlowVolumeList.TakeLast(days).Sum();
                    moneyFlowVolumeSumList.Add(moneyFlowVolumeSum);

                    decimal volumeSum = tempVolumeList.TakeLast(days).Sum();
                    volumeSumList.Add(volumeSum);

                    decimal prevChaikinMoneyFlow = chaikinMoneyFlowList.LastOrDefault();
                    decimal chaikinMoneyFlow = volumeSum != 0 ? moneyFlowVolumeSum / volumeSum : 0;
                    chaikinMoneyFlowList.Add(chaikinMoneyFlow);

                    var signal = GetCompareSignal(chaikinMoneyFlow, prevChaikinMoneyFlow);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (moneyFlowVolumeSumList, volumeSumList, chaikinMoneyFlowList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateTwiggsMoneyFlow(StockData stockDataClass, string maType, int days = 21)
        {
            //method = moving average, user defined, default is EMA
            //period = user defined, default is 21
            //ma = moving average
            //trh = true high
            //trl = true low
            //prev = previous, index = current bar number
            //LT = lessThan, MT = moreThan

            //lastClose = price[index - 1];
            //trh = max(high, lastClose);
            //trl = min(low, lastClose);
            //ad = ((close - trl) - (trh - close)) / (trh - trl) * volume;
            //smoothAd = ma(method, index, period, ad);
            //smoothVol = ma(method, index, period, volume);
            //Plot: TMF = smoothAd / smoothVol;
            //Signals
            //prevTmf = TMF[index - 1];
            //highSell = tmf for last sell signal, reset to max_negative at each  buy signal;
            //lowBuy = tmf for last buy signal, reset to max_positive at each sell signal;
            //sell = (tmf MT topGuide) AND(prevTmf MT tmf) AND(tmf MT highSell);
            //buy = (tmf LT bottomGuide AND prevTmf LT tmf) AND(tmf LT lowBuy);
            List<decimal> adList = new();
            List<decimal> tmfList = new();
            List<decimal> smoothAdList = new();
            List<Signal> signalsList = new();

            try
            {
                List<decimal> volumeEmaList = GetMovingAverageList(maType, stockDataClass.Volumes, stockDataClass, days);

                for (int i = 0; i < stockDataClass.ClosePrices.Count; i++)
                {
                    decimal currentPrice = stockDataClass.ClosePrices.ElementAtOrDefault(i);
                    decimal currentHigh = stockDataClass.HighPrices.ElementAtOrDefault(i);
                    decimal currentLow = stockDataClass.LowPrices.ElementAtOrDefault(i);
                    decimal currentVolume = stockDataClass.Volumes.ElementAtOrDefault(i);
                    decimal prevPrice = i >= 1 ? stockDataClass.ClosePrices.ElementAtOrDefault(i - 1) : 0;
                    decimal trh = Math.Max(currentHigh, prevPrice);
                    decimal trl = Math.Min(currentLow, prevPrice);

                    decimal ad = trh - trl != 0 ? ((currentPrice - trl) - (trh - currentPrice)) / (trh - trl) * currentVolume : 0;
                    adList.Add(ad);
                }

                smoothAdList = GetMovingAverageList(maType, adList, stockDataClass, days);
                for (int j = 0; j < stockDataClass.ClosePrices.Count; j++)
                {
                    decimal currentEmaVolume = volumeEmaList.ElementAtOrDefault(j);
                    decimal smoothAd = smoothAdList.ElementAtOrDefault(j);
                    decimal prevTmf1 = j >= 1 ? tmfList.ElementAtOrDefault(j - 1) : 0;
                    decimal prevTmf2 = j >= 2 ? tmfList.ElementAtOrDefault(j - 2) : 0;

                    decimal tmf = currentEmaVolume != 0 ? MinOrMax(smoothAd / currentEmaVolume, 1, -1) : 0;
                    tmfList.Add(tmf);

                    var signal = GetRsiSignal(tmf - prevTmf1, prevTmf1 - prevTmf2, tmf, prevTmf1, 0.2m, -0.2m);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (adList, smoothAdList, tmfList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateChaikinVolatility(StockData stockDataClass, int days = 10)
        {
            ////////////////////////////////////////////////////////////
            //  Copyright by HPotter v1.0 13/08/2014
            // Chaikin's Volatility indicator compares the spread between a security's
            // high and low prices. It quantifies volatility as a widening of the range
            // between the high and the low price.
            // You can use in the xPrice1 and xPrice2 any series: Open, High, Low, Close, HL2,
            // HLC3, OHLC4 and ect...
            ///////////////////////////////////////////////////////////
            //study(title = "Chaikin Volatility Strategy")
            //Length = input(10, minval = 1)
            //ROCLength = input(12, minval = 1)
            //Trigger = input(0, minval = 1)
            //hline(0, color = purple, linestyle = line)
            //hline(Trigger, color = red, linestyle = line)
            //xPrice1 = high
            //xPrice2 = low
            //xPrice = xPrice1 - xPrice2
            //xROC_EMA = roc(ema(xPrice, Length), ROCLength)
            //pos = iff(xROC_EMA < Trigger, 1,
            //        iff(xROC_EMA > Trigger, -1, nz(pos[1], 0)))
            //barcolor(pos == -1 ? red : pos == 1 ? green : blue)
            //plot(xROC_EMA, color = blue, title = "Chaikin Volatility Strategy")
            List<decimal> chaikinVolatilityList = new();
            List<decimal> highLowList = new();
            List<decimal> highLowEmaList = new();
            List<Signal> signalsList = new();

            try
            {
                int rocLength = MinOrMax((int)Math.Ceiling(days / 0.8333));

                for (int i = 0; i < stockDataClass.HighPrices.Count; i++)
                {
                    decimal currentHigh = stockDataClass.HighPrices.ElementAtOrDefault(i);
                    decimal currentLow = stockDataClass.LowPrices.ElementAtOrDefault(i);
                    decimal prevHighLowEma = i >= rocLength ? highLowEmaList.ElementAtOrDefault(i - rocLength) : 0;

                    decimal highLow = currentHigh - currentLow;
                    highLowList.Add(highLow);

                    decimal highLowEma = CalculateExponentialMovingAverage(highLow, highLowEmaList.LastOrDefault(), days);
                    highLowEmaList.Add(highLowEma);

                    decimal prevChaikinVolatility = chaikinVolatilityList.LastOrDefault();
                    decimal chaikinVolatility = prevHighLowEma != 0 ? (highLowEma - prevHighLowEma) / prevHighLowEma * 100 : 0;
                    chaikinVolatilityList.Add(chaikinVolatility);

                    var signal = GetCompareSignal(chaikinVolatility, prevChaikinVolatility, true);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (highLowList, highLowEmaList, chaikinVolatilityList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateChandeQuickStick(StockData stockDataClass, int days = 14)
        {
            //@version=2
            ////////////////////////////////////////////////////////////
            //  Copyright by HPotter v1.0 06/03/2018
            // A technical indicator developed by Tushar Chande to numerically identify 
            // trends in candlestick charting. It is calculated by taking an 'n' period 
            // moving average of the difference between the open and closing prices. A 
            // Qstick value greater than zero means that the majority of the last 'n' days 
            // have been up, indicating that buying pressure has been increasing. 
            //
            // Transaction signals come from when the Qstick indicator crosses through the 
            // zero line. Crossing above zero is used as the entry signal because it is indicating 
            // that buying pressure is increasing, while sell signals come from the indicator 
            // crossing down through zero. In addition, an 'n' period moving average of the Qstick 
            // values can be drawn to act as a signal line. Transaction signals are then generated 
            // when the Qstick value crosses through the trigger line.
            ////////////////////////////////////////////////////////////
            //study(title = "Qstick Indicator")
            //Length = input(14, minval = 1)
            //xR = close - open
            //xQstick = sma(xR, Length)
            //clr = iff(xQstick >= 0, green, red)
            //p1 = plot(0, color = black, title = "0")
            //p2 = plot(xQstick, color = blue, title = "Qstick")
            //fill(p1, p2, color = clr)
            List<decimal> openCloseList = new();
            List<decimal> smaList = new();
            List<decimal> emaList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.OpenPrices.Count; i++)
                {
                    decimal currentOpen = stockDataClass.OpenPrices.ElementAtOrDefault(i);
                    decimal currentClose = stockDataClass.ClosePrices.ElementAtOrDefault(i);

                    decimal openClose = currentClose - currentOpen;
                    openCloseList.Add(openClose);

                    decimal prevSma = smaList.LastOrDefault();
                    decimal sma = openCloseList.TakeLast(days).Average();
                    smaList.Add(sma);

                    decimal ema = CalculateExponentialMovingAverage(openClose, emaList.LastOrDefault(), days);
                    emaList.Add(ema);

                    var signal = GetCompareSignal(sma, prevSma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (openCloseList, smaList, emaList, signalsList);
        }

        public static (List<decimal>, List<Signal>) CalculateRangeActionVerificationIndex(StockData stockDataClass, string maType, int days = 7)
        {
            //@version=2
            ////////////////////////////////////////////////////////////
            //  Copyright by HPotter v1.0 16/05/2017
            // The indicator represents the relative convergence/divergence of the moving 
            // averages of the financial asset, increased a hundred times. It is based on 
            // a different principle than the ADX. Chande suggests a 13-week SMA as the 
            // basis for the indicator. It represents the quarterly (3 months = 65 working days) 
            // sentiments of the market participants concerning prices. The short moving average 
            // comprises 10% of the one and is rounded to seven.
            ////////////////////////////////////////////////////////////
            //study(title = "Range Action Verification Index (RAVI)", shorttitle = "RAVI")
            //LengthMAFast = input(title = "Length MA Fast", defval = 7)
            //LengthMASlow = input(title = "Length MA Slow", defval = 65)
            //xMAF = sma(close, LengthMAFast)
            //xMAS = sma(close, LengthMASlow)
            //xRAVI = ((xMAF - xMAS) / xMAS) * 100
            //plot(xRAVI, color = green, title = "RAVI")
            List<decimal> raviList = new();
            List<Signal> signalsList = new();

            try
            {
                int fastPeriod = days;
                int slowPeriod = MinOrMax((int)Math.Ceiling(fastPeriod / 0.108));

                var smaFastList = GetMovingAverageList(maType, null, stockDataClass, fastPeriod);
                var smaSlowList = GetMovingAverageList(maType, null, stockDataClass, slowPeriod);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal fastMA = smaFastList.ElementAtOrDefault(i);
                    decimal slowMA = smaSlowList.ElementAtOrDefault(i);
                    decimal prevRavi1 = i >= 1 ? raviList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevRavi2 = i >= 2 ? raviList.ElementAtOrDefault(i - 2) : 0;

                    decimal ravi = slowMA != 0 ? (fastMA - slowMA) / slowMA * 100 : 0;
                    raviList.Add(ravi);

                    var signal = GetCompareSignal(ravi - prevRavi1, prevRavi1 - prevRavi2);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (raviList, signalsList);
        }

        public static (List<decimal>, List<Signal>) CalculatePrettyGoodOscillator(StockData stockDataClass, string maType, int days = 14)
        {
            //@version=3
            // Copyright (c) 2018-present, Alex Orekhov (everget)
            // Pretty Good Oscillator script may be freely distributed under the MIT license.
            //study("Pretty Good Oscillator", shorttitle = "PGO")

            //length = input(title = "Length", type = integer, defval = 14, minval = 1)
            //upperLevel = input(title = "Upper Level", type = float, step = 0.1, defval = 2.0)
            //lowerLevel = input(title = "Lower Level", type = float, step = 0.1, defval = -2.0)
            //maxLevel = input(title = "Max Level", type = float, step = 0.1, defval = 4.0)
            //minLevel = input(title = "Min Level", type = float, step = 0.1, defval = -4.0)
            //highlightBreakouts = input(title = "Highlight Overbought/Oversold Breakouts ?", type = bool, defval = true)
            //src = input(title = "Source", type = source, defval = close)

            //pgo = (src - sma(src, length)) / atr(length)

            //pgoColor = pgo > upperLevel ? #0ebb23 : pgo < lowerLevel ? #ff0000 : #f4b77d
            //plot(pgo, title = "PGO", linewidth = 2, color = pgoColor, transp = 0)

            //transparent = color(white, 100)

            //maxLevelPlot = hline(maxLevel, title = "Max Level", linestyle = dotted, color = transparent)
            //upperLevelPlot = hline(upperLevel, title = "Upper Level", linestyle = dotted)
            //hline(0, title = "Zero Level", linestyle = dotted)
            //lowerLevelPlot = hline(lowerLevel, title = "Lower Level", linestyle = dotted)
            //minLevelPlot = hline(minLevel, title = "Min Level", linestyle = dotted, color = transparent)

            //fill(upperLevelPlot, lowerLevelPlot, color = purple, transp = 95)

            //upperFillColor = pgo > upperLevel and highlightBreakouts ? green: transparent
            //lowerFillColor = pgo < lowerLevel and highlightBreakouts ? red: transparent

            //fill(maxLevelPlot, upperLevelPlot, color = upperFillColor, transp = 90)
            //fill(minLevelPlot, lowerLevelPlot, color = lowerFillColor, transp = 90)
            List<decimal> pgoList = new();
            List<Signal> signalsList = new();

            try
            {
                List<decimal> smaList = GetMovingAverageList(maType, null, stockDataClass, days);
                var atrList = CalculateAverageTrueRange(stockDataClass, maType, days).Item1;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal sma = smaList.ElementAtOrDefault(i);
                    decimal atr = atrList.ElementAtOrDefault(i);

                    decimal prevPgo = pgoList.LastOrDefault();
                    decimal pgo = atr != 0 ? (currentValue - sma) / atr : 0;
                    pgoList.Add(pgo);

                    var signal = GetCompareSignal(pgo, prevPgo);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (pgoList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateFractalChaosBands(StockData stockDataClass)
        {
            //@version=2
            ////////////////////////////////////////////////////////////
            //  Copyright by HPotter v1.0 15/02/2018
            //  Stock market moves in a highly chaotic way, but at a larger scale, the movements 
            // follow a certain pattern that can be applied to shorter or longer periods of time 
            // and we can use Fractal Chaos Bands Indicator to identify those patterns. Basically, 
            // the Fractal Chaos Bands Indicator helps us to identify whether the stock market is 
            // trending or not. When a market is trending, the bands will have a slope and if market 
            // is not trending the bands will flatten out. As the slope of the bands decreases, it 
            // signifies that the market is choppy, insecure and variable. As the graph becomes more 
            // and more abrupt, be it going up or down, the significance is that the market becomes 
            // trendy, or stable. Fractal Chaos Bands Indicator is used similarly to other bands-indicator 
            // (Bollinger bands for instance), offering trading opportunities when price moves above or 
            // under the fractal lines.
            //
            // The FCB indicator looks back in time depending on the number of time periods trader selected 
            // to plot the indicator. The upper fractal line is made by plotting stock price highs and the 
            // lower fractal line is made by plotting stock price lows. Essentially, the Fractal Chaos Bands 
            // show an overall panorama of the price movement, as they filter out the insignificant fluctuations 
            // of the stock price.
            ////////////////////////////////////////////////////////////
            //fractalUp(pattern) =>
            //p = high[pattern + 1]
            //okl = 1
            //okr = 1
            //for i = pattern to 1
            //okl := iff(high[i] < high[i + 1] and okl == 1, 1, 0)
            //for i = pattern + 2 to pattern * 2 + 1
            //okr := iff(high[i] < high[i - 1] and okr == 1, 1, 0)
            //res = iff(okl == 1 and okr == 1, p, res[1])
            //res

            //fractalDn(pattern) =>
            //p = low[pattern + 1]
            //okl = 1
            //okr = 1
            //for i = pattern to 1
            //okl := iff(low[i] > low[i + 1] and okl == 1, 1, 0)
            //for i = pattern + 2 to pattern * 2 + 1
            //okr := iff(low[i] > low[i - 1] and okr == 1, 1, 0)
            //res = iff(okl == 1 and okr == 1, p, res[1])
            //res

            //study(title = "Fractal Chaos Bands", overlay = true)
            //Pattern = input(1, minval = 1)
            //xUpper = fractalUp(Pattern)
            //xLower = fractalDn(Pattern)
            //plot(xUpper, color = red, title = "FCBUp")
            //plot(xLower, color = green, title = "FCBDn")
            List<decimal> upperBandList = new();
            List<decimal> lowerBandList = new();
            List<decimal> oklUpperList = new();
            List<decimal> okrUpperList = new();
            List<decimal> oklLowerList = new();
            List<decimal> okrLowerList = new();
            List<decimal> middleBandList = new();
            List<Signal> signalsList = new();

            try
            {
                var minMaxList = VolumeInputCheck(stockDataClass, 0, false);
                var highList = minMaxList.Item1;
                var lowList = minMaxList.Item2;

                for (int i = 0; i < stockDataClass.HighPrices.Count; i++)
                {
                    decimal prevHigh1 = i >= 1 ? highList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevHigh2 = i >= 2 ? highList.ElementAtOrDefault(i - 2) : 0;
                    decimal prevHigh3 = i >= 3 ? highList.ElementAtOrDefault(i - 3) : 0;
                    decimal prevLow1 = i >= 1 ? lowList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevLow2 = i >= 2 ? lowList.ElementAtOrDefault(i - 2) : 0;
                    decimal prevLow3 = i >= 3 ? lowList.ElementAtOrDefault(i - 3) : 0;
                    decimal currentClose = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevClose = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal oklUpper = prevHigh1 < prevHigh2 ? 1 : 0;
                    oklUpperList.Add(oklUpper);

                    decimal okrUpper = prevHigh3 < prevHigh2 ? 1 : 0;
                    okrUpperList.Add(okrUpper);

                    decimal oklLower = prevLow1 > prevLow2 ? 1 : 0;
                    oklLowerList.Add(oklLower);

                    decimal okrLower = prevLow3 > prevLow2 ? 1 : 0;
                    okrLowerList.Add(okrLower);

                    decimal prevUpperBand = upperBandList.LastOrDefault();
                    decimal upperBand = oklUpper == 1 && okrUpper == 1 ? prevHigh2 : prevUpperBand;
                    upperBandList.Add(upperBand);

                    decimal prevLowerBand = lowerBandList.LastOrDefault();
                    decimal lowerBand = oklLower == 1 && okrLower == 1 ? prevLow2 : prevLowerBand;
                    lowerBandList.Add(lowerBand);

                    decimal prevMiddleBand = middleBandList.LastOrDefault();
                    decimal middleBand = (upperBand + lowerBand) / 2;
                    middleBandList.Add(middleBand);

                    var signal = GetBollingerBandsSignal(currentClose - middleBand, prevClose - prevMiddleBand, currentClose, prevClose, upperBand, prevUpperBand, lowerBand, prevLowerBand);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (oklUpperList, okrUpperList, oklLowerList, okrLowerList, upperBandList, lowerBandList, middleBandList, signalsList);
        }

        public static (List<decimal>, List<Signal>) CalculateFractalChaosOscillator(StockData stockDataClass)
        {
            //@version=2
            ////////////////////////////////////////////////////////////
            //  Copyright by HPotter v1.0 20/02/2018
            //   The value of Fractal Chaos Oscillator is calculated as the difference between 
            // the most subtle movements of the market. In general, its value moves between 
            // -1.000 and 1.000. The higher the value of the Fractal Chaos Oscillator, the 
            // more one can say that it follows a certain trend – an increase in prices trend, 
            // or a decrease in prices trend.
            //
            //   Being an indicator expressed in a numeric value, traders say that this is an 
            // indicator that puts a value on the trendiness of the markets. When the FCO reaches 
            // a high value, they initiate the “buy” operation, contrarily when the FCO reaches a 
            // low value, they signal the “sell” action. This is an excellent indicator to use in 
            // intra-day trading.
            ////////////////////////////////////////////////////////////
            //fractalUp(pattern) =>
            //p = high[pattern + 1]
            //okl = 1
            //okr = 1
            //for i = pattern to 1
            //okl := iff(high[i] < high[i + 1] and okl == 1, 1, 0)
            //for i = pattern + 2 to pattern * 2 + 1
            //okr := iff(high[i] < high[i - 1] and okr == 1, 1, 0)
            //res = iff(okl == 1 and okr == 1, p, res[1])
            //res

            //fractalDn(pattern) =>
            //p = low[pattern + 1]
            //okl = 1
            //okr = 1
            //for i = pattern to 1
            //okl := iff(low[i] > low[i + 1] and okl == 1, 1, 0)
            //for i = pattern + 2 to pattern * 2 + 1
            //okr := iff(low[i] > low[i - 1] and okr == 1, 1, 0)
            //res = iff(okl == 1 and okr == 1, p, res[1])
            //res

            //study(title = "Fractal Chaos Oscillator", overlay = false)
            //Pattern = input(1, minval = 1)
            //xUpper = fractalUp(Pattern)
            //xLower = fractalDn(Pattern)
            //xRes = iff(xUpper != xUpper[1], 1,
            //       iff(xLower != xLower[1], -1, 0))
            //plot(xRes, color = blue, title = "FCO")
            List<decimal> fcoList = new();
            List<Signal> signalsList = new();

            try
            {
                var fractalChaosBandsList = CalculateFractalChaosBands(stockDataClass);

                for (int i = 0; i < stockDataClass.HighPrices.Count; i++)
                {
                    decimal upperBand = fractalChaosBandsList.Item5.ElementAtOrDefault(i);
                    decimal prevUpperBand = i >= 1 ? fractalChaosBandsList.Item5.ElementAtOrDefault(i - 1) : 0;
                    decimal lowerBand = fractalChaosBandsList.Item6.ElementAtOrDefault(i);
                    decimal prevLowerBand = i >= 1 ? fractalChaosBandsList.Item6.ElementAtOrDefault(i - 1) : 0;

                    decimal prevFco = fcoList.LastOrDefault();
                    decimal fco = upperBand != prevUpperBand ? 1 : lowerBand != prevLowerBand ? -1 : 0;
                    fcoList.Add(fco);

                    var signal = GetCompareSignal(fco, prevFco);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (fcoList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<Signal>) CalculateShinoharaIntensityRatio(StockData stockDataClass, int days = 14)
        {
            // @version=2
            //study("Shinohara Ratio")
            //len = input(title = "Length", type = integer, defval = 14)
            //line1 = input(title = "Line 1", type = integer, defval = 50)
            //line2 = input(title = "Line 2", type = integer, defval = 100)
            //line3 = input(title = "Line 3", type = integer, defval = 150)
            //line4 = input(title = "Line 4", type = integer, defval = 80)
            //line5 = input(title = "Line 5", type = integer, defval = 120)

            //A_bull = sum(high, len) - sum(open, len)
            //A_bear = sum(open, len) - sum(low, len)

            //B_bull = sum(high, len) - sum(close[1], len)
            //B_bear = sum(close[1], len) - sum(low, len)

            //A_ratio = 100 * A_bull / A_bear
            //B_ratio = 100 * B_bull / B_bear

            //plot(A_ratio, color = blue, title = "A Ratio")
            //plot(B_ratio, color = red, title = "B Ratio")
            //hline(line1, color = red, linestyle = solid)
            //hline(line2, color = black, linestyle = solid)
            //hline(line3, color = blue, linestyle = solid)
            //hline(line4, color = green, linestyle = solid)
            //hline(line5, color = green, linestyle = solid)
            List<decimal> openList = new();
            List<decimal> tempLowList = new();
            List<decimal> tempHighList = new();
            List<decimal> prevCloseList = new();
            List<decimal> openSumList = new();
            List<decimal> lowSumList = new();
            List<decimal> highSumList = new();
            List<decimal> prevCloseSumList = new();
            List<decimal> bullAList = new();
            List<decimal> bullBList = new();
            List<decimal> bearAList = new();
            List<decimal> bearBList = new();
            List<decimal> ratioAList = new();
            List<decimal> ratioBList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.HighPrices.Count; i++)
                {
                    decimal high = stockDataClass.HighPrices.ElementAtOrDefault(i);
                    tempHighList.Add(high);

                    decimal low = stockDataClass.LowPrices.ElementAtOrDefault(i);
                    tempLowList.Add(low);

                    decimal open = stockDataClass.OpenPrices.ElementAtOrDefault(i);
                    openList.Add(open);

                    decimal prevClose = i >= 1 ? stockDataClass.ClosePrices.ElementAtOrDefault(i - 1) : 0;
                    prevCloseList.Add(prevClose);

                    decimal highSum = tempHighList.TakeLast(days).Sum();
                    highSumList.Add(highSum);

                    decimal lowSum = tempLowList.TakeLast(days).Sum();
                    lowSumList.Add(lowSum);

                    decimal openSum = openList.TakeLast(days).Sum();
                    openSumList.Add(openSum);

                    decimal prevCloseSum = prevCloseList.TakeLast(days).Sum();
                    prevCloseSumList.Add(prevCloseSum);

                    decimal bullA = highSum - openSum;
                    bullAList.Add(bullA);

                    decimal bearA = openSum - lowSum;
                    bearAList.Add(bearA);

                    decimal bullB = highSum - prevCloseSum;
                    bullBList.Add(bullB);

                    decimal bearB = prevCloseSum - lowSum;
                    bearBList.Add(bearB);

                    decimal prevRatioA = ratioAList.LastOrDefault();
                    decimal ratioA = bearA != 0 ? bullA / bearA * 100 : 0;
                    ratioAList.Add(ratioA);

                    decimal prevRatioB = ratioBList.LastOrDefault();
                    decimal ratioB = bearB != 0 ? bullB / bearB * 100 : 0;
                    ratioBList.Add(ratioB);

                    var signal = GetCompareSignal(ratioA - ratioB, prevRatioA - prevRatioB);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (prevCloseList, highSumList, lowSumList, openSumList, prevCloseSumList, bullAList, bullBList, bearAList, bearBList, ratioAList, ratioBList, signalsList);
        }

        public static (List<decimal>, List<Signal>) CalculatePsychologicalLine(StockData stockDataClass, int days = 20)
        {
            //@version=2
            ////////////////////////////////////////////////////////////
            //  Copyright by HPotter v1.0 06/03/2018
            // Psychological line (PSY), as an indicator, is the ratio of the number of 
            // rising periods over the total number of periods. It reflects the buying 
            // power in relation to the selling power.
            //
            // If PSY is above 50%, it indicates that buyers are in control. Likewise, 
            // if it is below 50%, it indicates the sellers are in control. If the PSY 
            // moves along the 50% area, it indicates balance between the buyers and 
            // sellers and therefore there is no direction movement for the market.
            ////////////////////////////////////////////////////////////
            //study(title = "Psychological line")
            //Length = input(20, minval = 1)
            //xPSY = sum(close > close[1], Length) / Length * 100
            //clr = iff(xPSY >= 50, green, red)
            //p1 = plot(50, color = black, title = "0")
            //p2 = plot(xPSY, color = blue, title = "PSY")
            //fill(p1, p2, color = clr)
            List<decimal> condList = new();
            List<decimal> condSumList = new();
            List<decimal> psyList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevPsy1 = i >= 1 ? psyList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevPsy2 = i >= 2 ? psyList.ElementAtOrDefault(i - 2) : 0;

                    decimal cond = currentValue > prevValue ? 1 : 0;
                    condList.Add(cond);

                    decimal condSum = condList.TakeLast(days).Sum();
                    condSumList.Add(condSum);

                    decimal psy = days != 0 ? condSum / days * 100 : 0;
                    psyList.Add(psy);

                    var signal = GetCompareSignal(psy - prevPsy1, prevPsy1 - prevPsy2);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (psyList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateChandeIntradayMomentumIndex(StockData stockDataClass, string maType, int days = 6)
        {
            //
            // @author LazyBear 
            // List of all my indicators: https://www.tradingview.com/v/4IneGo8h/
            //
            //study("Intrad1Zy Momentum Index [LazyBear]", shorttitle = "IMI_LB")
            //length = input(14, "IMI Length")
            //lengthMA = input(6, "IMI MA Length")
            //obLevel = input(70, "IMI static OB level")
            //osLevel = input(20, "IMI static OS level")
            //mult = input(2.0, title = "Volatility Bands Stdev Mult")
            //lengthBB = input(20, title = "Volatility Bands Length")
            //applySmoothing = input(false, "Smooth IMI")
            //lowBand = input(10, "Smoothing LowerBand")
            //PI = 3.14159265359
            //EhlersSuperSmootherFilter(price, lower) =>
            //    a1 = exp(-PI * sqrt(2) / lower)
            //
            //    coeff2 = 2 * a1 * cos(sqrt(2) * PI / lower)
            //
            //    coeff3 = -pow(a1, 2)
            //
            //    coeff1 = 1 - coeff2 - coeff3
            //
            //    filt = coeff1 * (price + nz(price[1])) / 2 + coeff2 * nz(filt[1]) + coeff3 * nz(filt[2])

            //gains = iff(close > open, nz(gains[1]) + (close - open), 0)
            //losses = iff(close < open, nz(losses[1]) + (open - close), 0)
            //upt = sum(gains, length)
            //dnt = sum(losses, length)
            //imi = applySmoothing ? EhlersSuperSmootherFilter(100 * (upt / (upt + dnt)), lowBand) : 100 * (upt / (upt + dnt))
            //basisx = ema(imi, lengthBB)
            //devx = (mult * stdev(imi, lengthBB))
            //ulx = (basisx + devx)
            //llx = (basisx - devx)

            // Uncomment if you want more bands
            //hline(90)
            //hline(10)
            //hline(obLevel)
            //hline((obLevel + osLevel) / 2, linestyle = dotted)
            //hline(osLevel)
            //plot(imi, color = red, linewidth = 2)
            //plot(imi >= ulx ? imi : na, color = green, style = cross, linewidth = 3)
            //plot(imi <= llx ? imi : na, color = maroon, style = cross, linewidth = 3)
            //plot(ema(imi, lengthMA), color = blue)
            decimal mult = 2;
            List<decimal> imiStdDevUnfilteredList = new();
            List<decimal> imiStdDevFilteredList = new();
            List<decimal> imiFilteredList = new();
            List<decimal> imiUnfilteredList = new();
            List<decimal> gainsList = new();
            List<decimal> lossesList = new();
            List<decimal> uptList = new();
            List<decimal> dntList = new();
            List<decimal> basisXUnfilteredList = new();
            List<decimal> basisXFilteredList = new();
            List<decimal> devXUnfilteredList = new();
            List<decimal> devXFilteredList = new();
            List<decimal> ulxUnfilteredList = new();
            List<decimal> llxUnfilteredList = new();
            List<decimal> ulxFilteredList = new();
            List<decimal> llxFilteredList = new();
            List<Signal> signalsList = new();

            try
            {
                int length = (int)Math.Ceiling(days / 0.4286);
                int lengthMa = days;
                int lowerBand = (int)Math.Ceiling(days / 0.6);
                int lengthBB = lowerBand * 2;

                for (int i = 0; i < stockDataClass.ClosePrices.Count; i++)
                {
                    decimal currentClose = stockDataClass.ClosePrices.ElementAtOrDefault(i);
                    decimal currentOpen = stockDataClass.OpenPrices.ElementAtOrDefault(i);
                    decimal prevImi1 = i >= 1 ? imiUnfilteredList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevImi2 = i >= 2 ? imiUnfilteredList.ElementAtOrDefault(i - 2) : 0;

                    decimal prevGains = gainsList.LastOrDefault();
                    decimal gains = currentClose > currentOpen ? prevGains + (currentClose - currentOpen) : 0;
                    gainsList.Add(gains);

                    decimal prevLosses = lossesList.LastOrDefault();
                    decimal losses = currentClose < currentOpen ? prevLosses + (currentOpen - currentClose) : 0;
                    lossesList.Add(losses);

                    decimal upt = gainsList.TakeLast(length).Sum();
                    uptList.Add(upt);

                    decimal dnt = lossesList.TakeLast(length).Sum();
                    dntList.Add(dnt);

                    decimal imiUnfiltered = upt + dnt != 0 ? MinOrMax(100 * upt / (upt + dnt), 100, 0) : 0;
                    imiUnfilteredList.Add(imiUnfiltered);

                    var signal = GetRsiSignal(imiUnfiltered - prevImi1, prevImi1 - prevImi2, imiUnfiltered, prevImi1, 70, 30);
                    signalsList.Add(signal);
                }

                imiFilteredList = GetMovingAverageList("EhlersSuperSmootherFilter", imiUnfilteredList, stockDataClass, lowerBand);
                basisXFilteredList = GetMovingAverageList(maType, imiFilteredList, stockDataClass, lengthBB);
                imiStdDevFilteredList = CalculateStandardDeviationVolatility(imiFilteredList, stockDataClass, lengthBB).Item4;
                basisXUnfilteredList = GetMovingAverageList(maType, imiUnfilteredList, stockDataClass, lengthBB);
                imiStdDevUnfilteredList = CalculateStandardDeviationVolatility(imiUnfilteredList, stockDataClass, lengthBB).Item4;
                for (int j = 0; j < imiFilteredList.Count; j++)
                {
                    decimal imiStdDevFiltered = imiStdDevFilteredList.ElementAtOrDefault(j);
                    decimal basisxFiltered = basisXFilteredList.ElementAtOrDefault(j);
                    decimal imiStdDevUnfiltered = imiStdDevUnfilteredList.ElementAtOrDefault(j);
                    decimal basisxUnfiltered = basisXUnfilteredList.ElementAtOrDefault(j);

                    decimal devxFiltered = mult * imiStdDevFiltered;
                    devXFilteredList.Add(devxFiltered);

                    decimal devxUnfiltered = mult * imiStdDevUnfiltered;
                    devXUnfilteredList.Add(devxUnfiltered);

                    decimal ulxFiltered = basisxFiltered + devxFiltered;
                    ulxFilteredList.Add(ulxFiltered);

                    decimal llxFiltered = basisxFiltered - devxFiltered;
                    llxFilteredList.Add(llxFiltered);

                    decimal ulxUnfiltered = basisxUnfiltered + devxUnfiltered;
                    ulxUnfilteredList.Add(ulxUnfiltered);

                    decimal llxUnfiltered = basisxUnfiltered - devxUnfiltered;
                    llxUnfilteredList.Add(llxUnfiltered);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (gainsList, lossesList, uptList, dntList, imiUnfilteredList, imiFilteredList, basisXUnfilteredList, basisXFilteredList, imiStdDevUnfilteredList,
                imiStdDevFilteredList, devXUnfilteredList, devXFilteredList, ulxUnfilteredList, ulxFilteredList, llxUnfilteredList, llxFilteredList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateAccumulativeSwingIndex(StockData stockDataClass, int days)
        {
            //@version=3
            // Copyright (c) 2017-present, Alex Orekhov (everget)
            // Accumulative Swing Index script may be freely distributed under the MIT license.
            //study("Accumulative Swing Index", shorttitle = "ASI")

            //limit = input(title = "Limit Move Value", type = float, defval = 10000)

            // Swing Index
            //            getSI(limit) =>
            //    H_C1 = abs(high - close[1])
            //    L_C1 = abs(low - close[1])
            //    H_L = abs(high - low)
            //    C1_O1 = abs(close[1] - open[1])
            //    K = max(H_C1, L_C1)
            //    R = iff(H_C1 >= max(L_C1, H_L), H_C1 - 0.5 * L_C1 + 0.25 * C1_O1, iff(L_C1 >= max(H_C1, H_L), L_C1 - 0.5 * H_C1 + 0.25 * C1_O1, H_L + 0.25 * C1_O1))
            //    result = 50 * ((close - close[1] + 0.5 * (close - open) + 0.25 * (close[1] - open[1])) / R) * K / limit
            //    result

            // Accumulative Swing Index
            //asi = cum(getSI(limit))

            //asiColor = asi >= asi[1] ? #0ebb23 : red

            //plot(asi, title = "ASI", color = asiColor, transp = 0)
            List<decimal> swingIndexList = new();
            List<decimal> accumulativeSwingIndexList = new();
            List<decimal> kList = new();
            List<decimal> rList = new();
            List<decimal> asiOscillatorList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.OpenPrices.Count; i++)
                {
                    decimal currentClose = stockDataClass.ClosePrices.ElementAtOrDefault(i);
                    decimal currentHigh = stockDataClass.HighPrices.ElementAtOrDefault(i);
                    decimal currentLow = stockDataClass.LowPrices.ElementAtOrDefault(i);
                    decimal currentOpen = stockDataClass.OpenPrices.ElementAtOrDefault(i);
                    decimal prevClose = i >= 1 ? stockDataClass.ClosePrices.ElementAtOrDefault(i - 1) : 0;
                    decimal prevOpen = i >= 1 ? stockDataClass.OpenPrices.ElementAtOrDefault(i - 1) : 0;
                    decimal prevHigh = i >= 1 ? stockDataClass.HighPrices.ElementAtOrDefault(i - 1) : 0;
                    decimal prevLow = i >= 1 ? stockDataClass.LowPrices.ElementAtOrDefault(i - 1) : 0;
                    decimal prevHighCurrentClose = prevHigh - currentClose;
                    decimal prevLowCurrentClose = prevLow - currentClose;
                    decimal prevClosePrevOpen = prevClose - prevOpen;
                    decimal currentHighPrevClose = currentHigh - prevClose;
                    decimal currentLowPrevClose = currentLow - prevClose;
                    decimal t = currentHigh - currentLow;

                    decimal k = Math.Max(Math.Abs(prevHighCurrentClose), Math.Abs(prevLowCurrentClose));
                    kList.Add(k);

                    decimal r = currentHighPrevClose > Math.Max(currentLowPrevClose, t) ? currentHighPrevClose - (0.5m * currentLowPrevClose) + (0.25m * prevClosePrevOpen) :
                        currentLowPrevClose > Math.Max(currentHighPrevClose, t) ? currentLowPrevClose - (0.5m * currentHighPrevClose) + (0.25m * prevClosePrevOpen) :
                        t > Math.Max(currentHighPrevClose, currentLowPrevClose) ? t + (0.25m * prevClosePrevOpen) : 0;
                    rList.Add(r);

                    decimal swingIndex = r != 0 && t != 0 ? 50 * ((prevClose - currentClose + (0.5m * prevClosePrevOpen) + (0.25m * (currentClose - currentOpen))) / r) * (k / t) : 0;
                    swingIndexList.Add(swingIndex);

                    decimal prevSwingIndex = accumulativeSwingIndexList.LastOrDefault();
                    decimal accumulativeSwingIndex = prevSwingIndex + swingIndex;
                    accumulativeSwingIndexList.Add(accumulativeSwingIndex);

                    decimal asiOscillator = accumulativeSwingIndexList.TakeLast(days).Average();
                    asiOscillatorList.Add(asiOscillator);

                    var signal = GetCompareSignal(accumulativeSwingIndex, prevSwingIndex);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (kList, rList, swingIndexList, accumulativeSwingIndexList, asiOscillatorList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateTradersDynamicIndex(
            StockData stockDataClass, string maType, int days = 2)
        {
            //
            // @author LazyBear
            // If you use this code in its orignal/modified form, do drop me a note. 
            // 
            //study("Traders Dynamic Index [LazyBear]", shorttitle = "TDI_LB")
            //lengthrsi = input(13)
            //src = close
            //lengthband = input(34)
            //lengthrsipl = input(2)
            //lengthtradesl = input(7)

            //r = rsi(src, lengthrsi)
            //ma = sma(r, lengthband)
            //offs = (1.6185 * stdev(r, lengthband))
            //up = ma + offs
            //dn = ma - offs
            //mid = (up + dn) / 2
            //mab = sma(r, lengthrsipl)
            //mbb = sma(r, lengthtradesl)

            //hline(32)
            //hline(68)
            //upl = plot(up, color = blue)
            //dnl = plot(dn, color = blue)
            //midl = plot(mid, color = orange, linewidth = 2)
            //fill(upl, midl, red, transp = 90)
            //fill(midl, dnl, green, transp = 90)
            //plot(mab, color = green, linewidth = 2)
            //plot(mbb, color = red, linewidth = 2)
            List<decimal> rsiSmaList = new();
            List<decimal> stdDevList = new();
            List<decimal> offsList = new();
            List<decimal> upList = new();
            List<decimal> dnList = new();
            List<decimal> midList = new();
            List<decimal> mabList = new();
            List<decimal> mbbList = new();
            List<decimal> tempList = new();
            List<Signal> signalsList = new();

            try
            {
                int lengthRsi = (int)Math.Ceiling(days / 0.1539);
                int lengthBand = days * 17;
                int lengthRsiPl = days;
                int lengthTradeSl = MinOrMax((int)Math.Ceiling(days / 0.2858));

                List<decimal> rsiList = CalculateRelativeStrengthIndex(null, stockDataClass, maType, lengthRsi).Item4;
                stdDevList = CalculateStandardDeviationVolatility(rsiList, stockDataClass, lengthBand).Item4;

                for (int i = 0; i < rsiList.Count; i++)
                {
                    decimal rsi = rsiList.ElementAtOrDefault(i);
                    tempList.Add(rsi);

                    decimal rsiSma = tempList.TakeLast(lengthBand).Average();
                    rsiSmaList.Add(rsiSma);

                    decimal stdDev = stdDevList.ElementAtOrDefault(i);

                    decimal offs = 1.6185m * stdDev;
                    offsList.Add(offs);

                    decimal up = rsiSma + offs;
                    upList.Add(up);

                    decimal dn = rsiSma - offs;
                    dnList.Add(dn);

                    decimal mid = (up + dn) / 2;
                    midList.Add(mid);

                    decimal prevMab = mabList.LastOrDefault();
                    decimal mab = tempList.TakeLast(lengthRsiPl).Average();
                    mabList.Add(mab);

                    decimal prevMbb = mbbList.LastOrDefault();
                    decimal mbb = tempList.TakeLast(lengthTradeSl).Average();
                    mbbList.Add(mbb);

                    var signal = GetCompareSignal(mab - mbb, prevMab - prevMbb);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (rsiSmaList, stdDevList, offsList, upList, dnList, midList, mabList, mbbList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateVolumePriceConfirmationIndicator(StockData stockDataClass, string maType, int days = 5)
        {
            //
            // @author LazyBear
            //
            // If you use this code in its orignal/modified form, do drop me a note. 
            // 
            //study("Volume Price Confirmation Indicator [LazyBear]", shorttitle = "VPCI_LB")
            //shortTerm = input(5)
            //longTerm = input(20)

            //src = close
            //vpc = vwma(src, longTerm) - sma(src, longTerm)
            //vpr = vwma(src, shortTerm) / sma(src, shortTerm)
            //vm = sma(volume, shortTerm) / sma(volume, longTerm)

            //vpci = vpc * vpr * vm
            //hline(0)
            //plot(vpci, color = orange, linewidth = 2)

            //DrawMA = input(true, type = bool, title = "Draw MA on VPCI?")
            //lengthMA = input(8, "VPCI MA Length")
            //s = sma(vpci, lengthMA)
            //plot(DrawMA ? s : na, color = teal)

            //DrawBands = input(false, type = bool)
            //HighlightBreaches = input(true, type = bool)
            //length = input(20, title = "BB Length")
            //mult = input(2.5)
            //bb_s = vpci
            //basis = sma(bb_s, length)
            //dev = (mult * stdev(bb_s, length))
            //upper = (basis + dev)
            //lower = (basis - dev)

            //plot(DrawBands ? basis : na, color = gray, style = line)
            //p1 = plot(DrawBands ? upper : na, color = gray)
            //p2 = plot(DrawBands ? lower : na, color = gray)
            //fill(p1, p2, blue)

            //b_color = (bb_s > upper) ? red : (bb_s < lower) ? green : na
            //offs_v = 0.3
            //breach_pos = (bb_s >= upper) ? (bb_s + offs_v) : (bb_s <= lower ? (bb_s - offs_v) : 0)
            //Breached = (bb_s >= upper) or(bb_s <= lower)
            //plot(HighlightBreaches and Breached ? breach_pos : na, style = cross, color = b_color, linewidth = 3)
            List<decimal> vpcList = new();
            List<decimal> vprList = new();
            List<decimal> vmList = new();
            List<decimal> vpciList = new();
            List<decimal> vpciSmaList = new();
            List<Signal> signalsList = new();

            try
            {
                int longTerm = MinOrMax(days * 4);
                int lengthMa = MinOrMax((int)Math.Ceiling(days / 0.625));

                List<decimal> vwmaShortList = CalculateVolumeWeightedMovingAverage(stockDataClass, maType, days).Item3;
                List<decimal> vwmaLongList = CalculateVolumeWeightedMovingAverage(stockDataClass, maType, longTerm).Item3;
                List<decimal> volumeSmaShortList = GetMovingAverageList(maType, null, stockDataClass, days);
                List<decimal> volumeSmaLongList = GetMovingAverageList(maType, null, stockDataClass, longTerm);
                List<decimal> smaShortList = GetMovingAverageList(maType, null, stockDataClass, days);
                List<decimal> smaLongList = GetMovingAverageList(maType, null, stockDataClass, longTerm);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal vwmaLong = vwmaLongList.ElementAtOrDefault(i);
                    decimal vwmaShort = vwmaShortList.ElementAtOrDefault(i);
                    decimal volumeSmaLong = volumeSmaLongList.ElementAtOrDefault(i);
                    decimal volumeSmaShort = volumeSmaShortList.ElementAtOrDefault(i);
                    decimal smaLong = smaLongList.ElementAtOrDefault(i);
                    decimal smaShort = smaShortList.ElementAtOrDefault(i);

                    decimal vpc = vwmaLong - smaLong;
                    vpcList.Add(vpc);

                    decimal vpr = smaShort != 0 ? vwmaShort / smaShort : 0;
                    vprList.Add(vpr);

                    decimal vm = volumeSmaLong != 0 ? volumeSmaShort / volumeSmaLong : 0;
                    vmList.Add(vm);

                    decimal prevVpci = vpciList.LastOrDefault();
                    decimal vpci = vpc * vpr * vm;
                    vpciList.Add(vpci);

                    decimal prevVpciSma = vpciSmaList.LastOrDefault();
                    decimal vpciSma = vpciList.TakeLast(lengthMa).Average();
                    vpciSmaList.Add(vpciSma);

                    var signal = GetCompareSignal(vpci - vpciSma, prevVpci - prevVpciSma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (vpcList, vprList, vmList, vpciList, vpciSmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateVolumePositiveNegativeIndicator(StockData stockDataClass,
            string maType, int days = 3)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Volume Positive Negative Indicator [CC] script may be freely distributed under the MIT license.
            //study("Volume Positive Negative Indicator [CC]", overlay = false)

            //f_security(_symbol, _res, _src, _repaint) => 
            //    security(_symbol, _res, _src[_repaint ? 0 : barstate.isrealtime ? 1 : 0])[_repaint ? 0 : barstate.isrealtime ? 0 : 1]

            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //length = input(title = "Length", type = input.integer, defval = 30, minval = 1)
            //smoothLength = input(title = "SmoothLength", type = input.integer, defval = 3, minval = 1)
            //c = f_security(syminfo.tickerid, res, close, rep)
            //h = f_security(syminfo.tickerid, res, high, rep)
            //l = f_security(syminfo.tickerid, res, low, rep)
            //v = f_security(syminfo.tickerid, res, volume, rep)

            //mav = ema(v, length)
            //mav:= mav > 0 ? mav : 1
            //avg = (h + l + c) / 3
            //mf = avg - nz(avg[1])
            //mc = 0.1 * atr(length)

            //vmp = mf > mc ? v : 0
            //vp = sum(vmp, length)
            //vmn = mf < -mc ? v : 0
            //vn = sum(vmn, length)
            //vpn = ema((vp - vn) / mav / length * 100, smoothLength)

            //sig = vpn > 0 ? 1 : vpn < 0 ? -1 : 0
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //vpniColor = sig > 0 ? color.green : sig < 0 ? color.red : color.black
            //barcolor(bar ? vpniColor : na)
            //plot(vpn, title = "VPNI", color = vpniColor, linewidth = 2)
            List<decimal> mfList = new();
            List<decimal> mcList = new();
            List<decimal> vmpList = new();
            List<decimal> vpList = new();
            List<decimal> vmnList = new();
            List<decimal> vnList = new();
            List<decimal> vpnList = new();
            List<decimal> vpnEmaList = new();
            List<Signal> signalsList = new();

            try
            {
                int smoothLength = days;
                int length = days * 10;

                var mavList = GetMovingAverageList(maType, null, stockDataClass, length);
                var tpList = CalculateTypicalPrice(stockDataClass).Item1;
                var atrList = CalculateAverageTrueRange(stockDataClass, maType, length).Item1;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal mav = mavList.ElementAtOrDefault(i);
                    mav = mav > 0 ? mav : 1;
                    decimal tp = tpList.ElementAtOrDefault(i);
                    decimal prevTp = i >= 1 ? tpList.ElementAtOrDefault(i - 1) : 0;
                    decimal atr = atrList.ElementAtOrDefault(i);
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);

                    decimal mf = tp - prevTp;
                    mfList.Add(mf);

                    decimal mc = 0.1m * atr;
                    mcList.Add(mc);

                    decimal vmp = mf > mc ? currentValue : 0;
                    vmpList.Add(vmp);

                    decimal vp = vmpList.TakeLast(length).Sum();
                    vpList.Add(vp);

                    decimal vmn = mf < -mc ? currentValue : 0;
                    vmnList.Add(vmn);

                    decimal vn = vmnList.TakeLast(length).Sum();
                    vnList.Add(vn);

                    decimal vpn = mav != 0 ? (vp - vn) / mav / length * 100 : 0;
                    vpnList.Add(vpn);
                }

                vpnEmaList = GetMovingAverageList(maType, vpnList, stockDataClass, smoothLength);
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal vpnEma = vpnEmaList.ElementAtOrDefault(j);
                    decimal prevVpnEma = j >= 1 ? vpnEmaList.ElementAtOrDefault(j - 1) : 0;

                    var signal = GetCompareSignal(vpnEma, prevVpnEma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (mfList, mcList, vmpList, vpList, vmnList, vnList, vpnList, vpnEmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateBetterVolumeIndicator(StockData stockDataClass, int days = 8)
        {
            //
            // @author LazyBear
            //
            // If you use this code in its original/modified form, do drop me a note. 
            //
            //study(title = "Better Volume Indicator [LazyBear]", shorttitle = "BVI_LB")
            //

            // Configurable params
            //
            //length = input(8, title = "Lookback")
            //enableBarColors = input(false, type = bool)
            //use2Bars = input(true, type = bool)
            //lowVol = input(true, type = bool)
            //climaxUp = input(true, type = bool)
            //climaxDown = input(true, type = bool)
            //churn = input(true, type = bool)
            //climaxChurn = input(true, type = bool)

            //
            // Tweak the colors
            //
            //lowVolColor = yellow
            //climaxUpColor = red
            //climaxDownColor = white
            //churnColor = green
            //climaxChurnColor = #8B008B
            //defColor = #00FFFF	 
            // Don't change anything below this
            //
            //range = tr
            //v = volume
            //v1 = close >= open ? (v * ((range) / ((2 + (range * range) / 10) * range + (open - close)))) : 
            //(v * (((range + close - open)) / (2 + (range * range) / 10) * range + (close - open)))
            //v2 = v - v1
            //v3 = v1 + v2
            //v4 = v1 * range
            //v5 = (v1 - v2) * range
            //v6 = v2 * range
            //v7 = (v2 - v1) * range
            //v8 = (range != 0 ? v1 / range : 1)
            //v9 = (range != 0 ? (v1 - v2) / range : 1)
            //v10 = (range != 0 ? v2 / range : 1)
            //v11 = (range != 0 ? (v2 - v1) / range : 1)
            //v12 = (range != 0 ? v3 / range : 1)
            //v13 = use2Bars ? v3 + v3[1] : 1
            //v14 = (use2Bars ? (v1 + v1[1]) * (highest(high, 2) - lowest(low, 2)) : 1)
            //v15 = (use2Bars ? (v1 + v1[1] - v2 - v2[1]) * (highest(high, 2) - lowest(low, 2)) : 1)
            //v16 = (use2Bars ? (v2 + v2[1]) * (highest(high, 2) - lowest(low, 2)) : 1)
            //v17 = (use2Bars ? (v2 + v2[1] - v1 - v1[1]) * (highest(high, 2) - lowest(low, 2)) : 1)
            //v18 = ((use2Bars and(highest(high, 2) != lowest(low, 2))) ? (v1 + v1[1]) / (highest(high, 2) - lowest(low, 2)) : 1)
            //v19 = ((use2Bars and(highest(high, 2) != lowest(low, 2))) ? (v1 + v1[1] - v2 - v2[1]) / (highest(high, 2) - lowest(low, 2)) : 1)
            //v20 = ((use2Bars and(highest(high, 2) != lowest(low, 2))) ? (v2 + v2[1]) / (highest(high, 2) - lowest(low, 2)) : 1)
            //v21 = ((use2Bars and(highest(high, 2) != lowest(low, 2))) ? (v2 + v2[1] - v1 - v1[1]) / (highest(high, 2) - lowest(low, 2)) : 1)
            //v22 = ((use2Bars and(highest(high, 2) != lowest(low, 2))) ? v13 / (highest(high, 2) - lowest(low, 2)) : 1)

            //c1 = (v3 == lowest(v3, length) ? 1 : 0)
            //c2 = ((v4 == highest(v4, length) and close > open) ? 1 : 0)
            //c3 = ((v5 == highest(v5, length) and close > open) ? 1 : 0)
            //c4 = ((v6 == highest(v6, length) and close<open) ? 1 : 0)
            //c5 = ((v7 == highest(v7, length) and close<open) ? 1 : 0)
            //c6 = ((v8 == lowest(v8, length) and close<open) ? 1 : 0)
            //c7 = ((v9 == lowest(v9, length) and close<open) ? 1 : 0)
            //c8 = ((v10 == lowest(v10, length) and close > open) ? 1 : 0)
            //c9 = ((v11 == lowest(v11, length) and close > open) ? 1 :  0)
            //c10 = (v12 == highest(v12, length) ? 1 : 0)
            //c11 = (use2Bars and(v13 == lowest(v13, length) and close > open and close[1] > open[1]) ? 1 : 0)
            //c12 = (use2Bars and(v14 == highest(v14, length) and close > open and close[1] > open[1]) ? 1 : 0)
            //c13 = (use2Bars and(v15 == highest(v15, length) and close > open and close[1] < open[1]) ? 1 : 0)
            //c14 = (use2Bars and(v16 == lowest(v16, length) and close < open and close[1] < open[1]) ? 1 : 0)
            //c15 = (use2Bars and(v17 == lowest(v17, length) and close < open and close[1] < open[1]) ? 1 : 0)
            //c16 = (use2Bars and(v18 == lowest(v18, length) and close < open and close[1] < open[1]) ? 1 : 0)
            //c17 = (use2Bars and(v19 == lowest(v19, length) and close > open and close[1] < open[1]) ? 1 : 0)
            //c18 = (use2Bars and(v20 == lowest(v20, length) and close > open and close[1] > open[1]) ? 1 : 0)
            //c19 = (use2Bars and(v21 == lowest(v21, length) and close > open and close[1] > open[1]) ? 1 : 0)
            //c20 = (use2Bars and(v22 == lowest(v22, length)) ? 1 : 0)

            //c0 = (climaxUp and(c2 or c3 or c8 or c9 or c12 or c13 or c18 or c19)) ? climaxUpColor: ((climaxDown and(c4 or c5 or c6 or c7 or c14 or c15 or c16 or c17)) ? climaxDownColor: ((churn and c10 or c20) ? churnColor: defColor))
            //v_color = (climaxChurn and(c10 or c20)) and(c2 or c3 or c4 or c5 or c6 or c7 or c8 or c9) ? climaxChurnColor : ((lowVol and(c1 or c11)) ? lowVolColor: c0)
            //plot(not enableBarColors ? volume : na, style = columns, linewidth = 1, color = v_color)
            //plot(not enableBarColors ? sma(volume, length) : na, color = orange, linewidth = 2)
            //barcolor(enableBarColors ? v_color : na)
            List<decimal> v1List = new();
            List<decimal> v2List = new();
            List<decimal> v3List = new();
            List<decimal> v4List = new();
            List<decimal> v5List = new();
            List<decimal> v6List = new();
            List<decimal> v7List = new();
            List<decimal> v8List = new();
            List<decimal> v9List = new();
            List<decimal> v10List = new();
            List<decimal> v11List = new();
            List<decimal> v12List = new();
            List<decimal> v13List = new();
            List<decimal> v14List = new();
            List<decimal> v15List = new();
            List<decimal> v16List = new();
            List<decimal> v17List = new();
            List<decimal> v18List = new();
            List<decimal> v19List = new();
            List<decimal> v20List = new();
            List<decimal> v21List = new();
            List<decimal> v22List = new();
            List<Signal> signalsList = new();

            try
            {
                int length = MinOrMax(days * 4);

                var minMaxList = VolumeInputCheck(stockDataClass, days, true);
                List<decimal> highestHighList = minMaxList.Item1;
                List<decimal> lowestLowList = minMaxList.Item2;

                for (int i = 0; i < stockDataClass.OpenPrices.Count; i++)
                {
                    decimal highest = highestHighList.ElementAtOrDefault(i);
                    decimal lowest = lowestLowList.ElementAtOrDefault(i);
                    decimal currentHigh = stockDataClass.HighPrices.ElementAtOrDefault(i);
                    decimal currentLow = stockDataClass.LowPrices.ElementAtOrDefault(i);
                    decimal currentVolume = stockDataClass.Volumes.ElementAtOrDefault(i);
                    decimal currentOpen = stockDataClass.OpenPrices.ElementAtOrDefault(i);
                    decimal currentClose = stockDataClass.ClosePrices.ElementAtOrDefault(i);
                    decimal highLowRange = highest - lowest;
                    decimal prevClose = i >= 1 ? stockDataClass.ClosePrices.ElementAtOrDefault(i - 1) : 0;
                    decimal prevOpen = i >= 1 ? stockDataClass.OpenPrices.ElementAtOrDefault(i - 1) : 0;
                    decimal range = Math.Max(currentHigh - currentLow, Math.Max(Math.Abs(currentHigh - prevClose), Math.Abs(currentLow - prevClose)));

                    decimal prevV1 = v1List.LastOrDefault();
                    decimal v1 = currentClose > currentOpen ? (range / ((2 * range) + currentOpen - currentClose)) * currentVolume :
                        currentClose < currentOpen ? ((range + currentClose - currentOpen) / ((2 * range) + currentClose - currentOpen)) * currentVolume : 0.5m * currentVolume;
                    v1List.Add(v1);

                    decimal prevV2 = v2List.LastOrDefault();
                    decimal v2 = currentVolume - v1;
                    v2List.Add(v2);

                    decimal prevV3 = v3List.LastOrDefault();
                    decimal v3 = v1 + v2;
                    v3List.Add(v3);

                    decimal v4 = v1 * range;
                    v4List.Add(v4);

                    decimal v5 = (v1 - v2) * range;
                    v5List.Add(v5);

                    decimal v6 = v2 * range;
                    v6List.Add(v6);

                    decimal v7 = (v2 - v1) * range;
                    v7List.Add(v7);

                    decimal v8 = range != 0 ? v1 / range : 0;
                    v8List.Add(v8);

                    decimal v9 = range != 0 ? (v1 - v2) / range : 0;
                    v9List.Add(v9);

                    decimal v10 = range != 0 ? v2 / range : 0;
                    v10List.Add(v10);

                    decimal v11 = range != 0 ? (v2 - v1) / range : 0;
                    v11List.Add(v11);

                    decimal v12 = range != 0 ? v3 / range : 0;
                    v12List.Add(v12);

                    decimal v13 = v3 + prevV3;
                    v13List.Add(v13);

                    decimal v14 = (v1 + prevV1) * highLowRange;
                    v14List.Add(v14);

                    decimal v15 = (v1 + prevV1 - v2 - prevV2) * highLowRange;
                    v15List.Add(v15);

                    decimal v16 = (v2 + prevV2) * highLowRange;
                    v16List.Add(v16);

                    decimal v17 = (v2 + prevV2 - v1 - prevV1) * highLowRange;
                    v17List.Add(v17);

                    decimal v18 = highLowRange != 0 ? (v1 + prevV1) / highLowRange : 0;
                    v18List.Add(v18);

                    decimal v19 = highLowRange != 0 ? (v1 + prevV1 - v2 - prevV2) / highLowRange : 0;
                    v19List.Add(v19);

                    decimal v20 = highLowRange != 0 ? (v2 + prevV2) / highLowRange : 0;
                    v20List.Add(v20);

                    decimal v21 = highLowRange != 0 ? (v2 + prevV2 - v1 - prevV1) / highLowRange : 0;
                    v21List.Add(v21);

                    decimal v22 = highLowRange != 0 ? v13 / highLowRange : 0;
                    v22List.Add(v22);

                    bool c1 = v3 == v3List.TakeLast(length).Min();
                    bool c2 = v4 == v4List.TakeLast(length).Max() && currentClose > currentOpen;
                    bool c3 = v5 == v5List.TakeLast(length).Max() && currentClose > currentOpen;
                    bool c4 = v6 == v6List.TakeLast(length).Max() && currentClose < currentOpen;
                    bool c5 = v7 == v7List.TakeLast(length).Max() && currentClose < currentOpen;
                    bool c6 = v8 == v8List.TakeLast(length).Min() && currentClose < currentOpen;
                    bool c7 = v9 == v9List.TakeLast(length).Min() && currentClose < currentOpen;
                    bool c8 = v10 == v10List.TakeLast(length).Min() && currentClose > currentOpen;
                    bool c9 = v11 == v11List.TakeLast(length).Min() && currentClose > currentOpen;
                    bool c10 = v12 == v12List.TakeLast(length).Max();
                    bool c11 = v13 == v13List.TakeLast(length).Min() && currentClose > currentOpen && prevClose > prevOpen;
                    bool c12 = v14 == v14List.TakeLast(length).Max() && currentClose > currentOpen && prevClose > prevOpen;
                    bool c13 = v15 == v15List.TakeLast(length).Max() && currentClose > currentOpen && prevClose < prevOpen;
                    bool c14 = v16 == v16List.TakeLast(length).Min() && currentClose < currentOpen && prevClose < prevOpen;
                    bool c15 = v17 == v17List.TakeLast(length).Min() && currentClose < currentOpen && prevClose < prevOpen;
                    bool c16 = v18 == v18List.TakeLast(length).Min() && currentClose < currentOpen && prevClose < prevOpen;
                    bool c17 = v19 == v19List.TakeLast(length).Min() && currentClose > currentOpen && prevClose < prevOpen;
                    bool c18 = v20 == v20List.TakeLast(length).Min() && currentClose > currentOpen && prevClose > prevOpen;
                    bool c19 = v21 == v21List.TakeLast(length).Min() && currentClose > currentOpen && prevClose > prevOpen;
                    bool c20 = v22 == v22List.TakeLast(length).Min();
                    bool climaxUp = c2 || c3 || c8 || c9 || c12 || c13 || c18 || c19;
                    bool climaxDown = c4 || c5 || c6 || c7 || c14 || c15 || c16 || c17;
                    bool churn = c10 || c20;
                    bool lowVolue = c1 || c11;

                    var signal = GetConditionSignal(climaxUp, climaxDown);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (v1List, v2List, v3List, v4List, v5List, v6List, v7List, v8List, v9List, v10List, v11List, v12List, v13List, v14List, v15List, v16List, v17List, v18List,
                v19List, v20List, v21List, v22List, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateRateOfChange(List<decimal>? customValuesList, StockData stockDataClass, int days = 12)
        {
            //period = user defined, default is 12
            //maPeriod = user defined, default is 20
            //method = moving average (ma), user defined, default is EMA
            //roc = rate of change
            //index = current bar number

            //ROC = roc(index, period, close) * 100;
            //SIG = ma(method, index, maPeriod, ROC);
            // Signals
            //buy = crossedAbove(ROC, SIG);
            //sell = crossedBelow(ROC, SIG);

            //ROC = [(Close - Close n periods ago) / (Close n periods ago)] * 100
            //volRoc = 100 * (v - priorV) / (v + priorV);
            //rocfs = (price * 100) / firstP - 100;
            decimal firstValue = stockDataClass.InputValues.Where(i => i != 0).FirstOrDefault();
            List<decimal> rocList = new();
            List<decimal> roc2List = new();
            List<decimal> tempList = new();
            List<decimal> rocfsList = new();
            List<decimal> rocEmaList = new();
            List<Signal> signalsList = new();

            try
            {
                int maPeriod = MinOrMax((int)Math.Ceiling(days / 0.6));

                if (customValuesList != null)
                {
                    stockDataClass.InputValues = customValuesList;
                }

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= days ? stockDataClass.InputValues.ElementAtOrDefault(i - days) : 0;

                    decimal rocfs = firstValue != 0 ? (currentValue * 100 / firstValue) - 100 : 0;
                    rocfsList.Add(rocfs);

                    decimal prevRoc = rocList.LastOrDefault();
                    decimal roc = prevValue != 0 ? (currentValue - prevValue) / prevValue * 100 : 0;
                    rocList.Add(roc);

                    decimal roc2 = currentValue + prevValue != 0 ? 100 * (currentValue - prevValue) / (currentValue + prevValue) : 0;
                    roc2List.Add(roc2);

                    decimal prevRocEma = rocEmaList.LastOrDefault();
                    decimal rocEma = CalculateExponentialMovingAverage(roc, prevRocEma, maPeriod);
                    rocEmaList.Add(rocEma);

                    var signal = GetCompareSignal(roc - rocEma, prevRoc - prevRocEma);
                    signalsList.Add(signal);
                }

                // reset the input values list
                stockDataClass = LoadCalculations.GetInputValuesList(stockDataClass.InputName, stockDataClass);
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (rocList, roc2List, rocfsList, rocEmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateDynamicMomentumIndex(
            StockData stockDataClass, string maType, int days = 5)
        {
            //input = price, user defined, default is close
            //sdPeriod = user defined, default is 5
            //avSdPeriod = user defined, default is 10
            //rsiPeriod = user defined, default is 14
            //upLimit = user defined, default is 30
            //loLimit = user defined, default is 5
            //stdDev = std = standard deviation
            //av = average, prev = previous
            //rsi = Relative Strength Index
            //sma = simple moving average, index = current bar number

            //stdDev = std(index, sdPeriod, input);
            //avSd = sma(index, avSdPeriod, stdDev);
            //dTime = round(rsiPeriod / avSd); //period dependent on average of stdDev
            //lenDmi = max(min(dTime, upLimit), loLimit);  //determine period length
            //Plot: dmi = rsi(lenDmi, input)[0];
            //Signals
            //prevDmi = dmi[index - 1];
            //highSell = dmi for last sell signal, reset to max_negative at each  buy signal;
            //lowBuy = dmi for last buy signal, reset to max_positive at each sell signal;
            //sell = (dmi moreThan topGuide) AND(prevDmi moreThan dmi  AND(dmi moreThan highSell);
            //buy = (dmi lessThan bottGuide AND prevDmi lessThan dmi AND(dmi lessThan lowBuy);
            List<decimal> lossList = new();
            List<decimal> gainList = new();
            List<decimal> avgGainEmaList = new();
            List<decimal> avgLossEmaList = new();
            List<decimal> avgGainSmaList = new();
            List<decimal> avgLossSmaList = new();
            List<decimal> avgGainWmaList = new();
            List<decimal> avgLossWmaList = new();
            List<decimal> rsEmaList = new();
            List<decimal> dmiEmaList = new();
            List<decimal> dmiSignalEmaList = new();
            List<decimal> dmiHistogramEmaList = new();
            List<decimal> rsSmaList = new();
            List<decimal> dmiSmaList = new();
            List<decimal> dmiSignalSmaList = new();
            List<decimal> dmiHistogramSmaList = new();
            List<decimal> rsWmaList = new();
            List<decimal> dmiWmaList = new();
            List<decimal> dmiSignalWmaList = new();
            List<decimal> dmiHistogramWmaList = new();
            List<Signal> signalsList = new();

            try
            {
                int sdPeriod = days;
                int avSdPeriod = MinOrMax(sdPeriod * 2);
                int loLimit = sdPeriod;
                int upLimit = MinOrMax(sdPeriod * 6);
                int rsiPeriod = MinOrMax((int)Math.Ceiling(sdPeriod / 0.3581));

                List<decimal> standardDeviationList = CalculateStandardDeviationVolatility(null, stockDataClass, sdPeriod).Item4;
                List<decimal> stdDeviationSmaList = GetMovingAverageList(maType, standardDeviationList, stockDataClass, avSdPeriod);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal asd = stdDeviationSmaList.ElementAtOrDefault(i);
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    int dTime = 0;
                    try
                    {
                        dTime = asd != 0 ? Math.Min(upLimit, (int)Math.Ceiling(rsiPeriod / asd)) : 0;
                    }
                    catch
                    {
                        dTime = upLimit;
                    }

                    int dmiLength = Math.Max(Math.Min(dTime, upLimit), loLimit);
                    decimal priceChg = currentValue - prevValue;

                    decimal loss = priceChg < 0 ? Math.Abs(priceChg) : 0;
                    lossList.Add(loss);

                    decimal gain = priceChg > 0 ? priceChg : 0;
                    gainList.Add(gain);

                    decimal avgGainSma = gainList.TakeLast(dmiLength).Average();
                    avgGainSmaList.Add(avgGainSma);

                    decimal avgLossSma = lossList.TakeLast(dmiLength).Average();
                    avgLossSmaList.Add(avgLossSma);

                    decimal rsSma = avgLossSma != 0 ? avgGainSma / avgLossSma : 0;
                    rsSmaList.Add(rsSma);

                    decimal dmiSma = avgLossSma == 0 ? 100 : avgGainSma == 0 ? 0 : 100 - (100 / (1 + rsSma));
                    dmiSmaList.Add(dmiSma);

                    decimal dmiSignalSma = CalculateExponentialMovingAverage(dmiSma, dmiSignalSmaList.LastOrDefault(), days);
                    dmiSignalSmaList.Add(dmiSignalSma);

                    decimal dmiHistogramSma = dmiSma - dmiSignalSma;
                    dmiHistogramSmaList.Add(dmiHistogramSma);

                    decimal avgGainEma = CalculateExponentialMovingAverage(gain, avgGainEmaList.LastOrDefault(), dmiLength);
                    avgGainEmaList.Add(avgGainEma);

                    decimal avgLossEma = CalculateExponentialMovingAverage(loss, avgLossEmaList.LastOrDefault(), dmiLength);
                    avgLossEmaList.Add(avgLossEma);

                    decimal rsEma = avgLossEma != 0 ? avgGainEma / avgLossEma : 0;
                    rsEmaList.Add(rsEma);

                    decimal dmiEma = avgLossEma == 0 ? 100 : avgGainEma == 0 ? 0 : 100 - (100 / (1 + rsEma));
                    dmiEmaList.Add(dmiEma);

                    decimal dmiSignalEma = CalculateExponentialMovingAverage(dmiEma, dmiSignalEmaList.LastOrDefault(), days);
                    dmiSignalEmaList.Add(dmiSignalEma);

                    decimal dmiHistogramEma = dmiEma - dmiSignalEma;
                    dmiHistogramEmaList.Add(dmiHistogramEma);

                    decimal factor = (decimal)1 / dmiLength;
                    decimal avgGainWma = (gain * factor) + (avgGainWmaList.LastOrDefault() * (1 - factor));
                    avgGainWmaList.Add(avgGainWma);

                    decimal avgLossWma = (loss * factor) + (avgLossWmaList.LastOrDefault() * (1 - factor));
                    avgLossWmaList.Add(avgLossWma);

                    decimal rsWma = avgLossWma != 0 ? avgGainWma / avgLossWma : 0;
                    rsWmaList.Add(rsWma);

                    decimal prevDmiWma = dmiWmaList.LastOrDefault();
                    decimal dmiWma = avgLossWma == 0 ? 100 : avgGainWma == 0 ? 0 : MinOrMax(100 - (100 / (1 + rsWma)), 100, 0);
                    dmiWmaList.Add(dmiWma);

                    decimal dmiSignalWma = CalculateExponentialMovingAverage(dmiWma, dmiSignalWmaList.LastOrDefault(), days);
                    dmiSignalWmaList.Add(dmiSignalWma);

                    decimal prevDmiHistogram = dmiHistogramWmaList.LastOrDefault();
                    decimal dmiHistogramWma = dmiWma - dmiSignalWma;
                    dmiHistogramWmaList.Add(dmiHistogramWma);

                    var signal = GetRsiSignal(dmiHistogramWma, prevDmiHistogram, dmiWma, prevDmiWma, 70, 30);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (avgGainSmaList, avgLossSmaList, rsSmaList, dmiSmaList, dmiSignalSmaList, dmiHistogramSmaList, avgGainEmaList, avgLossEmaList, rsEmaList, dmiEmaList,
                dmiSignalEmaList, dmiHistogramEmaList, avgGainWmaList, avgLossWmaList, rsWmaList, dmiWmaList, dmiSignalWmaList, dmiHistogramWmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateMcGinleyDynamicIndicator(StockData stockDataClass, int days)
        {
            //@version=4
            //study("McGinley Dynamic", shorttitle = "MD", overlay = true)

            //length = input(title = "Length", type = input.integer, defval = 14)
            //mdK = input(title = "K Constant", type = input.float, step = 0.1, defval = 0.6)
            //src = input(title = "Source", type = input.source, defval = close)
            //highlightMovements = input(title = "Highlight ?", type = input.bool, defval = false)

            //_md(src, length, const) =>
            //    md = 0.0

            //    md:= na(md[1]) ? src : md[1] + (src - md[1]) / (const * length * pow(src / md[1], 4))

            //md = _md(src, length, mdK)

            //mdColor = highlightMovements ? (md > md[1] ? color.green : color.red) : #512da8
            //plot(md, title = "MD", linewidth = 2, color = mdColor, transp = 0)
            decimal k = 0.6m;
            List<decimal> mdiList = new();
            List<decimal> ratioList = new();
            List<decimal> bottomList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevMdi = i >= 1 ? mdiList.LastOrDefault() : currentValue;
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal ratio = prevMdi != 0 ? currentValue / prevMdi : 0;
                    ratioList.Add(ratio);

                    decimal bottom = k * days * Pow(ratio, 4);
                    bottomList.Add(bottom);

                    decimal mdi = bottom != 0 ? prevMdi + ((currentValue - prevMdi) / Math.Max(bottom, 1)) : currentValue;
                    mdiList.Add(mdi);

                    var signal = GetCompareSignal(currentValue - mdi, prevValue - prevMdi);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (ratioList, bottomList, mdiList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateSvama(StockData stockDataClass, int days)
        {
            //@version=4
            //study("SVAMA", overlay = true)
            //Method = input("Max", options =["Max", "Min"])
            //----
            //h = 0.,l = 0.,c = 0.
            //----
            //a = volume
            //h:= a > nz(h[1], a) ? a : nz(h[1], a)
            //l:= a < nz(l[1], a) ? a : nz(l[1], a)
            //----
            //b = Method == "Max" ? a / h : l / a
            //c:= b * close + (1 - b) * nz(c[1], close)
            //----
            //plot(c, color =#2196f3,linewidth=2,transp=0)
            List<decimal> hList = new();
            List<decimal> lList = new();
            List<decimal> bMaxList = new();
            List<decimal> bMinList = new();
            List<decimal> cMaxList = new();
            List<decimal> cMinList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal a = stockDataClass.Volumes.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal prevH = i >= 1 ? hList.ElementAtOrDefault(i - 1) : a;
                    decimal h = a > prevH ? a : prevH;
                    hList.Add(h);

                    decimal prevL = i >= 1 ? lList.ElementAtOrDefault(i - 1) : a;
                    decimal l = a < prevL ? a : prevL;
                    lList.Add(l);

                    decimal bMax = h != 0 ? a / h : 0;
                    bMaxList.Add(bMax);

                    decimal bMin = a != 0 ? l / a : 0;
                    bMinList.Add(bMin);

                    decimal prevCMax = i >= 1 ? cMaxList.ElementAtOrDefault(i - 1) : currentValue;
                    decimal cMax = (bMax * currentValue) + ((1 - bMax) * prevCMax);
                    cMaxList.Add(cMax);

                    decimal prevCMin = i >= 1 ? cMinList.ElementAtOrDefault(i - 1) : currentValue;
                    decimal cMin = (bMin * currentValue) + ((1 - bMin) * prevCMin);
                    cMinList.Add(cMin);

                    var signal = GetCompareSignal(currentValue - cMax, prevValue - prevCMax);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (hList, lList, bMinList, bMaxList, cMinList, cMaxList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculatePriceVolumeTrend(StockData stockDataClass, int days)
        {
            // PVT = prev PVT + volume * (close - prevClose) / prevClose
            List<decimal> priceVolumeTrendList = new();
            List<decimal> pvtEmaList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal currentVolume = stockDataClass.Volumes.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal prevPvt = priceVolumeTrendList.LastOrDefault();
                    decimal pvt = prevValue != 0 ? prevPvt + (currentVolume * ((currentValue - prevValue) / prevValue)) : prevPvt;
                    priceVolumeTrendList.Add(pvt);

                    decimal prevPvtEma = pvtEmaList.LastOrDefault();
                    decimal pvtEma = CalculateExponentialMovingAverage(pvt, prevPvtEma, days);
                    pvtEmaList.Add(pvtEma);

                    var signal = GetCompareSignal(pvt - pvtEma, prevPvt - prevPvtEma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (priceVolumeTrendList, pvtEmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateFiniteVolumeElements(StockData stockDataClass, string maType, int days = 22)
        {
            //@version=2
            ////////////////////////////////////////////////////////////
            //  Copyright by HPotter v1.0 22/05/2014
            // The FVE is a pure volume indicator. Unlike most of the other indicators 
            // (except OBV), price change doesn?t come into the equation for the FVE (price 
            // is not multiplied by volume), but is only used to determine whether money is 
            // flowing in or out of the stock. This is contrary to the current trend in the 
            // design of modern money flow indicators. The author decided against a price-volume 
            // indicator for the following reasons:
            // - A pure volume indicator has more power to contradict.
            // - The number of buyers or sellers (which is assessed by volume) will be the same, 
            //     regardless of the price fluctuation.
            // - Price-volume indicators tend to spike excessively at breakouts or breakdowns.
            //
            // WARNING:
            //  - This script to change bars colors.
            ////////////////////////////////////////////////////////////
            //study(title = "Finite Volume Elements (FVE) Strategy", shorttitle = "FVE")
            //Period = input(22, minval = 1)
            //Factor = input(0.3, minval = 1)
            //xhl2 = hl2
            //xhlc3 = hlc3
            //xClose = close
            //xVolume = volume
            //xSMAV = sma(xVolume, Period)
            //nMF = xClose - xhl2 + xhlc3 - xhlc3[1]
            //nVlm = iff(nMF > Factor * xClose / 100, xVolume,
            //       iff(nMF < -Factor * xClose / 100, -xVolume, 0))
            //nRes = nz(nRes[1], 0) + ((nVlm / xSMAV) / Period) * 100
            //pos = iff(nRes > nRes[1] and nRes > nRes[2], 1,
            //      iff(nRes < nRes[1] and nRes < nRes[2], -1, nz(pos[1], 0)))
            //barcolor(pos == -1 ? red : pos == 1 ? green : blue)
            //plot(nRes, color = red, title = "FVE")
            List<decimal> nmfList = new();
            List<decimal> nvlmList = new();
            List<decimal> fveList = new();
            List<decimal> bullList = new();
            List<decimal> bearList = new();
            List<Signal> signalsList = new();

            try
            {
                decimal factor = 0.3m;

                var medianPriceList = CalculateMedianPrice(stockDataClass).Item2;
                var typicalPriceList = CalculateTypicalPrice(stockDataClass).Item1;
                var volumeSmaList = GetMovingAverageList(maType, stockDataClass.Volumes, stockDataClass, days);

                for (int i = 0; i < stockDataClass.HighPrices.Count; i++)
                {
                    decimal medianPrice = medianPriceList.ElementAtOrDefault(i);
                    decimal typicalPrice = typicalPriceList.ElementAtOrDefault(i);
                    decimal prevTypicalPrice = i >= 1 ? typicalPriceList.ElementAtOrDefault(i - 1) : 0;
                    decimal volumeSma = volumeSmaList.ElementAtOrDefault(i);
                    decimal volume = stockDataClass.Volumes.ElementAtOrDefault(i);
                    decimal close = stockDataClass.InputValues.ElementAtOrDefault(i);

                    decimal nmf = close - medianPrice + typicalPrice - prevTypicalPrice;
                    nmfList.Add(nmf);

                    decimal nvlm = nmf > factor * close / 100 ? volume : nmf < -factor * close / 100 ? -volume : 0;
                    nvlmList.Add(nvlm);

                    decimal prevFve = fveList.LastOrDefault();
                    decimal prevFve2 = i >= 2 ? fveList.ElementAtOrDefault(i - 2) : 0;
                    decimal fve = volumeSma != 0 && days != 0 ? prevFve + (nvlm / volumeSma / days * 100) : prevFve;
                    fveList.Add(fve);

                    decimal prevBullSlope = bullList.LastOrDefault();
                    decimal bullSlope = fve - Math.Max(prevFve, prevFve2);
                    bullList.Add(bullSlope);

                    decimal prevBearSlope = bearList.LastOrDefault();
                    decimal bearSlope = fve - Math.Min(prevFve, prevFve2);
                    bearList.Add(bearSlope);

                    var signal = GetBullishBearishSignal(bullSlope, prevBullSlope, bearSlope, prevBearSlope);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (nmfList, nvlmList, fveList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateModifiedPriceVolumeTrend(StockData stockDataClass, int days = 23)
        {
            ////////////////////////////////////////////////////////////
            //  Copyright by HPotter v1.0 17/07/2018
            //  The related article is copyrighted material from
            //  Stocks & Commodities.
            //  Strategy by HPotter.
            //
            // WARNING:
            //  - This script to change bars colors.
            ////////////////////////////////////////////////////////////
            //study(title = "Modified Price-Volume Trend Strategy", shorttitle = "MPVT")
            //Level = input(0)
            //Scale = input(1)
            //Length = input(23)
            //xOHLC4 = ohlc4
            //xV = volume
            //rV = xV / 50000
            //xCumPVT = nz(xCumPVT[1]) + (rV * (xOHLC4 - xOHLC4[1]) / xOHLC4[1])
            //nRes = Level + Scale * xCumPVT
            //xMARes = sma(nRes, Length)
            //pos = iff(nRes > xMARes, 1,
            //      iff(nRes < xMARes, -1, nz(pos[1], 0)))
            //barcolor(pos == -1 ? red : pos == 1 ? green : blue)
            //plot(nRes, color = red, title = "MPVT", linewidth = 2)
            //plot(xMARes, color = blue, title = "MPVT", linewidth = 2)
            List<decimal> mpvtList = new();
            List<decimal> mpvtSignalList = new();
            List<decimal> rvList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal currentVolume = stockDataClass.Volumes.ElementAtOrDefault(i);

                    decimal rv = currentVolume / 50000;
                    rvList.Add(rv);

                    decimal prevMpvt = mpvtList.LastOrDefault();
                    decimal mpvt = prevValue != 0 ? prevMpvt + (rv * (currentValue - prevValue) / prevValue) : 0;
                    mpvtList.Add(mpvt);

                    decimal prevMpvtSignal = mpvtSignalList.LastOrDefault();
                    decimal mpvtSignal = mpvtList.TakeLast(days).Average();
                    mpvtSignalList.Add(mpvtSignal);

                    var signal = GetCompareSignal(mpvt - mpvtSignal, prevMpvt - prevMpvtSignal);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (rvList, mpvtList, mpvtSignalList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateOnBalanceVolume(StockData stockDataClass, int days = 20)
        {
            //
            // @author LazyBear
            // 
            // Appreciate a note if you use this code anywhere. 
            // 
            //study(title = "On Balance Volume Oscillator [LazyBear]", shorttitle = "OBVOSC_LB")
            //src = close
            //length = input(20)
            //obv(src) => cum(change(src) > 0 ? volume : change(src) < 0 ? -volume : 0 * volume)
            //os = obv(src)
            //obv_osc = (os - ema(os, length))
            //obc_color = obv_osc > 0 ? green : red
            //plot(obv_osc, color = obc_color, style = line, title = "OBV-Points", linewidth = 2)
            //plot(obv_osc, color = silver, transp = 70, title = "OBV", style = area)
            //hline(0)
            List<decimal> obvList = new();
            List<decimal> obvOscillatorList = new();
            List<decimal> obvEmaList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal currentVolume = stockDataClass.Volumes.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal prevObv = obvList.LastOrDefault();
                    decimal obv = currentValue > prevValue ? prevObv + currentVolume : currentValue < prevValue ? prevObv - currentVolume : prevObv;
                    obvList.Add(obv);

                    decimal obvEma = CalculateExponentialMovingAverage(obv, obvEmaList.LastOrDefault(), days);
                    obvEmaList.Add(obvEma);

                    decimal prevObvOscillator = obvOscillatorList.LastOrDefault();
                    decimal obvOscillator = obv - obvEma;
                    obvOscillatorList.Add(obvOscillator);

                    var signal = GetCompareSignal(obvOscillator, prevObvOscillator);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (obvList, obvEmaList, obvOscillatorList, signalsList);
        }

        public static (List<decimal>, List<Signal>) CalculateGuppyCountBackLine(StockData stockDataClass, int days = 21)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Guppy Count Back Line script may be freely distributed under the MIT license.
            //study("Guppy Count Back Line", shorttitle = "GCBL", overlay = true)

            //lbLength = input(title = "LookBackLength", type = input.integer, defval = 21, minval = 1)
            //src = input(title = "Source", type = input.source, defval = close)

            //ll = lowest(lbLength)
            //hh = highest(lbLength)

            //hCount = 0, lCount = 0
            //cbl = src
            //for i = 0 to lbLength
            //    if low[i] == ll
            //        for j = i + 1 to i + lbLength
            //            lCount := lCount + (high[j] > high[i] ? 1 : 0)
            //            if lCount == 2
            //                cbl:= high[j]
            //                break
            //    if high[i] == hh
            //        for j = i + 1 to i + lbLength
            //            hCount := hCount + (low[j] < low[i] ? 1 : 0)
            //            if hCount == 2
            //                cbl:= low[j]
            //                break

            //cblColor = src > cbl ? color.green : src < cbl ? color.red : color.black
            //plot(cbl, color = cblColor, linewidth = 2)
            List<decimal> cblList = new();
            List<Signal> signalsList = new();

            try
            {
                var list = VolumeInputCheck(stockDataClass, days, true);
                var hhList = list.Item1;
                var llList = list.Item2;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal hh = hhList.ElementAtOrDefault(i);
                    decimal ll = llList.ElementAtOrDefault(i);

                    decimal prevCbl = cblList.LastOrDefault();
                    int hCount = 0, lCount = 0;
                    decimal cbl = currentValue;
                    for (int j = 0; j <= days; j++)
                    {
                        decimal currentLow = i >= j ? stockDataClass.LowPrices.ElementAtOrDefault(i - j) : 0;
                        decimal currentHigh = i >= j ? stockDataClass.HighPrices.ElementAtOrDefault(i - j) : 0;

                        if (currentLow == ll)
                        {
                            for (int k = j + 1; k <= j + days; k++)
                            {
                                decimal prevHigh = i >= k ? stockDataClass.HighPrices.ElementAtOrDefault(i - k) : 0;
                                lCount += prevHigh > currentHigh ? 1 : 0;
                                if (lCount == 2)
                                {
                                    cbl = prevHigh;
                                    break;
                                }
                            }
                        }

                        if (currentHigh == hh)
                        {
                            for (int k = j + 1; k <= j + days; k++)
                            {
                                decimal prevLow = i >= k ? stockDataClass.LowPrices.ElementAtOrDefault(i - k) : 0;
                                hCount += prevLow > currentLow ? 1 : 0;
                                if (hCount == 2)
                                {
                                    cbl = prevLow;
                                    break;
                                }
                            }
                        }
                    }
                    cblList.Add(cbl);

                    var signal = GetCompareSignal(currentValue - cbl, prevValue - prevCbl);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (cblList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateOnBalanceVolumeDisparityIndicator(
            StockData stockDataClass, string maType, int days = 4)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // On Balance Volume Disparity Indicator script may be freely distributed under the MIT license.
            //study(title = "On Balance Volume Disparity Indicator", shorttitle = "OBVDI", overlay = false)

            //src = input(title = "Source", type = input.source, defval = close)
            //length = input(title = "Length", type = input.integer, defval = 33, minval = 1)
            //sigLength = input(title = "SignalLength", type = input.integer, defval = 4, minval = 1)
            //topGuide = input(title = "TopGuide", type = input.float, defval = 1.1, minval = .01)
            //botGuide = input(title = "BotGuide", type = input.float, defval = 0.9, minval = .01)

            //srcSma = sma(src, length)
            //srcDev = stdev(src, length)
            //obvSma = sma(obv, length)
            //obvDev = stdev(obv, length)

            //aTop = src - (srcSma - (2 * srcDev))
            //aBot = (srcSma + (2 * srcDev)) - (srcSma - (2 * srcDev))
            //a = aBot != 0 ? aTop / aBot : 0

            //bTop = obv - (obvSma - (2 * obvDev))
            //bBot = (obvSma + (2 * obvDev)) - (obvSma - (2 * obvDev))
            //b = bBot != 0 ? bTop / bBot : 0

            //obvdi = 1 + b != 0 ? (1 + a) / (1 + b) : 0
            //sig = sma(obvdi, sigLength)

            //hline(topGuide, color = color.green, linewidth = 1)
            //hline(botGuide, color = color.red, linewidth = 1)
            //bsc = 0.0
            //bsc:= (obvdi[1] < botGuide and obvdi > botGuide) or obvdi > sig ? 1 : (obvdi[1] > topGuide and obvdi<topGuide) or obvdi<botGuide ? -1 : nz(bsc[1], 0)
            //obvdiColor = bsc > 0 ? color.green : bsc < 0 ? color.red : color.black
            //plot(obvdi, color = obvdiColor, linewidth = 2)
            //plot(sig, color = color.black, linewidth = 1)
            List<decimal> obvdiList = new();
            List<decimal> obvdiEmaList = new();
            List<decimal> bTopList = new();
            List<decimal> bBotList = new();
            List<decimal> aList = new();
            List<decimal> bList = new();
            List<decimal> bscList = new();
            List<Signal> signalsList = new();
            decimal topGuide = 1.1m, botGuide = 0.9m;

            try
            {
                int length = (int)Math.Ceiling(days / 0.1213);

                var obvList = CalculateOnBalanceVolume(stockDataClass, length).Item1;
                var obvSmaList = GetMovingAverageList(maType, obvList, stockDataClass, length);
                var obvStdDevList = CalculateStandardDeviationVolatility(obvList, stockDataClass, length).Item4;
                var smaList = GetMovingAverageList(maType, null, stockDataClass, length);
                var stdDevList = CalculateStandardDeviationVolatility(null, stockDataClass, length).Item4;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal sma = smaList.ElementAtOrDefault(i);
                    decimal stdDev = stdDevList.ElementAtOrDefault(i);
                    decimal obvSma = obvSmaList.ElementAtOrDefault(i);
                    decimal obvStdDev = obvStdDevList.ElementAtOrDefault(i);
                    decimal aTop = currentValue - (sma - (2 * stdDev));
                    decimal aBot = currentValue + (2 * stdDev) - (sma - (2 * stdDev));
                    decimal obv = obvList.ElementAtOrDefault(i);

                    decimal a = aBot != 0 ? aTop / aBot : 0;
                    aList.Add(a);

                    decimal bTop = obv - (obvSma - (2 * obvStdDev));
                    bTopList.Add(bTop);

                    decimal bBot = obvSma + (2 * obvStdDev) - (obvSma - (2 * obvStdDev));
                    bBotList.Add(bBot);

                    decimal b = bBot != 0 ? bTop / bBot : 0;
                    bList.Add(b);

                    decimal prevObvdi = obvdiList.LastOrDefault();
                    decimal obvdi = 1 + b != 0 ? (1 + a) / (1 + b) : 0;
                    obvdiList.Add(obvdi);

                    decimal obvdiEma = obvdiList.TakeLast(days).Average();
                    obvdiEmaList.Add(obvdiEma);

                    decimal prevBsc = bscList.LastOrDefault();
                    decimal bsc = (prevObvdi < botGuide && obvdi > botGuide) || obvdi > obvdiEma ? 1 : (prevObvdi > topGuide && obvdi < topGuide) || obvdi < botGuide ? -1 : prevBsc;
                    bscList.Add(bsc);

                    var signal = GetCompareSignal(bsc, prevBsc);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (aList, bTopList, bBotList, bList, obvdiList, obvdiEmaList, bscList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateNegativeVolumeDisparityIndicator(StockData stockDataClass, string maType, int days = 4)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Negative Volume Disparity Indicator script may be freely distributed under the MIT license.
            //study(title = "Negative Volume Disparity Indicator", shorttitle = "NVDI", overlay = false)

            //src = input(title = "Source", type = input.source, defval = close)
            //length = input(title = "Length", type = input.integer, defval = 33, minval = 1)
            //sigLength = input(title = "SignalLength", type = input.integer, defval = 4, minval = 1)
            //topGuide = input(title = "TopGuide", type = input.float, defval = 1.1, minval = .01)
            //botGuide = input(title = "BotGuide", type = input.float, defval = 0.9, minval = .01)

            //srcSma = sma(src, length)
            //srcDev = stdev(src, length)
            //nviSma = sma(nvi, length)
            //nviDev = stdev(nvi, length)

            //aTop = src - (srcSma - (2 * srcDev))
            //aBot = (srcSma + (2 * srcDev)) - (srcSma - (2 * srcDev))
            //a = aBot != 0 ? aTop / aBot : 0

            //bTop = nvi - (nviSma - (2 * nviDev))
            //bBot = (nviSma + (2 * nviDev)) - (nviSma - (2 * nviDev))
            //b = bBot != 0 ? bTop / bBot : 0

            //nvdi = 1 + b != 0 ? (1 + a) / (1 + b) : 0
            //sig = sma(nvdi, sigLength)

            //hline(topGuide, color = color.green, linewidth = 1)
            //hline(botGuide, color = color.red, linewidth = 1)
            //bsc = 0.0
            //bsc:= (nvdi[1] < botGuide and nvdi > botGuide) or nvdi > sig ? 1 : (nvdi[1] > topGuide and nvdi < topGuide) or nvdi < botGuide ? -1 : nz(bsc[1], 0)
            //nvdiColor = bsc > 0 ? color.green : bsc < 0 ? color.red : color.black
            //plot(nvdi, color = nvdiColor, linewidth = 2)
            //plot(sig, color = color.black, linewidth = 1)
            List<decimal> nvdiList = new();
            List<decimal> nvdiEmaList = new();
            List<decimal> bTopList = new();
            List<decimal> bBotList = new();
            List<decimal> bList = new();
            List<decimal> bscList = new();
            List<Signal> signalsList = new();
            decimal botGuide = 0.9m, topGuide = 1.1m;

            try
            {
                int length = (int)Math.Ceiling(days / 0.1213);

                var nviList = CalculateNegativeVolumeIndex(stockDataClass, length).Item2;
                var nviSmaList = GetMovingAverageList(maType, nviList, stockDataClass, length);
                var nviStdDevList = CalculateStandardDeviationVolatility(nviList, stockDataClass, length).Item4;
                var smaList = GetMovingAverageList(maType, null, stockDataClass, length);
                var stdDevList = CalculateStandardDeviationVolatility(null, stockDataClass, length).Item4;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal sma = smaList.ElementAtOrDefault(i);
                    decimal stdDev = stdDevList.ElementAtOrDefault(i);
                    decimal nviSma = nviSmaList.ElementAtOrDefault(i);
                    decimal nviStdDev = nviStdDevList.ElementAtOrDefault(i);
                    decimal aTop = currentValue - (sma - (2 * stdDev));
                    decimal aBot = (currentValue + (2 * stdDev)) - (sma - (2 * stdDev));
                    decimal nvi = nviList.ElementAtOrDefault(i);
                    decimal a = aBot != 0 ? aTop / aBot : 0;

                    decimal bTop = nvi - (nviSma - (2 * nviStdDev));
                    bTopList.Add(bTop);

                    decimal bBot = (nviSma + (2 * nviStdDev)) - (nviSma - (2 * nviStdDev));
                    bBotList.Add(bBot);

                    decimal b = bBot != 0 ? bTop / bBot : 0;
                    bList.Add(b);

                    decimal prevNvdi = nvdiList.LastOrDefault();
                    decimal nvdi = 1 + b != 0 ? (1 + a) / (1 + b) : 0;
                    nvdiList.Add(nvdi);

                    decimal nvdiEma = nvdiList.TakeLast(days).Average();
                    nvdiEmaList.Add(nvdiEma);

                    decimal prevBsc = bscList.LastOrDefault();
                    decimal bsc = (prevNvdi < botGuide && nvdi > botGuide) || nvdi > nvdiEma ? 1 : (prevNvdi > topGuide && nvdi < topGuide) || nvdi < botGuide ? -1 : prevBsc;
                    bscList.Add(bsc);

                    var signal = GetCompareSignal(bsc, prevBsc);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (bTopList, bBotList, bList, nvdiList, nvdiEmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateOnBalanceVolumeReflex(StockData stockDataClass, int days = 4)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // On Balance Volume Reflex script may be freely distributed under the MIT license.
            //study(title = "On Balance Volume Reflex", shorttitle = "OVR", overlay = false, format = format.volume)

            //src = input(title = "Source", type = input.source, defval = close)
            //lbLength = input(title = "LookBackLength", type = input.integer, defval = 4, minval = 1)
            //sigLength = input(title = "SignalLength", type = input.integer, defval = 14, minval = 1)

            //ovr = cum(sign(change(src, lbLength)) * volume)
            //sig = sma(ovr, sigLength)

            //ovrColor = ovr > sig ? color.green : ovr < sig ? color.red : color.black
            //plot(ovr, title = "OVR", linewidth = 2, color = ovrColor, transp = 0)
            //plot(sig, title = "SIG", linewidth = 1, color = color.black, transp = 0)
            List<decimal> ovrList = new();
            List<decimal> ovrEmaList = new();
            List<Signal> signalsList = new();

            try
            {
                int sigLength = (int)Math.Ceiling(days / 0.2857);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal currentVolume = stockDataClass.Volumes.ElementAtOrDefault(i);
                    decimal prevValue = i >= days ? stockDataClass.InputValues.ElementAtOrDefault(i - days) : 0;

                    decimal prevOvr = ovrList.LastOrDefault();
                    decimal ovr = currentValue > prevValue ? prevOvr + currentVolume : currentValue < prevValue ? prevOvr - currentVolume : prevOvr;
                    ovrList.Add(ovr);

                    decimal prevOvrEma = ovrEmaList.LastOrDefault();
                    decimal ovrEma = ovrList.TakeLast(sigLength).Average();
                    ovrEmaList.Add(ovrEma);

                    var signal = GetCompareSignal(ovr - ovrEma, prevOvr - prevOvrEma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (ovrList, ovrEmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateOnBalanceVolumeModified(StockData stockDataClass, string maType, int days = 7)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // On Balance Volume Modified script may be freely distributed under the MIT license.
            //study(title = "On Balance Volume Modified", shorttitle = "OBVM", format = format.volume)

            //src = input(title = "Source", type = input.source, defval = close)
            //length1 = input(title = "Length1", type = input.integer, defval = 7, minval = 1)
            //length2 = input(title = "Length2", type = input.integer, defval = 10, minval = 1)

            // obv = src[0] > src[1] ? obv[1] + volume : src[0] < src[1] ? obv[1] - volume : obv[1]
            //obvm = ema(obv, length1)
            //sig = ema(obvm, length2)

            //obvmColor = obvm > sig ? color.green : obvm < sig ? color.red : color.black
            //plot(obvm, title = "OBVM", linewidth = 2, color = obvmColor, transp = 0)
            //plot(sig, title = "SIG", linewidth = 1, color = color.black, transp = 0)
            List<decimal> obvmList = new();
            List<decimal> sigList = new();
            List<Signal> signalsList = new();

            try
            {
                int length2 = (int)Math.Ceiling(days / 0.7);

                var obvList = CalculateOnBalanceVolume(stockDataClass, days).Item1;
                obvmList = GetMovingAverageList(maType, obvList, stockDataClass, days);
                sigList = GetMovingAverageList(maType, obvmList, stockDataClass, length2);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal obvm = obvmList.ElementAtOrDefault(i);
                    decimal sig = sigList.ElementAtOrDefault(i);
                    decimal prevObvm = i >= 1 ? obvmList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevSig = i >= 1 ? sigList.ElementAtOrDefault(i - 1) : 0;

                    var signal = GetCompareSignal(obvm - sig, prevObvm - prevSig);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (obvmList, sigList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateStationaryExtrapolatedLevelsOscillator(StockData stockDataClass, string maType, int days = 200)
        {
            //@version=4
            //study("Stationary Extrapolated Levels Oscillator", shorttitle = "SELO", overlay = false)
            //length = input(200),src = input(close)
            //----
            //y = src - sma(src, length)
            //ext = (2 * y[length] - y[length * 2]) / 2
            //osc = min(max(stoch(y, ext, ext, length * 2) / 100, 0), 1)
            //----
            //plot(osc, color = osc == 1 ? color.red : osc == 0 ? color.lime :#2196f3,linewidth=2,transp=0)
            //hline(0.8, color =#e65100,linewidth=2),hline(0.2,color=#e65100,linewidth=2)
            List<decimal> extList = new();
            List<decimal> oscList = new();
            List<decimal> yList = new();
            List<decimal> highestList = new();
            List<decimal> lowestList = new();
            List<decimal> stochList = new();
            List<Signal> signalsList = new();

            try
            {
                var smaList = GetMovingAverageList(maType, null, stockDataClass, days);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal sma = smaList.ElementAtOrDefault(i);
                    decimal prevY = i >= days ? yList.ElementAtOrDefault(i - days) : 0;
                    decimal prevY2 = i >= days * 2 ? yList.ElementAtOrDefault(i - (days * 2)) : 0;
                    decimal prevOsc1 = i >= 1 ? oscList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevOsc2 = i >= 2 ? oscList.ElementAtOrDefault(i - 2) : 0;

                    decimal y = currentValue - sma;
                    yList.Add(y);

                    decimal ext = ((2 * prevY) - prevY2) / 2;
                    extList.Add(ext);

                    var lbList = extList.TakeLast(days * 2).ToList();
                    decimal highest = lbList.Max();
                    highestList.Add(highest);

                    decimal lowest = lbList.Min();
                    lowestList.Add(lowest);

                    decimal stoch = highest - lowest != 0 ? MinOrMax((y - lowest) / (highest - lowest) * 100, 100, 0) : 0;
                    stochList.Add(stoch);

                    decimal osc = stoch / 100;
                    oscList.Add(osc);

                    var signal = GetRsiSignal(osc - prevOsc1, prevOsc1 - prevOsc2, osc, prevOsc1, 0.8m, 0.2m);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (extList, highestList, lowestList, stochList, oscList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateStationaryExtrapolatedLevels(StockData stockDataClass, string maType, int days = 200)
        {
            //@version=3
            //study("Stationary Extrapolated Levels", overlay = false)
            //length = input(200),show = input(false, title = "Show Extrapolated Values")
            //
            //
            //x = n
            //y = close - sma(close, length)
            //ext = (y[length] + ((x - x[length]) / (x[length * 2] - x[length])) * (y[length * 2] - y[length])) / 2
            //
            //upper = highest(highest(ext, length), length)
            //lower = lowest(lowest(ext, length), length)
            //e = show ? ext : na
            //
            //a = plot(upper, color = green, transp = 0)
            //plot(y, color = aqua, transp = 0)
            //plot(e, color = white, transp = 0, offset = length)
            //b = plot(lower, color = red, transp = 0)
            //fill(a, b, color = blue, transp = 95)
            List<decimal> extList = new();
            List<decimal> upperList = new();
            List<decimal> yList = new();
            List<decimal> highestList = new();
            List<decimal> lowestList = new();
            List<decimal> lowerList = new();
            List<decimal> xList = new();
            List<Signal> signalsList = new();

            try
            {
                var smaList = GetMovingAverageList(maType, null, stockDataClass, days);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal sma = smaList.ElementAtOrDefault(i);
                    decimal priorY = i >= days ? yList.ElementAtOrDefault(i - days) : 0;
                    decimal priorY2 = i >= days * 2 ? yList.ElementAtOrDefault(i - (days * 2)) : 0;
                    decimal priorX = i >= days ? xList.ElementAtOrDefault(i - days) : 0;
                    decimal priorX2 = i >= days * 2 ? xList.ElementAtOrDefault(i - (days * 2)) : 0;

                    decimal x = i;
                    xList.Add(i);

                    decimal prevY = yList.LastOrDefault();
                    decimal y = currentValue - sma;
                    yList.Add(y);

                    decimal prevExt = extList.LastOrDefault();
                    decimal ext = priorX2 - priorX != 0 && priorY2 - priorY != 0 ? (priorY + ((x - priorX) / (priorX2 - priorX) * (priorY2 - priorY))) / 2 : 0;
                    extList.Add(ext);

                    var lbList = extList.TakeLast(days).ToList();
                    decimal highest = lbList.Max();
                    highestList.Add(highest);

                    decimal lowest = lbList.Min();
                    lowestList.Add(lowest);

                    decimal upper = highestList.TakeLast(days).Max();
                    upperList.Add(upper);

                    decimal lower = lowestList.TakeLast(days).Min();
                    lowerList.Add(lower);

                    var signal = GetCompareSignal(y - ext, prevY - prevExt);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (extList, highestList, lowestList, upperList, lowerList, yList, signalsList);
        }

        public static (List<decimal>, List<Signal>) CalculateLinearExtrapolation(StockData stockDataClass, int days = 500)
        {
            //@version=3
            //study("Linear Extrapolation", overlay = true)
            //forecast = input(500)
            //
            //x = n
            //y = close
            //ext = y[forecast] + ((x - x[forecast]) / (x[forecast * 2] - x[forecast])) * (y[forecast * 2] - y[forecast])
            //
            //plot(ext, offset = forecast)
            List<decimal> extList = new();
            List<decimal> yList = new();
            List<decimal> xList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal priorY = i >= days ? yList.ElementAtOrDefault(i - days) : 0;
                    decimal priorY2 = i >= days * 2 ? yList.ElementAtOrDefault(i - (days * 2)) : 0;
                    decimal priorX = i >= days ? xList.ElementAtOrDefault(i - days) : 0;
                    decimal priorX2 = i >= days * 2 ? xList.ElementAtOrDefault(i - (days * 2)) : 0;

                    decimal x = i;
                    xList.Add(i);

                    decimal prevY = yList.LastOrDefault();
                    decimal y = currentValue;
                    yList.Add(y);

                    decimal prevExt = extList.LastOrDefault();
                    decimal ext = priorX2 - priorX != 0 && priorY2 - priorY != 0 ? priorY + ((x - priorX) / (priorX2 - priorX) * (priorY2 - priorY)) : priorY;
                    extList.Add(ext);

                    var signal = GetCompareSignal(y - ext, prevY - prevExt);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (extList, signalsList);
        }

        public static (List<decimal>, List<Signal>) CalculateInverseFisherFastZScore(StockData stockDataClass, string maType, int days = 50)
        {
            //@version=2
            //study("Inverse Fisher Fast Z-score")
            //length = input(50)
            //----
            //src = sma(close, length)
            //fz = (linreg(src, length / 2, 0) - linreg(src, length, 0)) / stdev(src, length) / 2
            //ifz = (exp(10 * fz) - 1) / (exp(10 * fz) + 1)
            //----
            //plot(ifz, color =#e65100,transp=0)
            List<decimal> ifzList = new();
            List<Signal> signalsList = new();

            try
            {
                int length1 = days;
                int length2 = MinOrMax((int)Math.Ceiling((decimal)days / 2));

                var smaList = GetMovingAverageList(maType, null, stockDataClass, length1);
                var stdDevList = CalculateStandardDeviationVolatility(smaList, stockDataClass, length1).Item4;
                var linregList = CalculateLinearRegression(smaList, stockDataClass, length1).Item15;
                var linreg2List = CalculateLinearRegression(smaList, stockDataClass, length2).Item15;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal sma = smaList.ElementAtOrDefault(i);
                    decimal linreg = linregList.ElementAtOrDefault(i);
                    decimal linreg2 = linreg2List.ElementAtOrDefault(i);
                    decimal stdDev = stdDevList.ElementAtOrDefault(i);
                    decimal fz = stdDev != 0 ? (linreg2 - linreg) / stdDev / 2 : 0;
                    decimal prevIfz1 = i >= 1 ? ifzList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevIfz2 = i >= 2 ? ifzList.ElementAtOrDefault(i - 2) : 0;

                    decimal ifz = Exp(10 * fz) + 1 != 0 ? (Exp(10 * fz) - 1) / (Exp(10 * fz) + 1) : 0;
                    ifzList.Add(ifz);

                    var signal = GetCompareSignal(ifz - prevIfz1, prevIfz1 - prevIfz2);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (ifzList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateInverseFisherZScore(StockData stockDataClass, string maType, int days = 100)
        {
            //@version=2
            //study("Inverse Fisher Z-Score")
            //length = input(100),smooth = input(false)
            //----
            //src = smooth ? wma(ohlc4, length) : ohlc4
            //z = (src - sma(src, length)) / stdev(src, length)
            //f = ((exp(2 * z) - 1) / (exp(2 * z) + 1) + 1) * 50
            //----
            //plot(f, color =#2196f3,transp=0)
            //hline(80)
            //hline(20)
            List<decimal> fList = new();
            List<decimal> zList = new();
            List<Signal> signalsList = new();

            try
            {
                var smaList = GetMovingAverageList(maType, null, stockDataClass, days);
                var stdDevList = CalculateStandardDeviationVolatility(null, stockDataClass, days).Item4;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal sma = smaList.ElementAtOrDefault(i);
                    decimal stdDev = stdDevList.ElementAtOrDefault(i);
                    decimal prevF1 = i >= 1 ? fList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevF2 = i >= 2 ? fList.ElementAtOrDefault(i - 2) : 0;

                    decimal z = stdDev != 0 ? (currentValue - sma) / stdDev : 0;
                    zList.Add(z);

                    decimal expZ = expZ = Exp(2 * z);
                    decimal f = expZ + 1 != 0 ? MinOrMax((((expZ - 1) / (expZ + 1)) + 1) * 50, 100, 0) : 0;
                    fList.Add(f);

                    var signal = GetRsiSignal(f - prevF1, prevF1 - prevF2, f, prevF1, 80, 20);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (zList, fList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<decimal>, List<Signal>) CalculateRecursiveRelativeStrengthIndex(StockData stockDataClass, string maType, int days = 14)
        {
            //@version=3
            //study("Recursive Rsi", shorttitle = "R-Rsi")
            //length = input(14)
            //----
            //source = input(close)
            //src = sma(change(source, length), length)
            //b = 0.
            //----
            //for i = 1 to length
            //    a = rsi(src, length) * length / i
            //    b := sma(rsi(avg(a, nz(b[i], src)), i), length)
            //----
            //plot(b, title = "R-Rsi", color =#e65100,linewidth=2,transp=0)
            List<decimal> chgList = new();
            List<decimal> srcList = new();
            List<decimal> aList = new();
            List<decimal> bList = new();
            List<decimal> rsiList = new();
            List<decimal> rsList = new();
            List<decimal> avgRsiList = new();
            List<decimal> avgList = new();
            List<decimal> gainList = new();
            List<decimal> lossList = new();
            List<decimal> avgGainList = new();
            List<decimal> avgLossList = new();
            List<decimal> avgChgList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int h = 0; h < stockDataClass.InputValues.Count; h++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(h);
                    decimal prevValue = h >= days ? stockDataClass.InputValues.ElementAtOrDefault(h - days) : 0;

                    decimal chg = currentValue - prevValue;
                    chgList.Add(chg);
                }

                srcList = GetMovingAverageList(maType, chgList, stockDataClass, days);
                rsiList = CalculateRelativeStrengthIndex(srcList, stockDataClass, maType, days).Item4;
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal rsi = rsiList.ElementAtOrDefault(i);
                    decimal src = srcList.ElementAtOrDefault(i);
                    decimal prevB1 = i >= 1 ? bList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevB2 = i >= 2 ? bList.ElementAtOrDefault(i - 2) : 0;

                    decimal a = 0, b = 0, avg = 0, gain = 0, loss = 0, avgGain = 0, avgLoss = 0, rs = 0, avgRsi = 0, avgChg = 0;
                    for (int j = 1; j <= days; j++)
                    {
                        decimal prevB = i >= j ? bList.ElementAtOrDefault(i - j) : src;
                        decimal prevAvg = i >= j ? avgList.ElementAtOrDefault(i - j) : 0;
                        decimal prevGain = i >= j ? gainList.ElementAtOrDefault(i - j) : 0;
                        decimal prevLoss = i >= j ? lossList.ElementAtOrDefault(i - j) : 0;
                        decimal k = (decimal)j / days;

                        a = rsi * days / j;
                        avg = (a + prevB) / 2;
                        avgChg = avg - prevAvg;
                        gain = avgChg > 0 ? avgChg : 0;
                        loss = avgChg < 0 ? Math.Abs(avgChg) : 0;
                        avgGain = (gain * k) + (prevGain * (1 - k));
                        avgLoss = (loss * k) + (prevLoss * (1 - k));
                        rs = avgLoss != 0 ? avgGain / avgLoss : 0;
                        avgRsi = avgLoss == 0 ? 100 : avgGain == 0 ? 0 : MinOrMax(100 - (100 / (1 + rs)), 1, 0);
                        b = avgRsiList.Count >= days ? avgRsiList.TakeLast(days).Average() : avgRsi;
                    }
                    aList.Add(a);
                    avgList.Add(avg);
                    avgChgList.Add(avgChg);
                    gainList.Add(gain);
                    lossList.Add(loss);
                    avgGainList.Add(avgGain);
                    avgLossList.Add(avgLoss);
                    rsList.Add(rs);
                    avgRsiList.Add(avgRsi);
                    bList.Add(b);

                    var signal = GetRsiSignal(b - prevB1, prevB1 - prevB2, b, prevB1, 0.8m, 0.2m);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (srcList, rsiList, aList, avgList, avgChgList, gainList, lossList, avgGainList, avgLossList, rsList, avgRsiList, bList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculatePositiveVolumeIndex(StockData stockDataClass, int days = 255)
        {
            ////////////////////////////////////////////////////////////
            //  Copyright by HPotter v1.0 11/06/2014
            // The theory behind the indexes is as follows: On days of increasing volume, 
            // you can expect prices to increase, and on days of decreasing volume, you can 
            // expect prices to decrease. This goes with the idea of the market being in-gear 
            // and out-of-gear. Both PVI and NVI work in similar fashions: Both are a running 
            // cumulative of values, which means you either keep adding or subtracting price 
            // rate of change each day to the previous day`s sum. In the case of PVI, if today`s 
            // volume is less than yesterday`s, don`t add anything; if today`s volume is greater, 
            // then add today`s price rate of change. For NVI, add today`s price rate of change 
            // only if today`s volume is less than yesterday`s.
            ////////////////////////////////////////////////////////////
            //study(title = "Positive Volume Index", shorttitle = "Positive Volume Index")
            //EMA_Len = input(255, minval = 1)
            //xROC = roc(close, 1)
            //nRes = iff(volume > volume[1], nz(nRes[1], 0) + xROC, nz(nRes[1], 0))
            //nResEMA = ema(nRes, EMA_Len)
            //plot(nRes, color = red, title = "PVI")
            //plot(nResEMA, color = blue, title = "EMA")
            List<decimal> pviList = new();
            List<decimal> pviEmaList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentClose = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal currentVolume = stockDataClass.Volumes.ElementAtOrDefault(i);
                    decimal prevClose = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevVolume = i >= 1 ? stockDataClass.Volumes.ElementAtOrDefault(i - 1) : 0;
                    decimal ratio = prevClose != 0 ? (currentClose - prevClose) / prevClose : 0;

                    decimal prevPvi = pviList.LastOrDefault();
                    decimal pvi = currentVolume <= prevVolume ? prevPvi : prevPvi + (prevPvi * ratio);
                    pviList.Add(pvi);

                    decimal prevPviEma = pviEmaList.LastOrDefault();
                    decimal pviEma = CalculateExponentialMovingAverage(pvi, prevPviEma, days);
                    pviEmaList.Add(pviEma);

                    var signal = GetCompareSignal(pvi - pviEma, prevPvi - prevPviEma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (pviList, pviEmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateNegativeVolumeIndex(StockData stockDataClass, int days = 255)
        {
            //Calculate NVI:

            //IF volume >= Previous Volume then
            //NVI = NVI Previous
            //ELSE
            //NVI = [NVI Previous] * (1 + (Close - Previous Close) / Previous Close)
            //Apply Simple Moving Average(SMA) to NVI.
            //Add second line(signal line) which is EMA applied to NVI.
            List<decimal> nviList = new();
            List<decimal> nviEmaList = new();
            List<decimal> closePctChgList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentClose = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal currentVolume = stockDataClass.Volumes.ElementAtOrDefault(i);
                    decimal prevClose = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevVolume = i >= 1 ? stockDataClass.Volumes.ElementAtOrDefault(i - 1) : 0;
                    decimal ratio = prevClose != 0 ? (currentClose - prevClose) / prevClose : 0;

                    decimal closePctChg = CalculatePercentChange(currentClose, prevClose);
                    closePctChgList.Add(closePctChg);

                    decimal prevNvi = nviList.LastOrDefault();
                    decimal nvi = currentVolume >= prevVolume ? prevNvi : prevNvi + (prevNvi * ratio);
                    nviList.Add(nvi);

                    decimal prevNviEma = nviEmaList.LastOrDefault();
                    decimal nviEma = CalculateExponentialMovingAverage(nvi, prevNviEma, days);
                    nviEmaList.Add(nviEma);

                    var signal = GetCompareSignal(nvi - nviEma, prevNvi - prevNviEma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (closePctChgList, nviList, nviEmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateTFSVolumeOscillator(StockData stockDataClass, int days = 7)
        {
            ////////////////////////////////////////////////////////////
            //  Copyright by HPotter v1.0 16/06/2014
            // This is the second part of TFS trading strategy. The concept of this 
            // indicator is similar to that of On-Balance Volume indicator (OBV). It 
            // is calculated according to these rules:
            // If Close > Open, Volume is positive
            // If Close < Open, Volume is negative
            // If Close = Open, Volume is neutral
            // Then you take the 7-day MA of the results. 
            ////////////////////////////////////////////////////////////
            //study(title = "TFS: Volume Oscillator", shorttitle = "TFS: Volume Oscillator")
            //AvgLen = input(7, minval = 1)
            //hline(0, color = red, linestyle = line)
            //xClose = close
            //xOpen = open
            //xVolume = volume
            //nVolAccum = sum(iff(xClose > xOpen, xVolume, iff(xClose < xOpen, -xVolume, 0)), AvgLen)
            //nRes = nVolAccum / AvgLen
            //plot(nRes, color = blue, title = "TFS", style = histogram)
            List<decimal> totvList = new();
            List<decimal> totvSumList = new();
            List<decimal> tfsvoList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.OpenPrices.Count; i++)
                {
                    decimal open = stockDataClass.OpenPrices.ElementAtOrDefault(i);
                    decimal close = stockDataClass.ClosePrices.ElementAtOrDefault(i);
                    decimal volume = stockDataClass.Volumes.ElementAtOrDefault(i);

                    decimal totv = close > open ? volume : close < open ? -volume : 0;
                    totvList.Add(totv);

                    decimal totvSum = totvList.TakeLast(days).Sum();
                    totvSumList.Add(totvSum);

                    decimal prevTfsvo = tfsvoList.LastOrDefault();
                    decimal tfsvo = totvSum / days;
                    tfsvoList.Add(tfsvo);

                    var signal = GetCompareSignal(tfsvo, prevTfsvo);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (totvList, totvSumList, tfsvoList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateUpsideDownsideVolume(StockData stockDataClass, int days = 50)
        {
            //input = price, user defined, default is closing price
            //period = user defined, default is 50
            //index = current bar number
            //prev = previous

            //lastU = udVol[index - 1];
            //udVol = upDnVol(index, period, input);
            //Plot: udVol = upDnVol(index, period, key);
            //Signals
            //sell = (udVol moreThan midGuide) AND(lastU lessThan midGuide);
            //buy = (udVol lessThan midGuide) AND(lastU moreThan midGuide);
            //Method upDnVol(int index, int period, Object input){
            //ivolume = 0, iprice = 0, prevP = 0;
            //upVol = 0, dnVol = 0, upDnVol = 0;
            //for (i = index - period + 1; i LOE index; i++) {
            //ivolume = volume[i];
            //iprice = price[i];
            //prevP = price[i - 1];
            //if (iprice MOE prevP) upVol = upVol + ivolume;
            //if (iprice lessThan prevP) dnVol = dnVol + ivolume;
            //endFor
            //if (dnVol != 0) upDnVol = upVol / dnVol;
            //return upDnVol;
            //endMethod
            List<decimal> upVolList = new();
            List<decimal> downVolList = new();
            List<decimal> upVolSumList = new();
            List<decimal> downVolSumList = new();
            List<decimal> upDownVolumeList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal currentVolume = stockDataClass.Volumes.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal upVol = currentValue > prevValue ? currentVolume : 0;
                    upVolList.Add(upVol);

                    decimal downVol = currentValue < prevValue ? currentVolume * -1 : 0;
                    downVolList.Add(downVol);

                    decimal upVolSum = upVolList.TakeLast(days).Sum();
                    upVolSumList.Add(upVolSum);

                    decimal downVolSum = downVolList.TakeLast(days).Sum();
                    downVolSumList.Add(downVolSum);

                    decimal prevUpDownVol = upDownVolumeList.LastOrDefault();
                    decimal upDownVol = downVolSum != 0 ? upVolSum / downVolSum : 0;
                    upDownVolumeList.Add(upDownVol);

                    var signal = GetCompareSignal(upDownVol, prevUpDownVol);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (upVolList, upVolSumList, downVolList, downVolSumList, upDownVolumeList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateMoneyFlowIndex(StockData stockDataClass, int days = 20)
        {
            //period = user defined, default is 20
            //LT = less than, LOR= = less or equal
            //index = current bar number

            //PMF = 0; // positive money flow
            //NMF = 0; // negative money flow
            //pTP = getTypicalPrice(index - period);
            //for (i = index - period + 1; i LOR = index; i++)
            //decimal TP = getTypicalPrice(i);
            //decimal MF = TP * getVolume(i); // money flow
            //if (TP MT pTP) PMF += MF;
            //else NMF += MF;
            //pTP = TP;
            //endFor
            //Plot: MFI = 100 * (PMF / (PMF + NMF));
            // Signals
            //buy = crossedAbove(MFI, topGuide);
            //sell = crossedBelow(MFI, bottGuide);
            List<decimal> mfiList = new();
            List<decimal> mfiRatioList = new();
            List<decimal> rawMoneyFlowList = new();
            List<decimal> posMoneyFlowList = new();
            List<decimal> posMoneyFlowTotalList = new();
            List<decimal> negMoneyFlowList = new();
            List<decimal> negMoneyFlowTotalList = new();
            List<Signal> signalsList = new();

            try
            {
                var tpList = CalculateTypicalPrice(stockDataClass);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentVolume = stockDataClass.Volumes.ElementAtOrDefault(i);
                    decimal typicalPrice = tpList.Item1.ElementAtOrDefault(i);
                    decimal prevTypicalPrice = i >= 1 ? tpList.Item1.ElementAtOrDefault(i - 1) : 0;
                    decimal prevMfi1 = i >= 1 ? mfiList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevMfi2 = i >= 2 ? mfiList.ElementAtOrDefault(i - 2) : 0;

                    decimal rawMoneyFlow = typicalPrice * currentVolume;
                    rawMoneyFlowList.Add(rawMoneyFlow);

                    decimal posMoneyFlow = typicalPrice > prevTypicalPrice ? rawMoneyFlow : 0;
                    posMoneyFlowList.Add(posMoneyFlow);

                    decimal negMoneyFlow = typicalPrice < prevTypicalPrice ? rawMoneyFlow : 0;
                    negMoneyFlowList.Add(negMoneyFlow);

                    decimal posMoneyFlowTotal = posMoneyFlowList.TakeLast(days).Sum();
                    posMoneyFlowTotalList.Add(posMoneyFlowTotal);

                    decimal negMoneyFlowTotal = negMoneyFlowList.TakeLast(days).Sum();
                    negMoneyFlowTotalList.Add(negMoneyFlowTotal);

                    decimal mfiRatio = negMoneyFlowTotal != 0 ? MinOrMax(posMoneyFlowTotal / negMoneyFlowTotal, 1, 0) : 0;
                    mfiRatioList.Add(mfiRatio);

                    decimal mfi = negMoneyFlowTotal == 0 ? 100 : posMoneyFlowTotal == 0 ? 0 : MinOrMax(100 - (100 / (1 + mfiRatio)), 100, 0);
                    mfiList.Add(mfi);

                    var signal = GetRsiSignal(mfi - prevMfi1, prevMfi1 - prevMfi2, mfi, prevMfi1, 80, 20);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (rawMoneyFlowList, posMoneyFlowList, negMoneyFlowList, posMoneyFlowTotalList, negMoneyFlowTotalList, mfiRatioList, mfiList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>)
            CalculateStandardDeviationVolatility(List<decimal>? customValuesList, StockData stockDataClass, int days = 10)
        {
            // Calculate the average(mean) price for the number of periods or observations.
            // Determine each period's deviation (close less average price).
            // Square each period's deviation.
            // Sum the squared deviations.
            // Divide this sum by the number of observations.
            // The standard deviation is then equal to the square root of that number.
            List<decimal> stdDevVolatilityList = new();
            List<decimal> deviationSquaredList = new();
            List<decimal> divisionOfSumList = new();
            List<decimal> deviationList = new();
            List<decimal> stdDevEmaList = new();
            List<decimal> absDevList = new();
            List<decimal> meanAbsDevList = new();
            List<decimal> hvList = new();
            List<Signal> signalsList = new();

            try
            {
                if (customValuesList != null)
                {
                    stockDataClass.InputValues = customValuesList;
                }

                decimal annualSqrt = Sqrt((double)365);
                int signalPeriod = days;
                int length = days * 2;

                var smaList = CalculateSimpleMovingAverage(stockDataClass, length).Item1;
                var emaList = CalculateExponentialMovingAverage(stockDataClass, length).Item1;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentEma = emaList.ElementAtOrDefault(i);
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal avgPrice = smaList.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevEma = i >= 1 ? emaList.ElementAtOrDefault(i - 1) : 0;

                    decimal currentDeviation = currentValue - avgPrice;
                    deviationList.Add(currentDeviation);

                    decimal absDev = Math.Abs(currentValue - avgPrice);
                    absDevList.Add(absDev);

                    decimal meanAbsDev = absDevList.TakeLast(length).Average();
                    meanAbsDevList.Add(meanAbsDev);

                    decimal deviationSquared = Pow(currentDeviation, 2);
                    deviationSquaredList.Add(deviationSquared);

                    decimal divisionOfSum = deviationSquaredList.TakeLast(length).Average();
                    divisionOfSumList.Add(divisionOfSum);

                    decimal stdDevVolatility = divisionOfSum >= 0 ? Sqrt(divisionOfSum) : 0;
                    stdDevVolatilityList.Add(stdDevVolatility);

                    decimal hv = 100 * stdDevVolatility * annualSqrt;
                    hvList.Add(hv);

                    decimal stdDevEma = CalculateExponentialMovingAverage(stdDevVolatility, stdDevEmaList.LastOrDefault(), signalPeriod);
                    stdDevEmaList.Add(stdDevEma);

                    var signal = GetVolatilitySignal(currentValue - currentEma, prevValue - prevEma, stdDevVolatility, stdDevEma);
                    signalsList.Add(signal);
                }

                // reset the input values list
                stockDataClass = LoadCalculations.GetInputValuesList(stockDataClass.InputName, stockDataClass);
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (deviationList, deviationSquaredList, divisionOfSumList, stdDevVolatilityList, hvList, stdDevEmaList, absDevList, meanAbsDevList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateHistoricalVolatility(StockData stockDataClass, int days = 10)
        {
            //input = price, user defined, default is close
            //period = user defined, default is 20
            // annual = user defined, default is 365
            //prev = previous
            //log = natural logarithm
            //std = standard deviation
            //sqrt = square root
            //index = current bar number

            //value = price[index];
            //prevValue = price[index - 1];
            //temp = log(value / prevValue);
            //Plot: hv = 100 * std(period, temp) * sqrt(annual);
            List<decimal> devLogSqList = new();
            List<decimal> devLogSqAvgList = new();
            List<decimal> devLogList = new();
            List<decimal> hvList = new();
            List<decimal> hvEmaList = new();
            List<decimal> tempLogList = new();
            List<decimal> stdDevLogList = new();
            List<decimal> avgLogList = new();
            List<Signal> signalsList = new();

            try
            {
                decimal annualSqrt = Sqrt((double)365);
                int signalPeriod = days;
                int length = days * 2;

                var emaList = CalculateExponentialMovingAverage(stockDataClass, length).Item1;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentEma = emaList.ElementAtOrDefault(i);
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal temp = prevValue != 0 ? currentValue / prevValue : 0;
                    decimal prevEma = i >= 1 ? emaList.ElementAtOrDefault(i - 1) : 0;

                    decimal tempLog = temp > 0 ? Log(temp) : 0;
                    tempLogList.Add(tempLog);

                    decimal avgLog = tempLogList.TakeLast(length).Average();
                    avgLogList.Add(avgLog);

                    decimal devLog = tempLog - avgLog;
                    devLogList.Add(devLog);

                    decimal devLogSq = Pow(devLog, 2);
                    devLogSqList.Add(devLogSq);

                    decimal devLogSqAvg = devLogSqList.TakeLast(length).Average();
                    devLogSqAvgList.Add(devLogSqAvg);

                    decimal stdDevLog = devLogSqAvg >= 0 ? Sqrt(devLogSqAvg) : 0;
                    stdDevLogList.Add(stdDevLog);

                    decimal hv = 100 * stdDevLog * annualSqrt;
                    hvList.Add(hv);

                    decimal hvEma = CalculateExponentialMovingAverage(hv, hvEmaList.LastOrDefault(), signalPeriod);
                    hvEmaList.Add(hvEma);

                    var signal = GetVolatilitySignal(currentValue - currentEma, prevValue - prevEma, hv, hvEma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (tempLogList, avgLogList, devLogList, devLogSqList, devLogSqAvgList, stdDevLogList, hvList, hvEmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateHistoricalVolatilityPercentile(StockData stockDataClass, int days = 10)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Historical Volatility Percentile + SMA script may be freely distributed under the MIT license.
            //study(title = "Historical Volatility Percentile + SMA", shorttitle = "HVP", overlay = false)

            //src = input(title = "Source", type = input.source, defval = close)
            //length = input(title = "Length", type = input.integer, defval = 21, minval = 1)
            //annualLength = input(title = "AnnualLength", type = input.integer, defval = 252, minval = 1)

            //r = log(src / nz(src[1], src))
            //rAvg = sma(r, length)
            //hv = sqrt(sum(pow(r - rAvg, 2), length) / (length - 1)) * sqrt(annualLength)

            //count = 0.
            //for i = 0 to annualLength - 1
            //    count := count + (hv[i] < hv ? 1 : 0)
            //hvp = count / annualLength * 100
            //hvpSma = sma(hvp, length)
            //sig = ema(src, length)

            //hvpColor = hvp >= hvpSma and src > sig ? color.green : hvp >= hvpSma and src < sig ? color.red : color.black
            //plot(0, color = color.black, linewidth = 1)
            //plot(hvp, title = "HVP", linewidth = 2, color = hvpColor, transp = 0)
            //plot(hvpSma, title = "HVPSMA", linewidth = 2, color = color.blue, transp = 0)
            List<decimal> devLogSqList = new();
            List<decimal> devLogSqAvgList = new();
            List<decimal> hvList = new();
            List<decimal> hvpList = new();
            List<decimal> hvpEmaList = new();
            List<decimal> tempLogList = new();
            List<decimal> stdDevLogList = new();
            List<Signal> signalsList = new();

            try
            {
                int annualLength = (int)Math.Ceiling(days / 0.0397);
                int signalPeriod = days;
                int length = (int)Math.Ceiling(days / 0.4762);

                List<decimal> emaList = CalculateExponentialMovingAverage(stockDataClass, length).Item1;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentEma = emaList.ElementAtOrDefault(i);
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal temp = prevValue != 0 ? currentValue / prevValue : 0;
                    decimal prevEma = i >= 1 ? emaList.ElementAtOrDefault(i - 1) : 0;

                    decimal tempLog = temp > 0 ? Log(temp) : 0;
                    tempLogList.Add(tempLog);

                    decimal avgLog = tempLogList.TakeLast(length).Average();
                    decimal devLog = tempLog - avgLog;

                    decimal devLogSq = Pow(devLog, 2);
                    devLogSqList.Add(devLogSq);

                    decimal devLogSqAvg = devLogSqList.TakeLast(length).Sum() / (length - 1);
                    devLogSqAvgList.Add(devLogSqAvg);

                    decimal stdDevLog = devLogSqAvg >= 0 ? Sqrt(devLogSqAvg) : 0;
                    stdDevLogList.Add(stdDevLog);

                    decimal hv = stdDevLog * Sqrt((double)annualLength);
                    decimal count = hvList.TakeLast(annualLength).Where(i => i < hv).Count();
                    hvList.Add(hv);

                    decimal hvp = count / annualLength * 100;
                    hvpList.Add(hvp);

                    decimal hvpEma = CalculateExponentialMovingAverage(hvp, hvpEmaList.LastOrDefault(), signalPeriod);
                    hvpEmaList.Add(hvpEma);

                    var signal = GetVolatilitySignal(currentValue - currentEma, prevValue - prevEma, hvp, hvpEma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (devLogSqAvgList, stdDevLogList, hvList, hvpList, hvpEmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateStatisticalVolatility(StockData stockDataClass, int days = 15)
        {
            ////////////////////////////////////////////////////////////
            //  Copyright by HPotter v1.0 29/05/2014
            // This indicator used to calculate the statistical volatility, sometime 
            // called historical volatility, based on the Extreme Value Method.
            // Please use this link to get more information about Volatility. 
            ////////////////////////////////////////////////////////////
            //study(title = "Statistical Volatility - Extreme Value Method ", shorttitle = "Statistical Volatility")
            //Length = input(30, minval = 1)
            //xMaxC = highest(close, Length)
            //xMaxH = highest(high, Length)
            //xMinC = lowest(close, Length)
            //xMinL = lowest(low, Length)
            //SqrTime = sqrt(253 / Length)
            //Vol = ((0.6 * log(xMaxC / xMinC) * SqrTime) + (0.6 * log(xMaxH / xMinL) * SqrTime)) * 0.5
            //nRes = iff(Vol < 0, 0, iff(Vol > 2.99, 2.99, Vol))
            //plot(nRes, color = blue, title = "Statistical Volatility")
            List<decimal> volList = new();
            List<decimal> volEmaList = new();
            List<decimal> cLogList = new();
            List<decimal> hlLogList = new();
            List<Signal> signalsList = new();

            try
            {
                int annualLength = (int)Math.Ceiling(days / 0.0593);
                int length = days * 2;
                decimal annualSqrt = Sqrt((decimal)annualLength / length);
                int signalPeriod = days;

                var minMax1List = GetMaxAndMinValuesList(stockDataClass.InputValues, length);
                var highestValueList = minMax1List.Item1;
                var lowestValueList = minMax1List.Item2;
                var list = VolumeInputCheck(stockDataClass, length, true);
                var highestHighList = list.Item1;
                var lowestLowList = list.Item2;
                List<decimal> emaList = CalculateExponentialMovingAverage(stockDataClass, length).Item1;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentEma = emaList.ElementAtOrDefault(i);
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal maxC = highestValueList.ElementAtOrDefault(i);
                    decimal minC = lowestValueList.ElementAtOrDefault(i);
                    decimal maxH = highestHighList.ElementAtOrDefault(i);
                    decimal minL = lowestLowList.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevEma = i >= 1 ? emaList.ElementAtOrDefault(i - 1) : 0;

                    decimal cLog = minC != 0 ? Log(maxC / minC) : 0;
                    cLogList.Add(cLog);

                    decimal hlLog = minL != 0 ? Log(maxH / minL) : 0;
                    hlLogList.Add(hlLog);

                    decimal vol = MinOrMax(((0.6m * cLog * annualSqrt) + (0.6m * hlLog * annualSqrt)) * 0.5m, 2.99m, 0);
                    volList.Add(vol);

                    decimal volEma = CalculateExponentialMovingAverage(vol, volEmaList.LastOrDefault(), signalPeriod);
                    volEmaList.Add(volEma);

                    var signal = GetVolatilitySignal(currentValue - currentEma, prevValue - prevEma, vol, volEma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (cLogList, hlLogList, volList, volEmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculatePeriodicChannel(StockData stockDataClass, int days = 2)
        {
            //@version=3
            //study("Periodic Channel", overlay = true)
            //order = input(500),invert = input(false)
            //
            //y = n
            //z = (y - cum(y) / n) / (cum(abs((y - cum(y) / n))) / n)
            //
            //s = n * sign(cum(correlation(close, n, 2)))
            //sin = invert ? sin(s / order) * -1 : sin(s / order)
            //zs = (sin - cum(sin) / n) / (cum(abs((sin - cum(sin) / n))) / n)
            //k = (cum(close) / n) + ((z + zs) * (cum(abs((close - cum(close) / n))) / n))
            //
            //os = cum(abs(close - k)) / n
            //ap = k + os
            //bp = ap + os
            //cp = bp + os
            //al = k - os
            //bl = al - os
            //cl = bl - os
            //
            //plot(cp, color = red, transp = 0, linewidth = 2),plot(bp, color = orange, transp = 0, linewidth = 1),plot(ap, color = orange, transp = 0, linewidth = 0)
            //plot(k, color = aqua, transp = 0)
            //plot(al, color = green, transp = 0, linewidth = 0),plot(bl, color = green, transp = 0, linewidth = 1),plot(cl, color = lime, transp = 0, linewidth = 2)
            List<decimal> zList = new();
            List<decimal> sList = new();
            List<decimal> sinList = new();
            List<decimal> inSinList = new();
            List<decimal> zsList = new();
            List<decimal> inZsList = new();
            List<decimal> kList = new();
            List<decimal> inKList = new();
            List<decimal> osList = new();
            List<decimal> apList = new();
            List<decimal> bpList = new();
            List<decimal> cpList = new();
            List<decimal> alList = new();
            List<decimal> blList = new();
            List<decimal> clList = new();
            List<decimal> inOsList = new();
            List<decimal> inApList = new();
            List<decimal> inBpList = new();
            List<decimal> inCpList = new();
            List<decimal> inAlList = new();
            List<decimal> inBlList = new();
            List<decimal> inClList = new();
            List<decimal> indexList = new();
            List<decimal> indexCumList = new();
            List<decimal> indexCumDiffList = new();
            List<decimal> absIndexCumDiffList = new();
            List<decimal> absIndexCumList = new();
            List<decimal> sinCumList = new();
            List<decimal> sinCumDiffList = new();
            List<decimal> absSinCumDiffList = new();
            List<decimal> absSinCumList = new();
            List<decimal> inSinCumList = new();
            List<decimal> inSinCumDiffList = new();
            List<decimal> absInSinCumDiffList = new();
            List<decimal> absInSinCumList = new();
            List<decimal> corrList = new();
            List<decimal> tempList = new();
            List<decimal> cumList = new();
            List<decimal> absDiffList = new();
            List<decimal> absDiffCumList = new();
            List<decimal> absKDiffList = new();
            List<decimal> absInKDiffList = new();
            List<Signal> signalsList = new();

            try
            {
                int corrLength = days;
                int length = days * 250;

                for (int h = 0; h < stockDataClass.InputValues.Count; h++)
                {
                    decimal prevValue = tempList.LastOrDefault();
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(h);
                    tempList.Add(currentValue);

                    decimal index = h;
                    indexList.Add(index);

                    decimal indexCum = h != 0 ? indexList.Sum() / h : 0;
                    indexCumList.Add(indexCum);

                    decimal indexCumDiff = h - indexCum;
                    indexCumDiffList.Add(indexCumDiff);

                    decimal absIndexCumDiff = Math.Abs(h - indexCum);
                    absIndexCumDiffList.Add(absIndexCumDiff);

                    decimal absIndexCum = h != 0 ? absIndexCumDiffList.Sum() / h : 0;
                    absIndexCumList.Add(absIndexCum);

                    decimal z = absIndexCum != 0 ? indexCumDiff / absIndexCum : 0;
                    zList.Add(z);

                    var corr = GoodnessOfFit.R(indexList.TakeLast(corrLength).Select(x => (double)x), tempList.TakeLast(corrLength).Select(x => (double)x));
                    corr = IsValueNullOrInfinity(corr) ? 0 : corr;
                    corrList.Add((decimal)corr);

                    decimal s = h * Math.Sign(corrList.Sum());
                    sList.Add(s);

                    decimal sin = Sin(s / length);
                    sinList.Add(sin);

                    decimal inSin = Sin(s / length) * -1;
                    inSinList.Add(inSin);

                    decimal sinCum = h != 0 ? sinList.Sum() / h : 0;
                    sinCumList.Add(sinCum);

                    decimal inSinCum = h != 0 ? inSinList.Sum() / h : 0;
                    inSinCumList.Add(inSinCum);

                    decimal sinCumDiff = sin - sinCum;
                    sinCumDiffList.Add(sinCumDiff);

                    decimal inSinCumDiff = inSin - inSinCum;
                    inSinCumDiffList.Add(inSinCumDiff);

                    decimal absSinCumDiff = Math.Abs(sin - sinCum);
                    absSinCumDiffList.Add(absSinCumDiff);

                    decimal absSinCum = h != 0 ? absSinCumDiffList.Sum() / h : 0;
                    absSinCumList.Add(absSinCum);

                    decimal absInSinCumDiff = Math.Abs(inSin - inSinCum);
                    absInSinCumDiffList.Add(absInSinCumDiff);

                    decimal absInSinCum = h != 0 ? absInSinCumDiffList.Sum() / h : 0;
                    absInSinCumList.Add(absInSinCum);

                    decimal zs = absSinCum != 0 ? sinCumDiff / absSinCum : 0;
                    zsList.Add(zs);

                    decimal inZs = absInSinCum != 0 ? inSinCumDiff / absInSinCum : 0;
                    inZsList.Add(inZs);

                    decimal cum = h != 0 ? tempList.Sum() / h : 0;
                    cumList.Add(cum);

                    decimal absDiff = Math.Abs(currentValue - cum);
                    absDiffList.Add(absDiff);

                    decimal absDiffCum = h != 0 ? absDiffList.Sum() / h : 0;
                    absDiffCumList.Add(absDiffCum);

                    decimal prevK = kList.LastOrDefault();
                    decimal k = cum + ((z + zs) * absDiffCum);
                    kList.Add(k);

                    decimal inK = cum + ((z + inZs) * absDiffCum);
                    inKList.Add(inK);

                    decimal absKDiff = Math.Abs(currentValue - k);
                    absKDiffList.Add(absKDiff);

                    decimal absInKDiff = Math.Abs(currentValue - inK);
                    absInKDiffList.Add(absInKDiff);

                    decimal os = h != 0 ? absKDiffList.Sum() / h : 0;
                    osList.Add(os);

                    decimal inOs = h != 0 ? absInKDiffList.Sum() / h : 0;
                    inOsList.Add(inOs);

                    decimal ap = k + os;
                    apList.Add(ap);

                    decimal inAp = inK + inOs;
                    inApList.Add(inAp);

                    decimal bp = ap + os;
                    bpList.Add(bp);

                    decimal inBp = inAp + inOs;
                    inBpList.Add(inBp);

                    decimal cp = bp + os;
                    cpList.Add(cp);

                    decimal inCp = inBp + inOs;
                    inCpList.Add(inCp);

                    decimal al = k - os;
                    alList.Add(al);

                    decimal inAl = inK - inOs;
                    inAlList.Add(inAl);

                    decimal bl = al - os;
                    blList.Add(bl);

                    decimal inBl = inAl - inOs;
                    inBlList.Add(inBl);

                    decimal cl = bl - os;
                    clList.Add(cl);

                    decimal inCl = inBl - inOs;
                    inClList.Add(inCl);

                    var signal = GetCompareSignal(currentValue - k, prevValue - prevK);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (indexCumList, indexCumDiffList, absIndexCumList, absIndexCumDiffList, zList, sList, sinList, inSinList, sinCumList, inSinCumList, sinCumDiffList, inSinCumDiffList,
                absSinCumList, absSinCumDiffList, absInSinCumList, absInSinCumDiffList, zsList, inZsList, cumList, absDiffList, absDiffCumList, kList, inKList, absKDiffList,
                absInKDiffList, osList, inOsList, apList, inApList, bpList, inBpList, cpList, inCpList, alList, inAlList, blList, inBlList, clList, inClList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateTrendForceHistogram(StockData stockDataClass, int days = 14)
        {
            //@version=2
            //study("Trend Force Histogram")
            //length = input(14)
            //----
            //a = rising(close, length)
            //b = falling(close, length)
            //c = a ? nz(c[1]) + 1 : change(b) ? 0 : nz(c[1])
            //d = b ? nz(d[1]) + 1 : change(a) ? 0 : nz(d[1])
            //avg = avg(c, d)
            //----
            //f(x)=>cum(x) / n
            //rmean = f(avg)
            //osc = avg - rmean
            //----
            //plot(osc, color = osc > 0 ?#2196f3:red,style=histogram)
            List<decimal> aList = new();
            List<decimal> bList = new();
            List<decimal> cList = new();
            List<decimal> dList = new();
            List<decimal> avgList = new();
            List<decimal> rmeanList = new();
            List<decimal> oscList = new();
            List<decimal> tempList = new();
            List<Signal> signalsList = new();

            try
            {
                var emaList = CalculateExponentialMovingAverage(stockDataClass, days).Item1;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal ema = emaList.ElementAtOrDefault(i);
                    decimal prevEma = i >= 1 ? emaList.ElementAtOrDefault(i - 1) : 0;

                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    tempList.Add(prevValue);

                    var lbList = tempList.TakeLast(days).ToList();
                    decimal prevA = aList.LastOrDefault();
                    decimal a = currentValue > lbList.Max() ? 1 : 0;
                    aList.Add(a);

                    decimal prevB = bList.LastOrDefault();
                    decimal b = currentValue < lbList.Min() ? 1 : 0;
                    bList.Add(b);

                    decimal prevC = cList.LastOrDefault();
                    decimal c = a == 1 ? prevC + 1 : b - prevB == 1 ? 0 : prevC;
                    cList.Add(c);

                    decimal prevD = dList.LastOrDefault();
                    decimal d = b == 1 ? prevD + 1 : a - prevA == 1 ? 0 : prevD;
                    dList.Add(d);

                    decimal avg = (c + d) / 2;
                    avgList.Add(avg);

                    decimal rmean = i != 0 ? avgList.Sum() / i : 0;
                    rmeanList.Add(rmean);

                    decimal osc = avg - rmean;
                    oscList.Add(osc);

                    var signal = GetVolatilitySignal(currentValue - ema, prevValue - prevEma, osc, 0);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (aList, bList, cList, dList, avgList, rmeanList, oscList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateWellRoundedMovingAverage(StockData stockDataClass, int days = 14)
        {
            //@version=2
            //study("Well Rounded Moving Average", shorttitle = "WRMA", overlay = true)
            //length = input(14),src = input(close),smo = input(false, title = "Extra Smooth")
            //----
            //alpha = 2 / (length + 1)
            //p1 = smo ? length / 4 : 1
            //p2 = smo ? length / 4 : length / 2
            //----
            //a = nz(a[1]) + alpha * nz(A[1])
            //b = nz(b[1]) + alpha * nz(B[1])
            //y = ema(a + b, p1)
            //A = src - y
            //B = src - ema(y, p2)
            //----
            //plot(y, color = red, transp = 0)
            List<decimal> aList = new();
            List<decimal> bList = new();
            List<decimal> abList = new();
            List<decimal> yList = new();
            List<decimal> srcYList = new();
            List<decimal> srcEmaList = new();
            List<decimal> yEmaList = new();
            List<decimal> aSmoList = new();
            List<decimal> bSmoList = new();
            List<decimal> abSmoList = new();
            List<decimal> ySmoList = new();
            List<decimal> srcYSmoList = new();
            List<decimal> srcEmaSmoList = new();
            List<decimal> yEmaSmoList = new();
            List<Signal> signalsList = new();

            try
            {
                decimal alpha = (decimal)2 / (days + 1);
                int smoLength = MinOrMax((int)Math.Ceiling((decimal)days / 4));
                int length = MinOrMax((int)Math.Ceiling((decimal)days / 2));

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevA = i >= 1 ? aList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevB = i >= 1 ? bList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevSrcY = i >= 1 ? srcYList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevSrcEma = i >= 1 ? srcEmaList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevASmo = i >= 1 ? aSmoList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevBSmo = i >= 1 ? bSmoList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevSrcYSmo = i >= 1 ? srcYSmoList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevSrcEmaSmo = i >= 1 ? srcEmaSmoList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal a = prevA + (alpha * prevSrcY);
                    aList.Add(a);

                    decimal b = prevB + (alpha * prevSrcEma);
                    bList.Add(b);

                    decimal ab = a + b;
                    abList.Add(ab);

                    decimal prevY = yList.LastOrDefault();
                    decimal y = CalculateExponentialMovingAverage(ab, prevY, 1);
                    yList.Add(y);

                    decimal srcY = currentValue - y;
                    srcYList.Add(srcY);

                    decimal yEma = CalculateExponentialMovingAverage(y, yEmaList.LastOrDefault(), length);
                    yEmaList.Add(yEma);

                    decimal srcEma = currentValue - yEma;
                    srcEmaList.Add(srcEma);

                    decimal aSmo = prevASmo + (alpha * prevSrcYSmo);
                    aSmoList.Add(aSmo);

                    decimal bSmo = prevBSmo + (alpha * prevSrcEmaSmo);
                    bSmoList.Add(bSmo);

                    decimal abSmo = aSmo + bSmo;
                    abSmoList.Add(abSmo);

                    decimal ySmo = CalculateExponentialMovingAverage(abSmo, ySmoList.LastOrDefault(), smoLength);
                    ySmoList.Add(ySmo);

                    decimal srcYSmo = currentValue - ySmo;
                    srcYSmoList.Add(srcYSmo);

                    decimal yEmaSmo = CalculateExponentialMovingAverage(ySmo, yEmaSmoList.LastOrDefault(), smoLength);
                    yEmaSmoList.Add(yEmaSmo);

                    decimal srcEmaSmo = currentValue - yEmaSmo;
                    srcEmaSmoList.Add(srcEmaSmo);

                    var signal = GetCompareSignal(currentValue - y, prevValue - prevY);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (aList, bList, abList, yList, srcYList, yEmaList, srcEmaList, aSmoList, bSmoList, abSmoList, ySmoList, srcYSmoList, yEmaSmoList, srcEmaSmoList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateTrendImpulseFilter(StockData stockDataClass, int days = 100)
        {
            //@version=2
            //study("Trend Impulse Filter", overlay = true)
            //src = input(close),length = input(100),center = input(10),paint = input(true, title = "Color Based On Indicator Direction"),arrows = input(false, title = "Plot Arrows")
            //----
            //a = rising(src, length) or falling(src, length) ? 1 : 0
            //b = ema(a * src + (1 - a) * nz(b[1], src), center)
            //----
            //os = fixnan(b > b[1] ? 1 : b < b[1] ? -1 : na)
            //css = fixnan(b > b[1] ? #0080ff : b < b[1] ? #e65100 : na)
            //plot(b, color = paint ? css :#0080ff,linewidth=3,transp=0)
            //plotarrow(arrows ? change(os) : na, title = "Arrow", colorup =#0080ff, colordown=#e65100, maxheight=50, minheight=0, transp=0)
            List<decimal> tempList = new();
            List<decimal> bList = new();
            List<decimal> aList = new();
            List<decimal> bEmaList = new();
            List<Signal> signalsList = new();

            try
            {
                int center = MinOrMax((int)Math.Ceiling((decimal)days / 10));

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevB = i >= 1 ? bList.ElementAtOrDefault(i - 1) : currentValue;

                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    tempList.Add(prevValue);

                    var lbList = tempList.TakeLast(days).ToList();
                    decimal a = currentValue > lbList.Max() || currentValue < lbList.Min() ? 1 : 0;
                    aList.Add(a);

                    decimal b = (a * currentValue) + ((1 - a) * prevB);
                    bList.Add(b);

                    decimal prevBEma = bEmaList.LastOrDefault();
                    decimal bEma = CalculateExponentialMovingAverage(b, prevBEma, center);
                    bEmaList.Add(bEma);

                    var signal = GetCompareSignal(currentValue - bEma, prevValue - prevBEma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (aList, bList, bEmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateFallingRisingFilter(StockData stockDataClass, int days = 14)
        {
            //@version=2
            //study("Falling-Rising Filter", shorttitle = "FRF", overlay = true)
            //length = input(14)
            //----
            //src = input(close)
            //alpha = 2 / (length + 1)
            //beta = rising(src, length) or falling(src, length) ? 1 : alpha
            //----
            //a = nz(a[1]) + alpha * nz(error[1]) + beta * nz(error[1])
            //error = src - a
            //----
            //plot(a, color = red, transp = 0)
            List<decimal> tempList = new();
            List<decimal> betaList = new();
            List<decimal> aList = new();
            List<decimal> errorList = new();
            List<Signal> signalsList = new();

            try
            {
                decimal alpha = (decimal)2 / (days + 1);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevA = i >= 1 ? aList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevError = i >= 1 ? errorList.ElementAtOrDefault(i - 1) : 0;

                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    tempList.Add(prevValue);

                    var lbList = tempList.TakeLast(days).ToList();
                    decimal beta = currentValue > lbList.Max() || currentValue < lbList.Min() ? 1 : alpha;
                    betaList.Add(beta);

                    decimal a = prevA + (alpha * prevError) + (beta * prevError);
                    aList.Add(a);

                    decimal error = currentValue - a;
                    errorList.Add(error);

                    var signal = GetCompareSignal(error, prevError);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (betaList, aList, errorList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>)
            CalculateSmoothedDeltaRatioOscillator(StockData stockDataClass, string maType, int days = 100)
        {
            //@version=3
            //study("Smoothed Delta's Ratio Oscillator", shorttitle = "SDRO")
            //length = input(100),source = input(close),smoothed = input(false)
            //----
            //src = smoothed ? linreg(source, length, 0) : source
            //a = sma(abs(change(src, length)), length)
            //b = change(sma(src, length), length)
            //c = b / a
            //----
            //plot(c, color =#0080FF,transp=0)
            //hline(0.8, color =#e65100),hline(-0.8,color=#e65100)
            List<decimal> aList = new();
            List<decimal> aSmoList = new();
            List<decimal> bList = new();
            List<decimal> bSmoList = new();
            List<decimal> cList = new();
            List<decimal> cSmoList = new();
            List<decimal> linregSmaList = new();
            List<decimal> absChgList = new();
            List<decimal> absChgLinregList = new();
            List<Signal> signalsList = new();

            try
            {
                var linregList = CalculateLinearRegression(null, stockDataClass, days).Item15;
                var smaList = GetMovingAverageList(maType, null, stockDataClass, days);
                linregSmaList = GetMovingAverageList(maType, linregList, stockDataClass, days);

                for (int h = 0; h < stockDataClass.InputValues.Count; h++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(h);
                    decimal linreg = linregList.ElementAtOrDefault(h);
                    decimal prevValue = h >= days ? stockDataClass.InputValues.ElementAtOrDefault(h - days) : 0;
                    decimal prevLinreg = h >= days ? linregList.ElementAtOrDefault(h - days) : 0;
                    decimal sma = smaList.ElementAtOrDefault(h);
                    decimal linregSma = linregSmaList.ElementAtOrDefault(h);
                    decimal prevSma = h >= days ? smaList.ElementAtOrDefault(h - days) : 0;
                    decimal prevLinregSma = h >= days ? linregSmaList.ElementAtOrDefault(h - days) : 0;

                    decimal absChg = Math.Abs(currentValue - prevValue);
                    absChgList.Add(absChg);

                    decimal absChgLinreg = Math.Abs(linreg - prevLinreg);
                    absChgLinregList.Add(absChgLinreg);

                    decimal b = sma - prevSma;
                    bList.Add(b);

                    decimal bSmo = linregSma - prevLinregSma;
                    bSmoList.Add(bSmo);
                }

                aList = GetMovingAverageList(maType, absChgList, stockDataClass, days);
                aSmoList = GetMovingAverageList(maType, absChgLinregList, stockDataClass, days);
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal a = aList.ElementAtOrDefault(i);
                    decimal aSmo = aSmoList.ElementAtOrDefault(i);
                    decimal b = bList.ElementAtOrDefault(i);
                    decimal bSmo = bSmoList.ElementAtOrDefault(i);
                    decimal prevC1 = i >= 1 ? cList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevC2 = i >= 2 ? cList.ElementAtOrDefault(i - 2) : 0;

                    decimal c = a != 0 ? MinOrMax(b / a, 1, 0) : 0;
                    cList.Add(c);

                    decimal cSmo = aSmo != 0 ? MinOrMax(bSmo / aSmo, 1, 0) : 0;
                    cSmoList.Add(cSmo);

                    var signal = GetRsiSignal(c - prevC1, prevC1 - prevC2, c, prevC1, 0.8m, 0.2m);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (linregSmaList, absChgLinregList, bList, bSmoList, aList, aSmoList, cList, cSmoList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateJapaneseCorrelationCoefficient(StockData stockDataClass, string maType, int days = 50)
        {
            //@version=3
            //study("Japanese Correlation Coefficient")
            //length = input(50)
            //----
            //c = sma(close, length / 2)
            //h = sma(high, length / 2)
            //l = sma(low, length / 2)
            //jo = change(c, length / 2) / (highest(h, length / 2) - lowest(l, length / 2))
            //----
            //plot(jo, color =#e65100,transp=0)
            List<decimal> joList = new();
            List<decimal> cChgList = new();
            List<decimal> highestList = new();
            List<decimal> lowestList = new();
            List<Signal> signalsList = new();

            try
            {
                int length = MinOrMax((int)Math.Ceiling((decimal)days / 2));

                var inputList = VolumeInputCheck(stockDataClass, length, false);
                var hList = GetMovingAverageList(maType, inputList.Item1, stockDataClass, length);
                var lList = GetMovingAverageList(maType, inputList.Item2, stockDataClass, length);
                var cList = GetMovingAverageList(maType, null, stockDataClass, length);
                var minMaxList = GetMaxAndMinValuesList(hList, lList, length);
                highestList = minMaxList.Item1;
                lowestList = minMaxList.Item2;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal c = cList.ElementAtOrDefault(i);
                    decimal h = hList.ElementAtOrDefault(i);
                    decimal l = lList.ElementAtOrDefault(i);
                    decimal prevC = i >= length ? cList.ElementAtOrDefault(i - length) : 0;
                    decimal highest = highestList.ElementAtOrDefault(i);
                    decimal lowest = lowestList.ElementAtOrDefault(i);
                    decimal prevJo1 = i >= 1 ? joList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevJo2 = i >= 2 ? joList.ElementAtOrDefault(i - 2) : 0;

                    decimal cChg = c - prevC;
                    cChgList.Add(cChg);

                    decimal jo = highest - lowest != 0 ? cChg / (highest - lowest) : 0;
                    joList.Add(jo);

                    var signal = GetCompareSignal(jo - prevJo1, prevJo1 - prevJo2);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (cChgList, highestList, lowestList, joList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>)
            CalculateNarrowSidewaysChannel(StockData stockDataClass, decimal stdDeviationFactor, string maType, int days = 20)
        {
            //bollinger bands uses a factor of 2
            //narrow sideways channel uses a factor of 3
            //Middle Band = 20 - day simple moving average(SMA)
            //Upper Band = 20 - day SMA + (20 - day standard deviation of price x 2)
            //Lower Band = 20 - day SMA – (20 - day standard deviation of price x 2)
            //Bollinger Bandwith = ( (Upper Band - Lower Band) / Middle Band) * 100
            //%B = (Price - Lower Band)/(Upper Band - Lower Band)
            // Calc Impulse
            //bbi = bbr - nz(bbr[1])
            //cond1 = top lessThan prevBb[0] AND bott moreThan prevBb[1];
            //cond2 = top moreThan prevBb[0] AND bott lessThan prevBb[1];
            //cond3 = (cond1 == false) AND(cond2 == false);
            //if (cond1) nmP = 1;
            //if (cond2) nmP = 2;
            //if (cond3) nmP = 3;
            //cctbbo=100 * ( src + 2*stdev( src, length) - sma( src, length ) ) / ( 4 * stdev( src, length ) )
            List<decimal> upperBandList = new();
            List<decimal> lowerBandList = new();
            List<decimal> innerUpperBandList = new();
            List<decimal> innerLowerBandList = new();
            List<decimal> bollingerBandwithList = new();
            List<decimal> bollingerBandwithIndicatorList = new();
            List<decimal> nmpList = new();
            List<decimal> bbiList = new();
            List<decimal> cctbboList = new();
            List<Signal> signalsList = new();

            try
            {
                var narrowChannel = CalculateBollingerBands(null, stockDataClass, stdDeviationFactor, maType, days);
                upperBandList = narrowChannel.Item1;
                lowerBandList = narrowChannel.Item2;
                bollingerBandwithList = narrowChannel.Item3;
                bollingerBandwithIndicatorList = narrowChannel.Item4;
                nmpList = narrowChannel.Item5;
                bbiList = narrowChannel.Item6;
                cctbboList = narrowChannel.Item7;
                innerUpperBandList = narrowChannel.Item8;
                innerLowerBandList = narrowChannel.Item9;
                signalsList = narrowChannel.Item10;
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (upperBandList, lowerBandList, bollingerBandwithList, bollingerBandwithIndicatorList, nmpList, bbiList, cctbboList, innerUpperBandList, innerLowerBandList,
                signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>)
            CalculateBollingerBands(List<decimal>? customValuesList, StockData stockDataClass, decimal stdDeviationFactor, string maType, int days = 20)
        {
            //bollinger bands uses a factor of 2
            //narrow sideways channel uses a factor of 3
            //Middle Band = 20 - day simple moving average(SMA)
            //Upper Band = 20 - day SMA + (20 - day standard deviation of price x 2)
            //Lower Band = 20 - day SMA – (20 - day standard deviation of price x 2)
            //Bollinger Bandwith = ( (Upper Band - Lower Band) / Middle Band) * 100
            //%B = (Price - Lower Band)/(Upper Band - Lower Band)
            // Calc Impulse
            //bbi = bbr - nz(bbr[1])
            //cond1 = top lessThan prevBb[0] AND bott moreThan prevBb[1];
            //cond2 = top moreThan prevBb[0] AND bott lessThan prevBb[1];
            //cond3 = (cond1 == false) AND(cond2 == false);
            //if (cond1) nmP = 1;
            //if (cond2) nmP = 2;
            //if (cond3) nmP = 3;
            //cctbbo=100 * ( src + 2*stdev( src, length) - sma( src, length ) ) / ( 4 * stdev( src, length ) )
            List<decimal> upperBandList = new();
            List<decimal> lowerBandList = new();
            List<decimal> innerUpperBandList = new();
            List<decimal> innerLowerBandList = new();
            List<decimal> bollingerBandwithList = new();
            List<decimal> bollingerBandwithIndicatorList = new();
            List<decimal> nmpList = new();
            List<decimal> bbiList = new();
            List<decimal> cctbboList = new();
            List<Signal> signalsList = new();

            try
            {
                decimal stdDevFactor = stdDeviationFactor / 2;

                if (customValuesList != null)
                {
                    stockDataClass.InputValues = customValuesList;
                }

                List<decimal> smaList = GetMovingAverageList(maType, null, stockDataClass, days);
                List<decimal> stdDeviationList = CalculateStandardDeviationVolatility(null, stockDataClass, days).Item4;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal middleBand = smaList.ElementAtOrDefault(i);
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal currentStdDeviation = stdDeviationList.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevMiddleBand = i >= 1 ? smaList.ElementAtOrDefault(i - 1) : 0;

                    decimal prevUpperBand = upperBandList.LastOrDefault();
                    decimal upperBand = middleBand + (currentStdDeviation * stdDeviationFactor);
                    upperBandList.Add(upperBand);

                    decimal innerUpperBand = middleBand + (currentStdDeviation * stdDevFactor);
                    innerUpperBandList.Add(innerUpperBand);

                    decimal prevLowerBand = lowerBandList.LastOrDefault();
                    decimal lowerBand = middleBand - (currentStdDeviation * stdDeviationFactor);
                    lowerBandList.Add(lowerBand);

                    decimal innerLowerBand = middleBand - (currentStdDeviation * stdDevFactor);
                    innerLowerBandList.Add(innerLowerBand);

                    bool cond1 = upperBand < prevUpperBand && lowerBand > prevLowerBand;
                    bool cond2 = upperBand > prevUpperBand && lowerBand < prevLowerBand;
                    bool cond3 = (cond1 == false) && (cond2 == false);
                    decimal nmp = cond1 ? 1 : cond2 ? 2 : cond3 ? 3 : 0;
                    nmpList.Add(nmp);

                    decimal bollingerBandwith = middleBand != 0 ? (upperBand - lowerBand) / middleBand * 100 : 0;
                    bollingerBandwithList.Add(bollingerBandwith);

                    decimal prevBBIndicator = bollingerBandwithIndicatorList.LastOrDefault();
                    decimal bollingerBandwithIndicator = upperBand - lowerBand != 0 ? (currentValue - lowerBand) / (upperBand - lowerBand) : 0;
                    bollingerBandwithIndicatorList.Add(bollingerBandwithIndicator);

                    decimal bbi = bollingerBandwithIndicator - prevBBIndicator;
                    bbiList.Add(bbi);

                    decimal cctbbo = currentStdDeviation != 0 ? 100 * (currentValue + (2 * currentStdDeviation) - middleBand) / (4 * currentStdDeviation) : 0;
                    cctbboList.Add(cctbbo);

                    var signal = GetBollingerBandsSignal(currentValue - middleBand, prevValue - prevMiddleBand, currentValue, prevValue, upperBand, prevUpperBand, lowerBand, prevLowerBand);
                    signalsList.Add(signal);
                }

                // reset the input values list
                stockDataClass = LoadCalculations.GetInputValuesList(stockDataClass.InputName, stockDataClass);
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (upperBandList, lowerBandList, bollingerBandwithList, bollingerBandwithIndicatorList, nmpList, bbiList, cctbboList, innerUpperBandList, innerLowerBandList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculatePseudoPolynomialChannel(StockData stockDataClass, string maType, int days = 14)
        {
            //@version=2
            //study("Pseudo Polynomial Channel", overlay = true)
            //length = input(14),morph = input(0.9, minval = 0, maxval = 1),mult = input(1.),flatten = input(1.)
            //----
            //x = n
            //y = close
            //m(a, b) =>
            //    p = morph * a + (1 - morph) * b
            //k = nz(m(k[length], y), y) + (x - x[length]) / (x[length * 2] - x[length]) * (nz(m(k[length * 2], y), y) - nz(m(k[length], y), y)) / flatten
            //k1 = sma(k, length)
            //er = cum(abs(y - k1)) / n * mult
            //----
            //a = k1 + er
            //b = k1 - er
            //----
            //A = plot(a, color =#2196f3,linewidth=2,transp=0)
            //plot(k1, color =#e65100,linewidth=2,transp=0)
            //B = plot(b, color =#ff1100,linewidth=2,transp=0)
            //fill(A, B,#2196f3,transp=95)
            List<decimal> kList = new();
            List<decimal> kyList = new();
            List<decimal> ky2List = new();
            List<decimal> yK1List = new();
            List<decimal> erList = new();
            List<decimal> indexList = new();
            List<decimal> middleBandList = new();
            List<decimal> upperBandList = new();
            List<decimal> lowerBandList = new();
            List<decimal> innerUpperBandList = new();
            List<decimal> innerLowerBandList = new();
            List<decimal> bollingerBandwithList = new();
            List<decimal> bollingerBandwithIndicatorList = new();
            List<decimal> nmpList = new();
            List<decimal> bbiList = new();
            List<Signal> signalsList = new();
            decimal morph = 0.9m;

            try
            {
                for (int h = 0; h < stockDataClass.InputValues.Count; h++)
                {
                    decimal y = stockDataClass.InputValues.ElementAtOrDefault(h);
                    decimal prevK = h >= days ? kList.ElementAtOrDefault(h - days) : y;
                    decimal prevK2 = h >= days * 2 ? kList.ElementAtOrDefault(h - (days * 2)) : y;
                    decimal prevIndex = h >= days ? indexList.ElementAtOrDefault(h - days) : 0;
                    decimal prevIndex2 = h >= days * 2 ? indexList.ElementAtOrDefault(h - (days * 2)) : 0;

                    decimal index = h;
                    indexList.Add(h);

                    decimal ky = (morph * prevK) + ((1 - morph) * y);
                    kyList.Add(ky);

                    decimal ky2 = (morph * prevK2) + ((1 - morph) * y);
                    ky2List.Add(ky2);

                    decimal k = prevIndex2 - prevIndex != 0 ? ky + (((index - prevIndex) / (prevIndex2 - prevIndex)) * (ky2 - ky)) : 0;
                    kList.Add(k);
                }

                var k1List = GetMovingAverageList(maType, kList, stockDataClass, days);
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal k1 = k1List.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal yk1 = Math.Abs(currentValue - k1);
                    yK1List.Add(yk1);

                    decimal er = i != 0 ? yK1List.Sum() / i : 0;
                    erList.Add(er);

                    decimal prevUpperBand = upperBandList.LastOrDefault();
                    decimal upperBand = k1 + er;
                    upperBandList.Add(upperBand);

                    decimal prevLowerBand = lowerBandList.LastOrDefault();
                    decimal lowerBand = k1 - er;
                    lowerBandList.Add(lowerBand);

                    decimal prevMiddleBand = middleBandList.LastOrDefault();
                    decimal middleBand = (upperBand + lowerBand) / 2;
                    middleBandList.Add(middleBand);

                    decimal innerUpperBand = (upperBand + middleBand) / 2;
                    innerUpperBandList.Add(innerUpperBand);

                    decimal innerLowerBand = (lowerBand + middleBand) / 2;
                    innerLowerBandList.Add(innerLowerBand);

                    bool cond1 = upperBand < prevUpperBand && lowerBand > prevLowerBand;
                    bool cond2 = upperBand > prevUpperBand && lowerBand < prevLowerBand;
                    bool cond3 = (cond1 == false) && (cond2 == false);
                    decimal nmp = cond1 ? 1 : cond2 ? 2 : cond3 ? 3 : 0;
                    nmpList.Add(nmp);

                    decimal bollingerBandwith = middleBand != 0 ? (upperBand - lowerBand) / middleBand * 100 : 0;
                    bollingerBandwithList.Add(bollingerBandwith);

                    decimal prevBBIndicator = bollingerBandwithIndicatorList.LastOrDefault();
                    decimal bollingerBandwithIndicator = upperBand - lowerBand != 0 ? (currentValue - lowerBand) / (upperBand - lowerBand) : 0;
                    bollingerBandwithIndicatorList.Add(bollingerBandwithIndicator);

                    decimal bbi = bollingerBandwithIndicator - prevBBIndicator;
                    bbiList.Add(bbi);

                    var signal = GetBollingerBandsSignal(currentValue - middleBand, prevValue - prevMiddleBand, currentValue, prevValue, upperBand, prevUpperBand, lowerBand, prevLowerBand);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (kyList, ky2List, kList, yK1List, erList, upperBandList, lowerBandList, middleBandList, bollingerBandwithList, bollingerBandwithIndicatorList, nmpList, bbiList,
                innerUpperBandList, innerLowerBandList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>)
            CalculateVolumeAdaptiveBands(StockData stockDataClass, string maType, int days = 100)
        {
            //@version=3
            //study("Volume Adaptive Bands", overlay = true)
            //length = input(100),cr = input(1., "Correction Factor"),smoothed = input(false)
            //----
            //source = input(close)
            //src = smoothed ? sma(source, length) : source
            //a = sma(volume, length) * cr
            //b = sma(-volume, length) * cr
            //----
            //up = 0.
            //dn = 0.
            //up := sma((nz(up[1], src) + src * a) / a, length)
            //dn:= sma((nz(dn[1], src) + src * b) / b, length)
            //----
            //A = plot(up, title = "upper", color =#0094ff,linewidth=2,transp=0)
            //B = plot(dn, title = "basis", color =#ff6a00,linewidth=2,transp=0)
            //fill(A, B, title = "Background", color =#0094ff,transp=95)
            List<decimal> upList = new();
            List<decimal> dnList = new();
            List<decimal> upSmaList = new();
            List<decimal> dnSmaList = new();
            List<decimal> middleBandList = new();
            List<decimal> bollingerBandwithList = new();
            List<decimal> bollingerBandwithIndicatorList = new();
            List<decimal> nmpList = new();
            List<decimal> bbiList = new();
            List<Signal> signalsList = new();

            try
            {
                List<decimal> aList = GetMovingAverageList(maType, stockDataClass.Volumes, stockDataClass, days);

                for (int h = 0; h < stockDataClass.InputValues.Count; h++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(h);
                    decimal a = Math.Max(aList.ElementAtOrDefault(h), 1);
                    decimal b = a * -1;

                    decimal prevUp = h >= 1 ? upList.ElementAtOrDefault(h - 1) : currentValue;
                    decimal up = a != 0 ? (prevUp + (currentValue * a)) / a : 0;
                    upList.Add(up);

                    decimal prevDn = h >= 1 ? dnList.ElementAtOrDefault(h - 1) : currentValue;
                    decimal dn = b != 0 ? (prevDn + (currentValue * b)) / b : 0;
                    dnList.Add(dn);
                }

                upSmaList = GetMovingAverageList(maType, upList, stockDataClass, days);
                dnSmaList = GetMovingAverageList(maType, dnList, stockDataClass, days);
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal upperBand = upSmaList.ElementAtOrDefault(i);
                    decimal lowerBand = dnSmaList.ElementAtOrDefault(i);
                    decimal prevUpperBand = i >= 1 ? upSmaList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevLowerBand = i >= 1 ? dnSmaList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal prevMiddleBand = middleBandList.LastOrDefault();
                    decimal middleBand = (upperBand + lowerBand) / 2;
                    middleBandList.Add(middleBand);

                    bool cond1 = upperBand < prevUpperBand && lowerBand > prevLowerBand;
                    bool cond2 = upperBand > prevUpperBand && lowerBand < prevLowerBand;
                    bool cond3 = (cond1 == false) && (cond2 == false);
                    decimal nmp = cond1 ? 1 : cond2 ? 2 : cond3 ? 3 : 0;
                    nmpList.Add(nmp);

                    decimal bollingerBandwith = middleBand != 0 ? (upperBand - lowerBand) / middleBand * 100 : 0;
                    bollingerBandwithList.Add(bollingerBandwith);

                    decimal prevBBIndicator = bollingerBandwithIndicatorList.LastOrDefault();
                    decimal bollingerBandwithIndicator = upperBand - lowerBand != 0 ? (currentValue - lowerBand) / (upperBand - lowerBand) : 0;
                    bollingerBandwithIndicatorList.Add(bollingerBandwithIndicator);

                    decimal bbi = bollingerBandwithIndicator - prevBBIndicator;
                    bbiList.Add(bbi);

                    var signal = GetCompareSignal(currentValue - middleBand, prevValue - prevMiddleBand);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (upList, dnList, upSmaList, dnSmaList, middleBandList, bollingerBandwithList, bollingerBandwithIndicatorList, nmpList, bbiList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateAutoDispersionBands(StockData stockDataClass,
            string maType, int days = 90)
        {
            //@version=3
            //study("Auto-Dispersion Bands", overlay = true)
            //length = input(90),smooth = input(140)
            //----
            //band(src, mode)=>
            //    x = change(src, length)
            //    sq = sqrt(sma(x * x, length))
            //    a = src + sq
            //    b = src - sq
            //    A = wma(wma(highest(a, length), length), smooth)
            //    B = wma(wma(lowest(b, length), length), smooth)
            //    band = mode == "Upper" ? A : mode == "Lower" ? B : na
            //----
            //a = band(close, "Upper")
            //b = band(close, "Lower")
            //c = avg(a, b)
            //----
            //plot(a, linewidth = 2, transp = 0),plot(c, color = orange, linewidth = 2, transp = 0),plot(b, linewidth = 2, transp = 0)
            List<decimal> upperBandList = new();
            List<decimal> lowerBandList = new();
            List<decimal> middleBandList = new();
            List<decimal> bollingerBandwithList = new();
            List<decimal> bollingerBandwithIndicatorList = new();
            List<decimal> nmpList = new();
            List<decimal> bbiList = new();
            List<decimal> aList = new();
            List<decimal> bList = new();
            List<decimal> aMaxList = new();
            List<decimal> bMinList = new();
            List<decimal> aMaList = new();
            List<decimal> bMaList = new();
            List<decimal> sqList = new();
            List<decimal> x2List = new();
            List<decimal> x2SmaList = new();
            List<Signal> signalsList = new();

            try
            {
                int smoothLength = MinOrMax((int)Math.Ceiling(days / 0.6429));

                for (int h = 0; h < stockDataClass.InputValues.Count; h++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(h);
                    decimal prevValue = h >= days ? stockDataClass.InputValues.ElementAtOrDefault(h - days) : 0;
                    decimal x = currentValue - prevValue;

                    decimal x2 = x * x;
                    x2List.Add(x2);

                    decimal x2Sma = x2List.TakeLast(days).Average();
                    x2SmaList.Add(x2Sma);

                    decimal sq = x2Sma >= 0 ? Sqrt(x2Sma) : 0;
                    sqList.Add(sq);

                    decimal a = currentValue + sq;
                    aList.Add(a);

                    decimal b = currentValue - sq;
                    bList.Add(b);

                    decimal aMax = aList.TakeLast(days).Max();
                    aMaxList.Add(aMax);

                    decimal bMin = bList.TakeLast(days).Min();
                    bMinList.Add(bMin);
                }

                aMaList = GetMovingAverageList(maType, aMaxList, stockDataClass, days);
                upperBandList = GetMovingAverageList(maType, aMaList, stockDataClass, smoothLength);
                bMaList = GetMovingAverageList(maType, bMinList, stockDataClass, days);
                lowerBandList = GetMovingAverageList(maType, bMaList, stockDataClass, smoothLength);
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal upperBand = upperBandList.ElementAtOrDefault(i);
                    decimal lowerBand = lowerBandList.ElementAtOrDefault(i);
                    decimal prevUpperBand = i >= 1 ? upperBandList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevLowerBand = i >= 1 ? lowerBandList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal prevMiddleBand = middleBandList.LastOrDefault();
                    decimal middleBand = (upperBand + lowerBand) / 2;
                    middleBandList.Add(middleBand);

                    bool cond1 = upperBand < prevUpperBand && lowerBand > prevLowerBand;
                    bool cond2 = upperBand > prevUpperBand && lowerBand < prevLowerBand;
                    bool cond3 = (cond1 == false) && (cond2 == false);
                    decimal nmp = cond1 ? 1 : cond2 ? 2 : cond3 ? 3 : 0;
                    nmpList.Add(nmp);

                    decimal bollingerBandwith = middleBand != 0 ? (upperBand - lowerBand) / middleBand * 100 : 0;
                    bollingerBandwithList.Add(bollingerBandwith);

                    decimal prevBBIndicator = bollingerBandwithIndicatorList.LastOrDefault();
                    decimal bollingerBandwithIndicator = upperBand - lowerBand != 0 ? (currentValue - lowerBand) / (upperBand - lowerBand) : 0;
                    bollingerBandwithIndicatorList.Add(bollingerBandwithIndicator);

                    decimal bbi = bollingerBandwithIndicator - prevBBIndicator;
                    bbiList.Add(bbi);

                    var signal = GetCompareSignal(currentValue - middleBand, prevValue - prevMiddleBand);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (x2List, x2SmaList, sqList, aList, bList, aMaxList, bMinList, aMaList, bMaList, upperBandList, middleBandList, lowerBandList, bollingerBandwithList,
                bollingerBandwithIndicatorList, nmpList, bbiList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>)
            CalculateMeanAbsoluteErrorBands(StockData stockDataClass, decimal stdDeviationFactor,
            string maType, int days = 14)
        {
            //@version=4
            //study("Bands-Trailing Stop Utility", overlay = true)
            //in = input(close, title = "Source"),length = input(14),mult = input(1.),method = input("MAE", options =["MAE", "RMASE", "ATR", "RANGE", "STDEV"])
            //Ts = input(false, title = "Trailing Stop Mode")
            //----
            //f(a, b, c)=>method == a ? b : c
            //mae = cum(abs(close -in)) / bar_index
            //rmase = sqrt(sma(pow(close -in, 2), length))
            //range = highest(in, length) - lowest(in, length)
            //stdev = stdev(close, length)
            //----
            //dev = f("MAE", mae, f("RMASE", rmase, f("ATR", atr(length), f("RANGE", range, f("STDEV", stdev, 0))))) * mult
            //upper = in +dev * mult
            //lower = in -dev * mult
            //----
            //os = 0
            //os:= cross(close, upper) ? 1 : cross(close, lower) ? 0 : os[1]
            //ts = os * lower + (1 - os) * upper
            //css = os == 1 ? color.blue : color.red
            //----
            //plot(Ts ? na : upper, title = "Upper", linewidth = 2, transp = 0)
            //plot(Ts ? na : lower, title = "Lower", linewidth = 2, transp = 0)
            //plot(Ts ? ts : na, title = "Trailing Stop", color = css, linewidth = 2, transp = 0)
            List<decimal> upperBandList = new();
            List<decimal> lowerBandList = new();
            List<decimal> innerUpperBandList = new();
            List<decimal> innerLowerBandList = new();
            List<decimal> bollingerBandwithList = new();
            List<decimal> bollingerBandwithIndicatorList = new();
            List<decimal> nmpList = new();
            List<decimal> bbiList = new();
            List<decimal> cctbboList = new();
            List<decimal> devList = new();
            List<decimal> maeDevList = new();
            List<Signal> signalsList = new();

            try
            {
                decimal stdDevFactor = stdDeviationFactor / 2;

                List<decimal> smaList = GetMovingAverageList(maType, null, stockDataClass, days);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal middleBand = smaList.ElementAtOrDefault(i);
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevMiddleBand = i >= 1 ? smaList.ElementAtOrDefault(i - 1) : 0;

                    decimal dev = Math.Abs(currentValue - middleBand);
                    devList.Add(dev);

                    decimal maeDev = i != 0 ? devList.Sum() / i : 0;
                    maeDevList.Add(maeDev);

                    decimal prevUpperBand = upperBandList.LastOrDefault();
                    decimal upperBand = middleBand + (maeDev * stdDeviationFactor);
                    upperBandList.Add(upperBand);

                    decimal innerUpperBand = middleBand + (maeDev * stdDevFactor);
                    innerUpperBandList.Add(innerUpperBand);

                    decimal prevLowerBand = lowerBandList.LastOrDefault();
                    decimal lowerBand = middleBand - (maeDev * stdDeviationFactor);
                    lowerBandList.Add(lowerBand);

                    decimal innerLowerBand = middleBand - (maeDev * stdDevFactor);
                    innerLowerBandList.Add(innerLowerBand);

                    bool cond1 = upperBand < prevUpperBand && lowerBand > prevLowerBand;
                    bool cond2 = upperBand > prevUpperBand && lowerBand < prevLowerBand;
                    bool cond3 = (cond1 == false) && (cond2 == false);
                    decimal nmp = cond1 ? 1 : cond2 ? 2 : cond3 ? 3 : 0;
                    nmpList.Add(nmp);

                    decimal bollingerBandwith = middleBand != 0 ? (upperBand - lowerBand) / middleBand * 100 : 0;
                    bollingerBandwithList.Add(bollingerBandwith);

                    decimal prevBBIndicator = bollingerBandwithIndicatorList.LastOrDefault();
                    decimal bollingerBandwithIndicator = upperBand - lowerBand != 0 ? (currentValue - lowerBand) / (upperBand - lowerBand) : 0;
                    bollingerBandwithIndicatorList.Add(bollingerBandwithIndicator);

                    decimal bbi = bollingerBandwithIndicator - prevBBIndicator;
                    bbiList.Add(bbi);

                    decimal cctbbo = maeDev != 0 ? 100 * (currentValue + (2 * maeDev) - middleBand) / (4 * maeDev) : 0;
                    cctbboList.Add(cctbbo);

                    var signal = GetBollingerBandsSignal(currentValue - middleBand, prevValue - prevMiddleBand, currentValue, prevValue, upperBand, prevUpperBand, lowerBand, prevLowerBand);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (upperBandList, lowerBandList, bollingerBandwithList, bollingerBandwithIndicatorList, nmpList, bbiList, cctbboList,
                innerUpperBandList, innerLowerBandList, maeDevList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>)
            CalculateRangeBands(StockData stockDataClass, decimal stdDeviationFactor,
            string maType, int days = 14)
        {
            //@version=4
            //study("Bands-Trailing Stop Utility", overlay = true)
            //in = input(close, title = "Source"),length = input(14),mult = input(1.),method = input("MAE", options =["MAE", "RMASE", "ATR", "RANGE", "STDEV"])
            //Ts = input(false, title = "Trailing Stop Mode")
            //----
            //f(a, b, c)=>method == a ? b : c
            //mae = cum(abs(close -in)) / bar_index
            //rmase = sqrt(sma(pow(close -in, 2), length))
            //range = highest(in, length) - lowest(in, length)
            //stdev = stdev(close, length)
            //----
            //dev = f("MAE", mae, f("RMASE", rmase, f("ATR", atr(length), f("RANGE", range, f("STDEV", stdev, 0))))) * mult
            //upper = in +dev * mult
            //lower = in -dev * mult
            //----
            //os = 0
            //os:= cross(close, upper) ? 1 : cross(close, lower) ? 0 : os[1]
            //ts = os * lower + (1 - os) * upper
            //css = os == 1 ? color.blue : color.red
            //----
            //plot(Ts ? na : upper, title = "Upper", linewidth = 2, transp = 0)
            //plot(Ts ? na : lower, title = "Lower", linewidth = 2, transp = 0)
            //plot(Ts ? ts : na, title = "Trailing Stop", color = css, linewidth = 2, transp = 0)
            List<decimal> upperBandList = new();
            List<decimal> lowerBandList = new();
            List<decimal> innerUpperBandList = new();
            List<decimal> innerLowerBandList = new();
            List<decimal> bollingerBandwithList = new();
            List<decimal> bollingerBandwithIndicatorList = new();
            List<decimal> nmpList = new();
            List<decimal> bbiList = new();
            List<decimal> cctbboList = new();
            List<decimal> rangeDevList = new();
            List<Signal> signalsList = new();

            try
            {
                decimal stdDevFactor = stdDeviationFactor / 2;

                List<decimal> smaList = GetMovingAverageList(maType, null, stockDataClass, days);
                var minMaxList = GetMaxAndMinValuesList(smaList, days);
                var highestList = minMaxList.Item1;
                var lowestList = minMaxList.Item2;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal middleBand = smaList.ElementAtOrDefault(i);
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal highest = highestList.ElementAtOrDefault(i);
                    decimal lowest = lowestList.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevMiddleBand = i >= 1 ? smaList.ElementAtOrDefault(i - 1) : 0;

                    decimal rangeDev = highest - lowest;
                    rangeDevList.Add(rangeDev);

                    decimal prevUpperBand = upperBandList.LastOrDefault();
                    decimal upperBand = middleBand + (rangeDev * stdDeviationFactor);
                    upperBandList.Add(upperBand);

                    decimal innerUpperBand = middleBand + (rangeDev * stdDevFactor);
                    innerUpperBandList.Add(innerUpperBand);

                    decimal prevLowerBand = lowerBandList.LastOrDefault();
                    decimal lowerBand = middleBand - (rangeDev * stdDeviationFactor);
                    lowerBandList.Add(lowerBand);

                    decimal innerLowerBand = middleBand - (rangeDev * stdDevFactor);
                    innerLowerBandList.Add(innerLowerBand);

                    bool cond1 = upperBand < prevUpperBand && lowerBand > prevLowerBand;
                    bool cond2 = upperBand > prevUpperBand && lowerBand < prevLowerBand;
                    bool cond3 = (cond1 == false) && (cond2 == false);
                    decimal nmp = cond1 ? 1 : cond2 ? 2 : cond3 ? 3 : 0;
                    nmpList.Add(nmp);

                    decimal bollingerBandwith = middleBand != 0 ? (upperBand - lowerBand) / middleBand * 100 : 0;
                    bollingerBandwithList.Add(bollingerBandwith);

                    decimal prevBBIndicator = bollingerBandwithIndicatorList.LastOrDefault();
                    decimal bollingerBandwithIndicator = upperBand - lowerBand != 0 ? (currentValue - lowerBand) / (upperBand - lowerBand) : 0;
                    bollingerBandwithIndicatorList.Add(bollingerBandwithIndicator);

                    decimal bbi = bollingerBandwithIndicator - prevBBIndicator;
                    bbiList.Add(bbi);

                    decimal cctbbo = rangeDev != 0 ? 100 * (currentValue + (2 * rangeDev) - middleBand) / (4 * rangeDev) : 0;
                    cctbboList.Add(cctbbo);

                    var signal = GetBollingerBandsSignal(currentValue - middleBand, prevValue - prevMiddleBand, currentValue, prevValue, upperBand, prevUpperBand, lowerBand, prevLowerBand);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (upperBandList, lowerBandList, bollingerBandwithList, bollingerBandwithIndicatorList, nmpList, bbiList, cctbboList,
                innerUpperBandList, innerLowerBandList, rangeDevList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<decimal>, List<Signal>) CalculateRootMovingAverageSquaredErrorBands(StockData stockDataClass, decimal stdDeviationFactor, string maType, int days = 14)
        {
            //@version=4
            //study("Bands-Trailing Stop Utility", overlay = true)
            //in = input(close, title = "Source"),length = input(14),mult = input(1.),method = input("MAE", options =["MAE", "RMASE", "ATR", "RANGE", "STDEV"])
            //Ts = input(false, title = "Trailing Stop Mode")
            //----
            //f(a, b, c)=>method == a ? b : c
            //mae = cum(abs(close -in)) / bar_index
            //rmase = sqrt(sma(pow(close -in, 2), length))
            //range = highest(in, length) - lowest(in, length)
            //stdev = stdev(close, length)
            //----
            //dev = f("MAE", mae, f("RMASE", rmase, f("ATR", atr(length), f("RANGE", range, f("STDEV", stdev, 0))))) * mult
            //upper = in +dev * mult
            //lower = in -dev * mult
            //----
            //os = 0
            //os:= cross(close, upper) ? 1 : cross(close, lower) ? 0 : os[1]
            //ts = os * lower + (1 - os) * upper
            //css = os == 1 ? color.blue : color.red
            //----
            //plot(Ts ? na : upper, title = "Upper", linewidth = 2, transp = 0)
            //plot(Ts ? na : lower, title = "Lower", linewidth = 2, transp = 0)
            //plot(Ts ? ts : na, title = "Trailing Stop", color = css, linewidth = 2, transp = 0)
            List<decimal> upperBandList = new();
            List<decimal> lowerBandList = new();
            List<decimal> innerUpperBandList = new();
            List<decimal> innerLowerBandList = new();
            List<decimal> bollingerBandwithList = new();
            List<decimal> bollingerBandwithIndicatorList = new();
            List<decimal> nmpList = new();
            List<decimal> bbiList = new();
            List<decimal> cctbboList = new();
            List<decimal> rmaseDevList = new();
            List<decimal> powList = new();
            List<decimal> powSmaList = new();
            List<Signal> signalsList = new();

            try
            {
                decimal stdDevFactor = stdDeviationFactor / 2;

                List<decimal> smaList = GetMovingAverageList(maType, null, stockDataClass, days);

                for (int h = 0; h < stockDataClass.InputValues.Count; h++)
                {
                    decimal sma = smaList.ElementAtOrDefault(h);
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(h);

                    decimal pow = Pow(currentValue - sma, 2);
                    powList.Add(pow);
                }

                powSmaList = GetMovingAverageList(maType, powList, stockDataClass, days);
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal middleBand = smaList.ElementAtOrDefault(i);
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal powSma = powSmaList.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevMiddleBand = i >= 1 ? smaList.ElementAtOrDefault(i - 1) : 0;

                    decimal rmaseDev = powSma >= 0 ? Sqrt(powSma) : 0;
                    rmaseDevList.Add(rmaseDev);

                    decimal prevUpperBand = upperBandList.LastOrDefault();
                    decimal upperBand = middleBand + (rmaseDev * stdDeviationFactor);
                    upperBandList.Add(upperBand);

                    decimal innerUpperBand = middleBand + (rmaseDev * stdDevFactor);
                    innerUpperBandList.Add(innerUpperBand);

                    decimal prevLowerBand = lowerBandList.LastOrDefault();
                    decimal lowerBand = middleBand - (rmaseDev * stdDeviationFactor);
                    lowerBandList.Add(lowerBand);

                    decimal innerLowerBand = middleBand - (rmaseDev * stdDevFactor);
                    innerLowerBandList.Add(innerLowerBand);

                    bool cond1 = upperBand < prevUpperBand && lowerBand > prevLowerBand;
                    bool cond2 = upperBand > prevUpperBand && lowerBand < prevLowerBand;
                    bool cond3 = (cond1 == false) && (cond2 == false);
                    decimal nmp = cond1 ? 1 : cond2 ? 2 : cond3 ? 3 : 0;
                    nmpList.Add(nmp);

                    decimal bollingerBandwith = middleBand != 0 ? (upperBand - lowerBand) / middleBand * 100 : 0;
                    bollingerBandwithList.Add(bollingerBandwith);

                    decimal prevBBIndicator = bollingerBandwithIndicatorList.LastOrDefault();
                    decimal bollingerBandwithIndicator = upperBand - lowerBand != 0 ? (currentValue - lowerBand) / (upperBand - lowerBand) : 0;
                    bollingerBandwithIndicatorList.Add(bollingerBandwithIndicator);

                    decimal bbi = bollingerBandwithIndicator - prevBBIndicator;
                    bbiList.Add(bbi);

                    decimal cctbbo = rmaseDev != 0 ? 100 * (currentValue + (2 * rmaseDev) - middleBand) / (4 * rmaseDev) : 0;
                    cctbboList.Add(cctbbo);

                    var signal = GetBollingerBandsSignal(currentValue - middleBand, prevValue - prevMiddleBand, currentValue, prevValue, upperBand, prevUpperBand, lowerBand, prevLowerBand);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (upperBandList, lowerBandList, bollingerBandwithList, bollingerBandwithIndicatorList, nmpList, bbiList, cctbboList,
                innerUpperBandList, innerLowerBandList, powList, powSmaList, rmaseDevList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<decimal>, List<Signal>) CalculateKaufmanAdaptiveBands(StockData stockDataClass, decimal stdDeviationFactor, string maType, int days = 100)
        {
            //@version=4
            //study("Kaufman Adaptive Bands", overlay = true)
            //length = input(100),mult = input(1),power = input(3),src = input(close)
            //----
            //er = pow(abs(change(close, length)) / sum(abs(change(close)), length), power)
            //ma(x)=>a = 0.,a:= er * x + (1 - er) * nz(a[1], x)
            //dev = sqrt(ma(pow(src, 2)) - pow(ma(src), 2))
            //----
            //basis = ma(src)
            //upper = basis + dev * mult
            //lower = basis - dev * mult
            //----
            //plot(upper, linewidth = 2, transp = 0)
            //plot(basis, color =#e65100,linewidth=2,transp=0)
            //plot(lower, linewidth = 2, transp = 0)
            List<decimal> upperBandList = new();
            List<decimal> lowerBandList = new();
            List<decimal> innerUpperBandList = new();
            List<decimal> innerLowerBandList = new();
            List<decimal> bollingerBandwithList = new();
            List<decimal> bollingerBandwithIndicatorList = new();
            List<decimal> nmpList = new();
            List<decimal> bbiList = new();
            List<decimal> cctbboList = new();
            List<decimal> kaufmanDevList = new();
            List<decimal> powList = new();
            List<decimal> powSmaList = new();
            List<Signal> signalsList = new();

            try
            {
                decimal stdDevFactor = stdDeviationFactor / 2;

                var smaList = GetMovingAverageList(maType, null, stockDataClass, days);

                for (int h = 0; h < stockDataClass.InputValues.Count; h++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(h);

                    decimal pow = Pow(currentValue, 2);
                    powList.Add(pow);
                }

                powSmaList = GetMovingAverageList(maType, powList, stockDataClass, days);
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal middleBand = smaList.ElementAtOrDefault(i);
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal powSma = powSmaList.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevMiddleBand = i >= 1 ? smaList.ElementAtOrDefault(i - 1) : 0;

                    decimal kaufmanDev = powSma - Pow(middleBand, 2) >= 0 ? Sqrt(powSma - Pow(middleBand, 2)) : 0;
                    kaufmanDevList.Add(kaufmanDev);

                    decimal prevUpperBand = upperBandList.LastOrDefault();
                    decimal upperBand = middleBand + (kaufmanDev * stdDeviationFactor);
                    upperBandList.Add(upperBand);

                    decimal innerUpperBand = middleBand + (kaufmanDev * stdDevFactor);
                    innerUpperBandList.Add(innerUpperBand);

                    decimal prevLowerBand = lowerBandList.LastOrDefault();
                    decimal lowerBand = middleBand - (kaufmanDev * stdDeviationFactor);
                    lowerBandList.Add(lowerBand);

                    decimal innerLowerBand = middleBand - (kaufmanDev * stdDevFactor);
                    innerLowerBandList.Add(innerLowerBand);

                    bool cond1 = upperBand < prevUpperBand && lowerBand > prevLowerBand;
                    bool cond2 = upperBand > prevUpperBand && lowerBand < prevLowerBand;
                    bool cond3 = (cond1 == false) && (cond2 == false);
                    decimal nmp = cond1 ? 1 : cond2 ? 2 : cond3 ? 3 : 0;
                    nmpList.Add(nmp);

                    decimal bollingerBandwith = middleBand != 0 ? (upperBand - lowerBand) / middleBand * 100 : 0;
                    bollingerBandwithList.Add(bollingerBandwith);

                    decimal prevBBIndicator = bollingerBandwithIndicatorList.LastOrDefault();
                    decimal bollingerBandwithIndicator = upperBand - lowerBand != 0 ? (currentValue - lowerBand) / (upperBand - lowerBand) : 0;
                    bollingerBandwithIndicatorList.Add(bollingerBandwithIndicator);

                    decimal bbi = bollingerBandwithIndicator - prevBBIndicator;
                    bbiList.Add(bbi);

                    decimal cctbbo = kaufmanDev != 0 ? 100 * (currentValue + (2 * kaufmanDev) - middleBand) / (4 * kaufmanDev) : 0;
                    cctbboList.Add(cctbbo);

                    var signal = GetBollingerBandsSignal(currentValue - middleBand, prevValue - prevMiddleBand, currentValue, prevValue, upperBand, prevUpperBand, lowerBand, prevLowerBand);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (upperBandList, lowerBandList, bollingerBandwithList, bollingerBandwithIndicatorList, nmpList, bbiList, cctbboList,
                innerUpperBandList, innerLowerBandList, powList, powSmaList, kaufmanDevList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>)
            CalculateMeanAbsoluteDeviationBands(StockData stockDataClass, decimal stdDeviationFactor, string maType, int days = 20)
        {
            //@version=4
            // Copyright (c) 2020-present, Alex Orekhov (everget)
            // Mean Absolute Deviation Bands script may be freely distributed under the terms of the GPL-3.0 license.
            //study("Mean Absolute Deviation Bands", shorttitle = "MADB", overlay = true)

            //length = input(title = "Length", defval = 20, minval = 2)
            //mult = input(title = "Bands Multiplier", defval = 2.0, type = input.float, step = 0.1)
            //src = input(title = "Source", defval = close)

            //basis = sma(src, length)
            //dev = mult * dev(src, length)
            //upper = basis + dev
            //lower = basis - dev

            //plot(basis, title = "Basis", color =#351c75, transp=0)
            //upperPlot = plot(upper, title = "Upper", color =#45818e, transp=0)
            //lowerPlot = plot(lower, title = "Lower", color =#45818e, transp=0)
            //fill(upperPlot, lowerPlot, title = "MADB Background", color = color.new (#ffd966, 84))
            List<decimal> upperBandList = new();
            List<decimal> lowerBandList = new();
            List<decimal> innerUpperBandList = new();
            List<decimal> innerLowerBandList = new();
            List<decimal> bollingerBandwithList = new();
            List<decimal> bollingerBandwithIndicatorList = new();
            List<decimal> nmpList = new();
            List<decimal> bbiList = new();
            List<decimal> cctbboList = new();
            List<Signal> signalsList = new();

            try
            {
                decimal stdDevFactor = stdDeviationFactor / 2;

                List<decimal> smaList = GetMovingAverageList(maType, null, stockDataClass, days);
                List<decimal> devList = CalculateStandardDeviationVolatility(null, stockDataClass, days).Item8;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal middleBand = smaList.ElementAtOrDefault(i);
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal currentStdDeviation = devList.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevMiddleBand = i >= 1 ? smaList.ElementAtOrDefault(i - 1) : 0;

                    decimal prevUpperBand = upperBandList.LastOrDefault();
                    decimal upperBand = middleBand + (currentStdDeviation * stdDeviationFactor);
                    upperBandList.Add(upperBand);

                    decimal innerUpperBand = middleBand + (currentStdDeviation * stdDevFactor);
                    innerUpperBandList.Add(innerUpperBand);

                    decimal prevLowerBand = lowerBandList.LastOrDefault();
                    decimal lowerBand = middleBand - (currentStdDeviation * stdDeviationFactor);
                    lowerBandList.Add(lowerBand);

                    decimal innerLowerBand = middleBand - (currentStdDeviation * stdDevFactor);
                    innerLowerBandList.Add(innerLowerBand);

                    bool cond1 = upperBand < prevUpperBand && lowerBand > prevLowerBand;
                    bool cond2 = upperBand > prevUpperBand && lowerBand < prevLowerBand;
                    bool cond3 = (cond1 == false) && (cond2 == false);
                    decimal nmp = cond1 ? 1 : cond2 ? 2 : cond3 ? 3 : 0;
                    nmpList.Add(nmp);

                    decimal bollingerBandwith = middleBand != 0 ? (upperBand - lowerBand) / middleBand * 100 : 0;
                    bollingerBandwithList.Add(bollingerBandwith);

                    decimal prevBBIndicator = bollingerBandwithIndicatorList.LastOrDefault();
                    decimal bollingerBandwithIndicator = upperBand - lowerBand != 0 ? (currentValue - lowerBand) / (upperBand - lowerBand) : 0;
                    bollingerBandwithIndicatorList.Add(bollingerBandwithIndicator);

                    decimal bbi = bollingerBandwithIndicator - prevBBIndicator;
                    bbiList.Add(bbi);

                    decimal cctbbo = currentStdDeviation != 0 ? 100 * (currentValue + (2 * currentStdDeviation) - middleBand) / (4 * currentStdDeviation) : 0;
                    cctbboList.Add(cctbbo);

                    var signal = GetBollingerBandsSignal(currentValue - middleBand, prevValue - prevMiddleBand, currentValue, prevValue, upperBand, prevUpperBand, lowerBand, prevLowerBand);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (upperBandList, lowerBandList, bollingerBandwithList, bollingerBandwithIndicatorList, nmpList, bbiList, cctbboList,
                innerUpperBandList, innerLowerBandList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<decimal>, List<decimal>, List<Signal>) CalculateBollingerBandsFibonacciRatios(StockData stockDataClass, string maType, int days = 20)
        {
            //input = price, user defined, default is close
            //period = user defined, default is 20
            //fibRatio1 = fibonacci ratio1, default is 1.618
            //fibRatio2 = fibonacci ratio2, default is 2.618
            //fibRatio3 = fibonacci ratio3, default is 4.236
            //smma = smoothed simple moving average
            //sma = simple moving average
            //index = current bar number

            //TR = getTrueRange(index)
            //ATR = smma(index, period, TR);
            //sma = sma(index, period, input);
            //r1 = ATR * fibRatio1;
            //r2 = ATR * fibRatio2;
            //r3 = ATR * fibRatio3;
            //Plot1: fibTop3 = sma + r3;
            //Plot2: fibTop2 = sma + r2;
            //Plot3: fibTop3 = sma + r1;
            //Plot4: middle = sma;
            //Plot5: fibBott1 = sma - r1;
            //Plot6: fibBott2 = sma - r2;
            //Plot7: figBott3 = sma - r3;
            decimal fibRatio1 = 1.618m, fibRatio2 = 2.618m, fibRatio3 = 4.236m;
            List<decimal> r1List = new();
            List<decimal> r2List = new();
            List<decimal> r3List = new();
            List<decimal> fibTop3List = new();
            List<decimal> fibTop2List = new();
            List<decimal> fibTop1List = new();
            List<decimal> fibBottom1List = new();
            List<decimal> fibBottom2List = new();
            List<decimal> fibBottom3List = new();
            List<Signal> signalsList = new();

            try
            {
                var atrList = CalculateAverageTrueRange(stockDataClass, maType, days).Item1;
                List<decimal> smaList = GetMovingAverageList(maType, null, stockDataClass, days);

                for (int i = 0; i < atrList.Count; i++)
                {
                    decimal atr = atrList.ElementAtOrDefault(i);
                    decimal sma = smaList.ElementAtOrDefault(i);
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevSma = i >= 1 ? smaList.ElementAtOrDefault(i - 1) : 0;

                    decimal r1 = atr * fibRatio1;
                    r1List.Add(r1);

                    decimal r2 = atr * fibRatio2;
                    r2List.Add(r2);

                    decimal r3 = atr * fibRatio3;
                    r3List.Add(r3);

                    decimal prevFibTop3 = fibTop3List.LastOrDefault();
                    decimal fibTop3 = sma + r3;
                    fibTop3List.Add(fibTop3);

                    decimal fibTop2 = sma + r2;
                    fibTop2List.Add(fibTop2);

                    decimal fibTop1 = sma + r1;
                    fibTop1List.Add(fibTop1);

                    decimal fibBottom1 = sma - r1;
                    fibBottom1List.Add(fibBottom1);

                    decimal fibBottom2 = sma - r2;
                    fibBottom2List.Add(fibBottom2);

                    decimal prevFibBottom3 = fibBottom3List.LastOrDefault();
                    decimal fibBottom3 = sma - r3;
                    fibBottom3List.Add(fibBottom3);

                    var signal = GetBollingerBandsSignal(currentValue - sma, prevValue - prevSma, currentValue, prevValue, fibTop3, prevFibTop3, fibBottom3, prevFibBottom3);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (r1List, r2List, r3List, fibTop1List, fibTop2List, fibTop3List, fibBottom1List, fibBottom2List, fibBottom3List, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateVortexBands(StockData stockDataClass, string maType, int days = 20)
        {
            //@version=4
            // Copyright (c) 2020-present, Alex Orekhov (everget)
            // Vortex Bands script may be freely distributed under the terms of the GPL-3.0 license.
            //study("Vortex Bands", shorttitle = "VB", overlay = true)

            //length = input(title = "Length", type = input.integer, defval = 20)
            //mult = input(title = "Multiplier", type = input.float, step = 0.1, defval = 2)
            //src = input(title = "Source", type = input.source, defval = hlc3)
            //barColoringType = input(title = "Bar Coloring", defval = "None", options =["None", "Upper > Lower", "Close Above/Below Basis", "Close Inside Cloud", "Wicks Inside Cloud"])

            //_ema(src, alpha) =>
            //    out = src
            //    out := alpha * out +(1 - alpha) * nz(out[1], out)
            //    out

            //_mnma(src, length) =>
            //    alpha = 2 / (length + 1)
            //    ema1 = _ema(src, alpha)
            //    ema2 = _ema(ema1, alpha)
            //    out = ((2 - alpha) * ema1 - ema2) / (1 - alpha)
            //    out

            //basis = _mnma(src, length)
            //dev = mult * _mnma(src - basis, length)

            //upper = basis + dev
            //lower = basis - dev

            //plot(basis, title = "Basis", color = color.maroon, transp = 0)
            //upperBandPlot = plot(upper, title = "Upper", linewidth = 2, color = color.blue)
            //lowerBandPlot = plot(lower, title = "Lower", linewidth = 2, color = color.orange)
            //fill(upperBandPlot, lowerBandPlot, title = "Background", color = color.new(#ffd966, 90))

            //barColor =
            //     barColoringType == "Upper > Lower" ? (upper > lower ? color.lime : color.red) :
            //     barColoringType == "Close Above/Below Basis" ? (close > basis ? color.lime : color.red) :
            //     barColoringType == "Close Inside Cloud" ? (min(upper, lower) < close and close < max(upper, lower) ? color.lime : color.red) :
            //     barColoringType == "Wicks Inside Cloud" ? (min(upper, lower) < low and high < max(upper, lower) ? color.lime : color.red) :
            //     na

            //barcolor(barColor, title = "Bar Color")
            List<decimal> upperList = new();
            List<decimal> lowerList = new();
            List<decimal> devList = new();
            List<decimal> diffList = new();
            List<decimal> diffMaList = new();
            List<Signal> signalsList = new();

            try
            {
                var basisList = GetMovingAverageList(maType, null, stockDataClass, days);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal basis = basisList.ElementAtOrDefault(i);
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);

                    decimal diff = currentValue - basis;
                    diffList.Add(diff);
                }

                diffMaList = GetMovingAverageList(maType, diffList, stockDataClass, days);
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal diffMa = diffMaList.ElementAtOrDefault(j);
                    decimal basis = basisList.ElementAtOrDefault(j);

                    decimal dev = 2 * diffMa;
                    devList.Add(dev);

                    decimal upper = basis + dev;
                    upperList.Add(upper);

                    decimal lower = basis - dev;
                    lowerList.Add(lower);

                    var signal = GetConditionSignal(upper > lower && upper > basis, lower > upper && lower > basis);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (diffMaList, devList, upperList, lowerList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateDEnvelope(StockData stockDataClass, int days = 20)
        {
            //
            // @author LazyBear 
            // List of all my indicators: https://www.tradingview.com/v/4IneGo8h/
            //
            //study("DEnvelope [LazyBear]", shorttitle = "DENV_LB", overlay = true)
            //lb = input(20, title = "DEnvelope lookback length")
            //de = input(2, title = "DEnvelope band deviation")
            //alp = 2 / (lb + 1)
            //src = hlc3
            //mt = alp * src + (1 - alp) * nz(mt[1])
            //ut = alp * mt + (1 - alp) * nz(ut[1])
            //dt = ((2 - alp) * mt - ut) / (1 - alp)
            //mt2 = alp * abs(src - dt) + (1 - alp) * nz(mt2[1])
            //ut2 = alp * mt2 + (1 - alp) * nz(ut2[1])
            //dt2 = ((2 - alp) * mt2 - ut2) / (1 - alp)
            //but = dt + de * dt2
            //blt = dt - de * dt2
            //bbw = (but-blt)/dt
            //dbr = but>blt?(src - blt)/(but - blt)%cutoff:0
            decimal de = 2;
            List<decimal> mtList = new();
            List<decimal> utList = new();
            List<decimal> dtList = new();
            List<decimal> mt2List = new();
            List<decimal> ut2List = new();
            List<decimal> dt2List = new();
            List<decimal> butList = new();
            List<decimal> bltList = new();
            List<decimal> bbwList = new();
            List<decimal> dbrList = new();
            List<decimal> innerUpperList = new();
            List<decimal> innerLowerList = new();
            List<Signal> signalsList = new();

            try
            {
                decimal alp = (decimal)2 / (days + 1);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal prevMt = mtList.LastOrDefault();
                    decimal mt = (alp * currentValue) + ((1 - alp) * prevMt);
                    mtList.Add(mt);

                    decimal prevUt = utList.LastOrDefault();
                    decimal ut = (alp * mt) + ((1 - alp) * prevUt);
                    utList.Add(ut);

                    decimal prevDt = dtList.LastOrDefault();
                    decimal dt = (2 - alp) * (mt - ut) / (1 - alp);
                    dtList.Add(dt);

                    decimal prevMt2 = mt2List.LastOrDefault();
                    decimal mt2 = (alp * Math.Abs(currentValue - dt)) + ((1 - alp) * prevMt2);
                    mt2List.Add(mt2);

                    decimal prevUt2 = ut2List.LastOrDefault();
                    decimal ut2 = (alp * mt2) + ((1 - alp) * prevUt2);
                    ut2List.Add(ut2);

                    decimal dt2 = ((2 - alp) * (mt2 - ut2)) / (1 - alp);
                    dt2List.Add(dt2);

                    decimal prevBut = butList.LastOrDefault();
                    decimal but = dt + (de * dt2);
                    butList.Add(but);

                    decimal innerUpperBand = dt + dt2;
                    innerUpperList.Add(innerUpperBand);

                    decimal prevBlt = bltList.LastOrDefault();
                    decimal blt = dt - (de * dt2);
                    bltList.Add(blt);

                    decimal innerLowerBand = dt - dt2;
                    innerLowerList.Add(innerLowerBand);

                    decimal bbw = dt != 0 ? (but - blt) / dt : 0;
                    bbwList.Add(bbw);

                    decimal dbr = but - blt != 0 ? (currentValue - blt) / (but - blt) : 0;
                    dbrList.Add(dbr);

                    var signal = GetBollingerBandsSignal(currentValue - dt, prevValue - prevDt, currentValue, prevValue, but, prevBut, blt, prevBlt);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (utList, dtList, mt2List, ut2List, dt2List, butList, bltList, bbwList, dbrList, innerUpperList, innerLowerList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateTrigonometricOscillator(StockData stockDataClass, int days = 200)
        {
            //@version=3
            //study("Trigonometric Oscillator")
            //length = input(200)
            //
            //pi = 3.14159265359
            //
            //s = linreg(close, length, 0)
            //r = n
            //wa = asin(sign(change(s))) * 2
            //wb = asin(sign(change(r))) * 2
            //u = linreg(wa + 2 * pi * round((wa - wb) / (2 * pi)), length, 0)
            //o = atan(u)
            //
            //plot(o, color =#e91e63,linewidth=2,transp=0)
            //hline(1)
            //hline(-1)
            List<decimal> waList = new();
            List<decimal> wbList = new();
            List<decimal> uList = new();
            List<decimal> oList = new();
            List<decimal> uLinregList = new();
            List<Signal> signalsList = new();

            try
            {
                var sList = CalculateLinearRegression(null, stockDataClass, days).Item15;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal s = sList.ElementAtOrDefault(i);
                    decimal prevS = i >= 1 ? sList.ElementAtOrDefault(i - 1) : 0;

                    decimal wa = Asin((decimal)Math.Sign(s - prevS)) * 2;
                    waList.Add(wa);

                    decimal wb = Asin((decimal)Math.Sign(1)) * 2;
                    wbList.Add(wb);

                    decimal u = wa + (decimal)(2 * Math.PI * Math.Round((double)(wa - wb) / (2 * Math.PI)));
                    uList.Add(u);
                }

                uLinregList = CalculateLinearRegression(uList, stockDataClass, days).Item15;
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal u = uLinregList.ElementAtOrDefault(j);
                    decimal prevO1 = j >= 1 ? oList.ElementAtOrDefault(j - 1) : 0;
                    decimal prevO2 = j >= 2 ? oList.ElementAtOrDefault(j - 2) : 0;

                    decimal o = Atan(u);
                    oList.Add(o);

                    var signal = GetRsiSignal(o - prevO1, prevO1 - prevO2, o, prevO1, 1, -1);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (waList, wbList, uList, uLinregList, oList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateUniChannel(StockData stockDataClass, string maType, int days = 10)
        {
            //input = price (user defined, default is closing price)
            //method = moving average (user defined, default is SMA)
            //period = user defined, default is 10
            //ubFac = user defined, default is .02
            //lbFac = user defined, default is .02
            //type1 = user defined, default is false
            //ma = moving average

            //ma = ma(method, period, input);
            //if (type1) ub = ma + ubFac; lb = ma - lbFac;
            //else ub = ma + (ma * ubFac); lb = ma - (ma * lbFac);
            //Plot1: ub;
            //Plot2: ma;
            //Plot3: lb;
            //Signals
            //buy = low lessThan lb;
            //sell = high moreThan ub;
            decimal ubFac = 0.02m, lbFac = 0.02m, innerFac = 0.01m;
            bool type1 = false;
            List<decimal> upperBandList = new();
            List<decimal> lowerBandList = new();
            List<decimal> innerUpperBandList = new();
            List<decimal> innerLowerBandList = new();
            List<Signal> signalsList = new();

            try
            {
                List<decimal> smaList = GetMovingAverageList(maType, null, stockDataClass, days);

                for (int i = 0; i < smaList.Count; i++)
                {
                    decimal currentSma = smaList.ElementAtOrDefault(i);
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevSma = i >= 1 ? smaList.ElementAtOrDefault(i - 1) : 0;

                    decimal prevUb = upperBandList.LastOrDefault();
                    decimal ub = type1 ? currentSma + ubFac : currentSma + (currentSma * ubFac);
                    upperBandList.Add(ub);

                    decimal prevLb = lowerBandList.LastOrDefault();
                    decimal lb = type1 ? currentSma - lbFac : currentSma - (currentSma * lbFac);
                    lowerBandList.Add(lb);

                    decimal innerUb = currentSma + (currentSma * innerFac);
                    innerUpperBandList.Add(innerUb);

                    decimal innerLb = currentSma - (currentSma * innerFac);
                    innerLowerBandList.Add(innerLb);

                    var signal = GetBollingerBandsSignal(currentValue - currentSma, prevValue - prevSma, currentValue, prevValue, ub, prevUb, lb, prevLb);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (upperBandList, lowerBandList, innerUpperBandList, innerLowerBandList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateMovingAverageEnvelope(StockData stockDataClass, string maType, int days = 20)
        {
            //Upper Envelope: 20-day SMA + (20-day SMA x .025)
            //Lower Envelope: 20 - day SMA - (20 - day SMA x .025)
            List<decimal> upperEnvelopeList = new();
            List<decimal> lowerEnvelopeList = new();
            List<decimal> factorList = new();
            List<Signal> signalsList = new();

            try
            {
                List<decimal> smaList = GetMovingAverageList(maType, null, stockDataClass, days);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentSma20 = smaList.ElementAtOrDefault(i);
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevSma20 = i >= 1 ? smaList.ElementAtOrDefault(i - 1) : 0;

                    decimal factor = currentSma20 * 0.025m;
                    factorList.Add(factor);

                    decimal upperEnvelope = currentSma20 + factor;
                    upperEnvelopeList.Add(upperEnvelope);

                    decimal lowerEnvelope = currentSma20 - factor;
                    lowerEnvelopeList.Add(lowerEnvelope);

                    var signal = GetCompareSignal(currentValue - currentSma20, prevValue - prevSma20);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (factorList, upperEnvelopeList, lowerEnvelopeList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateSmartEnvelope(StockData stockDataClass, int days = 14)
        {
            //@version=4
            //study("Smart Envelope", overlay = true)
            //length = input(14),factor = input(1., minval = 0),src = input(close)
            //----
            //signa = 0.,signb = 0.,diff = abs(change(src))
            //a = 0.,a:= max(src, nz(a[1], src)) - min(abs(src - nz(a[1], src)), diff) / length * nz(signa[1])
            //b = 0.,b:= min(src, nz(b[1], src)) + min(abs(src - nz(b[1], src)), diff) / length * nz(signb[1])
            //signa:= b < b[1] ? -factor : factor
            //signb:= a > a[1] ? -factor : factor
            //----
            //plot(a, "Upper", color = color.blue, linewidth = 2, transp = 0)
            //plot(avg(a, b), "Average", color =#f57f17,linewidth=2,transp=0)
            //plot(b, "Lower", color =#ff1100,linewidth=2,transp=0)
            List<decimal> aList = new();
            List<decimal> bList = new();
            List<decimal> aSignalList = new();
            List<decimal> bSignalList = new();
            List<decimal> avgList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevA = i >= 1 ? aList.ElementAtOrDefault(i - 1) : currentValue;
                    decimal prevB = i >= 1 ? bList.ElementAtOrDefault(i - 1) : currentValue;
                    decimal prevASignal = aSignalList.LastOrDefault();
                    decimal prevBSignal = bSignalList.LastOrDefault();
                    decimal diff = Math.Abs(currentValue - prevValue);

                    decimal a = Math.Max(currentValue, prevA) - (Math.Min(Math.Abs(currentValue - prevA), diff) / days * prevASignal);
                    aList.Add(a);

                    decimal b = Math.Min(currentValue, prevB) + (Math.Min(Math.Abs(currentValue - prevB), diff) / days * prevBSignal);
                    bList.Add(b);

                    decimal aSignal = b < prevB ? -1 : 1;
                    aSignalList.Add(aSignal);

                    decimal bSignal = a > prevA ? -1 : 1;
                    bSignalList.Add(bSignal);

                    decimal prevAvg = avgList.LastOrDefault();
                    decimal avg = (a + b) / 2;
                    avgList.Add(avg);

                    var signal = GetCompareSignal(currentValue - avg, prevValue - prevAvg);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (aList, bList, aSignalList, bSignalList, avgList, signalsList);
        }

        public static (List<decimal>, List<Signal>) CalculateMovingAverageChannel(StockData stockDataClass, string maType, int days = 20)
        {
            //@version=3
            // Copyright (c) 2017-present, Alex Orekhov (everget)
            // Moving Average Channel indicator script may be freely distributed under the MIT license.
            //study("Moving Average Channel", shorttitle = "MAC", overlay = true)

            //upperSrc = input(title = "Upper Source", type = source, defval = high)
            //upperLength = input(title = "Upper Length", type = integer, defval = 20)
            //upperOffset = input(title = "Upper Offset", type = integer, defval = 0)

            //upperMA = sma(upperSrc, upperLength)

            //lowerSrc = input(title = "Lower Source", type = source, defval = low)
            //lowerLength = input(title = "Lower Length", type = integer, defval = 20)
            //lowerOffset = input(title = "Lower Offset", type = integer, defval = 0)

            //lowerMA = sma(lowerSrc, lowerLength)

            //plot(upperMA, title = "Upper", color =#3c78d8, transp=0, offset=upperOffset)
            //plot(lowerMA, title = "Lower", color =#e69138, transp=0, offset=lowerOffset)
            List<decimal> midChannelList = new();
            List<Signal> signalsList = new();

            try
            {
                var highMaList = GetMovingAverageList(maType, stockDataClass.HighPrices, stockDataClass, days);
                var lowMaList = GetMovingAverageList(maType, stockDataClass.LowPrices, stockDataClass, days);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal upperChannel = highMaList.ElementAtOrDefault(i);
                    decimal lowerChannel = lowMaList.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal prevMidChannel = midChannelList.LastOrDefault();
                    decimal midChannel = (upperChannel + lowerChannel) / 2;
                    midChannelList.Add(midChannel);

                    var signal = GetCompareSignal(currentValue - midChannel, prevValue - prevMidChannel);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (midChannelList, signalsList);
        }

        public static (List<decimal>, List<Signal>) CalculatePercentageTrend(StockData stockDataClass, int days = 15)
        {
            //Max_per = max period, user defined, default is 20
            //K = percent K, user defined, default is 15
            //MT = more than, MOE = more or equal
            //LT = less than, LOE = less or equal

            //C = close;
            //Trend = C;
            //Period = 0;
            //prevC = C;
            //for (int i = 1; i LT size(); i++) 
            //prevC = C;
            //C = getClose(i);
            //SetUp Period When New Trend Begin
            //if ((prevC LOE Trend AND C MT Trend)  OR(prevC MOE Trend AND C LT Trend) ) 
            //Period = 0;
            //endIf
            //if (Period LT Max_per ) //Counting UpTrends with dynamic period
            //if (C MT Trend) 
            //Period = Period + 1;
            //high = C;
            //for (int j = i - Period; j LOE i; j++)
            //jclose = getClose(j);
            //if (jclose MT high) high = jclose;
            //endFor
            //Trend = high * (1 - (K / 100));
            //endIf
            //Counting DownTrends with dynamic period
            //if (C LOE Trend) 
            //Period = Period + 1;
            //ilow = C;
            //for (int j = i - Period; j LOE i; j++) 
            //jclose = series.getClose(j);
            //if (jclose MT low) low = jclose;
            //endFor
            //endIf
            //Trend = ilow * (1 + (K / 100));
            //else  //Counting UpTrends with constant period
            //if (C MT Trend) 
            //ihigh = C;
            //for (int j = i - Max_per; j LOE i; j++) 
            //jclose = getClose(j);
            //if (jclose MT high) high = jclose;
            //endFor
            //Trend = ihigh * (1 - (K / 100));
            //endIf
            //Counting DownTrends with constant period
            //if (C LOE Trend) 
            //ilow = C;
            //for (int j = i - Max_per; j LOE i; j++) 
            //jclose = getClose(j);
            //if (jclose LT low) low = jclose;
            //endFor
            //Trend = ilow * (1 + (K / 100));
            //TP = Period; ;
            //Plot: Trend;
            //endif
            //endIf
            //endFor
            List<decimal> trendList = new();
            List<decimal> tempList = new();
            List<Signal> signalsList = new();

            try
            {
                decimal k = days, trend = 0;
                int period = (int)Math.Ceiling(days / 0.75);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    tempList.Add(currentValue);

                    period = (prevValue <= trend && currentValue > trend) || (prevValue >= trend && currentValue < trend) ? period = 0 : period;
                    period = period < days ? period + 1 : period;

                    decimal highest = period < days && currentValue > trend ? tempList.TakeLast(period).Max() : tempList.TakeLast(days).Max();
                    decimal lowest = period < days && currentValue <= trend ? tempList.TakeLast(period).Min() : tempList.TakeLast(days).Min();

                    decimal prevTrend = trendList.LastOrDefault();
                    trend = currentValue > trend ? highest * (1 - (k / 100)) : lowest * (1 + (k / 100));
                    trendList.Add(trend);

                    var signal = GetCompareSignal(currentValue - trend, prevValue - prevTrend);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (trendList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateVanillaABCDPattern(StockData stockDataClass)
        {
            // This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
            // © alexgrover

            //@version=4
            //study("Vanilla ABCD Pattern", overlay = true)
            //src = input(close),cnd = input(false, "Confirmation")
            //bar = input(true, "Last Bar Repaint")
            //----
            //up = src[3] > src[2] and src[1] > src[2] and src<src[2] 
            //dn = src[3] < src[2] and src[1] < src[2] and src > src[2]
            //os = 0,os:= up ? 1 : dn ? 0 : os[1]
            //f = 0,f:= os == 1 and close > open ? 1 : os == 0 and close<open ? 0 : f[1]
            //d = cnd ? change(f) : change(os)
            //----
            //plotshape(d == 1, "Up", shape.labelup, location.belowbar,
            //#2196f3,0,bar?0:1,text="↗",textcolor=color.white)
            //plotshape(d == -1, "dn", shape.labeldown, location.abovebar,
            //# ff1100,0,bar?0:1,text="↘",textcolor=color.white)
            List<decimal> osList = new();
            List<decimal> fList = new();
            List<decimal> upList = new();
            List<decimal> dnList = new();
            List<decimal> dfList = new();
            List<decimal> dosList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentOpen = stockDataClass.OpenPrices.ElementAtOrDefault(i);
                    decimal currentClose = stockDataClass.ClosePrices.ElementAtOrDefault(i);
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue1 = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevValue2 = i >= 2 ? stockDataClass.InputValues.ElementAtOrDefault(i - 2) : 0;
                    decimal prevValue3 = i >= 3 ? stockDataClass.InputValues.ElementAtOrDefault(i - 3) : 0;

                    decimal up = prevValue3 > prevValue2 && prevValue1 > prevValue2 && currentValue < prevValue2 ? 1 : 0;
                    upList.Add(up);

                    decimal dn = prevValue3 < prevValue2 && prevValue1 < prevValue2 && currentValue > prevValue2 ? 1 : 0;
                    dnList.Add(dn);

                    decimal prevOs = osList.LastOrDefault();
                    decimal os = up == 1 ? 1 : dn == 1 ? 0 : prevOs;
                    osList.Add(os);

                    decimal prevF = fList.LastOrDefault();
                    decimal f = os == 1 && currentClose > currentOpen ? 1 : os == 0 && currentClose < currentOpen ? 0 : prevF;
                    fList.Add(f);

                    decimal df = f - prevF;
                    dfList.Add(df);

                    decimal prevDos = dosList.LastOrDefault();
                    decimal dos = os - prevOs;
                    dosList.Add(dos);

                    var signal = GetCompareSignal(dos, prevDos);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (upList, dnList, osList, fList, dfList, dosList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculatePivotPointAverage(StockData stockDataClass, int days = 3)
        {
            //method = moving average, user defined, default is SMA
            //period = user defined, default is 3
            //priceM = price Method, user defined, default is 1
            //prev = previous, index = current bar number

            //prevH = high[index - 1];
            //prevL = low[index - 1];
            //prevC = close[index - 1];
            //pp = (prevH + prevL + prevC) / 3;
            //if (priceM == 1) pp = (prevH + prevL + prevC) / 3;
            //if (priceM == 2) pp = (prevH + prevL + prevC + open) / 4;
            //if (priceM == 3) pp = (prevH + prevL + open) / 3;
            //plot1: pp;
            //plot2: ppav = ma(method, period, pp);
            //Signals
            //sell = crossedAbove(PP, PPAV);
            //buy = crossedBelow(PP, PPAV);
            List<decimal> pp1List = new();
            List<decimal> pp2List = new();
            List<decimal> pp3List = new();
            List<decimal> ppav1List = new();
            List<decimal> ppav2List = new();
            List<decimal> ppav3List = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.HighPrices.Count; i++)
                {
                    decimal currentOpen = stockDataClass.OpenPrices.ElementAtOrDefault(i);
                    decimal prevHigh = i >= 1 ? stockDataClass.HighPrices.ElementAtOrDefault(i - 1) : 0;
                    decimal prevLow = i >= 1 ? stockDataClass.LowPrices.ElementAtOrDefault(i - 1) : 0;
                    decimal prevClose = i >= 1 ? stockDataClass.ClosePrices.ElementAtOrDefault(i - 1) : 0;

                    decimal prevPp1 = pp1List.LastOrDefault();
                    decimal pp1 = (prevHigh + prevLow + prevClose) / 3;
                    pp1List.Add(pp1);

                    decimal prevPpav1 = ppav1List.LastOrDefault();
                    decimal ppav1 = pp1List.TakeLast(days).Average();
                    ppav1List.Add(ppav1);

                    decimal pp2 = (prevHigh + prevLow + prevClose + currentOpen) / 4;
                    pp2List.Add(pp2);

                    decimal ppav2 = pp2List.TakeLast(days).Average();
                    ppav2List.Add(ppav2);

                    decimal pp3 = (prevHigh + prevLow + currentOpen) / 3;
                    pp3List.Add(pp3);

                    decimal ppav3 = pp3List.TakeLast(days).Average();
                    ppav3List.Add(ppav3);

                    var signal = GetCompareSignal(pp1 - ppav1, prevPp1 - prevPpav1);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (pp1List, ppav1List, pp2List, ppav2List, pp3List, ppav3List, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateMovingAverageDisplacedEnvelope(StockData stockDataClass, string maType, int days = 9)
        {
            //input = price, user defined, default is closing price
            //method = moving average, user defined, default is EMA
            //period = user defined, default is 9
            //perAb = percent above = user defined, default is .5
            //perBl = percent below = user defined, default is .5
            //disp = displacement = user defined, default is 13
            //index = current bar number
            //ma = moving average, prev = previous

            //Plot1: top = ma(method, index - disp, period, input) * ((100 + perAb) / 100);
            //Plot2: bott = ma(method, index - disp, period, input) * ((100 - perBl) / 100);
            //Signals
            //prevHigh = high[1];
            //prevLow = low[1];
            //sell = prevHigh moreThan top;
            //buy = prevLow lessThan bott;
            List<decimal> upperEnvelopeList = new();
            List<decimal> lowerEnvelopeList = new();
            List<decimal> middleEnvelopeList = new();
            List<Signal> signalsList = new();

            try
            {
                decimal perAb = 0.5m, perBl = 0.5m;
                int period = days;
                int disp = (int)Math.Ceiling(period / 0.6923);

                var emaList = GetMovingAverageList(maType, null, stockDataClass, days);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentEma = emaList.ElementAtOrDefault(i);
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevEma = i >= disp ? emaList.ElementAtOrDefault(i - disp) : 0;

                    decimal prevUpperEnvelope = upperEnvelopeList.LastOrDefault();
                    decimal upperEnvelope = prevEma * ((100 + perAb) / 100);
                    upperEnvelopeList.Add(upperEnvelope);

                    decimal prevLowerEnvelope = lowerEnvelopeList.LastOrDefault();
                    decimal lowerEnvelope = prevEma * ((100 - perBl) / 100);
                    lowerEnvelopeList.Add(lowerEnvelope);

                    decimal prevMiddleEnvelope = middleEnvelopeList.LastOrDefault();
                    decimal middleEnvelope = (upperEnvelope + lowerEnvelope) / 2;
                    middleEnvelopeList.Add(middleEnvelope);

                    var signal = GetBollingerBandsSignal(currentValue - middleEnvelope, prevValue - prevMiddleEnvelope, currentValue, prevValue,
                        upperEnvelope, prevUpperEnvelope, lowerEnvelope, prevLowerEnvelope);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (upperEnvelopeList, lowerEnvelopeList, middleEnvelopeList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateParabolicSAR(StockData stockDataClass)
        {
            //@version=4
            //strategy("Parabolic SAR Strategy", overlay = true)

            //start = input(0.02)
            //increment = input(0.02)
            //maximum = input(0.2)

            //var bool uptrend = na
            //var float EP = na
            //var float SAR = na
            //var float AF = start
            //var float nextBarSAR = na

            //if bar_index > 0
            //    firstTrendBar = false
            //    SAR:= nextBarSAR

            //if bar_index == 1
            //    float prevSAR = na
            //    float prevEP = na
            //    lowPrev = low[1]
            //    highPrev = high[1]
            //    closeCur = close
            //    closePrev = close[1]

            //if closeCur > closePrev
            //    uptrend:= true
            //    EP:= high
            //    prevSAR:= lowPrev
            //    prevEP:= high
            //else
            //    uptrend:= false
            //    EP:= low
            //    prevSAR:= highPrev
            //    prevEP:= low

            //firstTrendBar:= true
            //SAR:= prevSAR + start * (prevEP - prevSAR)

            //if uptrend
            //    if SAR > low
            //        firstTrendBar:= true
            //        uptrend:= false
            //        SAR:= max(EP, high)
            //        EP:= low
            //        AF:= start
            //else
            //    if SAR < high
            //        firstTrendBar:= true
            //        uptrend:= true
            //        SAR:= min(EP, low)
            //        EP:= high
            //        AF:= start

            //if not firstTrendBar
            //    if uptrend
            //        if high > EP
            //            EP:= high
            //            AF:= min(AF + increment, maximum)
            //    else
            //        if low < EP
            //            EP:= low
            //            AF:= min(AF + increment, maximum)

            //if uptrend
            //    SAR:= min(SAR, low[1])
            //    if bar_index > 1
            //        SAR:= min(SAR, low[2])
            //else
            //        SAR:= max(SAR, high[1])
            //    if bar_index > 1
            //        SAR:= max(SAR, high[2])

            //nextBarSAR:= SAR + AF * (EP - SAR)

            //if barstate.isconfirmed
            //    if uptrend
            //        strategy.entry("ParSE", strategy.short, stop = nextBarSAR, comment = "ParSE")
            //        strategy.cancel("ParLE")
            //    else
            //        strategy.entry("ParLE", strategy.long, stop = nextBarSAR, comment = "ParLE")
            //        strategy.cancel("ParSE")

            //plot(SAR, style=plot.style_cross, linewidth=3, color=color.orange)
            //plot(nextBarSAR, style=plot.style_cross, linewidth=3, color=color.aqua)
            //plot(strategy.equity, title="equity", color=color.red, linewidth=2, style=plot.style_areabr)
            decimal start = 0.02m, increment = 0.02m, maximum = 0.2m;
            List<decimal> sarList = new();
            List<decimal> nextSarList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.HighPrices.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal currentHigh = stockDataClass.HighPrices.ElementAtOrDefault(i);
                    decimal currentLow = stockDataClass.LowPrices.ElementAtOrDefault(i);
                    decimal prevHigh1 = i >= 1 ? stockDataClass.HighPrices.ElementAtOrDefault(i - 1) : 0;
                    decimal prevLow1 = i >= 1 ? stockDataClass.LowPrices.ElementAtOrDefault(i - 1) : 0;
                    decimal prevHigh2 = i >= 2 ? stockDataClass.HighPrices.ElementAtOrDefault(i - 2) : 0;
                    decimal prevLow2 = i >= 2 ? stockDataClass.LowPrices.ElementAtOrDefault(i - 2) : 0;

                    bool uptrend = false;
                    decimal ep = 0, prevSAR = 0, prevEP = 0, SAR = 0, af = start;
                    if (currentValue > prevValue)
                    {
                        uptrend = true;
                        ep = currentHigh;
                        prevSAR = prevLow1;
                        prevEP = currentHigh;
                    }
                    else
                    {
                        uptrend = false;
                        ep = currentLow;
                        prevSAR = prevHigh1;
                        prevEP = currentLow;
                    }

                    SAR = prevSAR + (start * (prevEP - prevSAR));

                    if (uptrend)
                    {
                        if (SAR > currentLow)
                        {
                            uptrend = false;
                            SAR = Math.Max(ep, currentHigh);
                            ep = currentLow;
                            af = start;
                        }
                    }
                    else
                    {
                        if (SAR < currentHigh)
                        {
                            uptrend = true;
                            SAR = Math.Min(ep, currentLow);
                            ep = currentHigh;
                            af = start;
                        }
                    }

                    if (uptrend)
                    {
                        if (currentHigh > ep)
                        {
                            ep = currentHigh;
                            af = Math.Min(af + increment, maximum);
                        }
                    }
                    else
                    {
                        if (currentLow < ep)
                        {
                            ep = currentLow;
                            af = Math.Min(af + increment, maximum);
                        }
                    }

                    if (uptrend)
                    {
                        SAR = i > 1 ? Math.Min(SAR, prevLow2) : Math.Min(SAR, prevLow1);
                    }
                    else
                    {
                        SAR = i > 1 ? Math.Max(SAR, prevHigh2) : Math.Max(SAR, prevHigh1);
                    }
                    sarList.Add(SAR);

                    decimal prevNextSar = nextSarList.LastOrDefault();
                    decimal nextSar = SAR + (af * (ep - SAR));
                    nextSarList.Add(nextSar);

                    var signal = GetCompareSignal(currentHigh - nextSar, prevHigh1 - prevNextSar);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (sarList, nextSarList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculatePriceVolumeRank(StockData stockDataClass, int days = 5)
        {
            //
            // @author LazyBear 
            // List of all my indicators: 
            // https://docs.google.com/document/d/15AGCufJZ8CIUvwFJ9W-IKns88gkWOKBCvByMEvm5MLo/edit?usp=sharing
            // 
            //study("Price Volume Rank [LazyBear]", shorttitle = "PVR_LB", overlay = false)
            //showMA = input(true, title = "Show MA Crossovers")
            //ma1 = input(5, title = "Fast MA Length", defval = 5),ma2 = input(10, title = "Slow MA Length", defval = 10)
            //dblSmoothing = input(false, title = "decimal Smoothing")
            //pvr = iff(close > close[1] and volume > volume[1], 1,
            //    iff(close > close[1] and volume <= volume[1], 2,
            //    iff(close <= close[1] and volume <= volume[1], 3, 4)))
            //ux = pvr > 3.0 ? pvr : na,lx = pvr < 2.0 ? pvr : na
            //u = plot(showMA ? na : na(volume) ? na : 2.0, color = green, title = "BullLine")
            //l = plot(showMA ? na : na(volume) ? na : 3.0, color = red, title = "BearLine")
            //fill(u, l, gray)
            //mal = plot(showMA ? na(volume) ? na : 2.5 : na, color = gray, title = "MACutoff")
            //plot(showMA ? na : na(volume) ? na : pvr, style = histogram, histbase = 2, color = pvr > 3.0 ? red : pvr < 2.0 ? green : gray, linewidth = 2, transp = 40, title = "PVR")
            //plot(showMA ? na : na(volume) ? na : pvr, style = circles, color = pvr >= 3.0 ? red : pvr <= 2.0 ? green : gray, linewidth = 4, title = "PVR Points")
            //sma1 = not showMA? na:dblSmoothing? sma(sma(pvr, ma1), ma1):sma(pvr, ma1), sma2 = not showMA? na:dblSmoothing? sma(sma(pvr, ma2), ma2):sma(pvr, ma2)
            //plot(showMA ? na(volume) ? na : sma1 : na, style = linebr, color = red, linewidth = 2, title = "Fast MA")
            //plot(showMA ? na(volume) ? na : sma2 : na, style = linebr, color = green, linewidth = 1, title = "Slow MA")
            //x = na(volume) ? (nz(x[1]) + 0.4) % 4.0 : na
            //plotshape(na(volume) ? x : na, style = shape.circle, color = red, text = "No volume", location = location.absolute, title = "ErrorText")
            List<decimal> pvrList = new();
            List<decimal> fastSmaList = new();
            List<decimal> slowSmaList = new();
            List<Signal> signalsList = new();

            try
            {
                int ma2 = MinOrMax(days * 2);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal currentVolume = stockDataClass.Volumes.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevVolume = i >= 1 ? stockDataClass.Volumes.ElementAtOrDefault(i - 1) : 0;

                    decimal pvr = currentValue > prevValue && currentVolume > prevVolume ? 1 : currentValue > prevValue && currentVolume <= prevVolume ? 2 :
                        currentValue <= prevValue && currentVolume <= prevVolume ? 3 : 4;
                    pvrList.Add(pvr);

                    decimal prevFastSma = fastSmaList.LastOrDefault();
                    decimal fastSma = pvrList.TakeLast(days).Average();
                    fastSmaList.Add(fastSma);

                    decimal prevSlowSma = slowSmaList.LastOrDefault();
                    decimal slowSma = pvrList.TakeLast(ma2).Average();
                    slowSmaList.Add(slowSma);

                    var signal = GetCompareSignal(fastSma - slowSma, prevFastSma - prevSlowSma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (pvrList, fastSmaList, slowSmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>)
            CalculatePriceVolumeOscillator(StockData stockDataClass, int days = 14)
        {
            // This code may be reused freely, without permission.

            //@version=4
            //study("Price/Volume Oscillator", "PVO")
            //pl = input(50, "Price Length"),vl = input(14, "Volume Length"),src = input(close)
            //----
            //v = volume
            //a = mom(src, pl)
            //b = mom(v, vl)
            //osca = sum(a, pl) / sum(abs(a), pl)
            //oscb = sum(b, vl) / sum(abs(b), vl)
            //----
            //css = osca > 0 and oscb > 0 ? #0cb51a:
            //  osca < 0 and oscb > 0 ? #ff1100 : na
            //A = plot(oscb, "Volume",#2157f3)
            //B = plot(osca, "Price", fixnan(css))
            //fill(A, B, fixnan(css), 75)
            //hline(0.8)
            //hline(-0.8)
            List<decimal> aList = new();
            List<decimal> bList = new();
            List<decimal> aSumList = new();
            List<decimal> bSumList = new();
            List<decimal> absAList = new();
            List<decimal> absBList = new();
            List<decimal> absASumList = new();
            List<decimal> absBSumList = new();
            List<decimal> oscAList = new();
            List<decimal> oscBList = new();
            List<Signal> signalsList = new();

            try
            {
                int pl = (int)Math.Ceiling(days / 0.28);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal currentVolume = stockDataClass.Volumes.ElementAtOrDefault(i);
                    decimal prevValue = i >= pl ? stockDataClass.InputValues.ElementAtOrDefault(i - pl) : 0;
                    decimal prevVolume = i >= days ? stockDataClass.Volumes.ElementAtOrDefault(i - days) : 0;

                    decimal a = currentValue - prevValue;
                    aList.Add(a);

                    decimal b = currentVolume - prevVolume;
                    bList.Add(b);

                    decimal absA = Math.Abs(a);
                    absAList.Add(absA);

                    decimal absB = Math.Abs(b);
                    absBList.Add(absB);

                    decimal aSum = aList.TakeLast(pl).Sum();
                    aSumList.Add(aSum);

                    decimal bSum = bList.TakeLast(days).Sum();
                    bSumList.Add(bSum);

                    decimal absASum = absAList.TakeLast(pl).Sum();
                    absASumList.Add(absASum);

                    decimal absBSum = absBList.TakeLast(days).Sum();
                    absBSumList.Add(absBSum);

                    decimal oscA = absASum != 0 ? aSum / absASum : 0;
                    oscAList.Add(oscA);

                    decimal oscB = absBSum != 0 ? bSum / absBSum : 0;
                    oscBList.Add(oscB);

                    var signal = GetConditionSignal(oscA > 0 && oscB > 0, oscA < 0 && oscB > 0);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (aList, bList, absAList, absBList, aSumList, bSumList, absASumList, absBSumList, oscAList, oscBList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<decimal>, List<decimal>, List<Signal>) CalculateFloorPivotPoints(StockData stockDataClass)
        {
            ////////////////////////////////////////////////////////////
            //  Copyright by HPotter v1.0 26/06/2018
            // The name ‘Floor-Trader Pivot,’ came from the fact that Pivot points can 
            // be calculated quickly, on the fly using price data from the previous day 
            // as an input. Although time-frames of less than a day can be used, Pivots are 
            // commonly plotted on the Daily Chart; using price data from the previous day’s 
            // trading activity. 
            //
            // WARNING:
            //  - This script to change bars colors.
            ////////////////////////////////////////////////////////////
            //study(title = "Floor Pivot Points Strategy", shorttitle = "FPP", overlay = true)
            //width = input(2, minval = 1)
            //xHigh = security(tickerid, "D", high[1])
            //xLow = security(tickerid, "D", low[1])
            //xClose = security(tickerid, "D", close[1])
            //vPP = (xHigh + xLow + xClose) / 3
            //vR1 = (vPP * 2) - xLow
            //vS1 = (vPP * 2) - xHigh
            //pos = iff(close > vR1, 1,
            //      iff(close < vS1, -1, nz(pos[1], 0)))
            //barcolor(pos == -1 ? red : pos == 1 ? green : blue)
            List<decimal> pivotList = new();
            List<decimal> resistanceLevel3List = new();
            List<decimal> resistanceLevel2List = new();
            List<decimal> resistanceLevel1List = new();
            List<decimal> supportLevel1List = new();
            List<decimal> supportLevel2List = new();
            List<decimal> supportLevel3List = new();
            List<decimal> midpoint1List = new();
            List<decimal> midpoint2List = new();
            List<decimal> midpoint3List = new();
            List<decimal> midpoint4List = new();
            List<decimal> midpoint5List = new();
            List<decimal> midpoint6List = new();
            List<Signal> signalsList = new();

            try
            {
                var minMaxList = VolumeInputCheck(stockDataClass, 0, false);
                var highList = minMaxList.Item1;
                var lowList = minMaxList.Item2;

                for (int i = 0; i < stockDataClass.HighPrices.Count; i++)
                {
                    decimal currentClose = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevHigh = i >= 1 ? highList.ElementAtOrDefault(i) : 0;
                    decimal prevLow = i >= 1 ? lowList.ElementAtOrDefault(i) : 0;
                    decimal prevClose = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i) : 0;

                    decimal range = prevHigh - prevLow;
                    decimal pivot = (prevHigh + prevLow + prevClose) / 3;
                    pivotList.Add(pivot);

                    decimal prevSupportLevel1 = supportLevel1List.LastOrDefault();
                    decimal supportLevel1 = (pivot * 2) - prevHigh;
                    supportLevel1List.Add(supportLevel1);

                    decimal prevResistanceLevel1 = resistanceLevel1List.LastOrDefault();
                    decimal resistanceLevel1 = (pivot * 2) - prevLow;
                    resistanceLevel1List.Add(resistanceLevel1);

                    decimal prevSupportLevel2 = supportLevel2List.LastOrDefault();
                    decimal supportLevel2 = pivot - range;
                    supportLevel2List.Add(supportLevel2);

                    decimal prevResistanceLevel2 = resistanceLevel2List.LastOrDefault();
                    decimal resistanceLevel2 = pivot + range;
                    resistanceLevel2List.Add(resistanceLevel2);

                    decimal supportLevel3 = supportLevel1 - range;
                    supportLevel3List.Add(supportLevel3);

                    decimal resistanceLevel3 = resistanceLevel1 + range;
                    resistanceLevel3List.Add(resistanceLevel3);

                    decimal midpoint1 = (supportLevel3 + supportLevel2) / 2;
                    midpoint1List.Add(midpoint1);

                    decimal midpoint2 = (supportLevel2 + supportLevel1) / 2;
                    midpoint2List.Add(midpoint2);

                    decimal midpoint3 = (supportLevel1 + pivot) / 2;
                    midpoint3List.Add(midpoint3);

                    decimal midpoint4 = (resistanceLevel1 + pivot) / 2;
                    midpoint4List.Add(midpoint4);

                    decimal midpoint5 = (resistanceLevel2 + resistanceLevel1) / 2;
                    midpoint5List.Add(midpoint5);

                    decimal midpoint6 = (resistanceLevel3 + resistanceLevel2) / 2;
                    midpoint6List.Add(midpoint6);

                    var signal = GetBullishBearishSignal(currentClose - resistanceLevel1, prevClose - prevResistanceLevel1, currentClose - supportLevel1, prevClose - prevSupportLevel1);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (pivotList, supportLevel1List, resistanceLevel1List, supportLevel2List, resistanceLevel2List, supportLevel3List, resistanceLevel3List, midpoint1List,
                midpoint2List, midpoint3List, midpoint4List, midpoint5List, midpoint6List, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateDynamicPivotPoints(StockData stockDataClass)
        {
            //@version=2
            ////////////////////////////////////////////////////////////
            //  Copyright by HPotter v1.0 14/06/2018
            // This Pivot points is calculated on the current day.
            // Pivot points simply took the high, low, and closing price from the previous period and 
            // divided by 3 to find the pivot. From this pivot, traders would then base their 
            // calculations for three support, and three resistance levels. The calculation for the most 
            // basic flavor of pivot points, known as ‘floor-trader pivots’, along with their support and 
            // resistance levels.
            //
            // WARNING:
            //  - This script to change bars colors.
            ////////////////////////////////////////////////////////////
            //study(title = "Dynamic Pivot Point Strategy", shorttitle = "Dynamic Pivot Point", overlay = true)
            //width = input(2, minval = 1)
            //xHigh = security(tickerid, "D", high[1])
            //xLow = security(tickerid, "D", low[1])
            //xClose = security(tickerid, "D", close[1])
            //vPP = (xHigh + xLow + xClose) / 3
            //vR1 = vPP + (vPP - xLow)
            //vS1 = vPP - (xHigh - vPP)
            //pos = iff(close > vR1, 1,
            //      iff(close < vS1, -1, nz(pos[1], 0)))
            //barcolor(pos == -1 ? red : pos == 1 ? green : blue)
            List<decimal> resistanceLevel1List = new();
            List<decimal> supportLevel1List = new();
            List<Signal> signalsList = new();

            try
            {
                var minMaxList = VolumeInputCheck(stockDataClass, 0, false);
                var highList = minMaxList.Item1;
                var lowList = minMaxList.Item2;

                for (int i = 0; i < stockDataClass.HighPrices.Count; i++)
                {
                    decimal currentClose = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevHigh = i >= 1 ? highList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevLow = i >= 1 ? lowList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevClose = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal pivot = (prevHigh + prevLow + prevClose) / 3;

                    decimal prevSupportLevel1 = supportLevel1List.LastOrDefault();
                    decimal supportLevel1 = pivot - (prevHigh - pivot);
                    supportLevel1List.Add(supportLevel1);

                    decimal prevResistanceLevel1 = resistanceLevel1List.LastOrDefault();
                    decimal resistanceLevel1 = pivot + (pivot - prevLow);
                    resistanceLevel1List.Add(resistanceLevel1);

                    var signal = GetBullishBearishSignal(currentClose - resistanceLevel1, prevClose - prevResistanceLevel1, currentClose - supportLevel1, prevClose - prevSupportLevel1);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (supportLevel1List, resistanceLevel1List, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateWoodiePivotPoints(StockData stockDataClass)
        {
            //@version=2
            ////////////////////////////////////////////////////////////
            //  Copyright by HPotter v1.0 21/08/2018
            // Simply input the vales of the high, low and closing price of the previous 
            // period to calculate the Woodie pivot point and the associated resistance 
            // and support levels for the present period.
            //
            // WARNING:
            //  - This script to change bars colors.
            ////////////////////////////////////////////////////////////
            //study(title = "Woodie Pivot Points Strategy", overlay = true)
            //width = input(2, minval = 1)
            //xHigh = security(tickerid, "D", high[1])
            //xLow = security(tickerid, "D", low[1])
            //xClose = security(tickerid, "D", close[1])
            //xPP = (xHigh + xLow + (xClose * 2)) / 4
            //pos = iff(close[1] < xPP[1] and close > xPP, 1,
            //       iff(close < xPP, -1, nz(pos[1], 0)))
            //barcolor(pos == -1 ? red : pos == 1 ? green : blue)
            //plot(xPP, color = blue, title = "WPP", style = circles, linewidth = width)

            //from https://www.babypips.com/tools/pivot-point-calculator
            //Pivot (P) = (H + L + 2 x C) / 4
            //Resistance(R1) = (2 x P) -L
            //R2 = P + H - L
            //Support(S1) = (2 x P) -H
            //S2 = P - H + L
            List<decimal> pivotList = new();
            List<decimal> resistanceLevel1List = new();
            List<decimal> resistanceLevel2List = new();
            List<decimal> resistanceLevel3List = new();
            List<decimal> resistanceLevel4List = new();
            List<decimal> supportLevel1List = new();
            List<decimal> supportLevel2List = new();
            List<decimal> supportLevel3List = new();
            List<decimal> supportLevel4List = new();
            List<decimal> midpoint1List = new();
            List<decimal> midpoint2List = new();
            List<decimal> midpoint3List = new();
            List<decimal> midpoint4List = new();
            List<Signal> signalsList = new();

            try
            {
                var minMaxList = VolumeInputCheck(stockDataClass, 0, false);
                var highList = minMaxList.Item1;
                var lowList = minMaxList.Item2;

                for (int i = 0; i < stockDataClass.HighPrices.Count; i++)
                {
                    decimal currentClose = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevHigh = i >= 1 ? highList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevLow = i >= 1 ? lowList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevClose = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal prevPivot = pivotList.LastOrDefault();
                    decimal range = prevHigh - prevLow;
                    decimal pivot = (prevHigh + prevLow + (prevClose * 2)) / 4;
                    pivotList.Add(pivot);

                    decimal supportLevel1 = (pivot * 2) - prevHigh;
                    supportLevel1List.Add(supportLevel1);

                    decimal resistanceLevel1 = (pivot * 2) - prevLow;
                    resistanceLevel1List.Add(resistanceLevel1);

                    decimal supportLevel2 = pivot - range;
                    supportLevel2List.Add(supportLevel2);

                    decimal resistanceLevel2 = pivot + range;
                    resistanceLevel2List.Add(resistanceLevel2);

                    decimal prevSupportLevel3 = supportLevel3List.LastOrDefault();
                    decimal supportLevel3 = prevLow - (2 * (prevHigh - pivot));
                    supportLevel3List.Add(supportLevel3);

                    decimal prevResistanceLevel3 = resistanceLevel3List.LastOrDefault();
                    decimal resistanceLevel3 = prevHigh + (2 * (pivot - prevLow));
                    resistanceLevel3List.Add(resistanceLevel3);

                    decimal supportLevel4 = supportLevel3 - range;
                    supportLevel4List.Add(supportLevel4);

                    decimal resistanceLevel4 = resistanceLevel3 + range;
                    resistanceLevel4List.Add(resistanceLevel4);

                    decimal midpoint1 = (supportLevel1 + supportLevel2) / 2;
                    midpoint1List.Add(midpoint1);

                    decimal midpoint2 = (pivot + supportLevel1) / 2;
                    midpoint2List.Add(midpoint2);

                    decimal midpoint3 = (resistanceLevel1 + pivot) / 2;
                    midpoint3List.Add(midpoint3);

                    decimal midpoint4 = (resistanceLevel1 + resistanceLevel2) / 2;
                    midpoint4List.Add(midpoint4);

                    var signal = GetCompareSignal(currentClose - pivot, prevClose - prevPivot);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (pivotList, supportLevel1List, resistanceLevel1List, supportLevel2List, resistanceLevel2List, supportLevel3List, resistanceLevel3List, supportLevel4List,
                resistanceLevel4List, midpoint1List, midpoint2List, midpoint3List, midpoint4List, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateDemarkPivotPoints(StockData stockDataClass)
        {
            //@version=2
            ////////////////////////////////////////////////////////////
            //  Copyright by HPotter v1.0 16/05/2018
            // Demark Pivot Points start with a different base and use different formulas for support 
            // and resistance. These Pivot Points are conditional on the relationship between the 
            // close and the open. 
            //
            // WARNING:
            //  - This script to change bars colors.
            ////////////////////////////////////////////////////////////
            //study(title = "DeMark Pivot Points ver 2.0 Strategy", shorttitle = "Pivot Point", overlay = true)
            //width = input(1, minval = 1)
            //xHigh = security(tickerid, "D", high[1])
            //xLow = security(tickerid, "D", low[1])
            //xClose = security(tickerid, "D", close[1])
            //xOpen = security(tickerid, "D", open[1])
            //xP = iff(xClose < xOpen, xHigh + (2 * xLow) + xClose,
            //     iff(xClose > xOpen, (2 * xHigh) + xLow + xClose,
            //     iff(xClose == xOpen, xHigh + xLow + (2 * xClose), xClose)))
            //xPP = xP / 4
            //vR1 = xP / 2 - xLow
            //vS1 = xP / 2 - xHigh
            //pos = iff(close < vS1, -1,
            //      iff(close > vS1, 1, nz(pos[1], 0)))
            //barcolor(pos == -1 ? red : pos == 1 ? green : blue)
            List<decimal> pivotList = new();
            List<decimal> resistanceLevel1List = new();
            List<decimal> supportLevel1List = new();
            List<decimal> xList = new();
            List<Signal> signalsList = new();

            try
            {
                var minMaxList = VolumeInputCheck(stockDataClass, 0, false);
                var highList = minMaxList.Item1;
                var lowList = minMaxList.Item2;

                for (int i = 0; i < stockDataClass.HighPrices.Count; i++)
                {
                    decimal currentClose = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevClose = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevOpen = i >= 1 ? stockDataClass.OpenPrices.ElementAtOrDefault(i - 1) : 0;
                    decimal prevLow = i >= 1 ? lowList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevHigh = i >= 1 ? highList.ElementAtOrDefault(i - 1) : 0;

                    decimal x = prevClose < prevOpen ? prevHigh + (2 * prevLow) + prevClose : prevClose > prevOpen ? (2 * prevHigh) + prevLow + prevClose :
                        prevClose == prevOpen ? prevHigh + prevLow + (2 * prevClose) : prevClose;
                    xList.Add(x);

                    decimal prevPivot = pivotList.LastOrDefault();
                    decimal pivot = x / 4;
                    pivotList.Add(pivot);

                    decimal ratio = x / 2;
                    decimal supportLevel1 = ratio - prevHigh;
                    supportLevel1List.Add(supportLevel1);

                    decimal resistanceLevel1 = ratio - prevLow;
                    resistanceLevel1List.Add(resistanceLevel1);

                    var signal = GetCompareSignal(currentClose - pivot, prevClose - prevPivot);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (pivotList, supportLevel1List, resistanceLevel1List, xList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<decimal>, List<decimal>, List<Signal>) CalculateStandardPivotPoints(StockData stockDataClass)
        {
            // Calculation

            //Pivot (P) = (H + L + C) / 3
            //Resistance(R1) = (2 x P) -L
            //R2 = P + H - L
            //R3 = H + 2 x(P - L)
            //Support(S1) = (2 x P) -H
            //S2 = P - H + L
            //S3 = L - 2 x(H - P)
            //M1 = (S3 + S2) / 2
            //M2 = (S2 + S1) / 2
            //M3 = (S1 + PP) / 2
            //M4 = (R1 + PP) / 2
            //M5 = (R2 + R1) / 2
            //M6 = (R3 + R2) / 2
            List<decimal> pivotList = new();
            List<decimal> resistanceLevel3List = new();
            List<decimal> resistanceLevel2List = new();
            List<decimal> resistanceLevel1List = new();
            List<decimal> supportLevel1List = new();
            List<decimal> supportLevel2List = new();
            List<decimal> supportLevel3List = new();
            List<decimal> midpoint1List = new();
            List<decimal> midpoint2List = new();
            List<decimal> midpoint3List = new();
            List<decimal> midpoint4List = new();
            List<decimal> midpoint5List = new();
            List<decimal> midpoint6List = new();
            List<Signal> signalsList = new();

            try
            {
                var minMaxList = VolumeInputCheck(stockDataClass, 0, false);
                var highList = minMaxList.Item1;
                var lowList = minMaxList.Item2;

                for (int i = 0; i < stockDataClass.HighPrices.Count; i++)
                {
                    decimal currentClose = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevClose = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevLow = i >= 1 ? lowList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevHigh = i >= 1 ? highList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevOpen = i >= 1 ? stockDataClass.OpenPrices.ElementAtOrDefault(i - 1) : 0;

                    decimal prevPivot = pivotList.LastOrDefault();
                    decimal range = prevHigh - prevLow;
                    decimal pivot = (prevHigh + prevLow + prevClose + prevOpen) / 4;
                    pivotList.Add(pivot);

                    decimal supportLevel1 = (pivot * 2) - prevHigh;
                    supportLevel1List.Add(supportLevel1);

                    decimal resistanceLevel1 = (pivot * 2) - prevLow;
                    resistanceLevel1List.Add(resistanceLevel1);

                    decimal range2 = resistanceLevel1 - supportLevel1;

                    decimal prevSupportLevel2 = supportLevel2List.LastOrDefault();
                    decimal supportLevel2 = pivot - range;
                    supportLevel2List.Add(supportLevel2);

                    decimal prevResistanceLevel2 = resistanceLevel2List.LastOrDefault();
                    decimal resistanceLevel2 = pivot + range;
                    resistanceLevel2List.Add(resistanceLevel2);

                    decimal supportLevel3 = pivot - range2;
                    supportLevel3List.Add(supportLevel3);

                    decimal resistanceLevel3 = pivot + range2;
                    resistanceLevel3List.Add(resistanceLevel3);

                    decimal midpoint1 = (supportLevel3 + supportLevel2) / 2;
                    midpoint1List.Add(midpoint1);

                    decimal midpoint2 = (supportLevel2 + supportLevel1) / 2;
                    midpoint2List.Add(midpoint2);

                    decimal midpoint3 = (supportLevel1 + pivot) / 2;
                    midpoint3List.Add(midpoint3);

                    decimal midpoint4 = (resistanceLevel1 + pivot) / 2;
                    midpoint4List.Add(midpoint4);

                    decimal midpoint5 = (resistanceLevel2 + resistanceLevel1) / 2;
                    midpoint5List.Add(midpoint5);

                    decimal midpoint6 = (resistanceLevel3 + resistanceLevel2) / 2;
                    midpoint6List.Add(midpoint6);

                    var signal = GetCompareSignal(currentClose - pivot, prevClose - prevPivot);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (pivotList, supportLevel1List, resistanceLevel1List, supportLevel2List, resistanceLevel2List, supportLevel3List, resistanceLevel3List, midpoint1List,
                midpoint2List, midpoint3List, midpoint4List, midpoint5List, midpoint6List, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateCamarillaPivotPoints(StockData stockDataClass)
        {
            //@version=4
            ////////////////////////////////////////////////////////////
            //  Copyright by HPotter v1.0 11/05/2020
            // Camarilla pivot point formula is the refined form of existing classic pivot point formula. 
            // The Camarilla method was developed by Nick Stott who was a very successful bond trader. 
            // What makes it better is the use of Fibonacci numbers in calculation of levels.
            //
            // Camarilla equations are used to calculate intraday support and resistance levels using 
            // the previous days volatility spread. Camarilla equations take previous day’s high, low and 
            // close as input and generates 8 levels of intraday support and resistance based on pivot points. 
            // There are 4 levels above pivot point and 4 levels below pivot points. The most important levels 
            // are L3 L4 and H3 H4. H3 and L3 are the levels to go against the trend with stop loss around H4 or L4 . 
            // While L4 and H4 are considered as breakout levels when these levels are breached its time to 
            // trade with the trend.
            //
            // WARNING:
            //  - For purpose educate only
            //  - This script to change bars colors.
            ////////////////////////////////////////////////////////////
            //study(title = "Camarilla Pivot Points V2 Strategy", shorttitle = "CPP V2", overlay = true)
            //res = input(title = "Resolution", type = input.resolution, defval = "D")
            //width = input(1, minval = 1)
            //SellFrom = input(title = "Sell from ", defval = "R1", options =["R1", "R2", "R3", "R4"])
            //BuyFrom = input(title = "Buu from ", defval = "S1", options =["S1", "S2", "S3", "S4"])
            //xHigh = security(syminfo.tickerid, res, high)
            //xLow = security(syminfo.tickerid, res, low)
            //xClose = security(syminfo.tickerid, res, close)
            //H4 = (0.55 * (xHigh - xLow)) + xClose
            //H3 = (0.275 * (xHigh - xLow)) + xClose
            //H2 = (0.183 * (xHigh - xLow)) + xClose
            //H1 = (0.0916 * (xHigh - xLow)) + xClose
            //L1 = xClose - (0.0916 * (xHigh - xLow))
            //L2 = xClose - (0.183 * (xHigh - xLow))
            //L3 = xClose - (0.275 * (xHigh - xLow))
            //L4 = xClose - (0.55 * (xHigh - xLow))
            //pos = 0
            //S = iff(BuyFrom == "S1", H1,
            //      iff(BuyFrom == "S2", H2,
            //       iff(BuyFrom == "S3", H3,
            //         iff(BuyFrom == "S4", H4, 0))))
            //B = iff(SellFrom == "R1", L1,
            //      iff(SellFrom == "R2", L2,
            //       iff(SellFrom == "R3", L3,
            //         iff(SellFrom == "R4", L4, 0))))
            //pos:= iff(close > B, 1,
            //      iff(close < S, -1, nz(pos[1], 0)))
            //barcolor(pos == -1 ? color.red : pos == 1 ? color.green : color.blue)
            List<decimal> resistanceLevel5List = new();
            List<decimal> resistanceLevel4List = new();
            List<decimal> resistanceLevel3List = new();
            List<decimal> resistanceLevel2List = new();
            List<decimal> resistanceLevel1List = new();
            List<decimal> supportLevel1List = new();
            List<decimal> supportLevel2List = new();
            List<decimal> supportLevel3List = new();
            List<decimal> supportLevel4List = new();
            List<decimal> supportLevel5List = new();
            List<decimal> midpoint1List = new();
            List<decimal> midpoint2List = new();
            List<decimal> midpoint3List = new();
            List<decimal> midpoint4List = new();
            List<decimal> midpoint5List = new();
            List<decimal> midpoint6List = new();
            List<Signal> signalsList = new();

            try
            {
                var minMaxList = VolumeInputCheck(stockDataClass, 0, false);
                var highList = minMaxList.Item1;
                var lowList = minMaxList.Item2;

                for (int i = 0; i < stockDataClass.HighPrices.Count; i++)
                {
                    decimal prevClose = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal currentClose = i >= 1 ? prevClose : stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevHigh = i >= 1 ? highList.ElementAtOrDefault(i - 1) : 0;
                    decimal currentHigh = i >= 1 ? prevHigh : highList.ElementAtOrDefault(i);
                    decimal prevLow = i >= 1 ? lowList.ElementAtOrDefault(i - 1) : 0;
                    decimal currentLow = i >= 1 ? prevLow : lowList.ElementAtOrDefault(i);
                    decimal range = currentHigh - currentLow;

                    decimal prevSupportLevel1 = supportLevel1List.LastOrDefault();
                    decimal supportLevel1 = currentClose - (0.0916m * range);
                    supportLevel1List.Add(supportLevel1);

                    decimal supportLevel2 = currentClose - (0.183m * range);
                    supportLevel2List.Add(supportLevel2);

                    decimal supportLevel3 = currentClose - (0.275m * range);
                    supportLevel3List.Add(supportLevel3);

                    decimal supportLevel4 = currentClose - (0.55m * range);
                    supportLevel4List.Add(supportLevel4);

                    decimal prevResistanceLevel1 = resistanceLevel1List.LastOrDefault();
                    decimal resistanceLevel1 = currentClose + (0.0916m * range);
                    resistanceLevel1List.Add(resistanceLevel1);

                    decimal resistanceLevel2 = currentClose + (0.183m * range);
                    resistanceLevel2List.Add(resistanceLevel2);

                    decimal resistanceLevel3 = currentClose + (0.275m * range);
                    resistanceLevel3List.Add(resistanceLevel3);

                    decimal resistanceLevel4 = currentClose + (0.55m * range);
                    resistanceLevel4List.Add(resistanceLevel4);

                    decimal resistanceLevel5 = currentLow != 0 ? currentHigh / currentLow * currentClose : 0;
                    resistanceLevel5List.Add(resistanceLevel5);

                    decimal supportLevel5 = currentClose - (resistanceLevel5 - currentClose);
                    supportLevel5List.Add(supportLevel5);

                    decimal midpoint1 = (supportLevel3 + supportLevel2) / 2;
                    midpoint1List.Add(midpoint1);

                    decimal midpoint2 = (supportLevel2 + supportLevel1) / 2;
                    midpoint2List.Add(midpoint2);

                    decimal midpoint3 = (resistanceLevel2 + resistanceLevel1) / 2;
                    midpoint3List.Add(midpoint3);

                    decimal midpoint4 = (resistanceLevel3 + resistanceLevel2) / 2;
                    midpoint4List.Add(midpoint4);

                    decimal midpoint5 = (resistanceLevel3 + resistanceLevel4) / 2;
                    midpoint5List.Add(midpoint5);

                    decimal midpoint6 = (supportLevel4 + supportLevel3) / 2;
                    midpoint6List.Add(midpoint6);

                    var signal = GetBullishBearishSignal(currentClose - resistanceLevel1, prevClose - prevResistanceLevel1, currentClose - supportLevel1, prevClose - prevSupportLevel1);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (supportLevel1List, resistanceLevel1List, supportLevel2List, resistanceLevel2List, supportLevel3List, resistanceLevel3List, supportLevel4List,
                resistanceLevel4List, supportLevel5List, resistanceLevel5List, midpoint1List, midpoint2List, midpoint3List, midpoint4List, midpoint5List,
                midpoint6List, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<decimal>, List<decimal>, List<Signal>) CalculateFibonacciPivotPoints(StockData stockDataClass)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Fibonacci Pivot Points script may be freely distributed under the MIT license.
            //study(title = "Fibonacci Pivot Points", shorttitle = "FPP", overlay = true)

            //width = input(title = "Width", type = input.integer, defval = 2, minval = 1)

            //pp = (high[1] + low[1] + close[1]) / 3
            //range = high[1] - low[1]
            //r1 = pp + (range * 0.382)
            //r2 = pp + (range * 0.618)
            //r3 = pp + (range * 1.000)
            //s1 = pp - (range * 0.382)
            //s2 = pp - (range * 0.618)
            //s3 = pp - (range * 1.000)

            //barcolor(close > pp ? color.green : close < pp ? color.red : color.black)
            //plot(pp, color = color.blue, title = "FPP", style = plot.style_line, linewidth = width)
            //plot(r1, color = color.blue, title = "FR1", style = plot.style_circles, linewidth = width)
            //plot(r2, color = color.blue, title = "FR2", style = plot.style_line, linewidth = width)
            //plot(r3, color = color.blue, title = "FR3", style = plot.style_circles, linewidth = width)
            //plot(s1, color = color.blue, title = "FS1", style = plot.style_circles, linewidth = width)
            //plot(s2, color = color.blue, title = "FS2", style = plot.style_line, linewidth = width)
            //plot(s3, color = color.blue, title = "FS3", style = plot.style_circles, linewidth = width)
            List<decimal> pivotList = new();
            List<decimal> resistanceLevel3List = new();
            List<decimal> resistanceLevel2List = new();
            List<decimal> resistanceLevel1List = new();
            List<decimal> supportLevel1List = new();
            List<decimal> supportLevel2List = new();
            List<decimal> supportLevel3List = new();
            List<decimal> midpoint1List = new();
            List<decimal> midpoint2List = new();
            List<decimal> midpoint3List = new();
            List<decimal> midpoint4List = new();
            List<decimal> midpoint5List = new();
            List<decimal> midpoint6List = new();
            List<Signal> signalsList = new();

            try
            {
                var minMaxList = VolumeInputCheck(stockDataClass, 0, false);
                var highList = minMaxList.Item1;
                var lowList = minMaxList.Item2;

                for (int i = 0; i < stockDataClass.HighPrices.Count; i++)
                {
                    decimal currentClose = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevClose = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevLow = i >= 1 ? lowList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevHigh = i >= 1 ? highList.ElementAtOrDefault(i - 1) : 0;

                    decimal prevPivot = pivotList.LastOrDefault();
                    decimal range = prevHigh - prevLow;
                    decimal pivot = (prevHigh + prevLow + prevClose) / 3;
                    pivotList.Add(pivot);

                    decimal supportLevel1 = pivot - (range * 0.382m);
                    supportLevel1List.Add(supportLevel1);

                    decimal prevSupportLevel2 = supportLevel2List.LastOrDefault();
                    decimal supportLevel2 = pivot - (range * 0.618m);
                    supportLevel2List.Add(supportLevel2);

                    decimal supportLevel3 = pivot - (range * 1);
                    supportLevel3List.Add(supportLevel3);

                    decimal resistanceLevel1 = pivot + (range * 0.382m);
                    resistanceLevel1List.Add(resistanceLevel1);

                    decimal prevResistanceLevel2 = resistanceLevel2List.LastOrDefault();
                    decimal resistanceLevel2 = pivot + (range * 0.618m);
                    resistanceLevel2List.Add(resistanceLevel2);

                    decimal resistanceLevel3 = pivot + (range * 1);
                    resistanceLevel3List.Add(resistanceLevel3);

                    decimal midpoint1 = (supportLevel3 + supportLevel2) / 2;
                    midpoint1List.Add(midpoint1);

                    decimal midpoint2 = (supportLevel2 + supportLevel1) / 2;
                    midpoint2List.Add(midpoint2);

                    decimal midpoint3 = (supportLevel1 + pivot) / 2;
                    midpoint3List.Add(midpoint3);

                    decimal midpoint4 = (resistanceLevel1 + pivot) / 2;
                    midpoint4List.Add(midpoint4);

                    decimal midpoint5 = (resistanceLevel2 + resistanceLevel1) / 2;
                    midpoint5List.Add(midpoint5);

                    decimal midpoint6 = (resistanceLevel3 + resistanceLevel2) / 2;
                    midpoint6List.Add(midpoint6);

                    var signal = GetCompareSignal(currentClose - pivot, prevClose - prevPivot);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (pivotList, supportLevel1List, resistanceLevel1List, supportLevel2List, resistanceLevel2List, supportLevel3List, resistanceLevel3List, midpoint1List,
                midpoint2List, midpoint3List, midpoint4List, midpoint5List, midpoint6List, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculatePolarizedFractalEfficiency(StockData stockDataClass, int days = 5)
        {
            //@version=2
            ////////////////////////////////////////////////////////////
            //  Copyright by HPotter v1.0 28/09/2017
            // The Polarized Fractal Efficiency (PFE) indicator measures the efficiency 
            // of price movements by drawing on concepts from fractal geometry and chaos 
            // theory. The more linear and efficient the price movement, the shorter the 
            // distance the prices must travel between two points and thus the more efficient 
            // the price movement.
            // WARNING:
            // - This script to change bars colors.
            ////////////////////////////////////////////////////////////
            //study(title = "PFE (Polarized Fractal Efficiency)", shorttitle = "PFE (Polarized Fractal Efficiency)")
            //Length = input(9, minval = 1)
            //LengthEMA = input(5, minval = 1)
            //BuyBand = input(50, step = 0.1)
            //SellBand = input(-50, step = 0.1)
            //hline(BuyBand, color = green, linestyle = line, title = "TopBand")
            //hline(SellBand, color = red, linestyle = line, title = "LowBand")
            //PFE = sqrt(pow(close - close[Length], 2) + 100)
            //C2C = sum(sqrt(pow((close - close[1]), 2) + 1), Length)
            //xFracEff = iff(close - close[Length] > 0, round((PFE / C2C) * 100), round(-(PFE / C2C) * 100))
            //xEMA = ema(xFracEff, LengthEMA)
            //pos = iff(xEMA < SellBand, -1,
            //iff(xEMA > BuyBand, 1, nz(pos[1], 0)))
            //barcolor(pos == -1 ? red : pos == 1 ? green : blue)
            //plot(xEMA, color = blue, title = "PFE")
            List<decimal> pfeList = new();
            List<decimal> c2cList = new();
            List<decimal> c2cSumList = new();
            List<decimal> fracEffList = new();
            List<decimal> efRatioList = new();
            List<decimal> emaList = new();
            List<Signal> signalsList = new();

            try
            {
                int emaLength = days;
                int length = (int)Math.Ceiling(days / 0.5556);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal priorValue = i >= length ? stockDataClass.InputValues.ElementAtOrDefault(i - length) : 0;

                    decimal pfe = Sqrt(Pow(currentValue - priorValue, 2) + 100);
                    pfeList.Add(pfe);

                    decimal c2c = Sqrt(Pow(currentValue - prevValue, 2) + 1);
                    c2cList.Add(c2c);

                    decimal c2cSum = c2cList.TakeLast(length).Sum();
                    c2cSumList.Add(c2cSum);

                    decimal efRatio = c2cSum != 0 ? pfe / c2cSum * 100 : 0;
                    efRatioList.Add(efRatio);

                    decimal fracEff = currentValue - priorValue > 0 ? efRatio : -efRatio;
                    fracEffList.Add(fracEff);

                    decimal prevEma = emaList.LastOrDefault();
                    decimal ema = CalculateExponentialMovingAverage(fracEff, prevEma, emaLength);
                    emaList.Add(ema);

                    var signal = GetCompareSignal(ema, prevEma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (pfeList, c2cList, c2cSumList, efRatioList, fracEffList, emaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateWoodieCommodityChannelIndex(StockData stockDataClass, int days = 6)
        {
            //@version=4
            //study(title = "Woodies CCI")

            //cciTurboLength = input(title = "CCI Turbo Length", type = input.integer, defval = 6, minval = 3, maxval = 14)
            //cci14Length = input(title = "CCI 14 Length", type = input.integer, defval = 14, minval = 7, maxval = 20)

            //source = close

            //cciTurbo = cci(source, cciTurboLength)
            //cci14 = cci(source, cci14Length)

            //last5IsDown = cci14[5] < 0 and cci14[4] < 0 and cci14[3] < 0 and cci14[2] < 0 and cci14[1] < 0
            //last5IsUp = cci14[5] > 0 and cci14[4] > 0 and cci14[3] > 0 and cci14[2] > 0 and cci14[1] > 0
            //histogramColor = last5IsUp ? color.green : last5IsDown ? color.red : cci14 < 0 ? color.green : color.red

            //plot(cci14, title = "CCI Turbo Histogram", color = histogramColor, style = plot.style_histogram)
            //plot(cciTurbo, title = "CCI Turbo", color = color.green, style = plot.style_line)
            //plot(cci14, title = "CCI 14", color = color.red, style = plot.style_line)

            //hline(0, title = "Zero Line", color = color.black, linestyle = hline.style_solid)
            //hline(100, title = "Hundred Line", color = color.black, linestyle = hline.style_dotted)
            //hline(-100, title = "Minus Line", color = color.black, linestyle = hline.style_dotted)
            List<decimal> downList = new();
            List<decimal> upList = new();
            List<Signal> signalsList = new();

            try
            {
                int length = (int)Math.Ceiling(days / 0.4286);

                var cciList = CalculateCommodityChannelIndex(stockDataClass, length).Item4;
                var turboCciList = CalculateCommodityChannelIndex(stockDataClass, days).Item4;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal prevCci1 = i >= 1 ? cciList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevCci2 = i >= 2 ? cciList.ElementAtOrDefault(i - 2) : 0;
                    decimal prevCci3 = i >= 3 ? cciList.ElementAtOrDefault(i - 3) : 0;
                    decimal prevCci4 = i >= 4 ? cciList.ElementAtOrDefault(i - 4) : 0;
                    decimal prevCci5 = i >= 5 ? cciList.ElementAtOrDefault(i - 5) : 0;
                    decimal prevTurboCci1 = i >= 1 ? cciList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevTurboCci2 = i >= 2 ? turboCciList.ElementAtOrDefault(i - 2) : 0;
                    decimal prevTurboCci3 = i >= 3 ? turboCciList.ElementAtOrDefault(i - 3) : 0;
                    decimal prevTurboCci4 = i >= 4 ? turboCciList.ElementAtOrDefault(i - 4) : 0;
                    decimal prevTurboCci5 = i >= 5 ? turboCciList.ElementAtOrDefault(i - 5) : 0;
                    decimal cci = cciList.ElementAtOrDefault(i);
                    decimal cciTurbo = turboCciList.ElementAtOrDefault(i);

                    decimal up = prevTurboCci5 > prevCci5 && prevTurboCci4 > prevCci4 && prevTurboCci3 > prevCci3 && prevTurboCci2 > prevCci2 && prevTurboCci1 > prevCci1 ? 1 : 0;
                    upList.Add(up);

                    decimal dn = prevTurboCci5 < prevCci5 && prevTurboCci4 < prevCci4 && prevTurboCci3 < prevCci3 && prevTurboCci2 < prevCci2 && prevTurboCci1 < prevCci1 ? 1 : 0;
                    downList.Add(dn);

                    var signal = GetCompareSignal(cci - cciTurbo, prevCci1 - prevTurboCci1);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (upList, downList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateBayesianOscillator(StockData stockDataClass, string maType, int days = 15)
        {
            // This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
            // © tista

            //@version=4
            //study("Bayesian BBSMA Oscillator", shorttitle = "BayesBbSmaOsc")

            //bbSmaPeriod = input(20, title = "BB SMA Period")
            //bbStdDevMult = input(2.5, title = "BB Standard Deviation", maxval = 50.0)

            //bbBasis = sma(close, bbSmaPeriod)
            //bbStdDev = bbStdDevMult * stdev(close, bbSmaPeriod)

            //bbUpper = bbBasis + bbStdDev
            //bbLower = bbBasis - bbStdDev

            // SMA
            //smaPeriod = input(20, title = "SMA Period")
            //smaValues = sma(close, smaPeriod)

            // Bayesian Theorem Starts
            //bayesPeriod = input(20, title = "Bayesian Lookback Period")

            // Next candles are breaking Down
            //probBbUpperUpSeq = close > bbUpper ? 1 : 0
            //probBbUpperUp = sum(probBbUpperUpSeq, bayesPeriod) / bayesPeriod
            //probBbUpperDownSeq = close < bbUpper ? 1 : 0
            //probBbUpperDown = sum(probBbUpperDownSeq, bayesPeriod) / bayesPeriod

            //probUpBbUpper = probBbUpperUp / (probBbUpperUp + probBbUpperDown)

            //probBbBasisUpSeq = close > bbBasis ? 1 : 0
            //probBbBasisUp = sum(probBbBasisUpSeq, bayesPeriod) / bayesPeriod
            //probBbBasisDownSeq = close < bbBasis ? 1 : 0
            //probBbBasisDown = sum(probBbBasisDownSeq, bayesPeriod) / bayesPeriod

            //probUpBbBasis = probBbBasisUp / (probBbBasisUp + probBbBasisDown)

            //probSmaUpSeq = close > smaValues ? 1 : 0
            //probSmaUp = sum(probSmaUpSeq, bayesPeriod) / bayesPeriod
            //probSmaDownSeq = close < smaValues ? 1 : 0
            //probSmaDown = sum(probSmaDownSeq, bayesPeriod) / bayesPeriod

            //probUpSma = probSmaUp / (probSmaUp + probSmaDown)

            //sigmaProbsDown = nz(probUpBbUpper * probUpBbBasis * probUpSma / probUpBbUpper * probUpBbBasis * probUpSma + ((1 - probUpBbUpper) * (1 - probUpBbBasis) * (1 - probUpSma)))

            // Next candles are breaking Up
            //probDownBbUpper = probBbUpperDown / (probBbUpperDown + probBbUpperUp)
            //probDownBbBasis = probBbBasisDown / (probBbBasisDown + probBbBasisUp)
            //probDownSma = probSmaDown / (probSmaDown + probSmaUp)

            //sigmaProbsUp = nz(probDownBbUpper * probDownBbBasis * probDownSma / probDownBbUpper * probDownBbBasis * probDownSma + ((1 - probDownBbUpper) * (1 - probDownBbBasis) * (1 - probDownSma)))

            //showNextCandleDown = input(true, title = "Plot Next Candles Breaking Down?")
            //plot(showNextCandleDown ? sigmaProbsDown * 100 : na, title = "Next Candle Breaking Down Probs", transp = 0, color = color.red, linewidth = 2)

            //showNextCandleUp = input(true, title = "Plot Next Candles Breaking Up?")
            //plot(showNextCandleUp ? sigmaProbsUp * 100 : na, title = "Next Candle Breaking Up Probs", transp = 0, color = color.green, linewidth = 2)

            //probPrime = nz(sigmaProbsDown * sigmaProbsUp / sigmaProbsDown * sigmaProbsUp + ((1 - sigmaProbsDown) * (1 - sigmaProbsUp)))

            //showPrime = input(true, title = "Plot Prime Probability?")
            //plot(showPrime ? probPrime * 100 : na, title = "Prime Probability", transp = 0, color = color.blue, linewidth = 2)

            //lowerThreshold = input(15.0, title = "Lower Threshold")

            //sideways = probPrime < lowerThreshold / 100 and sigmaProbsUp<lowerThreshold / 100 and sigmaProbsDown<lowerThreshold / 100

            //longUsingProbPrime = probPrime > lowerThreshold / 100 and probPrime[1] == 0
            //longUsingSigmaProbsUp = sigmaProbsUp < 1 and sigmaProbsUp[1] == 1

            //shortUsingProbPrime = probPrime == 0 and probPrime[1] > lowerThreshold / 100
            //shortUsingSigmaProbsDown = sigmaProbsDown < 1 and sigmaProbsDown[1] == 1

            //longSignal = longUsingProbPrime or longUsingSigmaProbsUp
            //shortSignal = shortUsingProbPrime or shortUsingSigmaProbsDown

            //barcolor(longSignal ? color.lime : na, title = "Long Bars")
            //barcolor(shortSignal ? color.maroon : na, title = "Short Bars")

            //hzl3 = hline(lowerThreshold, color =#333333, linestyle=hline.style_solid)
            //hzl4 = hline(0, color =#333333, linestyle=hline.style_solid)
            //fill(hzl3, hzl4, title = "Lower Threshold", color = sideways ? color.gray : color.maroon, transp = 70)

            //alertcondition(longSignal, title = "Long!", message = "Bayesian BBSMA - LONG - {{exchange}}:{{ticker}} at {{close}}")
            //alertcondition(shortSignal, title = "Short!", message = "Bayesian BBSMA - SHORT - {{exchange}}:{{ticker}} at {{close}}")
            List<decimal> probBbUpperUpSeqList = new();
            List<decimal> probBbUpperUpList = new();
            List<decimal> probBbUpperDownSeqList = new();
            List<decimal> probBbUpperDownList = new();
            List<decimal> probUpBbUpperList = new();
            List<decimal> probBbBasisUpSeqList = new();
            List<decimal> probBbBasisUpList = new();
            List<decimal> probBbBasisDownSeqList = new();
            List<decimal> probBbBasisDownList = new();
            List<decimal> probUpBbBasisList = new();
            List<decimal> sigmaProbsDownList = new();
            List<decimal> sigmaProbsUpList = new();
            List<decimal> probDownBbUpperList = new();
            List<decimal> probDownBbBasisList = new();
            List<decimal> probPrimeList = new();
            List<Signal> signalsList = new();

            try
            {
                int lowerThreshold = days;
                int length = (int)Math.Ceiling(days / 0.75);

                var bbList = CalculateBollingerBands(null, stockDataClass, 2.5m, maType, length);
                var upperBbList = bbList.Item1;
                var lowerBbList = bbList.Item2;
                List<decimal> basisList = GetMovingAverageList(maType, null, stockDataClass, length);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal upperBb = upperBbList.ElementAtOrDefault(i);
                    decimal lowerBb = lowerBbList.ElementAtOrDefault(i);
                    decimal basis = basisList.ElementAtOrDefault(i);

                    decimal probBbUpperUpSeq = currentValue > upperBb ? 1 : 0;
                    probBbUpperUpSeqList.Add(probBbUpperUpSeq);

                    decimal probBbUpperUp = probBbUpperUpSeqList.TakeLast(length).Average();
                    probBbUpperUpList.Add(probBbUpperUp);

                    decimal probBbUpperDownSeq = currentValue < upperBb ? 1 : 0;
                    probBbUpperDownSeqList.Add(probBbUpperDownSeq);

                    decimal probBbUpperDown = probBbUpperDownSeqList.TakeLast(length).Average();
                    probBbUpperDownList.Add(probBbUpperDown);

                    decimal probUpBbUpper = probBbUpperUp + probBbUpperDown != 0 ? probBbUpperUp / (probBbUpperUp + probBbUpperDown) : 0;
                    probUpBbUpperList.Add(probUpBbUpper);

                    decimal probDownBbUpper = probBbUpperUp + probBbUpperDown != 0 ? probBbUpperDown / (probBbUpperUp + probBbUpperDown) : 0;
                    probDownBbUpperList.Add(probDownBbUpper);

                    decimal probBbBasisUpSeq = currentValue > basis ? 1 : 0;
                    probBbBasisUpSeqList.Add(probBbBasisUpSeq);

                    decimal probBbBasisUp = probBbBasisUpSeqList.TakeLast(length).Average();
                    probBbBasisUpList.Add(probBbBasisUp);

                    decimal probBbBasisDownSeq = currentValue < basis ? 1 : 0;
                    probBbBasisDownSeqList.Add(probBbBasisDownSeq);

                    decimal probBbBasisDown = probBbBasisDownSeqList.TakeLast(length).Average();
                    probBbBasisDownList.Add(probBbBasisDown);

                    decimal probUpBbBasis = probBbBasisUp + probBbBasisDown != 0 ? probBbBasisUp / (probBbBasisUp + probBbBasisDown) : 0;
                    probUpBbBasisList.Add(probUpBbBasis);

                    decimal probDownBbBasis = probBbBasisUp + probBbBasisDown != 0 ? probBbBasisDown / (probBbBasisUp + probBbBasisDown) : 0;
                    probDownBbBasisList.Add(probDownBbBasis);

                    decimal prevSigmaProbsDown = sigmaProbsDownList.LastOrDefault();
                    decimal sigmaProbsDown = probUpBbUpper != 0 && probUpBbBasis != 0 ? ((probUpBbUpper * probUpBbBasis) / (probUpBbUpper * probUpBbBasis)) +
                        ((1 - probUpBbUpper) * (1 - probUpBbBasis)) : 0;
                    sigmaProbsDownList.Add(sigmaProbsDown);

                    decimal prevSigmaProbsUp = sigmaProbsUpList.LastOrDefault();
                    decimal sigmaProbsUp = probDownBbUpper != 0 && probDownBbBasis != 0 ? ((probDownBbUpper * probDownBbBasis) / (probDownBbUpper * probDownBbBasis)) +
                        ((1 - probDownBbUpper) * (1 - probDownBbBasis)) : 0;
                    sigmaProbsUpList.Add(sigmaProbsUp);

                    decimal prevProbPrime = probPrimeList.LastOrDefault();
                    decimal probPrime = sigmaProbsDown != 0 && sigmaProbsUp != 0 ? ((sigmaProbsDown * sigmaProbsUp) / (sigmaProbsDown * sigmaProbsUp)) +
                        ((1 - sigmaProbsDown) * (1 - sigmaProbsUp)) : 0;
                    probPrimeList.Add(probPrime);

                    bool longUsingProbPrime = probPrime > (decimal)lowerThreshold / 100 && prevProbPrime == 0;
                    bool longUsingSigmaProbsUp = sigmaProbsUp < 1 && prevSigmaProbsUp == 1;

                    bool shortUsingProbPrime = probPrime == 0 && prevProbPrime > (decimal)lowerThreshold / 100;
                    bool shortUsingSigmaProbsDown = sigmaProbsDown < 1 && prevSigmaProbsDown == 1;

                    var signal = GetConditionSignal(longUsingProbPrime || longUsingSigmaProbsUp, shortUsingProbPrime || shortUsingSigmaProbsDown);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (probBbUpperUpList, probBbUpperUpSeqList, probBbUpperDownList, probBbUpperDownSeqList, probBbBasisUpList, probBbBasisUpSeqList, probBbBasisDownList,
                probBbBasisDownSeqList, probUpBbUpperList, probDownBbUpperList, probUpBbBasisList, probDownBbBasisList, sigmaProbsUpList, sigmaProbsDownList, probPrimeList,
                signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculatePrimeNumberOscillator(List<decimal>? customValuesList, StockData stockDataClass,
            int days = 5)
        {
            //@version=2
            ////////////////////////////////////////////////////////////
            //  Copyright by HPotter v1.0 29/03/2018
            // Determining market trends has become a science even though a high number or people 
            // still believe it’s a gambling game. Mathematicians, technicians, brokers and investors 
            // have worked together in developing quite several indicators to help them better understand 
            // and forecast market movements.
            //
            // Developed by Modulus Financial Engineering Inc., the prime number oscillator indicates the 
            // nearest prime number, be it at the top or the bottom of the series, and outlines the 
            // difference between that prime number and the respective series.
            //
            // WARNING:
            // - This script to change bars colors.
            ////////////////////////////////////////////////////////////
            //PrimeNumberOscillator(price, percent) =>
            //res = 0
            //res1 = 0
            //res2 = 0
            //for j = price to price + (price * percent / 100)
            //    res1 := j
            //    for i = 2 to sqrt(price)
            //        res1 := iff(j % i == 0, 0, j)
            //        if res1 == 0
            //            break
            //    if res1 > 0
            //        break
            //for j = price to price - (price * percent / 100)
            //    res2 := j
            //    for i = 2 to sqrt(price)
            //        res2 := iff(j % i == 0, 0, j)
            //        if res2 == 0
            //            break
            //    if res2 > 0
            //        break
            //res:= iff(res1 - price < price - res2, res1 - price, res2 - price)
            //res:= iff(res == 0, res[1], res)
            //res

            //study(title = "Prime Number Oscillator Strategy")
            //percent = input(5, minval = 0.01, step = 0.01, title = "Tolerance Percentage")
            //xPNO = PrimeNumberOscillator(close, percent)
            //pos = iff(xPNO > 0, 1,
            //       iff(xPNO < 0, -1, nz(pos[1], 0)))
            //barcolor(pos == -1 ? red : pos == 1 ? green : blue)
            //clr = iff(xPNO > 0, green, red)
            //p1 = plot(xPNO, color = blue, title = "KPO")
            //p2 = plot(0, color = black, title = "0")
            //fill(p1, p2, color = clr)
            List<decimal> pnoList = new();
            List<decimal> pno1List = new();
            List<decimal> pno2List = new();
            List<Signal> signalsList = new();

            try
            {
                if (customValuesList != null)
                {
                    stockDataClass.InputValues = customValuesList;
                }

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal ratio = currentValue * days / 100;
                    Int64 convertedValue = (Int64)Math.Round(currentValue);
                    Int64 sqrtValue = currentValue >= 0 ? (Int64)Math.Round(Sqrt(currentValue)) : 0;
                    Int64 maxValue = (Int64)Math.Round(currentValue + ratio);
                    Int64 minValue = (Int64)Math.Round(currentValue - ratio);

                    decimal pno = 0, pno1 = 0, pno2 = 0;
                    for (Int64 j = convertedValue; j <= maxValue; j++)
                    {
                        pno1 = j;
                        for (int k = 2; k <= sqrtValue; k++)
                        {
                            pno1 = j % k == 0 ? 0 : j;
                            if (pno1 == 0)
                            {
                                break;
                            }
                        }

                        if (pno1 > 0)
                        {
                            break;
                        }
                    }
                    pno1 = pno1 == 0 ? pno1List.LastOrDefault() : pno1;
                    pno1List.Add(pno1);

                    for (Int64 l = convertedValue; l >= minValue; l--)
                    {
                        pno2 = l;
                        for (int m = 2; m <= sqrtValue; m++)
                        {
                            pno2 = l % m == 0 ? 0 : l;
                            if (pno2 == 0)
                            {
                                break;
                            }
                        }

                        if (pno2 > 0)
                        {
                            break;
                        }
                    }
                    pno2 = pno2 == 0 ? pno2List.LastOrDefault() : pno2;
                    pno2List.Add(pno2);

                    decimal prevPno = pnoList.LastOrDefault();
                    pno = pno1 - currentValue < currentValue - pno2 ? pno1 - currentValue : pno2 - currentValue;
                    pno = pno == 0 ? prevPno : pno;
                    pnoList.Add(pno);

                    var signal = GetCompareSignal(pno, prevPno);
                    signalsList.Add(signal);
                }

                // reset the input values list
                stockDataClass = LoadCalculations.GetInputValuesList(stockDataClass.InputName, stockDataClass);
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (pno1List, pno2List, pnoList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateHighLowBands(StockData stockDataClass, string maType, int days = 14)
        {
            //@version=2
            ////////////////////////////////////////////////////////////
            //  Copyright by HPotter v1.1 23/02/2018
            // As the name suggests, High low bands are two bands surrounding the underlying’s 
            // price. These bands are generated from the triangular moving averages calculated 
            // from the underlying’s price. The triangular moving average is, in turn, shifted 
            // up and down by a fixed percentage. The bands, thus formed, are termed as High 
            // low bands. The main theme and concept of High low bands is based upon the triangular 
            // moving average. 
            //
            // To fix do not correct to interpret a signal.
            //
            // WARNING:
            // - This script to change bars colors.
            ////////////////////////////////////////////////////////////
            //study(title = "High Low Bands", overlay = true)
            //Length = input(14, minval = 1)
            //PercentShift = input(1, minval = 0.01, step = 0.01)
            //xTMA = sma(sma(close, Length), Length)
            //xHighBand = xTMA + (xTMA * PercentShift / 100)
            //xLowBand = xTMA - (xTMA * PercentShift / 100)
            //pos = iff(close > xHighBand, 1,
            //      iff(close < xLowBand, -1, nz(pos[1], 0)))
            //barcolor(pos == -1 ? red : pos == 1 ? green : blue)
            //plot(xTMA, color = blue, title = "TMA")
            //plot(xHighBand, color = red, title = "High Band")
            //plot(xLowBand, color = red, title = "Low Band")
            List<decimal> highBandList = new();
            List<decimal> lowBandList = new();
            List<Signal> signalsList = new();
            decimal pctShift = 1;

            try
            {
                var tmaList1 = GetMovingAverageList(maType, null, stockDataClass, days);
                var tmaList2 = GetMovingAverageList(maType, tmaList1, stockDataClass, days);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal tma = tmaList2.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevTma = i >= 1 ? tmaList2.ElementAtOrDefault(i - 1) : 0;

                    decimal prevHighBand = highBandList.LastOrDefault();
                    decimal highBand = tma + (tma * pctShift / 100);
                    highBandList.Add(highBand);

                    decimal prevLowBand = lowBandList.LastOrDefault();
                    decimal lowBand = tma - (tma * pctShift / 100);
                    lowBandList.Add(lowBand);

                    var signal = GetBollingerBandsSignal(currentValue - tma, prevValue - prevTma, currentValue, prevValue, highBand, prevHighBand, lowBand, prevLowBand);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (highBandList, lowBandList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateAverageMoneyFlowOscillator(StockData stockDataClass, string maType, int days = 3)
        {
            // This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
            // © RedKTrader

            //@version=4
            //study(title = "RedK_AvgMoneyFlow Oscillator v1", shorttitle = "MFO_v1")
            //length = input(5, minval = 1)
            //smooth = input(3, minval = 1)

            //red = #d5180b, green = #007f0e
            //v = volume , c = change(close)

            //avgc = wma(c, length)
            //avgv = wma(v, length)
            //r = log(abs(avgv * avgc)) * sign(avgc)
            //k = stoch(r, r, r, length) * 2 - 100
            //ks = wma(k, smooth)

            //hline(0, title = "zero line", color = color.yellow, linestyle = hline.style_dotted, editable = false)
            //plot(ks, title = 'DV line', color = ks >= 0 ? green : red, linewidth = 3)
            List<decimal> chgList = new();
            List<decimal> rList = new();
            List<decimal> rhList = new();
            List<decimal> rlList = new();
            List<decimal> rsList = new();
            List<decimal> kList = new();
            List<decimal> ksList = new();
            List<Signal> signalsList = new();

            try
            {
                int length = (int)Math.Ceiling(days / 0.6);

                var avgvList = GetMovingAverageList(maType, stockDataClass.Volumes, stockDataClass, length);

                for (int h = 0; h < stockDataClass.InputValues.Count; h++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(h);
                    decimal prevValue = h >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(h - 1) : 0;

                    decimal chg = currentValue - prevValue;
                    chgList.Add(chg);
                }

                var avgcList = GetMovingAverageList(maType, chgList, stockDataClass, length);
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal avgv = avgvList.ElementAtOrDefault(i);
                    decimal avgc = avgcList.ElementAtOrDefault(i);

                    decimal r = Math.Abs(avgv * avgc) > 0 ? Log(Math.Abs(avgv * avgc)) * Math.Sign(avgc) : 0;
                    rList.Add(r);

                    var list = rList.TakeLast(length).ToList();
                    decimal rh = list.Max();
                    rhList.Add(rh);

                    decimal rl = list.Min();
                    rlList.Add(rl);

                    decimal rs = rh != rl ? (r - rl) / (rh - rl) * 100 : 0;
                    rsList.Add(rs);

                    decimal k = (rh * 2) - 100;
                    kList.Add(k);
                }

                ksList = GetMovingAverageList(maType, kList, stockDataClass, days);
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal ks = ksList.ElementAtOrDefault(j);
                    decimal prevKs = j >= 1 ? ksList.ElementAtOrDefault(j - 1) : 0;

                    var signal = GetCompareSignal(ks, prevKs);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (rList, rhList, rlList, rsList, kList, ksList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateTraderPressureIndex(
            StockData stockDataClass, string maType, int days = 2)
        {
            // This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
            // © RedKTrader

            //@version=4
            //study("RedK Trader Pressure Index (TPX)", shorttitle = "RedK_TPX v3.0", overlay = false, resolution = "", precision = 1)

            // Inputs
            //length = input(title = "Avg Length", defval = 7, minval = 1)
            //smooth = input(title = "Smoothing", defval = 3, minval = 1)

            // ****    CLevel is the "critical or control" level, whoever builds pressure that exceeds that level will be in control
            //clevel = input(title = "Control Level", defval = 30, minval = 5, maxval = 100, step = 5)

            // adding optional pre-smoothing - will cause a signal lag of ~1 bar @ value of 3 - will be off by default   
            //pre_s = input(title = "Pre-smoothing?", defval = false, inline = "pre-smoothing")
            //pre_sv = input(title = "", defval = 3, minval = 1, inline = "pre-smoothing")

            //Calculations
            //R is the 2-bar range used as "baseline" or denominator 
            //R = highest(2) - lowest(2)

            // Bull pressure is represented by how far they can pull the high and the low of previous bar up relative to the 2-bar range
            //hiup = max(change(high), 0)
            //loup = max(change(low), 0)
            //bulls = min((hiup + loup) / R, 1) * 100  //prevent big gaps causing a % over 100%
            //avgbull = wma(nz(bulls), length)
            //avgbulls = pre_s ? wma(avgbull, pre_sv) : avgbull

            // Bear pressure is represented by how far they can push the high and the low of previous bar down relative to the 2-bar range
            //hidn = min(change(high), 0)
            //lodn = min(change(low), 0)
            //bears = max((hidn + lodn) / R, -1) * -100     //convert to positive value
            //avgbear = wma(nz(bears), length)
            //avgbears = pre_s ? wma(avgbear, pre_sv) : avgbear

            //net = avgbulls - avgbears
            //TPX = wma(net, smooth)                 // final smoothing

            //colors & plots
            //col_bulls = #33ff0099   // 40% transp
            //col_bears = #ff111166   // 60% transp
            //col_level = #ffee00    
            //col_TPXup = color.white , col_TPXdn = color.gray
            //TPXBullish = TPX > 0

            //hline(0, color = col_level, linestyle = hline.style_solid, linewidth = 1, editable = false)
            //hline(clevel, title = "Control Level", color = col_level, linestyle = hline.style_dotted, linewidth = 2)

            //plot(avgbulls, title = "Bull Pressure", color = col_bulls, style = plot.style_area, linewidth = 3)
            //plot(avgbears, title = "Bear Pressure", color = col_bears, style = plot.style_area, linewidth = 3)
            //plot(TPX, title = "Net Pressure", color = TPXBullish ? col_TPXup : col_TPXdn, linewidth = 3)
            List<decimal> bullsList = new();
            List<decimal> bearsList = new();
            List<decimal> avgBullsList = new();
            List<decimal> avgBearsList = new();
            List<decimal> avgBullsSmoothList = new();
            List<decimal> avgBearsSmoothList = new();
            List<decimal> netList = new();
            List<decimal> netSmoothList = new();
            List<decimal> tpxList = new();
            List<decimal> tpxSmoothList = new();
            List<Signal> signalsList = new();

            try
            {
                int lbLength = days;
                int smoothLength = (int)Math.Ceiling(days / 0.667);
                int length = (int)Math.Ceiling(days / 0.2858);

                var volCheckList = VolumeInputCheck(stockDataClass, lbLength, false);
                var highList = volCheckList.Item1;
                var lowList = volCheckList.Item2;
                var maxList = GetMaxAndMinValuesList(highList, lowList, lbLength);
                var highestList = maxList.Item1;
                var lowestList = maxList.Item2;

                for (int h = 0; h < stockDataClass.InputValues.Count; h++)
                {
                    decimal high = highList.ElementAtOrDefault(h);
                    decimal low = lowList.ElementAtOrDefault(h);
                    decimal prevHigh = h >= 1 ? highList.ElementAtOrDefault(h - 1) : 0;
                    decimal prevLow = h >= 1 ? lowList.ElementAtOrDefault(h - 1) : 0;
                    decimal hiup = Math.Max(high - prevHigh, 0);
                    decimal loup = Math.Max(low - prevLow, 0);
                    decimal hidn = Math.Min(high - prevHigh, 0);
                    decimal lodn = Math.Min(low - prevLow, 0);
                    decimal highest = highestList.ElementAtOrDefault(h);
                    decimal lowest = lowestList.ElementAtOrDefault(h);
                    decimal range = highest - lowest;

                    decimal bulls = range != 0 ? Math.Min((hiup + loup) / range, 1) * 100 : 0;
                    bullsList.Add(bulls);

                    decimal bears = range != 0 ? Math.Max((hidn + lodn) / range, -1) * -100 : 0;
                    bearsList.Add(bears);
                }

                avgBullsList = GetMovingAverageList(maType, bullsList, stockDataClass, length);
                avgBullsSmoothList = GetMovingAverageList(maType, avgBullsList, stockDataClass, smoothLength);
                avgBearsList = GetMovingAverageList(maType, bearsList, stockDataClass, length);
                avgBearsSmoothList = GetMovingAverageList(maType, avgBearsList, stockDataClass, smoothLength);
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal avgBulls = avgBullsList.ElementAtOrDefault(i);
                    decimal avgBears = avgBearsList.ElementAtOrDefault(i);
                    decimal avgBullsSmooth = avgBullsSmoothList.ElementAtOrDefault(i);
                    decimal avgBearsSmooth = avgBearsSmoothList.ElementAtOrDefault(i);

                    decimal net = avgBulls - avgBears;
                    netList.Add(net);

                    decimal netSmooth = avgBullsSmooth - avgBearsSmooth;
                    netSmoothList.Add(netSmooth);
                }

                tpxList = GetMovingAverageList(maType, netList, stockDataClass, smoothLength);
                tpxSmoothList = GetMovingAverageList(maType, netSmoothList, stockDataClass, smoothLength);
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal tpx = tpxList.ElementAtOrDefault(j);
                    decimal prevTpx = j >= 1 ? tpxList.ElementAtOrDefault(j - 1) : 0;

                    var signal = GetCompareSignal(tpx, prevTpx);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (bullsList, bearsList, avgBullsList, avgBullsSmoothList, avgBearsList, avgBearsSmoothList, netList, netSmoothList, tpxList, tpxSmoothList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateStrengthOfMovement(
            StockData stockDataClass, string maType, int days = 3)
        {
            // This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
            // © RedKTrader

            //@version=4
            //study(title = "RedK Strength of Movement v4", shorttitle = "RedK_SoM_v4", overlay = false, resolution = "")
            //price = input(title = "Source", defval = close)
            //n = input(title = "Range", defval = 3, minval = 2, maxval = 5)
            //calc_hl = "High / Low" , calc_se = "Start / End"
            //calc = input(title = "SoM Calculation", options = [calc_se, calc_hl], defval = calc_se)
            //length = input(title = "Avg Length", defval = 10, minval = 1)
            //smooth = input(title = "Smoothing", defval = 3, minval = 1)

            // a is the n-bar average change of price - used as a proxy for the "strength of movement"
            // note that in an "n" number of bars, there's actually (n-1) number of "change ranges" 
            // v4.0 optional algos for calculation .. start/end = takes start price - end price  -- this is simpler
            //                                        high/low  = takes highest - lowest of range -- this exposes "breakout attempts"

            // calculate average "directional" change per period
            //move_se = price - price[n - 1]
            //move_hl = (highest(price, n) - lowest(price, n)) * sign(move_se)  //need to make this "directional" 

            //avgmove = calc == calc_se ?
            //  move_se / (n - 1) :
            //  move_hl / (n - 1)

            //aa = nz(avgmove / price[n - 1])              // v2: for technical accuracy, convert price change from absolute value to a ratio
            //b = wma(aa, length)                       // take the (weighted) average of the change ratio for a length of bars 

            // scale the result as a +100/-100 oscillator 
            // v2: updated with adjustment of highest/lowest values to avoid the "confusing visual" 
            //s = stoch(b, max(b, 0), min(b, 0), length) * 2 - 100

            //ss = wma(s, smooth)                     // final smoothing

            //col_somraw = color.new(color.silver, 80)
            //col_trendup = #2962ff
            //col_trenddn = #e91e63
            //col_zeroline = #ffee0044    //yellow with some transparency, which can't be set in hline()

            //plots
            //hline(0, color = col_zeroline, linestyle = hline.style_solid, editable = false)
            //hline(100, color = color.green, linestyle = hline.style_dotted, editable = false)
            //hline(-100, color = color.red, linestyle = hline.style_dotted, editable = false)

            //plot(s, title = "K_SoM Raw", color = col_somraw, linewidth = 1)
            //plot(ss, title = "K_SoM", color = ss >= 0 ? col_trendup : col_trenddn, linewidth = 3)

            //maxup = s == 100 ? 100 : na
            //maxdn = s == -100 ? -100 : na
            //plot(maxup, "Max Strength", style = plot.style_circles, color = col_trendup, linewidth = 3)
            //plot(maxdn, "Max Weakness", style = plot.style_circles, color = col_trenddn, linewidth = 3)
            List<decimal> aaSeList = new();
            List<decimal> bSeList = new();
            List<decimal> ssSeList = new();
            List<decimal> sSeList = new();
            List<decimal> ssHlList = new();
            List<decimal> avgMoveSeList = new();
            List<decimal> avgMoveHlList = new();
            List<decimal> aaHlList = new();
            List<decimal> bHlList = new();
            List<decimal> sHlList = new();
            List<Signal> signalsList = new();

            try
            {
                int smoothLength = days;
                int length = (int)Math.Ceiling(days / 0.3);

                var maxList = GetMaxAndMinValuesList(stockDataClass.InputValues, smoothLength);
                var highestList = maxList.Item1;
                var lowestList = maxList.Item2;

                for (int h = 0; h < stockDataClass.InputValues.Count; h++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(h);
                    decimal prevValue = h >= smoothLength - 1 ? stockDataClass.InputValues.ElementAtOrDefault(h - (smoothLength - 1)) : 0;
                    decimal highest = highestList.ElementAtOrDefault(h);
                    decimal lowest = lowestList.ElementAtOrDefault(h);
                    decimal moveSe = currentValue - prevValue;
                    decimal moveHl = (highest - lowest) * Math.Sign(moveSe);

                    decimal avgMoveSe = moveSe / (smoothLength - 1);
                    avgMoveSeList.Add(avgMoveSe);

                    decimal avgMoveHl = moveHl / (smoothLength - 1);
                    avgMoveHlList.Add(avgMoveHl);

                    decimal aaSe = prevValue != 0 ? avgMoveSe / prevValue : 0;
                    aaSeList.Add(aaSe);

                    decimal aaHl = prevValue != 0 ? avgMoveHl / prevValue : 0;
                    aaHlList.Add(aaHl);
                }

                bSeList = GetMovingAverageList(maType, aaSeList, stockDataClass, length);
                var bSeMinMaxList = GetMaxAndMinValuesList(bSeList, length);
                bHlList = GetMovingAverageList(maType, aaHlList, stockDataClass, length);
                var bHlMinMaxList = GetMaxAndMinValuesList(bHlList, length);
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal bSe = bSeList.ElementAtOrDefault(i);
                    decimal bSeMax = Math.Max(bSeMinMaxList.Item1.ElementAtOrDefault(i), 0);
                    decimal bSeMin = Math.Min(bSeMinMaxList.Item2.ElementAtOrDefault(i), 0);
                    decimal bHl = bHlList.ElementAtOrDefault(i);
                    decimal bHlMax = Math.Max(bSeMinMaxList.Item1.ElementAtOrDefault(i), 0);
                    decimal bHlMin = Math.Min(bSeMinMaxList.Item2.ElementAtOrDefault(i), 0);

                    decimal sSe = bSeMax - bSeMin != 0 ? ((bSe - bSeMin) / (bSeMax - bSeMin) * 100 * 2) - 100 : -100;
                    sSeList.Add(sSe);

                    decimal sHl = bHlMax - bHlMin != 0 ? ((bHl - bHlMin) / (bHlMax - bHlMin) * 100 * 2) - 100 : -100;
                    sHlList.Add(sHl);
                }

                ssSeList = GetMovingAverageList(maType, sSeList, stockDataClass, smoothLength);
                ssHlList = GetMovingAverageList(maType, sHlList, stockDataClass, smoothLength);
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal ssSe = ssSeList.ElementAtOrDefault(j);
                    decimal prevSsse = j >= 1 ? ssSeList.ElementAtOrDefault(j - 1) : 0;

                    var signal = GetCompareSignal(ssSe, prevSsse);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (avgMoveSeList, avgMoveHlList, aaSeList, aaHlList, bSeList, bHlList, sSeList, sHlList, ssSeList, ssHlList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateSlowSmoothedMovingAverage(StockData stockDataClass, string maType, int days = 15)
        {
            // This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
            // © RedKTrader

            //@version=4
            // RedK Slow Smooth WMA (RSS_WMA) is a triple-pass WMA
            // The idea here is to create a moving average that prioritizes smoothness over low-lag and fast-responsiveness
            // to be used to filter out noise from insignificant or retively smaller price moves and enable visualization and tracking of the longer-term trend
            // RSS_WMA can be used as a baseline with a faster MA, to set exit stops, and to help keep in positions for longer drations
            // the initial length used for the first WMA pass is 1/3 of the "combined smoothness" value selected in the settings
            // increments in the combined smoothness value will be allocated first to 1st pass, then 2nd pass, then 3rd pass consecutievly then back to 1st pass .. and so on.
            // *** =====================================================================================================================

            //study("RedK Slow_Smooth WMA", shorttitle = "RSS_WMA v1", overlay = true, resolution = "")

            //===============================================
            //            f_LazyLine(_data, _length) =>
            //    w1 = 0, w2 = 0, w3 = 0
            //    L1 = 0.0, L2 = 0.0, L3 = 0.0
            //    w = _length / 3

            //    if _length > 2
            //        w2:= round(w)
            //        w1:= round((_length - w2) / 2)
            //        w3:= int((_length - w2) / 2)

            //        L1:= wma(_data, w1)
            //        L2:= wma(L1, w2)
            //        L3:= wma(L2, w3)
            //    else
            //            L3:= _data
            //    L3
            //====================================

            //price = input(title = "Source", type = input.source, defval = close)
            //alpha = input(title = "Combined Smoothness", type = input.integer, defval = 15, minval = 1)

            //LL = f_LazyLine(price, alpha)

            //c_up = color.new(#33ff00, 0)
            //c_dn = color.new(#ff1111, 0)
            //uptrend = LL > LL[1]

            //plot(LL, "SS_WMA Line", color = uptrend ? c_up : c_dn, linewidth = 3)
            //plot(wma(price, alpha), "WMA", color = color.purple, display = 0)
            List<decimal> l1List = new();
            List<decimal> l2List = new();
            List<decimal> l3List = new();
            List<Signal> signalsList = new();

            try
            {
                int w2 = MinOrMax((int)Math.Ceiling((decimal)days / 3));
                int w1 = MinOrMax((int)Math.Ceiling((decimal)(days - w2) / 2));
                int w3 = MinOrMax((int)Math.Floor((decimal)(days - w2) / 2));

                l1List = GetMovingAverageList(maType, null, stockDataClass, w1);
                l2List = GetMovingAverageList(maType, l1List, stockDataClass, w2);
                l3List = GetMovingAverageList(maType, l2List, stockDataClass, w3);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal l3 = l3List.ElementAtOrDefault(i);
                    decimal prevL3 = i >= 1 ? l3List.ElementAtOrDefault(i - 1) : 0;

                    var signal = GetCompareSignal(currentValue - l3, prevValue - prevL3);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (l1List, l2List, l3List, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateCompoundRatioMovingAverage(StockData stockDataClass, string maType, int days = 20)
        {
            //@version=4
            // This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
            // © RedKTrader

            //study("Comp_Ratio_MA", shorttitle = "CoRa Wave", overlay = true, resolution = "")

            // ======================================================================    
            // Compound Ratio Weight MA function
            // Compound Ratio Weight is where the weight increases in a "logarithmicly linear" way (i.e., linear when plotted on a log chart) - similar to compound ratio
            // the "step ratio" between weights is consistent - that's not the case with linear-weight moving average (WMA), or EMA 
            // another advantage is we can significantly reduce the "tail weight" - which is "relatively" large in other MAs and contributes to lag
            //
            // Compound Weight ratio     r = (A/P)^1/t - 1
            // Weight at time t         A = P(1 + r)^t 
            //                            = Start_val * (1 + r) ^ index
            // Note: index is 0 at the furthest point back -- num periods = length -1
            //
            //            f_adj_crwma(source, length, Start_Wt, r_multi) =>
            //    numerator = 0.0, denom = 0.0, c_weight = 0.0
            //    //Start_Wt = 1.0    // Start Wight is an input in this version - can also be set to a basic value here.
            //    End_Wt = length     // use length as initial End Weight to calculate base "r"
            //    r = pow((End_Wt / Start_Wt), (1 / (length - 1))) - 1
            //    base = 1 + r * r_multi
            //    for i = 0 to length - 1
            //        c_weight    := Start_Wt * pow(base, (length - i))
            //        numerator   := numerator + source[i] * c_weight
            //        denom       := denom + c_weight
            //    numerator / denom
            // ====================================================================== ==   

            //data = input(title = "Source", type = input.source, defval = hlc3)
            //length = input(title = "length", type = input.integer, defval = 20, minval = 1)
            //r_multi = input(title = "Comp Ratio Multiplier", type = input.float, defval = 2.0, minval = 0, step = .1)
            //smooth = input(title = "Auto Smoothing", type = input.bool, defval = true, group = "Smoothing")
            //man_smooth = input(title = "Manual Smoothing", type = input.integer, defval = 1, minval = 1, step = 1, group = "Smoothing")

            //s = smooth ? max(round(sqrt(length)), 1) : man_smooth
            //cora_raw = f_adj_crwma(data, length, 0.01, r_multi)
            //cora_wave = wma(cora_raw, s)

            //c_up = color.new(color.aqua, 0)
            //c_dn = color.new(#FF9800   , 0)
            //cora_up = cora_wave > cora_wave[1]
            //plot(cora_wave, title = "Adjustible CoRa_Wave", color = cora_up ? c_up : c_dn, linewidth = 3)
            List<decimal> coraRawList = new();
            List<decimal> coraWaveList = new();
            List<decimal> sumList = new();
            List<decimal> weightedSumList = new();
            List<Signal> signalsList = new();

            try
            {
                decimal r = Pow(days, ((double)1 / (days - 1)) - 1);
                int smoothLength = Math.Max((int)Math.Round(Math.Sqrt(days)), 1);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal sum = 0, weightedSum = 0, bas = 1 + (r * 2);
                    for (int j = 0; j <= days - 1; j++)
                    {
                        decimal weight = Pow(bas, days - i);
                        decimal prevValue = i >= j ? stockDataClass.InputValues.ElementAtOrDefault(i - j) : 0;

                        sum += prevValue * weight;
                        weightedSum += weight;
                    }
                    sumList.Add(sum);
                    weightedSumList.Add(weightedSum);

                    decimal coraRaw = weightedSum != 0 ? sum / weightedSum : 0;
                    coraRawList.Add(coraRaw);
                }

                coraWaveList = GetMovingAverageList(maType, coraRawList, stockDataClass, smoothLength);
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(j);
                    decimal prevValue = j >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(j - 1) : 0;
                    decimal coraWave = coraWaveList.ElementAtOrDefault(j);
                    decimal prevCoraWave = j >= 1 ? coraWaveList.ElementAtOrDefault(j - 1) : 0;

                    var signal = GetCompareSignal(currentValue - coraWave, prevValue - prevCoraWave);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (sumList, weightedSumList, coraRawList, coraWaveList, signalsList);
        }

        public static (List<decimal>, List<Signal>) CalculatePerformanceIndex(StockData stockDataClass, int days = 14)
        {
            //@version=2
            ////////////////////////////////////////////////////////////
            //  Copyright by HPotter v1.0 22/03/2018
            // The Performance indicator or a more familiar term, KPI (key performance indicator), 
            // is an industry term that measures the performance. Generally used by organizations, 
            // they determine whether the company is successful or not, and the degree of success. 
            // It is used on a business’ different levels, to quantify the progress or regress of a 
            // department, of an employee or even of a certain program or activity. For a manager 
            // it’s extremely important to determine which KPIs are relevant for his activity, and 
            // what is important almost always depends on which department he wants to measure the 
            // performance for.  So the indicators set for the financial team will be different than 
            // the ones for the marketing department and so on.
            //
            // Similar to the KPIs companies use to measure their performance on a monthly, quarterly 
            // and yearly basis, the stock market makes use of a performance indicator as well, although 
            // on the market, the performance index is calculated on a daily basis. The stock market 
            // performance indicates the direction of the stock market as a whole, or of a specific stock 
            // and gives traders an overall impression over the future security prices, helping them decide 
            // the best move. A change in the indicator gives information about future trends a stock could 
            // adopt, information about a sector or even on the whole economy. The financial sector is the 
            // most relevant department of the economy and the indicators provide information on its overall 
            // health, so when a stock price moves upwards, the indicators are a signal of good news. On the 
            // other hand, if the price of a particular stock decreases, that is because bad news about its 
            // performance are out and they generate negative signals to the market, causing the price to go 
            // downwards. One could state that the movement of the security prices and consequently, the movement 
            // of the indicators are an overall evaluation of a country’s economic trend.
            //
            // WARNING:
            // - This script to change bars colors.
            ////////////////////////////////////////////////////////////
            //study(title = "Perfomance index Strategy")
            //Period = input(14, minval = 1)
            //xKPI = (close - close[Period]) * 100 / close[Period]
            //clr = iff(xKPI > 0, green, red)
            //p1 = plot(xKPI, color = blue, title = "KPI")
            //p2 = plot(0, color = blue, title = "0")
            //pos = iff(xKPI > 0, 1,
            //      iff(xKPI < 0, -1, nz(pos[1], 0)))
            //barcolor(pos == -1 ? red : pos == 1 ? green : blue)
            //fill(p1, p2, color = clr)
            List<decimal> kpiList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= days ? stockDataClass.InputValues.ElementAtOrDefault(i - days) : 0;

                    decimal prevKpi = kpiList.LastOrDefault();
                    decimal kpi = prevValue != 0 ? (currentValue - prevValue) * 100 / prevValue : 0;
                    kpiList.Add(kpi);

                    var signal = GetCompareSignal(kpi, prevKpi);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (kpiList, signalsList);
        }

        public static (List<decimal>, List<Signal>) CalculateVerticalHorizontalMovingAverage(StockData stockDataClass, int days = 50)
        {
            // This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License https://creativecommons.org/licenses/by-sa/4.0/
            // © Aneopsy & alexgrover

            //@version=4
            //study("Vertical Horizontal Moving Average [AneoPsy & alexgrover]", "VHMA", true)
            //length = input(defval = 50, type = input.integer, title = "Length")
            //src = input(defval = close, type = input.source, title = "Source")
            //alert = input("VHMA Direction Change", "Alert Conditions",
            //options =["VHMA Direction Change", "SRC/VHMA Crossover"])
            //------------------------------------------------------------------------------
            //vhma = 0.
            //R = highest(src, length) - lowest(src, length)
            //vhf = R / sum(abs(change(src)), length)
            //vhma:= nz(vhma[1] + pow(vhf, 2) * (src - vhma[1]), src)
            //------------------------------------------------------------------------------
            //lineColor = vhma > vhma[1] ? color.lime : color.red
            //plot(vhma, title = "VHMA", color = lineColor, linewidth = 2, transp = 0)
            //------------------------------------------------------------------------------
            //Alerts
            //------------------------------------------------------------------------------
            //string a = "VHMA Direction Change",string b = "SRC/VHMA Crossover"
            //buy = alert == a ? crossover(change(vhma), 0) : crossover(src, vhma)
            //sell = alert == a ? crossunder(change(vhma), 0) : crossunder(src, vhma)
            //alertcondition(buy, "Buy Alert", "VHMA Buy Alert")
            //alertcondition(sell, "Sell Alert", "VHMA Sell Alert")
            List<decimal> changeList = new();
            List<decimal> vhmaList = new();
            List<Signal> signalsList = new();

            try
            {
                var minMaxList = GetMaxAndMinValuesList(stockDataClass.InputValues, days);
                var highestList = minMaxList.Item1;
                var lowestList = minMaxList.Item2;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal priorValue = i >= days ? stockDataClass.InputValues.ElementAtOrDefault(i - days) : 0;
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal highest = highestList.ElementAtOrDefault(i);
                    decimal lowest = lowestList.ElementAtOrDefault(i);

                    decimal priceChange = Math.Abs(currentValue - priorValue);
                    changeList.Add(priceChange);

                    decimal numerator = highest - lowest;
                    decimal denominator = changeList.TakeLast(days).Sum();
                    decimal vhf = denominator != 0 ? numerator / denominator : 0;

                    decimal prevVhma = vhmaList.LastOrDefault();
                    decimal vhma = prevVhma + (Pow(vhf, 2) * (currentValue - prevVhma));
                    vhmaList.Add(vhma);

                    var signal = GetCompareSignal(currentValue - vhma, prevValue - prevVhma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (vhmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateNarrowBandpassFilter(StockData stockDataClass, int days = 50)
        {
            // This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License https://creativecommons.org/licenses/by-sa/4.0/
            // © alexgrover

            //@version=4
            //study("Narrow Bandpass Filter", "NBF")
            //peak = input(50, "Cycle Period")
            //bw = input(1, "Bandwidth")
            //src = input(close)
            //Win = input(true, "Windowing")
            //------------------------------------------------------------------------------
            //M = peak * bw
            //pi = 3.14159,sum = 0.
            //for i = 0 to M - 1
            //    x = i / (M - 1)
            //    win = 0.42 - 0.5 * cos(2 * pi * x)
            //      + 0.08 * cos(4 * pi * x)
            //    w = sin(2 * pi * i / peak) * iff(Win, win, 1)
            //    sum := sum + src[i] * w
            //------------------------------------------------------------------------------
            //css = change(sum) > 0 ? #007796 : #e65100
            //plot(sum, "Plot", css, 2)
            List<decimal> sumList = new();
            List<decimal> wList = new();
            List<decimal> xList = new();
            List<decimal> winList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal prevSum1 = i >= 1 ? sumList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevSum2 = i >= 2 ? sumList.ElementAtOrDefault(i - 2) : 0;

                    decimal w = 0, x = 0, win = 0, sum = 0;
                    for (int j = 0; j <= days - 1; j++)
                    {
                        decimal prevValue = i >= j ? stockDataClass.InputValues.ElementAtOrDefault(i - j) : 0;
                        x = j / (days - 1);
                        win = 0.42m - (0.5m * Cos(2 * Math.PI * (double)x)) + (0.08m * Cos(4 * Math.PI * (double)x));
                        w = Sin(2 * Math.PI * j / days) * win;
                        sum += prevValue * w;
                    }
                    wList.Add(w);
                    xList.Add(x);
                    winList.Add(win);
                    sumList.Add(sum);

                    var signal = GetCompareSignal(sum - prevSum1, prevSum1 - prevSum2);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (wList, xList, winList, sumList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateNthOrderDifferencingOscillator(StockData stockDataClass, int days = 2)
        {
            // This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License https://creativecommons.org/licenses/by-sa/4.0/
            // © alexgrover

            //@version=4
            //study("Nth Order Differencing Oscillator", "NODO")
            //length = input(14, "Oscillator Period")
            //order = input(2, "Differencing Order")
            //src = input(close)
            //------------------------------------------------------------------------------
            //sum = 0.,w = 1
            //for i = 0 to order
            //    x = sign((i + 1) % 2 - .5)
            //    w := w * ((order - i) / (i + 1))
            //    sum := sum + src[length * (i + 1)] * w * x
            //------------------------------------------------------------------------------
            //plot(src - sum, "Plot",#ff1100)
            List<decimal> xList = new();
            List<decimal> wList = new();
            List<decimal> sumList = new();
            List<decimal> nodoList = new();
            List<Signal> signalsList = new();

            try
            {
                int length = days * 7;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);

                    decimal sum = 0, w = 1, x = 0;
                    for (int j = 0; j <= days; j++)
                    {
                        decimal prevValue = i >= length * (j + 1) ? stockDataClass.InputValues.ElementAtOrDefault(i - (length * (j + 1))) : 0;
                        x = Math.Sign(((j + 1) % 2) - 0.5);
                        w *= (days - j) / (j + 1);
                        sum += prevValue * w * x;
                    }
                    xList.Add(x);
                    wList.Add(w);
                    sumList.Add(sum);

                    decimal prevNodo = nodoList.LastOrDefault();
                    decimal nodo = currentValue - sum;
                    nodoList.Add(nodo);

                    var signal = GetCompareSignal(nodo, prevNodo);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (wList, xList, sumList, nodoList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculatePrimeNumberBands(StockData stockDataClass, int days = 5)
        {
            //@version=2
            ////////////////////////////////////////////////////////////
            //  Copyright by HPotter v1.0 05/03/2018
            // Determining market trends has become a science even though a high number 
            // or people still believe it’s a gambling game. Mathematicians, technicians, 
            // brokers and investors have worked together in developing quite several 
            // indicators to help them better understand and forecast market movements.
            // The Prime Number Bands indicator was developed by Modulus Financial Engineering 
            // Inc. This indicator is charted by indentifying the highest and lowest prime number 
            // in the neighborhood and plotting the two series as a band.
            //
            // WARNING:
            // - This script to change bars colors.
            ////////////////////////////////////////////////////////////
            //PrimeNumberUpBand(price, percent) =>
            //res = 0
            //res1 = 0
            //for j = price to price + (price * percent / 100)
            //    res1 := j
            //    for i = 2 to sqrt(price)
            //        res1 := iff(j % i == 0, 0, j)
            //        if res1 == 0
            //            break
            //    if res1 > 0
            //        break
            //res:= iff(res1 == 0, res[1], res1)
            //res

            //PrimeNumberDnBand(price, percent) =>
            //    res = 0
            //    res2 = 0
            //    for j = price to price - (price * percent / 100)
            //        res2 := j
            //        for i = 2 to sqrt(price)
            //            res2 := iff(j % i == 0, 0, j)
            //            if res2 == 0
            //                break
            //        if res2 > 0
            //            break
            //    res:= iff(res2 == 0, res[1], res2)
            //    res

            //study(title = "Prime Number Bands Strategy", overlay = true)
            //percent = input(5, minval = 0.01, step = 0.01, title = "Tolerance Percentage")
            //Length = input(5, minval = 1)
            //srcUp = input(title = "Source Up Band", type = source, defval = high)
            //srcDn = input(title = "Source Down Band", type = source, defval = low)
            //xPNUB = PrimeNumberUpBand(srcUp, percent)
            //xPNDB = PrimeNumberDnBand(srcDn, percent)
            //xHighestPNUB = highest(xPNUB, Length)
            //xLowestPNUB = lowest(xPNDB, Length)
            //pos = iff(close > xHighestPNUB[1], 1,
            //      iff(close < xLowestPNUB[1], -1, nz(pos[1], 0)))
            //barcolor(pos == -1 ? red : pos == 1 ? green : blue)
            //plot(xHighestPNUB, color = red, title = "PNUp")
            //plot(xLowestPNUB, color = green, title = "PNDn")
            List<decimal> pnUpBandList = new();
            List<decimal> pnDnBandList = new();
            List<decimal> highestPnUpBandList = new();
            List<decimal> lowestPnDnBandList = new();
            List<Signal> signalsList = new();

            try
            {
                var list = VolumeInputCheck(stockDataClass, days, false);
                var highList = list.Item1;
                var lowList = list.Item2;
                var pnoUpBandList = CalculatePrimeNumberOscillator(highList, stockDataClass, days).Item1;
                var pnoDnBandList = CalculatePrimeNumberOscillator(lowList, stockDataClass, days).Item2;

                for (int i = 0; i < stockDataClass.HighPrices.Count; i++)
                {
                    decimal close = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevUpBand1 = i >= 1 ? highestPnUpBandList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevUpBand2 = i >= 2 ? highestPnUpBandList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevDnBand1 = i >= 1 ? lowestPnDnBandList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevDnBand2 = i >= 2 ? lowestPnDnBandList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevClose = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal pnUpBand = pnoUpBandList.ElementAtOrDefault(i);
                    pnUpBandList.Add(pnUpBand);

                    decimal pnDnBand = pnoDnBandList.ElementAtOrDefault(i);
                    pnDnBandList.Add(pnDnBand);

                    decimal highestPnUpBand = pnUpBandList.TakeLast(days).Max();
                    highestPnUpBandList.Add(highestPnUpBand);

                    decimal lowestPnDnBand = pnDnBandList.TakeLast(days).Min();
                    lowestPnDnBandList.Add(lowestPnDnBand);

                    var signal = GetBullishBearishSignal(close - prevUpBand1, prevClose - prevUpBand2, close - prevDnBand1, prevClose - prevDnBand2);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (pnUpBandList, pnDnBandList, highestPnUpBandList, lowestPnDnBandList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateQuantitativeQualitativeEstimation(StockData stockDataClass, string maType, int days = 5)
        {
            //study("QQERSX")

            //RSI_Period = input(14, title = 'RSI Length')
            //SF = input(5, title = 'RSI Smoothing')
            //QQE = input(4.236, title = 'Slow QQE Factor')
            //QQE = input(2.618, title = 'Fast QQE Factor')
            //ThreshHold = input(10, title = "Thresh-hold")
            //
            //sQQEx = input(false, title = "Show Smooth RSI, QQE Signal crosses")
            //sQQEz = input(false, title = "Show Smooth RSI Zero crosses")
            //sQQEc = input(false, title = "Show Smooth RSI Thresh Hold Channel Exits")

            //src = input(close, title = "RSI Source")
            //Wilders_Period = RSI_Period * 2 - 1
            //Rsi = rsi(src, RSI_Period)
            //RsiMa = ema(Rsi, SF)
            //AtrRsi = abs(RsiMa - RsiMa)
            //MaAtrRsi = ema(AtrRsi, Wilders_Period)
            //dar = ema(MaAtrRsi, Wilders_Period) * QQE

            //longband = 0.0
            //shortband = 0.0
            //trend = 0

            //DeltaFastAtrRsi = dar
            //RSIndex = RsiMa
            //newshortband = RSIndex + DeltaFastAtrRsi
            //newlongband = RSIndex - DeltaFastAtrRsi
            //longband:= RSIndex > longband and RSIndex > longband ? max(longband, newlongband) : newlongband
            //shortband:= RSIndex < shortband and RSIndex<shortband? min(shortband, newshortband):newshortband
            //trend := cross(RSIndex, shortband) ? 1 : cross(longband, RSIndex) ? -1 : nz(trend, 1)
            //FastAtrRsiTL = trend == 1 ? longband : shortband

            //
            // Find all the QQE Crosses
            //QQExlong = 0, QQExlong:= nz(QQExlong)
            //QQExshort = 0, QQExshort:= nz(QQExshort)
            //QQExlong:= sQQEx and FastAtrRsiTL<RSIndex ? QQExlong+1 : 0
            //QQExshort:= sQQEx and FastAtrRsiTL> RSIndex ? QQExshort + 1 : 0
            // Zero cross
            //QQEzlong = 0, QQEzlong:= nz(QQEzlong)
            //QQEzshort = 0, QQEzshort:= nz(QQEzshort)
            //QQEzlong:= sQQEz and RSIndex>= 50 ? QQEzlong + 1 : 0
            //QQEzshort:= sQQEz and RSIndex<50 ? QQEzshort + 1 : 0
            //
            // Thresh Hold channel Crosses give the BUY/SELL alerts.
            //QQEclong = 0, QQEclong:= nz(QQEclong)
            //QQEcshort = 0, QQEcshort:= nz(QQEcshort)
            //QQEclong:= sQQEc and RSIndex> (50 + ThreshHold) ? QQEclong + 1 : 0
            //QQEcshort:= sQQEc and RSIndex<(50 - ThreshHold) ? QQEcshort + 1 : 0

            // QQE exit from Thresh Hold Channel
            //plotshape(sQQEc and QQEclong == 1 ? RsiMa - 50 : na, title = "QQE XC Over Channel", style = shape.diamond, location = location.absolute, color = olive, transp = 0, size = size.small, offset = 0)
            //plotshape(sQQEc and QQEcshort == 1 ? RsiMa - 50 : na, title = "QQE XC Under Channel", style = shape.diamond, location = location.absolute, color = red, transp = 0, size = size.small, offset = 0)
            // QQE crosses
            //plotshape(sQQEx and QQExlong == 1 ? FastAtrRsiTL - 50 : na, title = "QQE XQ Cross Over", style = shape.circle, location = location.absolute, color = lime, transp = 0, size = size.small, offset = -1)
            //plotshape(sQQEx and QQExshort == 1 ? FastAtrRsiTL - 50 : na, title = "QQE XQ Cross Under", style = shape.circle, location = location.absolute, color = blue, transp = 0, size = size.small, offset = -1)
            // Signal crosses zero line
            //plotshape(sQQEz and QQEzlong == 1 ? RsiMa - 50 : na, title = "QQE XZ Zero Cross Over", style = shape.square, location = location.absolute, color = aqua, transp = 0, size = size.small, offset = 0)
            //plotshape(sQQEz and QQEzshort == 1 ? RsiMa - 50 : na, title = "QQE XZ Zero Cross Under", style = shape.square, location = location.
            List<decimal> rsiEmaList = new();
            List<decimal> atrRsiList = new();
            List<decimal> atrRsiEmaList = new();
            List<decimal> atrRsiEmaSmoothList = new();
            List<decimal> fastAtrRsiList = new();
            List<decimal> slowAtrRsiList = new();
            List<Signal> signalsList = new();

            try
            {
                decimal fastAtrMultiplier = 2.618m, slowAtrMultiplier = 4.236m;
                int rsiPeriod = (int)Math.Ceiling(days / 0.3572);
                int wildersPeriod = (rsiPeriod * 2) - 1;
                int smoothPeriod = days;

                var rsiList = CalculateRelativeStrengthIndex(null, stockDataClass, maType, rsiPeriod).Item4;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentRsi = rsiList.ElementAtOrDefault(i);

                    decimal prevRsiEma = rsiEmaList.LastOrDefault();
                    decimal currentRsiEma = CalculateExponentialMovingAverage(currentRsi, prevRsiEma, smoothPeriod);
                    rsiEmaList.Add(currentRsiEma);

                    decimal atrRsi = Math.Abs(currentRsiEma - prevRsiEma);
                    atrRsiList.Add(atrRsi);

                    decimal atrRsiEma = CalculateExponentialMovingAverage(atrRsi, atrRsiEmaList.LastOrDefault(), wildersPeriod);
                    atrRsiEmaList.Add(atrRsiEma);

                    decimal prevAtrRsiEmaSmooth = atrRsiEmaSmoothList.LastOrDefault();
                    decimal atrRsiEmaSmooth = CalculateExponentialMovingAverage(atrRsiEma, prevAtrRsiEmaSmooth, wildersPeriod);
                    atrRsiEmaSmoothList.Add(atrRsiEmaSmooth);

                    decimal prevFastTl = fastAtrRsiList.LastOrDefault();
                    decimal fastTl = atrRsiEmaSmooth * fastAtrMultiplier;
                    fastAtrRsiList.Add(fastTl);

                    decimal prevSlowTl = slowAtrRsiList.LastOrDefault();
                    decimal slowTl = atrRsiEmaSmooth * slowAtrMultiplier;
                    slowAtrRsiList.Add(slowTl);

                    var signal = GetBullishBearishSignal(atrRsiEmaSmooth - Math.Max(fastTl, slowTl), prevAtrRsiEmaSmooth - Math.Max(prevFastTl, prevSlowTl),
                        atrRsiEmaSmooth - Math.Min(fastTl, slowTl), prevAtrRsiEmaSmooth - Math.Min(prevFastTl, prevSlowTl));
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (rsiEmaList, atrRsiList, atrRsiEmaList, atrRsiEmaSmoothList, fastAtrRsiList, slowAtrRsiList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateVolumeAdjustedMovingAverage(StockData stockDataClass, string maType, int days)
        {
            //a. Compute the overall average volume in the chart: AvgVol = Average(Volume, all bars in the chart).
            //b.Compute the volume increment: VolInc = AvgVol * 0.67.
            //c.For each bar in the chart compute the volume ratio: VolRatio = Volume / VolInc.
            //d.Starting from the current bar and working backwards compute CumSum = Sum(VolRatio * Price) and CumDiv = Sum(VolRatio).
            //Stop when CumDiv = Period or Period bars are processed.In order to satisfy first condition only a fraction of the last VolRatio may be used.
            //e.VAMA = CumSum / CumDiv.
            List<decimal> priceVolumeRatioList = new();
            List<decimal> priceVolumeRatioSumList = new();
            List<decimal> vamaList = new();
            List<decimal> volumeIncrementList = new();
            List<decimal> volumeRatioList = new();
            List<decimal> volumeRatioSumList = new();
            List<Signal> signalsList = new();

            try
            {
                var volumeSmaList = GetMovingAverageList(maType, stockDataClass.Volumes, stockDataClass, days);

                for (int i = 0; i < volumeSmaList.Count; i++)
                {
                    decimal currentVolume = stockDataClass.Volumes.ElementAtOrDefault(i);
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal volumeSma = volumeSmaList.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal volumeIncrement = volumeSma * 0.67m;
                    volumeIncrementList.Add(volumeIncrement);

                    decimal volumeRatio = volumeIncrement != 0 ? currentVolume / volumeIncrement : 0;
                    volumeRatioList.Add(volumeRatio);

                    decimal priceVolumeRatio = currentValue * volumeRatio;
                    priceVolumeRatioList.Add(priceVolumeRatio);

                    decimal volumeRatioSum = volumeRatioList.TakeLast(days).Sum();
                    volumeRatioSumList.Add(volumeRatioSum);

                    decimal priceVolumeRatioSum = priceVolumeRatioList.TakeLast(days).Sum();
                    priceVolumeRatioSumList.Add(priceVolumeRatioSum);

                    decimal prevVama = vamaList.LastOrDefault();
                    decimal vama = volumeRatioSum != 0 ? priceVolumeRatioSum / volumeRatioSum : 0;
                    vamaList.Add(vama);

                    var signal = GetCompareSignal(currentValue - vama, prevValue - prevVama);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (volumeIncrementList, volumeRatioList, priceVolumeRatioList, volumeRatioSumList, priceVolumeRatioSumList, vamaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateMarketDirectionIndicator(StockData stockDataClass, int days = 13)
        {
            //
            // @author LazyBear 
            // List of all my indicators: 
            // https://docs.google.com/document/d/15AGCufJZ8CIUvwFJ9W-IKns88gkWOKBCvByMEvm5MLo/edit?usp=sharing
            // 
            //study("Market Direction Indicator [LazyBear]", shorttitle = "MDI_LB")
            //src = close
            //lenMA1 = input(13, title = "Short Length"), lenMA2 = input(55, title = "Long Length")
            //cutoff = input(2, title = "No-trend cutoff")
            //sbz = input(false, title = "Show Below Zero")
            //om = input(false, title = "Enable overlay mode")
            //calc_cp2(src, len1, len2) =>
            //    (len1 * (sum(src, len2 - 1)) - len2 * (sum(src, len1 - 1))) / (len2 - len1)

            //cp2 = calc_cp2(src, lenMA1, lenMA2)
            //mdi = 100 * (nz(cp2[1]) - cp2) / ((src + src[1]) / 2)
            //mdic = mdi < -cutoff ? (mdi < mdi[1] ? red : orange) : mdi > cutoff ? (mdi > mdi[1] ? green : lime) : gray
            //plot(om ? na : 0, color = gray, title = "ZeroLine"), plot(om ? na : sbz ? mdi : abs(mdi), style = columns, color = mdic, linewidth = 3, title = "MDI")
            //barcolor(om ? mdic : na)
            List<decimal> mdiList = new();
            List<decimal> cp2List = new();
            List<decimal> tempList = new();
            List<Signal> signalsList = new();

            try
            {
                int len1 = days;
                int len2 = MinOrMax((int)Math.Ceiling(len1 / 0.24));

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    tempList.Add(currentValue);

                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal len1Sum = tempList.TakeLast(len1 - 1).Sum();
                    decimal len2Sum = tempList.TakeLast(len2 - 1).Sum();

                    decimal prevCp2 = cp2List.LastOrDefault();
                    decimal cp2 = ((len1 * len2Sum) - (len2 * len1Sum)) / (len2 - len1);
                    cp2List.Add(cp2);

                    decimal prevMdi = mdiList.LastOrDefault();
                    decimal mdi = currentValue + prevValue != 0 ? 100 * (prevCp2 - cp2) / ((currentValue + prevValue) / 2) : 0;
                    mdiList.Add(mdi);

                    var signal = GetCompareSignal(mdi, prevMdi);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (cp2List, mdiList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateAnchoredMomentum(StockData stockDataClass, int days = 7)
        {
            //
            // @author LazyBear 
            // List of all my indicators: 
            // https://docs.google.com/document/d/15AGCufJZ8CIUvwFJ9W-IKns88gkWOKBCvByMEvm5MLo/edit?usp=sharing
            // 
            //study("Anchored Momentum [LazyBear]", shorttitle = "AMOM_LB")
            //src = close
            //l = input(10, title = "Momentum Period")
            //sl = input(8, title = "Signal Period")
            //sm = input(false, title = "Smooth Momentum")
            //smp = input(7, title = "Smoothing Period")
            //sh = input(false, title = "Show Histogram")
            //eb = input(false, title = "Enable Barcolors")
            //p = 2 * l + 1
            //amom = 100 * (((sm ? ema(src, smp) : src) / (sma(src, p)) - 1))
            //amoms = sma(amom, sl)
            List<decimal> tempList = new();
            List<decimal> amomList = new();
            List<decimal> amomsList = new();
            List<Signal> signalsList = new();

            try
            {
                int smp = days;
                int l = MinOrMax((int)Math.Ceiling(smp / 0.7));
                int sl = MinOrMax((int)Math.Ceiling(smp / 0.875));
                int p = MinOrMax((2 * l) + 1);

                List<decimal> emaList = CalculateExponentialMovingAverage(stockDataClass, smp).Item1;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentEma = emaList.ElementAtOrDefault(i);

                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    tempList.Add(currentValue);

                    decimal sma = tempList.TakeLast(p).Average();
                    decimal prevAmom = amomList.LastOrDefault();
                    decimal amom = sma != 0 ? 100 * ((currentEma / sma) - 1) : 0;
                    amomList.Add(amom);

                    decimal prevAmoms = amomsList.LastOrDefault();
                    decimal amoms = amomList.TakeLast(sl).Average();
                    amomsList.Add(amoms);

                    var signal = GetCompareSignal(amom - amoms, prevAmom - prevAmoms);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (amomList, amomsList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<Signal>) CalculateCoralTrendIndicator(StockData stockDataClass, int days = 21)
        {
            //
            // @author LazyBear 
            // List of all my indicators: 
            // https://docs.google.com/document/d/15AGCufJZ8CIUvwFJ9W-IKns88gkWOKBCvByMEvm5MLo/edit?usp=sharing
            // 
            //study(title = "Coral Trend Indicator [LazyBear]", shorttitle = "CTI_LB", overlay = true)
            //src = close
            //sm = input(21, title = "Smoothing Period")
            //cd = input(0.4, title = "Constant D")
            //ebc = input(false, title = "Color Bars")
            //ribm = input(false, title = "Ribbon Mode")
            //di = (sm - 1.0) / 2.0 + 1.0
            //c1 = 2 / (di + 1.0)
            //c2 = 1 - c1
            //c3 = 3.0 * (cd * cd + cd * cd * cd)
            //c4 = -3.0 * (2.0 * cd * cd + cd + cd * cd * cd)
            //c5 = 3.0 * cd + 1.0 + cd * cd * cd + 3.0 * cd * cd
            //i1 = c1 * src + c2 * nz(i1[1])
            //i2 = c1 * i1 + c2 * nz(i2[1])
            //i3 = c1 * i2 + c2 * nz(i3[1])
            //i4 = c1 * i3 + c2 * nz(i4[1])
            //i5 = c1 * i4 + c2 * nz(i5[1])
            //i6 = c1 * i5 + c2 * nz(i6[1])

            //bfr = -cd * cd * cd * i6 + c3 * (i5) + c4 * (i4) + c5 * (i3)
            //bfrC = bfr > nz(bfr[1]) ? green : bfr < nz(bfr[1]) ? red : blue
            //tc = ebc ? gray : bfrC
            //plot(ribm ? na : bfr, title = "Trend", linewidth = 3, style = circles, color = tc)
            //bgcolor(ribm ? bfrC : na, transp = 50)
            //barcolor(ebc ? bfrC : na)
            decimal cd = 0.4m;
            List<decimal> i1List = new();
            List<decimal> i2List = new();
            List<decimal> i3List = new();
            List<decimal> i4List = new();
            List<decimal> i5List = new();
            List<decimal> i6List = new();
            List<decimal> bfrList = new();
            List<Signal> signalsList = new();

            try
            {
                decimal di = ((days - 1) / 2) + 1;
                decimal c1 = 2 / (di + 1);
                decimal c2 = 1 - c1;
                decimal c3 = 3 * ((cd * cd) + (cd * cd * cd));
                decimal c4 = -3 * ((2 * cd * cd) + cd + (cd * cd * cd));
                decimal c5 = (3 * cd) + 1 + (cd * cd * cd) + (3 * cd * cd);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal prevI1 = i1List.LastOrDefault();
                    decimal i1 = (c1 * currentValue) + (c2 * prevI1);
                    i1List.Add(i1);

                    decimal prevI2 = i2List.LastOrDefault();
                    decimal i2 = (c1 * i1) + (c2 * prevI2);
                    i2List.Add(i2);

                    decimal prevI3 = i3List.LastOrDefault();
                    decimal i3 = (c1 * i2) + (c2 * prevI3);
                    i3List.Add(i3);

                    decimal prevI4 = i4List.LastOrDefault();
                    decimal i4 = (c1 * i3) + (c2 * prevI4);
                    i4List.Add(i4);

                    decimal prevI5 = i5List.LastOrDefault();
                    decimal i5 = (c1 * i4) + (c2 * prevI5);
                    i5List.Add(i5);

                    decimal prevI6 = i6List.LastOrDefault();
                    decimal i6 = (c1 * i5) + (c2 * prevI6);
                    i6List.Add(i6);

                    decimal prevBfr = bfrList.LastOrDefault();
                    decimal bfr = (-1 * cd * cd * cd * i6) + (c3 * i5) + (c4 * i4) + (c5 * i3);
                    bfrList.Add(bfr);

                    var signal = GetCompareSignal(currentValue - bfr, prevValue - prevBfr);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (i1List, i2List, i3List, i4List, i5List, i6List, bfrList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<decimal>, List<Signal>) CalculateEmaWaveIndicator(StockData stockDataClass, string maType, int days = 4)
        {
            //
            // @author LazyBear 
            // List of all my indicators: 
            // https://docs.google.com/document/d/15AGCufJZ8CIUvwFJ9W-IKns88gkWOKBCvByMEvm5MLo/edit?usp=sharing
            // 
            //study("EMA Wave Indicator [LazyBear]", shorttitle = "EWI_LB")
            //alength = input(5, title = "Wave A Length")
            //blength = input(25, title = "Wave B Length")
            //clength = input(50, title = "Wave C Length")
            //lengthMA = input(4, title = "Wave SMA Length")
            //mse = input(false, title = "Identify Spikes/Exhaustions")
            //cutoff = input(10, title = "Cutoff")
            //ebc = input(false, title = "Color Bars on Spikes/Exhaustions")
            //src = hlc3
            //ma(s, l) => ema(s, l)
            //wa = sma(src - ma(src, alength), lengthMA)
            //wb = sma(src - ma(src, blength), lengthMA)
            //wc = sma(src - ma(src, clength), lengthMA)
            //wcf = (wb != 0) ? (wc / wb > cutoff) : false
            //wbf = (wa != 0) ? (wb / wa > cutoff) : false
            //plot(0, color = gray, title = "ZeroLine")
            //plot(wc, color = maroon, style = histogram, linewidth = 3, title = "WaveC")
            //plot(mse and wcf ? wc : na, color = fuchsia, style = histogram, linewidth = 3, title = "WaveC Spike")
            //plot(wb, color = blue, style = histogram, linewidth = 3, title = "WaveB")
            //plot(mse and wbf ? wb : na, color = fuchsia, style = histogram, linewidth = 3, title = "WaveB Spike")
            //plot(wa, color = red, style = histogram, linewidth = 3, title = "WaveA")
            //barcolor(ebc ? (wcf and wbf) ? #81F7F3 : (wcf or wbf) ? fuchsia : na : na)
            List<decimal> emaADiffList = new();
            List<decimal> emaBDiffList = new();
            List<decimal> emaCDiffList = new();
            List<decimal> waList = new();
            List<decimal> wbList = new();
            List<decimal> wcList = new();
            List<decimal> wcfList = new();
            List<decimal> wbfList = new();
            List<decimal> maxList = new();
            List<decimal> minList = new();
            List<Signal> signalsList = new();

            try
            {
                int lengthMa = days;
                int aLength = (int)Math.Ceiling(days / 0.8);
                int bLength = MinOrMax(aLength * 5);
                int cLength = MinOrMax(aLength * 10);

                var emaAList = GetMovingAverageList(maType, null, stockDataClass, aLength);
                var emaBList = GetMovingAverageList(maType, null, stockDataClass, bLength);
                var emaCList = GetMovingAverageList(maType, null, stockDataClass, cLength);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal emaA = emaAList.ElementAtOrDefault(i);
                    decimal emaB = emaBList.ElementAtOrDefault(i);
                    decimal emaC = emaCList.ElementAtOrDefault(i);

                    decimal emaADiff = currentValue - emaA;
                    emaADiffList.Add(emaADiff);

                    decimal emaBDiff = currentValue - emaB;
                    emaBDiffList.Add(emaBDiff);

                    decimal emaCDiff = currentValue - emaC;
                    emaCDiffList.Add(emaCDiff);

                    decimal wa = emaADiffList.TakeLast(lengthMa).Average();
                    waList.Add(wa);

                    decimal wb = emaBDiffList.TakeLast(lengthMa).Average();
                    wbList.Add(wb);

                    decimal wc = emaCDiffList.TakeLast(lengthMa).Average();
                    wcList.Add(wc);

                    decimal wcf = wb != 0 ? wc / wb : 0;
                    wcfList.Add(wcf);

                    decimal wbf = wa != 0 ? wb / wa : 0;
                    wbfList.Add(wbf);

                    decimal prevMax = maxList.LastOrDefault();
                    decimal max = Math.Max(wa, Math.Max(wb, wc));
                    maxList.Add(max);

                    decimal prevMin = minList.LastOrDefault();
                    decimal min = Math.Min(wa, Math.Min(wb, wc));
                    minList.Add(min);

                    var signal = GetCompareSignal(max - min, prevMax - prevMin);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (emaADiffList, emaBDiffList, emaCDiffList, waList, wbList, wcList, wcfList, wbfList, maxList, minList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateVolatilitySwitchIndicator(StockData stockDataClass, int days = 14)
        {
            //
            // @author LazyBear 
            // List of all my indicators: 
            // https://docs.google.com/document/d/15AGCufJZ8CIUvwFJ9WIKns88gkWOKBCvByMEvm5MLo/edit?usp=sharing
            //http://www.aiqeducation.com/the-volatility-regime-switch-indicator_18/
            //study(title = "Volatility Switch [LazyBear]", shorttitle = "VOLSWITCH_LB")
            //dr = roc(close, 1) / sma(close, 2)
            //dummy = input(false, title = "------- Choose lengths below ----"), il21 = input(true, title = "21"), il14 = input(false, title = "14")

            //vola21 = stdev(dr, 21)
            //vswitch21 = ((vola21[1] <= vola21) + (vola21[2] <= vola21) + (vola21[3] <= vola21) +
            //        (vola21[4] <= vola21) + (vola21[5] <= vola21) + (vola21[6] <= vola21) +
            //        (vola21[7] <= vola21) + (vola21[8] <= vola21) + (vola21[9] <= vola21) +
            //        (vola21[10] <= vola21) + (vola21[11] <= vola21) + (vola21[12] <= vola21) +
            //        (vola21[13] <= vola21) + (vola21[14] <= vola21) + (vola21[15] <= vola21) +
            //        (vola21[16] <= vola21) + (vola21[17] <= vola21) + (vola21[18] <= vola21) +
            //        (vola21[19] <= vola21) + (vola21[20] <= vola21) + 1) / 21

            //vola14 = stdev(dr, 14)
            //vswitch14 = ((vola14[1] <= vola14) + (vola14[2] <= vola14) + (vola14[3] <= vola14) +
            //        (vola14[4] <= vola14) + (vola14[5] <= vola14) + (vola14[6] <= vola14) +
            //        (vola14[7] <= vola14) + (vola14[8] <= vola14) + (vola14[9] <= vola14) +
            //        (vola14[10] <= vola14) + (vola14[11] <= vola14) + (vola14[12] <= vola14) +
            //        (vola14[13] <= vola14) + 1) / 14
            //
            //hline(0.5, title = "Median")
            //plot(il21 ? vswitch21 : na, color = red, linewidth = 2, title = "VOLSWITCH_21")
            //plot(il14 ? vswitch14 : na, color = green, linewidth = 2, title = "VOLSWITCH_14")
            List<decimal> drList = new();
            List<decimal> tempVolaList = new();
            List<decimal> volaList = new();
            List<decimal> vswitchList = new();
            List<decimal> volaSumList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal rocSma = (currentValue + prevValue) / 2;
                    decimal dr = rocSma != 0 ? (currentValue - prevValue) / rocSma : 0;
                    drList.Add(dr);
                }

                volaList = CalculateStandardDeviationVolatility(drList, stockDataClass, days).Item4;
                var emaList = CalculateExponentialMovingAverage(stockDataClass, days).Item1;

                for (int j = 0; j < volaList.Count; j++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(j);
                    decimal currentEma = emaList.ElementAtOrDefault(j);
                    decimal prevValue = j >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(j - 1) : 0;
                    decimal prevEma = j >= 1 ? emaList.ElementAtOrDefault(j - 1) : 0;

                    decimal vola14 = volaList.ElementAtOrDefault(j);
                    tempVolaList.Add(vola14);

                    decimal vola14Sum = tempVolaList.TakeLast(days).Sum();
                    volaSumList.Add(vola14Sum);

                    decimal vswitch14 = vola14Sum / days;
                    vswitchList.Add(vswitch14);

                    var signal = GetVolatilitySignal(currentValue - currentEma, prevValue - prevEma, vswitch14, 0.5m);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (drList, volaList, volaSumList, vswitchList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateVariableMovingAverage(StockData stockDataClass, int days = 6)
        {
            //
            // @author LazyBear 
            // List of all my indicators: 
            // https://docs.google.com/document/d/15AGCufJZ8CIUvwFJ9W-IKns88gkWOKBCvByMEvm5MLo/edit?usp=sharing
            // 
            //study(title = "Variable Moving Average [LazyBear]", shorttitle = "VMA_LB", overlay = true)
            //src = close
            //l = input(6, title = "VMA Length")
            //std = input(false, title = "Show Trend Direction")
            //bc = input(false, title = "Color bars based on Trend")
            //k = 1.0 / l
            //pdm = max((src - src[1]), 0)
            //mdm = max((src[1] - src), 0)
            //pdmS = ((1 - k) * nz(pdmS[1]) + k * pdm)
            //mdmS = ((1 - k) * nz(mdmS[1]) + k * mdm)
            //s = pdmS + mdmS
            //pdi = pdmS / s
            //mdi = mdmS / s
            //pdiS = ((1 - k) * nz(pdiS[1]) + k * pdi)
            //mdiS = ((1 - k) * nz(mdiS[1]) + k * mdi)
            //d = abs(pdiS - mdiS)
            //s1 = pdiS + mdiS
            //iS = ((1 - k) * nz(iS[1]) + k * d / s1)
            //hhv = highest(iS, l)
            //llv = lowest(iS, l)
            //d1 = hhv - llv
            //vI = (iS - llv) / d1
            //vma = (1 - k * vI) * nz(vma[1]) + k * vI * src
            //vmaC = (vma > vma[1]) ? green : (vma < vma[1]) ? red : (vma == vma[1]) ? blue : black
            //plot(vma, color = std ? vmaC : black, linewidth = 3, title = "VMA")
            //barcolor(bc ? vmaC : na)
            List<decimal> vmaList = new();
            List<decimal> pdiList = new();
            List<decimal> mdiList = new();
            List<decimal> pdmsList = new();
            List<decimal> pdisList = new();
            List<decimal> mdmsList = new();
            List<decimal> mdisList = new();
            List<decimal> dList = new();
            List<decimal> s1List = new();
            List<decimal> sList = new();
            List<decimal> ds1List = new();
            List<decimal> isList = new();
            List<decimal> hhvList = new();
            List<decimal> llvList = new();
            List<decimal> d1List = new();
            List<decimal> viList = new();
            List<Signal> signalsList = new();

            try
            {
                decimal k = (decimal)1 / days;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal pdm = Math.Max(currentValue - prevValue, 0);
                    decimal mdm = Math.Max(prevValue - currentValue, 0);

                    decimal prevPdms = pdmsList.LastOrDefault();
                    decimal pdmS = ((1 - k) * prevPdms) + (k * pdm);
                    pdmsList.Add(pdmS);

                    decimal prevMdms = mdmsList.LastOrDefault();
                    decimal mdmS = ((1 - k) * prevMdms) + (k * mdm);
                    mdmsList.Add(mdmS);

                    decimal s = pdmS + mdmS;
                    sList.Add(s);

                    decimal pdi = s != 0 ? pdmS / s : 0;
                    pdiList.Add(pdi);

                    decimal mdi = s != 0 ? mdmS / s : 0;
                    mdiList.Add(mdi);

                    decimal prevPdis = pdisList.LastOrDefault();
                    decimal pdiS = ((1 - k) * prevPdis) + (k * pdi);
                    pdisList.Add(pdiS);

                    decimal prevMdis = mdisList.LastOrDefault();
                    decimal mdiS = ((1 - k) * prevMdis) + (k * mdi);
                    mdisList.Add(mdiS);

                    decimal d = Math.Abs(pdiS - mdiS);
                    dList.Add(d);

                    decimal s1 = pdiS + mdiS;
                    s1List.Add(s1);

                    decimal dS1 = s1 != 0 ? d / s1 : 0;
                    ds1List.Add(dS1);

                    decimal prevIs = isList.LastOrDefault();
                    decimal iS = ((1 - k) * prevIs) + (k * dS1);
                    isList.Add(iS);

                    var lbList = isList.TakeLast(days).ToList();
                    decimal hhv = lbList.Max();
                    hhvList.Add(hhv);

                    decimal llv = lbList.Min();
                    llvList.Add(llv);

                    decimal d1 = hhv - llv;
                    d1List.Add(d1);

                    decimal vI = d1 != 0 ? (iS - llv) / d1 : 0;
                    viList.Add(vI);

                    decimal prevVma = vmaList.LastOrDefault();
                    decimal vma = ((1 - k) * vI * prevVma) + (k * vI * currentValue);
                    vmaList.Add(vma);

                    var signal = GetCompareSignal(currentValue - vma, prevValue - prevVma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (pdmsList, mdmsList, sList, pdiList, mdiList, pdisList, mdisList, dList, s1List, ds1List, isList, hhvList, llvList, d1List, viList, vmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateVariableMovingAverageBands(StockData stockDataClass,
            string maType, int days = 6)
        {
            //
            // @author LazyBear 
            // List of all my indicators: 
            // https://docs.google.com/document/d/15AGCufJZ8CIUvwFJ9W-IKns88gkWOKBCvByMEvm5MLo/edit?usp=sharing
            // 
            //study(title = "Variable Moving Average Bands [LazyBear]", shorttitle = "VMABANDS_LB", overlay = true)
            //src = close
            //l = input(6, title = "VMA Length")
            //bm = input(1.5, title = "Bands Multipler")
            //std = input(false, title = "Show Trend Direction")
            //bc = input(false, title = "Color bars based on Trend")
            //calc_vma(src, l) => 
            //    k = 1.0 / l
            //    pdm = max((src - src[1]), 0)
            //    mdm = max((src[1] - src), 0)
            //    pdmS = ((1 - k) * nz(pdmS[1]) + k * pdm)
            //    mdmS = ((1 - k) * nz(mdmS[1]) + k * mdm)
            //    s = pdmS + mdmS
            //    pdi = pdmS / s
            //    mdi = mdmS / s
            //    pdiS = ((1 - k) * nz(pdiS[1]) + k * pdi)
            //    mdiS = ((1 - k) * nz(mdiS[1]) + k * mdi)
            //    d = abs(pdiS - mdiS)
            //    s1 = pdiS + mdiS
            //    iS = ((1 - k) * nz(iS[1]) + k * d / s1)
            //    hhv = highest(iS, l)
            //    llv = lowest(iS, l)
            //    d1 = hhv - llv
            //    vI = (iS - llv) / d1
            //    vma = (1 - k * vI) * nz(vma[1]) + k * vI * src
            //    vma

            //vma = calc_vma(src, l)
            //o = bm * atr(l)
            //uband = vma + o
            //lband = vma - o
            //vmaC = (vma > vma[1]) ? green : (vma < vma[1]) ? red : (vma == vma[1]) ? blue : black
            //plot(vma, color = std ? vmaC : black, linewidth = 3, title = "VMA")
            //ubx = plot(uband, color = gray, linewidth = 2, title = "UpperBand")
            //lbx = plot(lband, color = gray, linewidth = 2, title = "LowerBand")
            //fill(ubx, lbx, color = black, transp = 95)
            //barcolor(bc ? vmaC : na)
            decimal bm = 1.5m;
            List<decimal> ubandList = new();
            List<decimal> lbandList = new();
            List<decimal> oList = new();
            List<Signal> signalsList = new();

            try
            {
                var maList = GetMovingAverageList(maType, null, stockDataClass, days);
                var atrList = CalculateAverageTrueRange(stockDataClass, maType, days).Item1;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal currentAtr = atrList.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal vma = maList.ElementAtOrDefault(i);
                    decimal prevVma = i >= 1 ? maList.ElementAtOrDefault(i - 1) : 0;

                    decimal o = bm * currentAtr;
                    oList.Add(o);

                    decimal prevUband = ubandList.LastOrDefault();
                    decimal uband = vma + o;
                    ubandList.Add(uband);

                    decimal prevLband = lbandList.LastOrDefault();
                    decimal lband = vma - o;
                    lbandList.Add(lband);

                    var signal = GetBollingerBandsSignal(currentValue - vma, prevValue - prevVma, currentValue, prevValue, uband, prevUband, lband, prevLband);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (oList, ubandList, lbandList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateVariableAdaptiveMovingAverage(StockData stockDataClass, string maType, int days = 14)
        {
            //@version=2
            //study("Variable Adaptive Moving Average", shorttitle = "VAMA", overlay = true)
            //length = input(14)
            //----
            //c = sma(close, length)
            //o = sma(open, length)
            //h = sma(high, length)
            //l = sma(low, length)
            //lv = abs(c - o) / (h - l)
            //
            //ma = lv * close + (1 - lv) * nz(ma[1], close)
            //plot(ma, color =#FF0000,transp=0)
            List<decimal> vmaList = new();
            List<decimal> lvList = new();
            List<Signal> signalsList = new();

            try
            {
                var cList = GetMovingAverageList(maType, stockDataClass.ClosePrices, stockDataClass, days);
                var oList = GetMovingAverageList(maType, stockDataClass.OpenPrices, stockDataClass, days);
                var hList = GetMovingAverageList(maType, stockDataClass.HighPrices, stockDataClass, days);
                var lList = GetMovingAverageList(maType, stockDataClass.LowPrices, stockDataClass, days);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal c = cList.ElementAtOrDefault(i);
                    decimal o = oList.ElementAtOrDefault(i);
                    decimal h = hList.ElementAtOrDefault(i);
                    decimal l = lList.ElementAtOrDefault(i);

                    decimal lv = h - l != 0 ? MinOrMax(Math.Abs(c - o) / (h - l), 0.99m, 0.01m) : 0;
                    lvList.Add(lv);

                    decimal prevVma = i >= 1 ? vmaList.ElementAtOrDefault(i - 1) : currentValue;
                    decimal vma = (lv * currentValue) + ((1 - lv) * prevVma);
                    vmaList.Add(vma);

                    var signal = GetCompareSignal(currentValue - vma, prevValue - prevVma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (lvList, vmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateVariableLengthMovingAverage(
            StockData stockDataClass, string maType, int days = 5)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Variable Length Moving Average script may be freely distributed under the MIT license.
            //study(title = "Variable Length Moving Average", shorttitle = "VLMA", overlay = true)

            //src = input(title = "Source", type = input.source, defval = close)
            //minLength = input(title = "MinLength", type = input.integer, defval = 5, minval = 1)
            //maxLength = input(title = "MaxLength", type = input.integer, defval = 50, minval = 1)

            //mean = sma(src, maxLength)
            //stdDev = stdev(src, maxLength)
            //a = mean - (1.75 * stdDev)
            //b = mean - (0.25 * stdDev)
            //c = mean + (0.25 * stdDev)
            //d = mean + (1.75 * stdDev)

            //length = 0.0
            //length:= src >= b and src <= c ? nz(length[1], maxLength) + 1 : src < a or src > d ? nz(length[1], maxLength) - 1 : nz(length[1], maxLength)
            //sc = 2 / (max(min(length, maxLength), minLength) + 1)
            //vlma = 0.0
            //vlma:= (src * sc) + ((1 - sc) * nz(vlma[1], src))

            //vlmaColor = src > vlma ? color.green : src < vlma ? color.red : color.black
            //plot(vlma, title = "VLMA", linewidth = 3, color = vlmaColor, transp = 0)
            List<decimal> aList = new();
            List<decimal> bList = new();
            List<decimal> cList = new();
            List<decimal> dList = new();
            List<decimal> vlmaList = new();
            List<decimal> lengthList = new();
            List<decimal> scList = new();
            List<Signal> signalsList = new();

            try
            {
                int maxLength = days * 10;

                var smaList = GetMovingAverageList(maType, null, stockDataClass, maxLength);
                var stdDevList = CalculateStandardDeviationVolatility(null, stockDataClass, maxLength).Item4;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal sma = smaList.ElementAtOrDefault(i);
                    decimal stdDev = stdDevList.ElementAtOrDefault(i);

                    decimal a = sma - (1.75m * stdDev);
                    aList.Add(a);

                    decimal b = sma - (0.25m * stdDev);
                    bList.Add(b);

                    decimal c = sma + (0.25m * stdDev);
                    cList.Add(c);

                    decimal d = sma + (1.75m * stdDev);
                    dList.Add(d);

                    decimal prevLength = i >= 1 ? lengthList.ElementAtOrDefault(i - 1) : days;
                    decimal length = MinOrMax(currentValue >= b && currentValue <= c ? prevLength + 1 : currentValue < a || currentValue > d ? prevLength - 1 : prevLength, maxLength, days);
                    lengthList.Add(length);

                    decimal sc = 2 / (length + 1);
                    scList.Add(sc);

                    decimal prevVlma = i >= 1 ? vlmaList.ElementAtOrDefault(i - 1) : currentValue;
                    decimal vlma = (currentValue * sc) + ((1 - sc) * prevVlma);
                    vlmaList.Add(vlma);

                    var signal = GetCompareSignal(currentValue - vlma, prevValue - prevVlma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (aList, bList, cList, dList, lengthList, scList, vlmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateUltimateMovingAverage(
            StockData stockDataClass, string maType, int days = 5)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Ultimate Moving Average [CC+RedK] script may be freely distributed under the MIT license.
            //study("Ultimate Moving Average [CC+RedK]", overlay = true)

            //inp = input(title = "Source", type = input.source, defval = close)
            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //src = security(syminfo.tickerid, res, inp[rep ? 0 : barstate.isrealtime ? 1 : 0])[rep ? 0 : barstate.isrealtime ? 0 : 1]
            //acc = input(title = "Accelerator", type = input.float, defval = 1.0, minval = 1.0, step = 0.01)
            //minLength = input(title = "MinLength", type = input.integer, defval = 5, minval = 1)
            //maxLength = input(title = "MaxLength", type = input.integer, defval = 50, minval = 1)

            // We are checking current volatility to see how high it is and adjust accordingly. 
            // If volatility is very high then we use the minLength and vice versa
            // Reason behind this is to hug price closely during high volatility but lag for low volatility
            //mean = sma(src, maxLength)
            //stdDev = stdev(src, maxLength)
            //a = mean - (1.75 * stdDev)
            //b = mean - (0.25 * stdDev)
            //c = mean + (0.25 * stdDev)
            //d = mean + (1.75 * stdDev)

            //length = 0.0
            //length:= src >= b and src <= c ? nz(length[1], maxLength) + 1 : src < a or src > d ? nz(length[1], maxLength) - 1 : nz(length[1], maxLength)
            //len = round(max(min(length, maxLength), minLength))

            // We are providing a dynamic weight depending on the current momentum
            // When momentum is at an extreme for overbought/oversold then we give more weight to the current price
            //mf = mfi(src, len)
            //mfScaled = (mf * 2) - 100
            //p = acc + (abs(mfScaled) / 25)

            //sum = 0.0, weightSum = 0.0
            //for i = 0 to len - 1
            //    weight = pow(len - i, p)
            //    sum := sum + (src[i] * weight)
            //    weightSum := weightSum + weight
            //uma = sum / weightSum

            //slo = src - uma
            //sig = slo > 0 ? slo > nz(slo[1]) ? 2 : 1 : slo < 0 ? slo < nz(slo[1]) ? -2 : -1 : 0
            //alertcondition(crossover(sig, 1), "Strong Buy Signal", "Strong Bullish Change Detected")
            //alertcondition(crossunder(sig, -1), "Strong Sell Signal", "Strong Bearish Change Detected")
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //umaColor = sig > 1 ? color.green : sig > 0 ? color.lime : sig < -1 ? color.maroon : sig < 0 ? color.red : color.black
            //barcolor(bar ? umaColor : na)
            //plot(uma, title = "UMA", linewidth = 2, color = umaColor)
            List<decimal> pList = new();
            List<decimal> lengthList = new();
            List<decimal> mfScaledList = new();
            List<decimal> umaList = new();
            List<decimal> mfiList = new();
            List<decimal> mfiRatioList = new();
            List<decimal> rawMoneyFlowList = new();
            List<decimal> posMoneyFlowList = new();
            List<decimal> posMoneyFlowTotalList = new();
            List<decimal> negMoneyFlowList = new();
            List<decimal> negMoneyFlowTotalList = new();
            List<decimal> sumList = new();
            List<decimal> weightedSumList = new();
            List<Signal> signalsList = new();

            try
            {
                int maxLength = days * 10, acc = 1;

                var lenList = CalculateVariableLengthMovingAverage(stockDataClass, maType, days).Item5;
                var tpList = CalculateTypicalPrice(stockDataClass).Item1;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevVal = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal currentVolume = stockDataClass.Volumes.ElementAtOrDefault(i);
                    decimal typicalPrice = tpList.ElementAtOrDefault(i);
                    decimal prevTypicalPrice = i >= 1 ? tpList.ElementAtOrDefault(i - 1) : 0;

                    decimal length = MinOrMax(lenList.ElementAtOrDefault(i), maxLength, days);
                    lengthList.Add(length);

                    decimal rawMoneyFlow = typicalPrice * currentVolume;
                    rawMoneyFlowList.Add(rawMoneyFlow);

                    decimal posMoneyFlow = typicalPrice > prevTypicalPrice ? rawMoneyFlow : 0;
                    posMoneyFlowList.Add(posMoneyFlow);

                    decimal negMoneyFlow = typicalPrice < prevTypicalPrice ? rawMoneyFlow : 0;
                    negMoneyFlowList.Add(negMoneyFlow);

                    int len = (int)length;
                    decimal posMoneyFlowTotal = posMoneyFlowList.TakeLast(len).Sum();
                    posMoneyFlowTotalList.Add(posMoneyFlowTotal);

                    decimal negMoneyFlowTotal = negMoneyFlowList.TakeLast(len).Sum();
                    negMoneyFlowTotalList.Add(negMoneyFlowTotal);

                    decimal mfiRatio = negMoneyFlowTotal != 0 ? MinOrMax(posMoneyFlowTotal / negMoneyFlowTotal, 1, 0) : 0;
                    mfiRatioList.Add(mfiRatio);

                    decimal mfi = negMoneyFlowTotal == 0 ? 100 : posMoneyFlowTotal == 0 ? 0 : MinOrMax(100 - (100 / (1 + mfiRatio)), 100, 0);
                    mfiList.Add(mfi);

                    decimal mfScaled = (mfi * 2) - 100;
                    mfScaledList.Add(mfScaled);

                    decimal p = acc + (Math.Abs(mfScaled) / 25);
                    pList.Add(p);

                    decimal sum = 0, weightedSum = 0;
                    for (int j = 0; j <= len - 1; j++)
                    {
                        decimal weight = Pow(len - j, (double)p);
                        decimal prevValue = i >= j ? stockDataClass.InputValues.ElementAtOrDefault(i - j) : 0;

                        sum += prevValue * weight;
                        weightedSum += weight;
                    }
                    sumList.Add(sum);
                    weightedSumList.Add(weightedSum);

                    decimal prevUma = umaList.LastOrDefault();
                    decimal uma = weightedSum != 0 ? sum / weightedSum : 0;
                    umaList.Add(uma);

                    var signal = GetCompareSignal(currentValue - uma, prevVal - prevUma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (lengthList, posMoneyFlowTotalList, negMoneyFlowTotalList, mfiRatioList, mfiList, mfScaledList, pList, sumList, weightedSumList, umaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateUltimateMovingAverageBands(
            StockData stockDataClass, string maType, int days = 5)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Ultimate Moving Average Bands [CC+RedK] script may be freely distributed under the MIT license.
            //study("Ultimate Moving Average Bands [CC+RedK]", overlay = true)

            //inp = input(title = "Source", type = input.source, defval = close)
            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //src = security(syminfo.tickerid, res, inp[rep ? 0 : barstate.isrealtime ? 1 : 0])[rep ? 0 : barstate.isrealtime ? 0 : 1]
            //acc = input(title = "Accelerator", type = input.float, defval = 1.0, minval = 1.0, step = 0.01)
            //minLength = input(title = "MinLength", type = input.integer, defval = 5, minval = 1)
            //maxLength = input(title = "MaxLength", type = input.integer, defval = 50, minval = 1)
            //smoothLength = input(title = "SmoothLength", type = input.integer, defval = 4, minval = 1)
            //mult = input(title = "Multiple", type = input.float, defval = 2.0, minval = .01)

            // We are checking current volatility to see how high it is and adjust accordingly. 
            // If volatility is very high then we use the minLength and vice versa
            // Reason behind this is to hug price closely during high volatility but lag for low volatility
            //mean = sma(src, maxLength)
            //stdDev = stdev(src, maxLength)
            //a = mean - (1.75 * stdDev)
            //b = mean - (0.25 * stdDev)
            //c = mean + (0.25 * stdDev)
            //d = mean + (1.75 * stdDev)

            //length = 0.0
            //length:= src >= b and src <= c ? nz(length[1], maxLength) + 1 : src < a or src > d ? nz(length[1], maxLength) - 1 : nz(length[1], maxLength)
            //length:= max(min(length, maxLength), minLength)
            //len = round(length)

            // We are providing a dynamic weight depending on the current momentum
            // When momentum is at an extreme for overbought/oversold then we give more weight to the current price
            //mf = na(volume) or volume == 0 ? rsi(src, len) : mfi(src, len)
            //mfScaled = (mf * 2) - 100
            //p = acc + (abs(mfScaled) / 25)

            //sum = 0.0, weightSum = 0.0
            //for i = 0 to len - 1
            //    weight = pow(len - i, p)
            //    sum := sum + (src[i] * weight)
            //    weightSum := weightSum + weight
            //uma = wma(sum / weightSum, smoothLength)

            //stdev = stdev(src, len)
            //upperBand = uma + (stdev * mult)
            //lowerBand = uma - (stdev * mult)

            //slo = src - uma
            //sig = (src > upperBand and nz(src[1]) <= nz(upperBand[1])) or(src > lowerBand and nz(src[1]) <= nz(lowerBand[1]))
            //      ? 1 : (src < lowerBand and nz(src[1]) >= nz(lowerBand[1])) or(src < upperBand and nz(src[1]) >= nz(upperBand[1]))
            //      ? -1 : slo > 0 ? slo > nz(slo[1]) ? 2 : 1 : slo < 0 ? slo < nz(slo[1]) ? -2 : -1 : 0
            //alertcondition(crossover(sig, 1), "Strong Buy Signal", "Strong Bullish Change Detected")
            //alertcondition(crossunder(sig, -1), "Strong Sell Signal", "Strong Bearish Change Detected")
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //umaColor = sig > 1 ? color.green : sig > 0 ? color.lime : sig < -1 ? color.maroon : sig < 0 ? color.red : color.black
            //barcolor(bar ? umaColor : na)
            //plot(upperBand, title = "UpperBand", linewidth = 2, color = umaColor)
            //plot(uma, title = "MiddleBand", linewidth = 1, color = color.white)
            //plot(lowerBand, title = "LowerBand", linewidth = 2, color = umaColor)
            List<decimal> upperBandList = new();
            List<decimal> lowerBandList = new();
            List<Signal> signalsList = new();

            try
            {
                decimal mult = 2;

                var umaList = CalculateUltimateMovingAverage(stockDataClass, maType, days).Item10;
                var stdevList = CalculateStandardDeviationVolatility(null, stockDataClass, days).Item4;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevVal = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal uma = umaList.ElementAtOrDefault(i);
                    decimal prevUma = i >= 1 ? umaList.ElementAtOrDefault(i - 1) : 0;
                    decimal stdev = stdevList.ElementAtOrDefault(i);

                    decimal prevUpperBand = upperBandList.LastOrDefault();
                    decimal upperBand = uma + (mult * stdev);
                    upperBandList.Add(upperBand);

                    decimal prevLowerBand = lowerBandList.LastOrDefault();
                    decimal lowerBand = uma - (mult * stdev);
                    lowerBandList.Add(lowerBand);

                    var signal = GetBollingerBandsSignal(currentValue - uma, prevVal - prevUma, currentValue, prevVal, upperBand, prevUpperBand, lowerBand, prevLowerBand);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (upperBandList, lowerBandList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateRandomWalkIndex(StockData stockDataClass, string maType, int days = 14)
        {
            //@version=3
            // Copyright (c) 2018-present, Alex Orekhov (everget)
            // Random Walk Index indicator script may be freely distributed under the MIT license.
            //study("Random Walk Index", shorttitle = "RWI")

            //length = input(title = "Length", type = integer, defval = 14, minval = 1)

            //rwiHigh = (high - nz(low[length])) / (atr(length) * sqrt(length))
            //rwiLow = (nz(high[length]) - low) / (atr(length) * sqrt(length))

            //plot(rwiHigh, title = "High", linewidth = 2, color =#6d1e7f, transp=0)
            //plot(rwiLow, title = "Low", linewidth = 2, color =#ff3737, transp=0)
            List<decimal> rwiShortTermLowList = new();
            List<decimal> rwiShortTermHighList = new();
            List<decimal> bottomShortTermList = new();
            List<decimal> rwiShortTermHighMaxList = new();
            List<decimal> rwiShortTermLowMaxList = new();
            List<Signal> signalsList = new();

            try
            {
                var atrList = CalculateAverageTrueRange(stockDataClass, maType, days).Item1;

                for (int i = 0; i < stockDataClass.HighPrices.Count; i++)
                {
                    decimal currentAtr = atrList.ElementAtOrDefault(i);
                    decimal currentHigh = stockDataClass.HighPrices.ElementAtOrDefault(i);
                    decimal currentLow = stockDataClass.LowPrices.ElementAtOrDefault(i);
                    decimal prevShortTermHigh = i >= days ? stockDataClass.HighPrices.ElementAtOrDefault(i - days) : 0;
                    decimal prevShortTermLow = i >= days ? stockDataClass.LowPrices.ElementAtOrDefault(i - days) : 0;

                    decimal bottomShortTerm = currentAtr * Sqrt((double)days);
                    bottomShortTermList.Add(bottomShortTerm);

                    decimal prevRwiShortTermLow = rwiShortTermLowList.LastOrDefault();
                    decimal rwiShortTermLow = bottomShortTerm != 0 ? (prevShortTermHigh - currentLow) / bottomShortTerm : 0;
                    rwiShortTermLowList.Add(rwiShortTermLow);

                    decimal prevRwiShortTermHigh = rwiShortTermHighList.LastOrDefault();
                    decimal rwiShortTermHigh = bottomShortTerm != 0 ? (currentHigh - prevShortTermLow) / bottomShortTerm : 0;
                    rwiShortTermHighList.Add(rwiShortTermHigh);

                    decimal rwiShortTermLowMax = rwiShortTermLowList.TakeLast(days).Max();
                    rwiShortTermLowMaxList.Add(rwiShortTermLowMax);

                    decimal rwiShortTermHighMax = rwiShortTermHighList.TakeLast(days).Max();
                    rwiShortTermHighMaxList.Add(rwiShortTermHighMax);

                    var signal = GetCompareSignal(rwiShortTermHigh - rwiShortTermLow, prevRwiShortTermHigh - prevRwiShortTermLow);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (bottomShortTermList, rwiShortTermLowList, rwiShortTermHighList, rwiShortTermLowMaxList, rwiShortTermHighMaxList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateTrendPersistenceRateIndicator(StockData stockDataClass,
            string maType, int days = 5)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Trend Persistence Rate Indicator [CC] script may be freely distributed under the MIT license.
            //study("Trend Persistence Rate Indicator [CC]", overlay = false)

            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //inp = input(title = "Source", type = input.source, defval = close)
            //src = security(syminfo.tickerid, res, inp[rep ? 0 : barstate.isrealtime ? 1 : 0])[rep ? 0 : barstate.isrealtime ? 0 : 1]
            //length = input(title = "Length", type = input.integer, defval = 20, minval = 1)
            //maLength = input(title = "MaLength", type = input.integer, defval = 5, minval = 1)
            //mult = input(title = "Mult", type = input.float, defval = 0.1, minval = 0.01)
            //threshold = input(title = "Threshold", type = input.float, defval = 1.0, minval = 0.01)

            //ma = ema(src, maLength)
            //diff = (ma - nz(ma[1])) / mult

            //ctrP = sum(diff > threshold ? 1 : 0, length)
            //ctrM = sum(diff < -threshold ? 1 : 0, length)
            //tpr = abs(100 * (ctrP - ctrM) / length)
            //tprMa = ema(tpr, maLength)

            //sig = tpr > tprMa ? 1 : tpr < tprMa ? -1 : 0
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //tprColor = sig > 0 ? color.green : sig < 0 ? color.red : color.black
            //barcolor(bar ? tprColor : na)
            //plot(tpr, title = "TPR", color = tprColor, linewidth = 2)
            List<decimal> diffList = new();
            List<decimal> ctrPList = new();
            List<decimal> ctrMList = new();
            List<decimal> ctrPSumList = new();
            List<decimal> ctrMSumList = new();
            List<decimal> tprList = new();
            List<decimal> tprMaList = new();
            List<Signal> signalsList = new();

            try
            {
                int length = days * 4;
                int maLength = days;
                decimal mult = 0.1m, threshold = 1;

                var maList = GetMovingAverageList(maType, null, stockDataClass, maLength);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal prevMa1 = i >= 1 ? maList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevMa2 = i >= 2 ? maList.ElementAtOrDefault(i - 2) : 0;

                    decimal diff = (prevMa1 - prevMa2) / mult;
                    diffList.Add(diff);

                    decimal ctrP = diff > threshold ? 1 : 0;
                    ctrPList.Add(ctrP);

                    decimal ctrM = diff < -threshold ? 1 : 0;
                    ctrMList.Add(ctrM);

                    decimal ctrPSum = ctrPList.TakeLast(length).Sum();
                    ctrPSumList.Add(ctrPSum);

                    decimal ctrMSum = ctrMList.TakeLast(length).Sum();
                    ctrMSumList.Add(ctrMSum);

                    decimal tpr = Math.Abs(100 * (ctrPSum - ctrMSum) / length);
                    tprList.Add(tpr);
                }

                tprMaList = GetMovingAverageList(maType, tprList, stockDataClass, maLength);
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal tpr = tprList.ElementAtOrDefault(j);
                    decimal tprMa = tprMaList.ElementAtOrDefault(j);
                    decimal prevTpr = j >= 1 ? tprList.ElementAtOrDefault(j - 1) : 0;
                    decimal prevTprMa = j >= 1 ? tprMaList.ElementAtOrDefault(j - 1) : 0;

                    var signal = GetCompareSignal(tpr - tprMa, prevTpr - prevTprMa);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (diffList, ctrPList, ctrMList, ctrPSumList, ctrMSumList, tprList, tprMaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateDrunkardWalk(StockData stockDataClass, string maType, int days = 14)
        {
            //input = price, user defined, default is closing price
            //period = user defined, default is 80
            //pbPeriod = user defined, default is 14
            //std = Standard Deviation user defined, default is 2
            //index = current bar number

            //lowArr[] = lowestBar(index, period, LOW);
            //highArr[] = highestBar(index, period, HIGH);
            //lowest = lowArr[0]; //lowest low for the period
            //highest = highArr[0];  //highest high for the period
            //maxBar = highArr[1]; //index for highest high
            //minBar = lowArr[1]; //index for lowest low
            //dnRun = index - maxBar;
            //upRun = index - minBar;
            //Calculate Average True Range
            //atrUp = atr(index, upRun);
            //atrDn = atr(index, dnRun);
            //den = 0, upWalk = 0, dnWalk = 0;
            //if (dnRun moreThan 0 AND upRun moreThan 0) 
            //den = 1;
            //if (atrUp moreThan 0) 
            //den = atrUp;
            //endIf
            //upWalk = (high - lowest) / (Math.sqrt(upRun) * den);
            //den = 1;
            //if (atrDn moreThan 0) 
            //den = atrDn;
            //endIf
            //dnWalk = (highest - low) / (Math.sqrt(dnRun) * den);
            //endIf
            //pcb = perCentB(pbPeriod, index, std, key);
            //bbUp[] = bollingerBands(index, pbPeriod, std, std, UPWALK);
            //bbDn[] = bollingerBands(index, pbPeriod, std, std, DNWALK);
            //bbUp[0], bbUp[1]  0 is for top band 1 is for bottom band
            //if (upWalk lessOrEqual bbUp[1]) 
            //setBarColor(index, UPWALK, upBelowC);
            //endIf
            //if (dnWalk lessOrEqual bbDn[1])
            //setBarColor(index, DNWALK, dnBelowC);
            //endIf
            //if (upWalk moreOrEqual bbUp[0])
            //setBarColor(index, UPWALK, upAboveC);
            //endIf
            //if (dnWalk moreOrEqual bbUp[0])
            //setBarColor(index, DNWALK, dnAboveC);
            //endIf
            List<decimal> tempHighList = new();
            List<decimal> tempLowList = new();
            List<decimal> upDenList = new();
            List<decimal> dnDenList = new();
            List<decimal> upAtrList = new();
            List<decimal> dnAtrList = new();
            List<decimal> upwalkList = new();
            List<decimal> dnWalkList = new();
            List<decimal> upwalkSmaList = new();
            List<decimal> dnwalkSmaList = new();
            List<decimal> upwalkUpperBBList = new();
            List<decimal> upwalkLowerBBList = new();
            List<decimal> upwalkPercentBList = new();
            List<decimal> upwalkPercentBIndicatorList = new();
            List<decimal> upwalkStdDeviationList = new();
            List<decimal> dnwalkUpperBBList = new();
            List<decimal> dnwalkLowerBBList = new();
            List<decimal> dnwalkPercentBList = new();
            List<decimal> dnwalkPercentBIndicatorList = new();
            List<decimal> dnwalkStdDeviationList = new();
            List<Signal> signalsList = new();

            try
            {
                int period = (int)Math.Ceiling(days / 0.175);
                int pbPeriod = days;

                var trueRangeList = CalculateVortexIndicator(stockDataClass, pbPeriod).Item5;
                var maxMinList = VolumeInputCheck(stockDataClass, pbPeriod, true);
                var highestHighs = maxMinList.Item1;
                var lowestLows = maxMinList.Item2;

                for (int i = 0; i < stockDataClass.HighPrices.Count; i++)
                {
                    decimal currentTrueRange = trueRangeList.ElementAtOrDefault(i);
                    decimal highestHigh = highestHighs.ElementAtOrDefault(i);
                    decimal lowestLow = lowestLows.ElementAtOrDefault(i);

                    decimal currentHigh = stockDataClass.HighPrices.ElementAtOrDefault(i);
                    tempHighList.Add(currentHigh);

                    decimal currentLow = stockDataClass.LowPrices.ElementAtOrDefault(i);
                    tempLowList.Add(currentLow);

                    int maxIndex = tempHighList.LastIndexOf(highestHigh);
                    int minIndex = tempLowList.LastIndexOf(lowestLow);
                    int dnRun = i - maxIndex;
                    int upRun = i - minIndex;

                    decimal prevAtrUp = upAtrList.LastOrDefault();
                    decimal upK = upRun != 0 ? (decimal)1 / upRun : 0;
                    decimal atrUp = (currentTrueRange * upK) + (prevAtrUp * (1 - upK));
                    upAtrList.Add(atrUp);

                    decimal prevAtrDn = dnAtrList.LastOrDefault();
                    var dnK = dnRun != 0 ? (decimal)1 / dnRun : 0;
                    decimal atrDn = (currentTrueRange * dnK) + (prevAtrDn * (1 - dnK));
                    dnAtrList.Add(atrDn);

                    decimal upDen = atrUp > 0 ? atrUp : 1;
                    upDenList.Add(upDen);

                    decimal upWalk = upRun > 0 ? (currentHigh - lowestLow) / (Sqrt((double)upRun) * upDen) : 0;
                    upwalkList.Add(upWalk);

                    decimal dnDen = atrDn > 0 ? atrDn : 1;
                    dnDenList.Add(dnDen);

                    decimal dnWalk = dnRun > 0 ? (highestHigh - currentLow) / (Sqrt((double)dnRun) * dnDen) : 0;
                    dnWalkList.Add(dnWalk);

                    decimal upwalkSma = upwalkList.TakeLast(period).Average();
                    upwalkSmaList.Add(upwalkSma);

                    decimal dnwalkSma = dnWalkList.TakeLast(period).Average();
                    dnwalkSmaList.Add(dnwalkSma);
                }

                var stdDevationUpwalk = CalculateStandardDeviationVolatility(upwalkList, stockDataClass, period);
                upwalkStdDeviationList = stdDevationUpwalk.Item4;
                var bbUpwalk = CalculateBollingerBands(upwalkList, stockDataClass, 2, maType, period);
                upwalkUpperBBList = bbUpwalk.Item1;
                upwalkLowerBBList = bbUpwalk.Item2;
                upwalkPercentBList = bbUpwalk.Item3;
                upwalkPercentBIndicatorList = bbUpwalk.Item4;

                var stdDevationDnwalk = CalculateStandardDeviationVolatility(dnWalkList, stockDataClass, period);
                dnwalkStdDeviationList = stdDevationDnwalk.Item4;
                var bbDnwalk = CalculateBollingerBands(dnWalkList, stockDataClass, 2, maType, period);
                dnwalkUpperBBList = bbDnwalk.Item1;
                dnwalkLowerBBList = bbDnwalk.Item2;
                dnwalkPercentBList = bbDnwalk.Item3;
                dnwalkPercentBIndicatorList = bbDnwalk.Item4;

                for (int j = 0; j < stockDataClass.HighPrices.Count; j++)
                {
                    decimal upWalk = upwalkList.ElementAtOrDefault(j);
                    decimal dnWalk = dnWalkList.ElementAtOrDefault(j);
                    decimal prevUpWalk = j >= 1 ? upwalkList.ElementAtOrDefault(j - 1) : 0;
                    decimal prevDnWalk = j >= 1 ? dnWalkList.ElementAtOrDefault(j - 1) : 0;

                    var signal = GetCompareSignal(upWalk - dnWalk, prevUpWalk - prevDnWalk);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (upwalkList, upwalkSmaList, dnWalkList, dnwalkSmaList, upwalkStdDeviationList, upwalkUpperBBList, upwalkLowerBBList, upwalkPercentBList,
                upwalkPercentBIndicatorList, dnwalkStdDeviationList, dnwalkUpperBBList, dnwalkLowerBBList, dnwalkPercentBList, dnwalkPercentBIndicatorList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateMarketFacilitationIndex(StockData stockDataClass)
        {
            //
            // @author LazyBear
            // @credits http://en.wikipedia.org/wiki/Market_facilitation_index
            //
            // If you use this code in its original/modified form, do drop me a note. 
            //
            //study("Market Facilitation Index [LazyBear]", shorttitle = "MFIndex_LB", overlay = true)
            //plot_offs = input(0.005, title = "Indicator offset % (below low)")
            //r_hl = roc((high - low) / volume, 1)
            //r_v = roc(volume, 1)
            //green_f = (r_hl > 0) and(r_v > 0)
            //fade_f = (r_hl < 0) and(r_v < 0)
            //fake_f = (r_hl > 0) and(r_v < 0)
            //squat_f = (r_hl < 0) and(r_v > 0)
            //b_color = green_f ? green : fade_f ? blue : fake_f ? gray : squat_f ? red : na
            //plot(low - (low * plot_offs), color = b_color, style = circles, linewidth = 4)
            List<decimal> mfiList = new();
            List<decimal> mfiDiffList = new();
            List<decimal> volDiffList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.HighPrices.Count; i++)
                {
                    decimal currentHigh = stockDataClass.HighPrices.ElementAtOrDefault(i);
                    decimal currentLow = stockDataClass.LowPrices.ElementAtOrDefault(i);
                    decimal currentVolume = stockDataClass.Volumes.ElementAtOrDefault(i);
                    decimal prevVolume = i >= 1 ? stockDataClass.Volumes.ElementAtOrDefault(i - 1) : 0;

                    decimal prevMfi = mfiList.LastOrDefault();
                    decimal mfi = currentVolume != 0 ? (currentHigh - currentLow) / currentVolume : 0;
                    mfiList.Add(mfi);

                    decimal prevMfiDiff = mfiDiffList.LastOrDefault();
                    decimal mfiDiff = mfi - prevMfi;
                    mfiDiffList.Add(mfiDiff);

                    decimal prevVolDiff = volDiffList.LastOrDefault();
                    decimal volDiff = currentVolume - prevVolume;
                    volDiffList.Add(volDiff);

                    var signal = GetConditionSignal(mfiDiff > 0, volDiff > 0);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (mfiList, mfiDiffList, volDiffList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateVolumeWeightedMovingAverage(StockData stockDataClass, string maType, int days = 14)
        {
            //3-Day VWMA = (C1*V1 + C2*V2 + C3*V3) / (V1+ V2+ V3)
            // same as sma(x * y) / sma(y)
            List<decimal> volumePriceList = new();
            List<decimal> volumePriceSmaList = new();
            List<decimal> vwmaList = new();
            List<Signal> signalsList = new();

            try
            {
                List<decimal> volumeSmaList = GetMovingAverageList(maType, stockDataClass.Volumes, stockDataClass, days);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal currentVolume = stockDataClass.Volumes.ElementAtOrDefault(i);
                    decimal currentVolumeSma = volumeSmaList.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal volumePrice = currentValue * currentVolume;
                    volumePriceList.Add(volumePrice);

                    decimal volumePriceSma = volumePriceList.TakeLast(days).Average();
                    volumePriceSmaList.Add(volumePriceSma);

                    decimal prevVwma = vwmaList.LastOrDefault();
                    decimal vwma = currentVolumeSma != 0 ? volumePriceSma / currentVolumeSma : 0;
                    vwmaList.Add(vwma);

                    var signal = GetCompareSignal(currentValue - vwma, prevValue - prevVwma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (volumePriceList, volumePriceSmaList, vwmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateWindowedVolumeWeightedMovingAverage(
            StockData stockDataClass, int days = 100)
        {
            // This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
            // © alexgrover

            //@version=4
            //study("Windowed Volume Weighted Moving Average", overlay = true)
            //length = input(100),src = input(close),power = input(1.)
            //window = input("Bartlett", options =["Bartlett", "Blackman", "Hanning", "None"])
            //----
            //pi = 3.14159
            //a(x) => 1 - 2 * abs(x - length / 2) / length
            //b(x) => 0.42 - 0.5 * cos(2 * pi * (x / length)) + 0.08 * cos(4 * pi * (x / length))
            //c(x) => 0.5 - 0.5 * cos(2 * pi * x / length)
            //----
            //f(x, y, z) => window == x ? y : z
            //win(x) => f("Bartlett", a(x), f("Blackman", b(x), f("Hanning", c(x), 1)))
            //----
            //sumw = 0.,sum = 0.
            //for i = 0 to length - 1
            //    w = pow(volume[i], power) * win(i)
            //    sumw := sumw + w
            //    sum := sum + src[i] * w
            //wvwma = sum / sumw
            //----
            //plot(wvwma, "Output",#ff1100,2,transp=0)
            List<decimal> bartlettList = new();
            List<decimal> blackmanList = new();
            List<decimal> hanningList = new();
            List<decimal> bartlettWList = new();
            List<decimal> blackmanWList = new();
            List<decimal> hanningWList = new();
            List<decimal> bartlettVWList = new();
            List<decimal> blackmanVWList = new();
            List<decimal> hanningVWList = new();
            List<decimal> bartlettVWSumList = new();
            List<decimal> blackmanVWSumList = new();
            List<decimal> hanningVWSumList = new();
            List<decimal> bartlettWSumList = new();
            List<decimal> blackmanWSumList = new();
            List<decimal> hanningWSumList = new();
            List<decimal> bartlettWvwmaList = new();
            List<decimal> blackmanWvwmaList = new();
            List<decimal> hanningWvwmaList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal currentVolume = stockDataClass.Volumes.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal iRatio = (decimal)i / days;
                    decimal bartlett = 1 - (2 * Math.Abs(i - ((decimal)days / 2)) / days);
                    bartlettList.Add(bartlett);

                    decimal bartlettW = bartlett * currentVolume;
                    bartlettWList.Add(bartlettW);

                    decimal bartlettWSum = bartlettWList.TakeLast(days).Sum();
                    bartlettWSumList.Add(bartlettWSum);

                    decimal bartlettVW = currentValue * bartlettW;
                    bartlettVWList.Add(bartlettVW);

                    decimal bartlettVWSum = bartlettVWList.TakeLast(days).Sum();
                    bartlettVWSumList.Add(bartlettVWSum);

                    decimal prevBartlettWvwma = bartlettWvwmaList.LastOrDefault();
                    decimal bartlettWvwma = bartlettWSum != 0 ? bartlettVWSum / bartlettWSum : 0;
                    bartlettWvwmaList.Add(bartlettWvwma);

                    decimal blackman = 0.42m - (0.5m * Cos(2 * (decimal)Math.PI * iRatio)) + (0.08m * Cos(4 * (decimal)Math.PI * iRatio));
                    blackmanList.Add(blackman);

                    decimal blackmanW = blackman * currentVolume;
                    blackmanWList.Add(blackmanW);

                    decimal blackmanWSum = blackmanWList.TakeLast(days).Sum();
                    blackmanWSumList.Add(blackmanWSum);

                    decimal blackmanVW = currentValue * blackmanW;
                    blackmanVWList.Add(blackmanVW);

                    decimal blackmanVWSum = blackmanVWList.TakeLast(days).Sum();
                    blackmanVWSumList.Add(blackmanVWSum);

                    decimal blackmanWvwma = blackmanWSum != 0 ? blackmanVWSum / blackmanWSum : 0;
                    blackmanWvwmaList.Add(blackmanWvwma);

                    decimal hanning = 0.5m - (0.5m * Cos(2 * (decimal)Math.PI * iRatio));
                    hanningList.Add(hanning);

                    decimal hanningW = hanning * currentVolume;
                    hanningWList.Add(hanningW);

                    decimal hanningWSum = hanningWList.TakeLast(days).Sum();
                    hanningWSumList.Add(hanningWSum);

                    decimal hanningVW = currentValue * hanningW;
                    hanningVWList.Add(hanningVW);

                    decimal hanningVWSum = hanningVWList.TakeLast(days).Sum();
                    hanningVWSumList.Add(hanningVWSum);

                    decimal hanningWvwma = hanningWSum != 0 ? hanningVWSum / hanningWSum : 0;
                    hanningWvwmaList.Add(hanningWvwma);

                    var signal = GetCompareSignal(currentValue - bartlettWvwma, prevValue - prevBartlettWvwma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (bartlettList, bartlettVWList, bartlettWList, bartlettVWSumList, bartlettWSumList, bartlettWvwmaList, blackmanList, blackmanVWList, blackmanWList,
                blackmanVWSumList, blackmanWSumList, blackmanWvwmaList, hanningList, hanningVWList, hanningWList, hanningVWSumList, hanningWSumList, hanningWvwmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateVolumeWeightedAveragePrice(StockData stockDataClass, int days)
        {
            //There are five steps involved in the VWAP calculation. 
            //First, compute the typical price for the intraday period. 
            //This is the average of the high, low, and close: {(H+L+C)/3)}. 
            //Second, multiply the typical price by the period's volume. 
            //Third, create a running total of these values. This is also known as a cumulative total. 
            //Fourth, create a running total of volume (cumulative volume). 
            //Fifth, divide the running total of price-volume by the running total of volume.
            //Cumulative(Volume x Typical Price)/Cumulative(Volume)
            List<decimal> vwapList = new();
            List<decimal> tpList = new();
            List<decimal> volPriceSumList = new();
            List<decimal> volSumList = new();
            List<decimal> tempVolList = new();
            List<decimal> tempVolPriceList = new();
            List<Signal> signalsList = new();

            try
            {
                var list = VolumeInputCheck(stockDataClass, days, false);
                var highList = list.Item1;
                var lowList = list.Item2;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal currentHigh = highList.ElementAtOrDefault(i);
                    decimal currentLow = lowList.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal currentVolume = stockDataClass.Volumes.ElementAtOrDefault(i);
                    tempVolList.Add(currentVolume);

                    decimal tp = (currentValue + currentLow + currentHigh) / 3;
                    tpList.Add(tp);

                    decimal volumePrice = tp * currentVolume;
                    tempVolPriceList.Add(volumePrice);

                    decimal volPriceSum = tempVolPriceList.Sum();
                    volPriceSumList.Add(volPriceSum);

                    decimal volSum = tempVolList.Sum();
                    volSumList.Add(volSum);

                    decimal prevVwap = vwapList.LastOrDefault();
                    decimal vwap = volSum != 0 ? volPriceSum / volSum : 0;
                    vwapList.Add(vwap);

                    var signal = GetCompareSignal(currentValue - vwap, prevValue - prevVwap);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (tpList, volPriceSumList, volSumList, vwapList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateEnhancedIndex(StockData stockDataClass, string maType, int days = 8)
        {
            //
            // @author LazyBear 
            // List of all my indicators: https://www.tradingview.com/v/4IneGo8h/
            //
            //study("Enhanced Index [LazyBear]", shorttitle = "EIDX_LB")
            //src = close
            //length = input(14)
            //lengthMA = input(8)
            //dnm = (highest(src, length) - lowest(src, length))
            //closewr = 2 * (src - sma(src, round(length / 2))) / dnm
            //ul = hline(1, color = red), ll = hline(-1, color = green), hline(0)
            //fill(ul, ll)
            //plot(closewr, color = green, linewidth = 1)
            //plot(ema(closewr, lengthMA), color = red)
            List<decimal> closewrList = new();
            List<decimal> closewrEmaList = new();
            List<Signal> signalsList = new();

            try
            {
                int length = (int)Math.Ceiling(days / 0.5715);
                int smaLength = MinOrMax((int)Math.Ceiling((decimal)length / 2));

                var minMaxList = VolumeInputCheck(stockDataClass, length, true);
                var highestList = minMaxList.Item1;
                var lowestList = minMaxList.Item2;
                var smaList = GetMovingAverageList(maType, null, stockDataClass, smaLength);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal highest = highestList.ElementAtOrDefault(i);
                    decimal lowest = lowestList.ElementAtOrDefault(i);
                    decimal dnm = highest - lowest;
                    decimal sma = smaList.ElementAtOrDefault(i);

                    decimal prevCloseWr = closewrList.LastOrDefault();
                    decimal closewr = dnm != 0 ? 2 * (currentValue - sma) / dnm : 0;
                    closewrList.Add(closewr);

                    decimal prevCloseWrEma = closewrEmaList.LastOrDefault();
                    decimal closewrEma = CalculateExponentialMovingAverage(closewr, prevCloseWrEma, days);
                    closewrEmaList.Add(closewrEma);

                    var signal = GetCompareSignal(closewr - closewrEma, prevCloseWr - prevCloseWrEma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (closewrList, closewrEmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateEnhancedWilliamsR(StockData stockDataClass, string maType, int days = 5)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Enhanced Williams %R script may be freely distributed under the MIT license.
            //study("Enhanced Williams %R", shorttitle = "EWR", overlay = false)

            //length = input(title = "Length", type = input.integer, defval = 14)
            //sigLength = input(title = "SignalLength", type = input.integer, defval = 5)
            //src = input(title = "Source", type = input.source, defval = close)

            //maxVol = highest(volume, length)
            //minVol = lowest(volume, length)
            //maxSrc = highest(src, length)
            //minSrc = lowest(src, length)

            //volWr = maxVol - minVol != 0 ? 2 * (volume - sma(volume, length / 2)) / (maxVol - minVol) : 0
            //srcWr = maxSrc - minSrc != 0 ? 2 * (src - sma(src, length / 2)) / (maxSrc - minSrc) : 0
            //srcSwr = maxSrc - minSrc != 0 ? 2 * (src - src[1]) / (maxSrc - minSrc) : 0

            //cond1 = volWr > 0 and srcWr > 0 and src > src[1]
            //cond2 = volWr > 0 and srcWr< 0 and src < src[1]
            //af = length < 10 ? 0.25 : (length / 32) - 0.0625
            //ewr = cond1 or cond2 and srcSwr +af != 0 ? ((50 * (srcWr * ((srcSwr + af) * volWr))) + srcSwr + af) / (srcSwr + af) : 25 * ((srcWr * (volWr + 1)) + 2)
            //sig = ema(ewr, sigLength)

            //ul = hline(100, color = color.red)
            //ll = hline(-100, color = color.green)
            //hline(0)
            //fill(ul, ll)
            //plot(sig, color = color.black)
            //ewrColor = ewr > sig ? color.green : ewr < sig ? color.red : color.black
            //plot(ewr, title = "EWR", linewidth = 2, color = ewrColor, transp = 0)
            List<decimal> volWrList = new();
            List<decimal> srcWrList = new();
            List<decimal> srcSwrList = new();
            List<decimal> ewrList = new();
            List<decimal> ewrSignalList = new();
            List<Signal> signalsList = new();

            try
            {
                decimal af = days < 10 ? 0.25m : ((decimal)days / 32) - 0.0625m;
                int length = (int)Math.Ceiling((decimal)days / 0.3572m);
                int smaLength = MinOrMax((int)Math.Ceiling((decimal)length / 2));

                var minMaxSrcList = GetMaxAndMinValuesList(stockDataClass.HighPrices, stockDataClass.LowPrices, length);
                var highestSrcList = minMaxSrcList.Item1;
                var lowestSrcList = minMaxSrcList.Item2;
                var minMaxVolList = GetMaxAndMinValuesList(stockDataClass.Volumes, length);
                var highestVolList = minMaxVolList.Item1;
                var lowestVolList = minMaxVolList.Item2;
                var srcSmaList = GetMovingAverageList(maType, null, stockDataClass, smaLength);
                var volSmaList = GetMovingAverageList(maType, stockDataClass.Volumes, stockDataClass, smaLength);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal maxVol = highestVolList.ElementAtOrDefault(i);
                    decimal minVol = lowestVolList.ElementAtOrDefault(i);
                    decimal maxSrc = highestSrcList.ElementAtOrDefault(i);
                    decimal minSrc = lowestSrcList.ElementAtOrDefault(i);
                    decimal srcSma = srcSmaList.ElementAtOrDefault(i);
                    decimal volSma = volSmaList.ElementAtOrDefault(i);
                    decimal volume = stockDataClass.Volumes.ElementAtOrDefault(i);

                    decimal volWr = maxVol - minVol != 0 ? 2 * ((volume - volSma) / (maxVol - minVol)) : 0;
                    volWrList.Add(volWr);

                    decimal srcWr = maxSrc - minSrc != 0 ? 2 * ((currentValue - srcSma) / (maxSrc - minSrc)) : 0;
                    srcWrList.Add(srcWr);

                    decimal srcSwr = maxSrc - minSrc != 0 ? 2 * ((currentValue - prevValue) / (maxSrc - minSrc)) : 0;
                    srcSwrList.Add(srcSwr);

                    decimal prevEwr = ewrList.LastOrDefault();
                    decimal ewr = ((volWr > 0 && srcWr > 0 && currentValue > prevValue) || (volWr > 0 && srcWr < 0 && currentValue < prevValue)) && srcSwr + af != 0 ?
                        ((50 * (srcWr * ((srcSwr + af) * volWr))) + srcSwr + af) / (srcSwr + af) : 25 * ((srcWr * (volWr + 1)) + 2);
                    ewrList.Add(ewr);

                    decimal prevEwrSignal = ewrSignalList.LastOrDefault();
                    decimal ewrSignal = CalculateExponentialMovingAverage(ewr, prevEwrSignal, days);
                    ewrSignalList.Add(ewrSignal);

                    var signal = GetRsiSignal(ewr - ewrSignal, prevEwr - prevEwrSignal, ewr, prevEwr, 100, -100);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (volWrList, srcWrList, srcSwrList, ewrList, ewrSignalList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateOscOscillator(StockData stockDataClass, string maType, int days = 7)
        {
            //@version=3
            // Copyright (c) 2018-present, Alex Orekhov (everget)
            // OSC Oscillator indicator script may be freely distributed under the MIT license.
            //study("OSC Oscillator", shorttitle = "OSC")

            //slowLength = input(title = "Slow Length", type = integer, defval = 14, minval = 1)
            //fastLength = input(title = "Fast Length", type = integer, defval = 7, minval = 1)
            //src = input(title = "Source", type = source, defval = close)

            //osc = sma(src, slowLength) - sma(src, fastLength)

            //oscColor = osc >= 0.0 ? #0ebb23 : #ff0000
            //plot(osc, title = "OSC", linewidth = 2, color = oscColor, transp = 0)

            //hline(0, title = "Zero Level", linestyle = dotted, color =#989898)
            List<decimal> oscList = new();
            List<decimal> oscEmaList = new();
            List<Signal> signalsList = new();

            try
            {
                int fastLength = days;
                int slowLength = MinOrMax(fastLength * 2);

                var fastSmaList = GetMovingAverageList(maType, null, stockDataClass, fastLength);
                var slowSmaList = GetMovingAverageList(maType, null, stockDataClass, slowLength);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal fastSma = fastSmaList.ElementAtOrDefault(i);
                    decimal slowSma = slowSmaList.ElementAtOrDefault(i);

                    decimal prevOsc = oscList.LastOrDefault();
                    decimal osc = slowSma - fastSma;
                    oscList.Add(osc);

                    decimal prevOscEma = oscEmaList.LastOrDefault();
                    decimal oscEma = CalculateExponentialMovingAverage(osc, prevOscEma, fastLength);
                    oscEmaList.Add(oscEma);

                    var signal = GetCompareSignal(osc - oscEma, prevOsc - prevOscEma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (oscList, oscEmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateEarningSupportResistanceLevels(StockData stockDataClass)
        {
            //
            // @author LazyBear 
            // List of all my indicators: https://www.tradingview.com/v/4IneGo8h/
            //
            //study("Earnings S/R Levels [LazyBear]", shorttitle = "ELVLS_LB", overlay = true)
            //mode = input(1, "S/R mode", minval = 1, maxval = 2)
            //earnings = security("ESD:" + ticker + "_EARNINGS", "D", close, true)
            //ehl2_mode1 = (nz(earnings[1]) ? avg(low[2], high) : nz(ehl2_mode1[1])) // AVG2(low of 1 day pri, high of 1 day after)
            //ehl2_mode2 = (nz(earnings[1]) ? (hl2[2] + hl2 + close[1]) / 3 : nz(ehl2_mode2[1])) // AVG3(HL2 of 1 day pri, HL2 of 1 day after, close of earnings day)
            //ehl2 = mode == 1 ? ehl2_mode1 : mode == 2 ? ehl2_mode2 : ehl2_mode1 // default: mode1
            //plot(ehl2, linewidth = 2, style = circles)
            //Mode 1: Level = (low of 1 day prior to earnings + high of 1 day after earnings ) / 2.0
            //Mode 2: Level = (hl2 of 1 day prior to earnings + hl2 of 1 day after earnings + close from earnings day) / 3.0
            List<decimal> mode1List = new();
            List<decimal> mode2List = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.HighPrices.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal currentHigh = stockDataClass.HighPrices.ElementAtOrDefault(i);
                    decimal prevClose = i >= 1 ? stockDataClass.ClosePrices.ElementAtOrDefault(i - 1) : 0;
                    decimal prevLow = i >= 2 ? stockDataClass.LowPrices.ElementAtOrDefault(i - 2) : 0;
                    decimal prevValue2 = i >= 2 ? stockDataClass.InputValues.ElementAtOrDefault(i - 2) : 0;
                    decimal prevValue1 = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal prevMode1 = mode1List.LastOrDefault();
                    decimal mode1 = (prevLow + currentHigh) / 2;
                    mode1List.Add(mode1);

                    decimal prevMode2 = mode2List.LastOrDefault();
                    decimal mode2 = (prevValue2 + currentValue + prevClose) / 3;
                    mode2List.Add(mode2);

                    var signal = GetBullishBearishSignal(currentValue - Math.Max(mode1, mode2), prevValue1 - Math.Max(prevMode1, prevMode2),
                        currentValue - Math.Min(mode1, mode2), prevValue1 - Math.Min(prevMode1, prevMode2));
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (mode1List, mode2List, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateCalmarRatio(StockData stockDataClass, int days = 30)
        {
            //input = price, user defined, default is close
            //period = p1, user defined, default is 30
            //abs = absolute value, pow = power
            //index = current bar number

            //BarSize bar = getBarSize();
            //if (bar.getType() == BarSizeType.LINEAR) barMin = bar.getInterval();
            //else return;
            //minPerYr = 60 * 24 * 30 * 12;
            //barsPerYr = minPerYr / barMin;
            //priorP = price[index - p1];
            //maxDn = highest(index, p1, input);
            //dd = (price - maxDn) / maxDn;
            //ret = (price / priorP) - 1;  //returns for the period
            //power = barsPerYr / p1;
            //anualRet = Math.pow((1 + ret), power) - 1; //convert to annual return
            //maxDd = lowest(index, p1, DD); //largest negative value 
            //Plot: calmar = anualRet / Math.abs(maxDd);
            //Annualized Return = (1 + 23.74%) ^ (365 / 575) - 1 = 114.5% - 1 = 14.5%
            decimal barMin = 60 * 24;
            List<decimal> calmarList = new();
            List<decimal> tempList = new();
            List<decimal> ddList = new();
            List<decimal> retList = new();
            List<decimal> annualReturnList = new();
            List<Signal> signalsList = new();

            try
            {
                decimal minPerYr = 60 * 24 * 30 * 12;
                decimal barsPerYr = minPerYr / barMin;
                decimal power = barsPerYr / (days * 15);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    tempList.Add(currentValue);

                    decimal prevValue = i >= days ? stockDataClass.InputValues.ElementAtOrDefault(i - days) : 0;
                    decimal maxDn = tempList.TakeLast(days).Max();

                    decimal dd = maxDn != 0 ? (currentValue - maxDn) / maxDn : 0;
                    ddList.Add(dd);

                    decimal ret = prevValue != 0 ? (currentValue / prevValue) - 1 : 0;
                    retList.Add(ret);

                    decimal annualReturn = 1 + ret >= 0 ? Pow(1 + ret, (double)power) - 1 : 0;
                    annualReturnList.Add(annualReturn);

                    decimal maxDd = ddList.TakeLast(days).Min();
                    decimal prevCalmar = calmarList.LastOrDefault();
                    decimal calmar = maxDd != 0 ? annualReturn / Math.Abs(maxDd) : 0;
                    calmarList.Add(calmar);

                    var signal = GetCompareSignal(calmar - 2, prevCalmar - 2);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (ddList, retList, annualReturnList, calmarList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateInformationRatio(StockData stockDataClass, int days = 30)
        {
            //input = price, user defined, default is close
            //period = p1, user defined, default is 30
            //benchmark return = bmk, user defined, default is 5 percent
            //sma = simple moving average, sdDev = standard deviation
            //index = current bar number

            //BarSize bar = getBarSize();
            //if (bar.getType() == BarSizeType.LINEAR) barMin = bar.getInterval();
            //else return;
            //minPerYr = 60 * 24 * 30 * 12;
            //priorP = price[index - p1];
            //bmk = bmk / 100;  //convert percent to decimal
            //barsPerYr = minPerYr / barMin;
            //bench = Math.pow((1 + (bmk)), p1 / barsPerYr) - 1; //minium acceptable return/period compounded 
            //ret = (price / priorP) - 1;
            //av = sma(index, p1, RET);
            //std = sdDev(index, p1, RET)[0];
            //Plot: info = (av - bench) / std;
            decimal barMin = 60 * 24, bmk = 0.05m;
            List<decimal> infoList = new();
            List<decimal> benchList = new();
            List<decimal> retList = new();
            List<decimal> retSmaList = new();
            List<decimal> deviationList = new();
            List<decimal> deviationSquaredList = new();
            List<decimal> divisionOfSumList = new();
            List<decimal> stdDeviationList = new();
            List<Signal> signalsList = new();

            try
            {
                decimal minPerYr = 60 * 24 * 30 * 12;
                decimal barsPerYr = minPerYr / barMin;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= days ? stockDataClass.InputValues.ElementAtOrDefault(i - days) : 0;

                    decimal bench = Pow(1 + bmk, days / (double)barsPerYr) - 1;
                    benchList.Add(bench);

                    decimal ret = prevValue != 0 ? (currentValue / prevValue) - 1 : 0;
                    retList.Add(ret);

                    decimal retSma = retList.TakeLast(days).Average();
                    retSmaList.Add(retSma);

                    decimal currentDeviation = ret - retSma;
                    deviationList.Add(currentDeviation);

                    decimal deviationSquared = Pow(currentDeviation, 2);
                    deviationSquaredList.Add(deviationSquared);

                    decimal divisionOfSum = deviationSquaredList.TakeLast(days).Average();
                    divisionOfSumList.Add(divisionOfSum);

                    decimal stdDeviation = divisionOfSum >= 0 ? Sqrt(divisionOfSum) : 0;
                    stdDeviationList.Add(stdDeviation);

                    decimal prevInfo = infoList.LastOrDefault();
                    decimal info = stdDeviation != 0 ? (retSma - bench) / stdDeviation : 0;
                    infoList.Add(info);

                    var signal = GetCompareSignal(info - 5, prevInfo - 5);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (benchList, retSmaList, deviationList, deviationSquaredList, divisionOfSumList, stdDeviationList, infoList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateOmegaRatio(StockData stockDataClass, int days = 30)
        {
            //input = price, user defined, default is close
            //period = p1, user defined, default is 30
            //mar = margin, user defined, default is 5 percent
            //pow = power
            //index = current bar number

            //BarSize bar = getBarSize();
            //if (bar.getType() == BarSizeType.LINEAR) barMin = bar.getInterval();
            //else return;
            //minPerYr = 60 * 24 * 30 * 12;
            //priorP = price[index - p1];
            //mar = mar / 100;  //convert percent to decimal
            //barsPerYr = minPerYr / barMin;
            //th = Math.pow((1 + (mar)), p1 / barsPerYr) - 1; //minium acceptable return/period compounded 
            //ret = (price / priorP) - 1;
            //Plot: omega = omega(index, p1, th, ret);
            //Method omega(int index, int period, decimal th, Object key)
            //iprice = 0, upSide = 0, dnSide = 0;
            //for (i = index - period + 1; i lessThan = index; i++) 
            //iprice = price[i];
            //if (iprice lessThan th) 
            //dnSide = dnSide + (th - iprice);
            //endif
            //if (iprice moreThan th) 
            //upSide = upSide + (iprice - th);
            //endIf
            //endFor
            //if (dnSide != 0)
            //return upSide / dnSide;
            //else return null;
            //endMethod
            decimal barMin = 60 * 24, bmk = 0.05m;
            List<decimal> omegaList = new();
            List<decimal> benchList = new();
            List<decimal> retList = new();
            List<decimal> upsideList = new();
            List<decimal> downsideList = new();
            List<Signal> signalsList = new();

            try
            {
                decimal minPerYr = 60 * 24 * 30 * 12;
                decimal barsPerYr = minPerYr / barMin;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= days ? stockDataClass.InputValues.ElementAtOrDefault(i - days) : 0;

                    decimal bench = Pow(1 + bmk, days / (double)barsPerYr) - 1;
                    benchList.Add(bench);

                    decimal ret = prevValue != 0 ? (currentValue / prevValue) - 1 : 0;
                    retList.Add(ret);

                    decimal downSide = 0;
                    decimal upSide = 0;
                    for (int j = i - days + 1; j <= i && j >= 0; j++)
                    {
                        decimal iValue = retList.ElementAtOrDefault(j);

                        if (iValue < bench)
                        {
                            downSide += bench - iValue;
                        }
                        if (iValue > bench)
                        {
                            upSide += iValue - bench;
                        }
                    }
                    downsideList.Add(downSide);
                    upsideList.Add(upSide);

                    decimal prevOmega = omegaList.LastOrDefault();
                    decimal omega = downSide != 0 ? upSide / downSide : 0;
                    omegaList.Add(omega);

                    var signal = GetCompareSignal(omega - 5, prevOmega - 5);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (downsideList, upsideList, omegaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateSortinoRatio(StockData stockDataClass, int days = 30)
        {
            //input = price, user defined, default is close
            //period = p1, user defined, default is 30
            //safe = safe return percentage, user defined, default is 2
            //av = average, pow = power
            //sma = simple moving average, sdDev = standard deviation
            //index = current bar number

            //BarSize bar = getBarSize();
            //if (bar.getType() == BarSizeType.LINEAR) barMin = bar.getInterval();
            //else return;
            //minPerYr = 60 * 24 * 30 * 12;
            //barsPerYr = minPerYr / barMin;
            //adjSafe = Math.pow((1 + (safe)), p1 / barsPerYr) - 1; //safe return per period compounded
            //priorP = price[index - p1];
            //ret = ((price / priorP) - 1) - adjSafe; //safe return subtracted here to reflect Sharpe 1994 revision
            //av = sma(index, p1, RET);
            //stdMinus = sdDev(index, p1, RET)[2];
            //if (stdMinus != 0) sortino = av / stdMinus;
            decimal barMin = 60 * 24, bmk = 0.02m;
            List<decimal> sortinoList = new();
            List<decimal> retList = new();
            List<decimal> retSmaList = new();
            List<decimal> deviationList = new();
            List<decimal> deviationSquaredList = new();
            List<decimal> divisionOfSumList = new();
            List<decimal> stdDeviationList = new();
            List<Signal> signalsList = new();

            try
            {
                decimal minPerYr = 60 * 24 * 30 * 12;
                decimal barsPerYr = minPerYr / barMin;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= days ? stockDataClass.InputValues.ElementAtOrDefault(i - days) : 0;
                    decimal bench = Pow(1 + bmk, days / (double)barsPerYr) - 1;

                    decimal ret = prevValue != 0 ? ((currentValue / prevValue) - 1) - bench : 0;
                    retList.Add(ret);

                    decimal retSma = retList.TakeLast(days).Average();
                    retSmaList.Add(retSma);

                    decimal currentDeviation = Math.Min(ret - retSma, 0);
                    deviationList.Add(currentDeviation);

                    decimal deviationSquared = Pow(currentDeviation, 2);
                    deviationSquaredList.Add(deviationSquared);

                    decimal divisionOfSum = deviationSquaredList.TakeLast(days).Average();
                    divisionOfSumList.Add(divisionOfSum);

                    decimal stdDeviation = divisionOfSum >= 0 ? Sqrt(divisionOfSum) : 0;
                    stdDeviationList.Add(stdDeviation);

                    decimal prevSortino = sortinoList.LastOrDefault();
                    decimal sortino = stdDeviation != 0 ? retSma / stdDeviation : 0;
                    sortinoList.Add(sortino);

                    var signal = GetCompareSignal(sortino - 2, prevSortino - 2);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (retSmaList, deviationList, deviationSquaredList, divisionOfSumList, stdDeviationList, sortinoList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateSharpeRatio(StockData stockDataClass, int days = 30)
        {
            //input = price, user defined, default is close
            //period = p1, user defined, default is 30
            //safe = safe return percentage, user defined, default is 2
            //av = average, pow = power
            //sma = simple moving average, sdDev = standard deviation
            //index = current bar number

            //BarSize bar = getBarSize();
            //if (bar.getType() == BarSizeType.LINEAR) barMin = bar.getInterval();
            //else return;
            //minPerYr = 60 * 24 * 30 * 12;
            //barsPerYr = minPerYr / barMin;
            //adjSafe = Math.pow((1 + (safe)), p1 / barsPerYr) - 1; //safe return per period compounded
            //priorP = price[index - p1];
            //ret = ((price / priorP) - 1) - adjSafe; //safe return subtracted here to reflect Sharpe 1994 revision
            //av = sma(index, p1, RET);
            //std = sdDev(index, p1, RET)[2];
            //if (std != 0) sharpe = av / std;
            decimal barMin = 60 * 24, bmk = 0.02m;
            List<decimal> sharpeList = new();
            List<decimal> retList = new();
            List<decimal> retSmaList = new();
            List<decimal> deviationList = new();
            List<decimal> deviationSquaredList = new();
            List<decimal> divisionOfSumList = new();
            List<decimal> stdDeviationList = new();
            List<Signal> signalsList = new();

            try
            {
                decimal minPerYr = 60 * 24 * 30 * 12;
                decimal barsPerYr = minPerYr / barMin;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= days ? stockDataClass.InputValues.ElementAtOrDefault(i - days) : 0;
                    decimal bench = Pow(1 + bmk, days / (double)barsPerYr) - 1;

                    decimal ret = prevValue != 0 ? (currentValue / prevValue) - 1 - bench : 0;
                    retList.Add(ret);

                    decimal retSma = retList.TakeLast(days).Average();
                    retSmaList.Add(retSma);

                    decimal currentDeviation = ret - retSma;
                    deviationList.Add(currentDeviation);

                    decimal deviationSquared = Pow(currentDeviation, 2);
                    deviationSquaredList.Add(deviationSquared);

                    decimal divisionOfSum = deviationSquaredList.TakeLast(days).Average();
                    divisionOfSumList.Add(divisionOfSum);

                    decimal stdDeviation = divisionOfSum >= 0 ? Sqrt(divisionOfSum) : 0;
                    stdDeviationList.Add(stdDeviation);

                    decimal prevSharpe = sharpeList.LastOrDefault();
                    decimal sharpe = stdDeviation != 0 ? retSma / stdDeviation : 0;
                    sharpeList.Add(sharpe);

                    var signal = GetCompareSignal(sharpe - 2, prevSharpe - 2);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (retList, retSmaList, deviationList, deviationSquaredList, divisionOfSumList, stdDeviationList, sharpeList, signalsList);
        }

        public static (List<decimal>, List<Signal>) CalculateTreynorRatio(StockData stockDataClass, int days = 30)
        {
            //input = price, user defined, default is close
            //period = p1, user defined, default is 30
            //beta = user defined, default is 1
            //safe = safe return percentage, user defined, default is 2
            //av = average, pow = power
            //sma = simple moving average, sdDev = standard deviation
            //index = current bar number

            //barMin = 0;
            //BarSize bar = getBarSize();
            //if (bar.getType() == BarSizeType.LINEAR) barMin = bar.getInterval();
            //else return;
            //minPerYr = 60 * 24 * 30 * 12;
            //barsPerYr = minPerYr / barMin;
            //adjSafe = Math.pow((1 + (safe)), p1 / barsPerYr) - 1;  //safe return per period compounded
            //priorP = price[index - p1];
            //ret = (price / priorP) - 1
            //av = sma(index, p1, RET);
            //Plot: treynor = (av - adjSafe) / beta;
            decimal barMin = 60 * 24, bmk = 0.02m, beta = 1;
            List<decimal> treynorList = new();
            List<decimal> benchList = new();
            List<decimal> retList = new();
            List<decimal> retSmaList = new();
            List<Signal> signalsList = new();

            try
            {
                decimal minPerYr = 60 * 24 * 30 * 12;
                decimal barsPerYr = minPerYr / barMin;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= days ? stockDataClass.InputValues.ElementAtOrDefault(i - days) : 0;

                    decimal bench = Pow(1 + bmk, days / (double)barsPerYr) - 1;
                    benchList.Add(bench);

                    decimal ret = prevValue != 0 ? (currentValue / prevValue) - 1 : 0;
                    retList.Add(ret);

                    decimal retSma = retList.TakeLast(days).Average();
                    retSmaList.Add(retSma);

                    decimal prevTreynor = treynorList.LastOrDefault();
                    decimal treynor = beta != 0 ? (retSma - bench) / beta : 0;
                    treynorList.Add(treynor);

                    var signal = GetCompareSignal(treynor - 2, prevTreynor - 2);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (treynorList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateUpsidePotentialRatio(StockData stockDataClass, int days = 30)
        {
            //input = price, user defined, default is close
            //period = p1, user defined, default is 30
            //minium return = mar = user defined, default is 5 percent
            //pow = power, sqrt = squart root
            //sma = simple moving average, sdDev = standard deviation
            //index = current bar number

            //barMin = 0;
            //BarSize bar = getBarSize();
            //if (bar.getType() == BarSizeType.LINEAR) barMin = bar.getInterval();
            //else return;
            //minPerYr = 60 * 24 * 30 * 12;
            //priorP = price[index - p1];
            //mar = mar / 100;  //convert percent to decimal
            //barsPerYr = minPerYr / barMin;
            //pdRet = Math.pow((1 + mar), p1 / barsPerYr) - 1; //minium acceptable return/period compounded 
            //ret = (((price / priorP) - 1));
            //upside = upside(index, p1, pdRet, RET);
            //....Method upside(int index, int period, decimal mar, Object key)
            //ret = 0, upSide = 0, dnSide = 0;
            //for (int i = index - period + 1; i lessOr = index; i++)
            //ret = price[i];
            //if (ret moreThan mar)
            //upSide = upSide + (ret - mar) * (1 / period);
            //endIf
            //if (ret lessThan mar)
            //dnSide = dnSide + Math.pow((ret - mar), 2) * (1 / period);
            //endIf
            //endFor
            //if (dnSide moreThan 0)
            //return upSide / Math.sqrt(dnSide);
            decimal barMin = 60 * 24, bmk = 0.05m;
            List<decimal> benchList = new();
            List<decimal> retList = new();
            List<decimal> upsideList = new();
            List<decimal> downsideList = new();
            List<decimal> upsidePotentialList = new();
            List<Signal> signalsList = new();

            try
            {
                decimal minPerYr = 60 * 24 * 30 * 12;
                decimal barsPerYr = minPerYr / barMin;
                decimal ratio = (decimal)1 / days;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= days ? stockDataClass.InputValues.ElementAtOrDefault(i - days) : 0;

                    decimal bench = Pow(1 + bmk, days / (double)barsPerYr) - 1;
                    benchList.Add(bench);

                    decimal ret = prevValue != 0 ? (currentValue / prevValue) - 1 : 0;
                    retList.Add(ret);

                    decimal downSide = 0;
                    decimal upSide = 0;
                    for (int j = i - (days + 1); j <= i; j++)
                    {
                        decimal iValue = j >= 0 && i >= j ? retList.ElementAtOrDefault(i - j) : 0;

                        if (iValue < bench)
                        {
                            downSide += Pow(iValue - bench, 2) * ratio;
                        }
                        if (iValue > bench)
                        {
                            upSide += (iValue - bench) * ratio;
                        }
                    }
                    downsideList.Add(downSide);
                    upsideList.Add(upSide);

                    decimal prevUpsidePotential = upsidePotentialList.LastOrDefault();
                    decimal upsidePotential = downSide >= 0 ? upSide / Sqrt(downSide) : 0;
                    upsidePotentialList.Add(upsidePotential);

                    var signal = GetCompareSignal(upsidePotential - 5, prevUpsidePotential - 5);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (downsideList, upsideList, upsidePotentialList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<decimal>, List<Signal>) CalculateTechnicalRank(StockData stockDataClass, string maType, int days = 3)
        {
            //input = price, user defined, default is closing price
            //method = moving average (ma), user defined, default is EMA
            //p1 = period, user defined, default is 200
            //p2 = period, user defined, default is 125
            //p3 = period, user defined, default is 50
            //p4 = period, user defined, default is 20
            //p5 = period, user defined, default is 12
            //p6 = period, user defined, default is 26
            //p7 = period, user defined, default is 9
            //p8 = period, user defined, default is 3
            //p9 = period, user defined, default is 14
            //sma = simple moving average, ema = exponential moving average
            //roc = rate of change, rsi = relative strength index
            //index = current bar number

            //ma1 = sma(index, p1, input);
            //ltMa = .3 * 100 * (price - ma1) / ma1;
            //ltRoc = .3 * 100 * roc(index, p2, key);
            //ma2 = sma(index, p3, key);
            //mtMa = .15 * 100 * (price - ma2) / ma2;
            //mtRoc = .15 * 100 * roc(index, p4, input);
            //ma5 = ema(index, p5, input);
            //ma6 = ema(index, p6, key);
            //ppo = 100 * (ma5 - ma6) / ma6;
            //sig = ema(index, p7, key);
            //ppoHist = ppo - sig;
            //value = ppoHist[index];
            //priorV = ppoHist[index - p8];
            //slope = (value - priorV) / p8; //rise over run = slope of ppoHist
            //stPpo = .05 * 100 * slope;
            //rsi = rsi(index, p9, input)[0];
            //stRsi = .05 * rsi;
            //tr = ltMa + ltRoc + mtMa + mtRoc + stPpo + stRsi;
            //if (tr lessThan 0) tr = 0;
            //if (tr moreThan 100) tr = 100;
            List<decimal> ltMaList = new();
            List<decimal> ltRocList = new();
            List<decimal> mtMaList = new();
            List<decimal> mtRocList = new();
            List<decimal> slopeList = new();
            List<decimal> stPpoList = new();
            List<decimal> stRsiList = new();
            List<decimal> trList = new();
            List<Signal> signalsList = new();

            try
            {
                int p5 = days * 4;
                int p2 = (int)Math.Ceiling(days / 0.024);
                int p3 = (int)Math.Ceiling(days / 0.06);
                int p1 = p3 * 4;
                int p4 = (int)Math.Ceiling(days / 0.15);
                int p6 = (int)Math.Ceiling(days / 0.1154);
                int p7 = days * 3;
                int p8 = days;
                int p9 = (int)Math.Ceiling(days / 0.2143);

                var ema12List = CalculateExponentialMovingAverage(stockDataClass, p5).Item1;
                var ema200List = CalculateExponentialMovingAverage(stockDataClass, p1).Item1;
                var ema50List = CalculateExponentialMovingAverage(stockDataClass, p3).Item1;
                var roc125List = CalculateRateOfChange(null, stockDataClass, p2).Item1;
                var roc20List = CalculateRateOfChange(null, stockDataClass, p4).Item1;
                var ema26List = CalculateExponentialMovingAverage(stockDataClass, p6).Item1;
                var ppoHistogramList = CalculatePercentagePriceOscillator(stockDataClass, maType, p5).Item3;
                var rsi14List = CalculateRelativeStrengthIndex(null, stockDataClass, maType, p9).Item4;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentEma200 = ema200List.ElementAtOrDefault(i);
                    decimal currentEma50 = ema50List.ElementAtOrDefault(i);
                    decimal currentRoc125 = roc125List.ElementAtOrDefault(i);
                    decimal currentRoc20 = roc20List.ElementAtOrDefault(i);
                    decimal currentPpoHistogram = ppoHistogramList.ElementAtOrDefault(i);
                    decimal currentRsi = rsi14List.ElementAtOrDefault(i);
                    decimal currentPrice = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevTr1 = i >= 1 ? trList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevTr2 = i >= 2 ? trList.ElementAtOrDefault(i - 2) : 0;

                    decimal ltMa = currentEma200 != 0 ? 0.3m * 100 * (currentPrice - currentEma200) / currentEma200 : 0;
                    ltMaList.Add(ltMa);

                    decimal ltRoc = 0.3m * 100 * currentRoc125;
                    ltRocList.Add(ltRoc);

                    decimal mtMa = currentEma50 != 0 ? 0.15m * 100 * (currentPrice - currentEma50) / currentEma50 : 0;
                    mtMaList.Add(mtMa);

                    decimal mtRoc = 0.15m * 100 * currentRoc20;
                    mtRocList.Add(mtRoc);

                    decimal currentValue = currentPpoHistogram;
                    decimal prevValue = i >= p8 ? ppoHistogramList.ElementAtOrDefault(i - p8) : 0;

                    decimal slope = (currentValue - prevValue) / p8;
                    slopeList.Add(slope);

                    decimal stPpo = 0.05m * 100 * slope;
                    stPpoList.Add(stPpo);

                    decimal stRsi = 0.05m * currentRsi;
                    stRsiList.Add(stRsi);

                    decimal tr = Math.Min(100, Math.Max(0, ltMa + ltRoc + mtMa + mtRoc + stPpo + stRsi));
                    trList.Add(tr);

                    var signal = GetCompareSignal(tr - prevTr1, prevTr1 - prevTr2);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (ltMaList, ltRocList, mtMaList, mtRocList, slopeList, stPpoList, stRsiList, trList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateKurtosisIndicator(StockData stockDataClass, string maType, int days = 3)
        {
            ////////////////////////////////////////////////////////////
            //  Copyright by HPotter v1.0 26/06/2014
            // This indicator plots the Fast & Slow Kurtosis. The Kurtosis is a market
            // sentiment indicator. The Kurtosis is constructed from three different parts.
            // The Kurtosis, the Fast Kurtosis(FK), and the Fast/Slow Kurtosis(FSK).
            ////////////////////////////////////////////////////////////
            //study(title = "FSK (Fast and Slow Kurtosis)", shorttitle = "FSK (Fast and Slow Kurtosis)")
            //BuyZone = input(0)
            //hline(BuyZone, color = green, linestyle = line)
            //xMOM_R = mom(mom(close, 3), 1)
            //xMOM_RAvr = ema(xMOM_R, 65)
            //xMOM_RWAvr = wma(xMOM_RAvr, 3)
            //plot(xMOM_RAvr, color = blue, title = "FK")
            //plot(xMOM_RWAvr, color = red, title = "FSK")
            List<decimal> diffList = new();
            List<decimal> kList = new();
            List<decimal> fkList = new();
            List<decimal> fskList = new();
            List<Signal> signalsList = new();

            try
            {
                int fastKurtosisPeriod = MinOrMax((int)Math.Ceiling(days / 0.0462));

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= days ? stockDataClass.InputValues.ElementAtOrDefault(i - days) : 0;

                    decimal prevDiff = diffList.LastOrDefault();
                    decimal diff = currentValue - prevValue;
                    diffList.Add(diff);

                    decimal k = diff - prevDiff;
                    kList.Add(k);
                }

                fkList = GetMovingAverageList(maType, kList, stockDataClass, fastKurtosisPeriod);
                fskList = GetMovingAverageList("WeightedMovingAverage", fkList, stockDataClass, days);
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal fsk = fskList.ElementAtOrDefault(j);
                    decimal prevFsk = j >= 1 ? fskList.ElementAtOrDefault(j - 1) : 0;

                    var signal = GetCompareSignal(fsk, prevFsk);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (diffList, kList, fkList, fskList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateFastandSlowStochasticOscillator(StockData stockDataClass, string maType, int days = 3)
        {
            //input = price, user defined, default is closing price
            //method = moving average (ma), user defined, default is WMA
            //period1 = user defined, default is 3
            //period2 = user defined, default is 6
            //period3 = user defined, default is 9
            //period4 = user defined, default is 9
            //prev = previous, stochK = Stochastis fast K
            //index = current bar number

            //mom = momentum(index, period1, input);
            //prevMom = mon[index - 1];
            //prevFsk = FSK[index - 1];
            //fsk = (.03 * (mom - prevMom)) + ((1 - .03) * prevFsk);
            //v4 = ma(method, index, period2, fsk);
            //fastk = stochK(index, period3, key);
            //slowk = ma(method, index, period3, fastK);
            //fsst = (500 * v4) + slowk;
            //wfsst = ma(method, index, period4, fsst);
            List<decimal> slowKList = new();
            List<decimal> fsstList = new();
            List<decimal> wfsstList = new();
            List<Signal> signalsList = new();

            try
            {
                int period1 = days;
                int period2 = MinOrMax(period1 * 2);
                int period3 = MinOrMax(period1 * 3);
                int period4 = period3;

                List<decimal> fskList = CalculateFastandSlowKurtosisOscillator(stockDataClass, maType, period1).Item1;
                List<decimal> v4List = GetMovingAverageList(maType, fskList, stockDataClass, period2);
                List<decimal> fastKList = CalculateStochasticOscillator(null, stockDataClass, maType, period3).Item3;
                slowKList = GetMovingAverageList(maType, fastKList, stockDataClass, period3);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal v4 = v4List.ElementAtOrDefault(i);
                    decimal slowK = slowKList.ElementAtOrDefault(i);

                    decimal fsst = (500 * v4) + slowK;
                    fsstList.Add(fsst);
                }

                wfsstList = GetMovingAverageList(maType, fsstList, stockDataClass, period4);
                for (int j = 0; j < wfsstList.Count; j++)
                {
                    decimal fsst = fsstList.ElementAtOrDefault(j);
                    decimal wfsst = wfsstList.ElementAtOrDefault(j);
                    decimal prevFsst = j >= 1 ? fsstList.ElementAtOrDefault(j - 1) : 0;
                    decimal prevWfsst = j >= 1 ? wfsstList.ElementAtOrDefault(j - 1) : 0;

                    var signal = GetCompareSignal(fsst - wfsst, prevFsst - prevWfsst);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (slowKList, fsstList, wfsstList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateFastandSlowKurtosisOscillator(StockData stockDataClass, string maType, int days = 3)
        {
            //input = price (user defined, default is closing price)
            //method = moving average (user defined, default is WMA)
            //period = user defined, default is 3
            //prev = previous, index = current bar number

            //mom = momentum(index, period, input);
            //prevMom = mon[index - 1];
            //prevFsk = FSK[index - 1];
            //Plot1: fsk = (.03 * (mom - prevMom)) + ((1 - .03) * prevFsk);
            //Plot2: sig = ma(method, index, period, fsk);
            //Signals
            //highSell = fsk for last sell signal, reset to max_negative at each  buy signal;
            //lowBuy = fsk for last buy signal, reset to max_positive at each sell signal;
            //buy = crossedAbove(FSK, SIG);
            //sell = crossedBelow(FSK, SIG);
            decimal ratio = 0.03m;
            List<decimal> fskList = new();
            List<decimal> fskSignalList = new();
            List<decimal> momentumList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= days ? stockDataClass.InputValues.ElementAtOrDefault(i - days) : 0;

                    decimal prevMomentum = momentumList.LastOrDefault();
                    decimal momentum = currentValue - prevValue;
                    momentumList.Add(momentum);

                    decimal prevFsk = fskList.LastOrDefault();
                    decimal fsk = (ratio * (momentum - prevMomentum)) + ((1 - ratio) * prevFsk);
                    fskList.Add(fsk);
                }

                fskSignalList = GetMovingAverageList(maType, fskList, stockDataClass, days);
                for (int j = 0; j < fskSignalList.Count; j++)
                {
                    decimal fsk = fskList.ElementAtOrDefault(j);
                    decimal fskSignal = fskSignalList.ElementAtOrDefault(j);
                    decimal prevFsk = j >= 1 ? fskList.ElementAtOrDefault(j - 1) : 0;
                    decimal prevFskSignal = j >= 1 ? fskSignalList.ElementAtOrDefault(j - 1) : 0;

                    var signal = GetCompareSignal(fsk - fskSignal, prevFsk - prevFskSignal);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (fskList, fskSignalList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateFastandSlowRelativeStrengthIndexOscillator(StockData stockDataClass, string maType, int days = 3)
        {
            //input = price (user defined, default is closing price)
            //method = moving average (ma), user defined, default is WMA
            //period1 = user defined, default is 3
            //period2 = user defined, default is 6
            //period3 = user defined, default is 9
            //period4 = user defined, default is 6
            //prev = previous, rsi = Relative Strength Index
            //index = current bar number

            //mom = momentum(index, period1, input);
            //prevMom = mon[index - 1];
            //prevFsk = FSK[index - 1];
            //fsk = (.03 * (mom - prevMom)) + ((1 - .03) * prevFsk);
            //v4 = ma(method, index, period2, fsk);
            //rsi = rsi(index, period3, input)[0];
            //Plot1: fsrsi = (10000 * v4) + rsi;
            //Plot2: sig = ma(method, index, period4, FSRSI);
            //Signals
            //buy = crossedAbove(FSRSI, SIG);
            //sell = crossedBelow(FSRSI, SIG);
            List<decimal> v4List = new();
            List<decimal> fsrsiSignalList = new();
            List<decimal> fsrsiList = new();
            List<Signal> signalsList = new();

            try
            {
                int period1 = days;
                int period2 = MinOrMax(period1 * 2);
                int period3 = MinOrMax(period1 * 3);
                int period4 = period2;

                List<decimal> rsiList = CalculateRelativeStrengthIndex(null, stockDataClass, maType, period3).Item4;
                List<decimal> fskList = CalculateFastandSlowKurtosisOscillator(stockDataClass, maType, period1).Item1;
                v4List = GetMovingAverageList(maType, fskList, stockDataClass, period2);

                for (int i = 0; i < v4List.Count; i++)
                {
                    decimal rsi = rsiList.ElementAtOrDefault(i);
                    decimal v4 = v4List.ElementAtOrDefault(i);

                    decimal fsrsi = (10000 * v4) + rsi;
                    fsrsiList.Add(fsrsi);
                }

                fsrsiSignalList = GetMovingAverageList(maType, fsrsiList, stockDataClass, period4);
                for (int j = 0; j < fsrsiSignalList.Count; j++)
                {
                    decimal fsrsi = fsrsiList.ElementAtOrDefault(j);
                    decimal fsrsiSignal = fsrsiSignalList.ElementAtOrDefault(j);
                    decimal prevFsrsi = j >= 1 ? fsrsiList.ElementAtOrDefault(j - 1) : 0;
                    decimal prevFsrsiSignal = j >= 1 ? fsrsiSignalList.ElementAtOrDefault(j - 1) : 0;

                    var signal = GetCompareSignal(fsrsi - fsrsiSignal, prevFsrsi - prevFsrsiSignal);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (v4List, fsrsiList, fsrsiSignalList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateKaufmanAdaptiveMovingAverage(StockData stockDataClass, int days = 14)
        {
            //@version=3
            // Copyright (c) 2018-present, Alex Orekhov (everget)
            // Kaufman Adaptive Moving Average script may be freely distributed under the MIT license.
            //study("Kaufman Adaptive Moving Average", shorttitle = "KAMA", overlay = true)

            //length = input(title = "Length", type = integer, defval = 14)
            //fastLength = input(title = "Fast EMA Length", type = integer, defval = 2)
            //slowLength = input(title = "Slow EMA Length", type = integer, defval = 30)
            //highlightMovements = input(title = "Highlight Movements ?", type = bool, defval = true)
            //src = input(title = "Source", type = source, defval = close)

            //mom = abs(change(src, length))
            //volatility = sum(abs(change(src)), length)

            // Efficiency Ratio
            //er = volatility != 0 ? mom / volatility : 0

            //fastAlpha = 2 / (fastLength + 1)
            //slowAlpha = 2 / (slowLength + 1)

            // KAMA Alpha
            //sc = pow((er * (fastAlpha - slowAlpha)) + slowAlpha, 2)

            //kama = 0.0
            //kama:= sc * src + (1 - sc) * nz(kama[1])

            //kamaColor = highlightMovements ? (kama > kama[1] ? green : red) : #6d1e7f
            //plot(kama, title = "KAMA", linewidth = 2, color = kamaColor, transp = 0)
            List<decimal> volatilityList = new();
            List<decimal> efficiencyRatioList = new();
            List<decimal> smoothingConstantList = new();
            List<decimal> kamaList = new();
            List<decimal> volatilitySumList = new();
            List<decimal> momentumList = new();
            List<Signal> signalsList = new();

            try
            {
                int length = days;
                int fastLength = MinOrMax((int)Math.Ceiling((decimal)length / 7));
                int slowLength = MinOrMax((int)Math.Ceiling(length / 0.4667));
                decimal fastAlpha = (decimal)2 / (fastLength + 1);
                decimal slowAlpha = (decimal)2 / (slowLength + 1);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal priorValue = i >= length ? stockDataClass.InputValues.ElementAtOrDefault(i - length) : 0;

                    decimal volatility = Math.Abs(currentValue - prevValue);
                    volatilityList.Add(volatility);

                    decimal volatilitySum = volatilityList.TakeLast(length).Sum();
                    volatilitySumList.Add(volatilitySum);

                    decimal momentum = Math.Abs(currentValue - priorValue);
                    momentumList.Add(momentum);

                    decimal efficiencyRatio = volatilitySum != 0 ? momentum / volatilitySum : 0;
                    efficiencyRatioList.Add(efficiencyRatio);

                    decimal sc = Pow((efficiencyRatio * (fastAlpha - slowAlpha)) + slowAlpha, 2);
                    smoothingConstantList.Add(sc);

                    decimal prevKama = kamaList.LastOrDefault();
                    decimal currentKAMA = (sc * currentValue) + ((1 - sc) * prevKama);
                    kamaList.Add(currentKAMA);

                    var signal = GetCompareSignal(currentValue - currentKAMA, prevValue - prevKama);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (volatilitySumList, momentumList, efficiencyRatioList, smoothingConstantList, kamaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateMotionSmoothnessIndex(StockData stockDataClass, int days = 50)
        {
            //@version=4
            //study("Motion Smoothness Index")
            //length = input(50)
            //----
            //a = close
            //b = stdev(change(a), length) / stdev(a, length)
            //plot(b, color = color.teal, transp = 0),hline(.5)
            List<decimal> bList = new();
            List<decimal> aChgStdDevList = new();
            List<Signal> signalsList = new();

            try
            {
                var aChgList = CalculateMoveTracker(stockDataClass).Item1;
                aChgStdDevList = CalculateStandardDeviationVolatility(aChgList, stockDataClass, days).Item4;
                var stdDevList = CalculateStandardDeviationVolatility(null, stockDataClass, days).Item4;
                var emaList = CalculateExponentialMovingAverage(stockDataClass, days).Item1;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal currentEma = emaList.ElementAtOrDefault(i);
                    decimal aChgStdDev = aChgStdDevList.ElementAtOrDefault(i);
                    decimal stdDev = stdDevList.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevEma = i >= 1 ? emaList.ElementAtOrDefault(i - 1) : 0;

                    decimal b = stdDev != 0 ? aChgStdDev / stdDev : 0;
                    bList.Add(b);

                    var signal = GetVolatilitySignal(currentValue - currentEma, prevValue - prevEma, b, 0.5m);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (aChgStdDevList, bList, signalsList);
        }

        public static (List<decimal>, List<Signal>) CalculateHybridConvolutionFilter(StockData stockDataClass, int days = 14)
        {
            //@version=4
            //study("Hybrid Convolution Filter", overlay = true)
            //length = input(14)
            //----
            //f(x) => .5 * (1 - cos(x * 3.14159))
            //d(x) => f(x / length) - f((x - 1) / length)
            //----
            //filter(a, b) =>
            //    sum = 0.
            //    for i = 1 to length
            //        sgn = f(i / length)
            //        sum := sum + (sgn * b + (1 - sgn) * a[i - 1]) * d(i)
            //    sum
            //----
            //output = 0.
            //output := filter(close, nz(output[1], close))
            //plot(output)
            List<decimal> outputList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevVal = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal prevOutput = i >= 1 ? outputList.ElementAtOrDefault(i - 1) : currentValue;
                    decimal output = 0;
                    for (int j = 1; j <= days; j++)
                    {
                        decimal sign = (0.5m * (1 - Cos(MinOrMax((double)j / days * Math.PI, 0.99, 0.01))));
                        decimal d = sign - (0.5m * (1 - Cos(MinOrMax((double)(j - 1) / days, 0.99, 0.01))));
                        decimal prevValue = i >= j - 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - (j - 1)) : 0;

                        output += ((sign * prevOutput) + ((1 - sign) * prevValue)) * d;
                    }
                    outputList.Add(output);

                    var signal = GetCompareSignal(currentValue - output, prevVal - prevOutput);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (outputList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculatePoweredKaufmanAdaptiveMovingAverage(StockData stockDataClass, int days = 100)
        {
            //@version=4
            //study("Powered Kaufman Adaptive Moving Average", shorttitle = "P-KAMA", overlay = true)
            //length = input(100),factor = input(3.),src = input(close),sp = input(false, title = "Self Powered")
            //----
            //er = abs(change(close, length)) / sum(abs(change(close)), length)
            //pow = sp ? 1 / er : factor
            //per = pow(abs(change(close, length)) / sum(abs(change(close)), length), pow)
            //----
            //a = 0.
            //a := per * src + (1 - per) * nz(a[1], src)
            //----
            //plot(a, title = "P-KAMA", color =#f57f17,linewidth=2,transp=0)
            List<decimal> perList = new();
            List<decimal> perSpList = new();
            List<decimal> aList = new();
            List<decimal> aSpList = new();
            List<Signal> signalsList = new();

            try
            {
                var erList = CalculateKaufmanAdaptiveMovingAverage(stockDataClass, days).Item3;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal er = erList.ElementAtOrDefault(i);
                    decimal pow = 3;
                    decimal powSp = er != 0 ? 1 / er : pow;

                    decimal per = Pow(er, (double)pow);
                    perList.Add(per);

                    decimal perSp = Pow(er, (double)powSp);
                    perSpList.Add(perSp);

                    decimal prevA = i >= 1 ? aList.LastOrDefault() : currentValue;
                    decimal a = (per * currentValue) + ((1 - per) * prevA);
                    aList.Add(a);

                    decimal prevASp = i >= 1 ? aSpList.LastOrDefault() : currentValue;
                    decimal aSp = (perSp * currentValue) + ((1 - perSp) * prevASp);
                    aSpList.Add(aSp);

                    var signal = GetCompareSignal(currentValue - a, prevValue - prevA);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (perList, perSpList, aList, aSpList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateAdaptiveTrailingStop(StockData stockDataClass, int days = 100)
        {
            //@version=4
            //study("Adaptive Trailing Stop", shorttitle = "ATS", overlay = true)
            //length = input(100),factor = input(3, minval = 2),adaptive = input(true),smooth = input(false)
            //----
            //src = close
            //a = 0.,b = 0.,os = 0.,up = 0.,dn = 0.
            //----
            //er = adaptive ? pow(abs(change(src, length)) / sum(abs(change(src)), length), factor) : 1 / length
            //a:= max(src, nz(a[1], src)) - abs(src - nz(a[1], src)) * er
            //b:= min(src, nz(b[1], src)) + abs(src - nz(b[1], src)) * er
            //up:= a > a[1] ? a : a < a[1] and b<b[1] ? a: nz(up[1])
            //dn:= b < b[1] ? b : b > b[1] and a > a[1] ? b : nz(dn[1])
            //----
            //os:= cross(iff(smooth, a, up), src) ? 1 : cross(iff(smooth, b, dn), src) ? 0 : os[1]
            //ts = os * iff(smooth, b, dn) + (1 - os) * iff(smooth, a, up)
            //----
            //css = os == 1 ? color.blue : #ff1100
            //plot(ts, color = css, linewidth = 2, transp = 0)
            //alertcondition(crossover(src, ts), title = "TrendUp", message = "Market Trending Up")
            //alertcondition(crossunder(src, ts), title = "TrendDn", message = "Market Trending Down")
            List<decimal> upList = new();
            List<decimal> dnList = new();
            List<decimal> aList = new();
            List<decimal> bList = new();
            List<decimal> osList = new();
            List<decimal> tsList = new();
            List<Signal> signalsList = new();

            try
            {
                var perList = CalculatePoweredKaufmanAdaptiveMovingAverage(stockDataClass, days).Item1;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal per = perList.ElementAtOrDefault(i);

                    decimal prevA = i >= 1 ? aList.LastOrDefault() : currentValue;
                    decimal a = Math.Max(currentValue, prevA) - (Math.Abs(currentValue - prevA) * per);
                    aList.Add(a);

                    decimal prevB = i >= 1 ? bList.LastOrDefault() : currentValue;
                    decimal b = Math.Min(currentValue, prevB) + (Math.Abs(currentValue - prevB) * per);
                    bList.Add(b);

                    decimal prevUp = upList.LastOrDefault();
                    decimal up = a > prevA ? a : a < prevA && b < prevB ? a : prevUp;
                    upList.Add(up);

                    decimal prevDn = dnList.LastOrDefault();
                    decimal dn = b < prevB ? b : b > prevB && a > prevA ? b : prevDn;
                    dnList.Add(dn);

                    decimal prevOs = osList.LastOrDefault();
                    decimal os = up > currentValue ? 1 : dn > currentValue ? 0 : prevOs;
                    osList.Add(os);

                    decimal prevTs = tsList.LastOrDefault();
                    decimal ts = (os * dn) + ((1 - os) * up);
                    tsList.Add(ts);

                    var signal = GetCompareSignal(currentValue - ts, prevValue - prevTs);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (aList, bList, upList, dnList, osList, tsList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateLinearTrailingStop(StockData stockDataClass, int days = 14)
        {
            //@version=4
            //study("Linear Trailing Stop", overlay = true)
            //src = input(close),length = input(14),mult = input(28),point = input(false),extrapolate = input(true)
            //----
            //a = 0.
            //s = point ? syminfo.pointvalue * 10 * (1 / length) : syminfo.mintick * 100 * (1 / length)
            //x = src + change(nz(a[1], src)) * mult
            //a:= x > nz(a[1], x) + s ? nz(a[1], x) + s : x < nz(a[1], x) - s ? nz(a[1], x) - s : nz(a[1], x)
            //----
            //upper = 0.
            //lower = 0.
            //Up = a + abs(change(a)) * mult
            //Dn = a - abs(change(a)) * mult
            //upper:= Up == a ? nz(upper[1]) : Up
            //lower:= Dn == a ? nz(lower[1]) : Dn
            //----
            //os = 0
            //os:= cross(src, upper) ? 1 : cross(src, lower) ? 0 : os[1]
            //ts = os * lower + (1 - os) * upper
            //----
            //css = os == 1 ? #0080FF : #ff1100
            //n = bar_index
            //if barstate.islast and extrapolate == true
            //    line A = line.new (n[1], ts[1], n, ts, extend= extend.right,color = css,width = 2)
            //    line.delete(A[1])
            //plot(ts, color = css, linewidth = 2, transp = 0)
            List<decimal> upList = new();
            List<decimal> dnList = new();
            List<decimal> aList = new();
            List<decimal> xList = new();
            List<decimal> osList = new();
            List<decimal> tsList = new();
            List<decimal> upperList = new();
            List<decimal> lowerList = new();
            List<Signal> signalsList = new();
            decimal mult = 28;

            try
            {
                decimal s = (decimal)1 / days;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevA = i >= 1 ? aList.ElementAtOrDefault(i - 1) : currentValue;
                    decimal prevA2 = i >= 2 ? aList.ElementAtOrDefault(i - 2) : currentValue;
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal x = currentValue + ((prevA - prevA2) * mult);
                    xList.Add(x);

                    decimal a = x > prevA + s ? prevA + s : x < prevA - s ? prevA - s : prevA;
                    aList.Add(a);

                    decimal up = a + (Math.Abs(a - prevA) * mult);
                    upList.Add(up);

                    decimal dn = a - (Math.Abs(a - prevA) * mult);
                    dnList.Add(dn);

                    decimal prevUpper = upperList.LastOrDefault();
                    decimal upper = up == a ? prevUpper : up;
                    upperList.Add(upper);

                    decimal prevLower = lowerList.LastOrDefault();
                    decimal lower = dn == a ? prevLower : dn;
                    lowerList.Add(lower);

                    decimal prevOs = osList.LastOrDefault();
                    decimal os = currentValue > upper ? 1 : currentValue > lower ? 0 : prevOs;
                    osList.Add(os);

                    decimal prevTs = tsList.LastOrDefault();
                    decimal ts = (os * lower) + ((1 - os) * upper);
                    tsList.Add(ts);

                    var signal = GetCompareSignal(currentValue - ts, prevValue - prevTs);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (aList, xList, upList, dnList, upperList, lowerList, osList, tsList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateLinearChannels(StockData stockDataClass, int days = 14)
        {
            //@version=4
            //study("Linear Channels", overlay = true)
            //length = input(14),mult = input(50),spread = input(1, "Channels Spreading"),point = input(false),extrapolate = input(true)
            //----
            //a = 0.
            //s = point ? syminfo.pointvalue * 10 * (1 / length) : syminfo.mintick * 100 * (1 / length)
            //x = open + change(nz(a[1], open)) * mult
            //a:= x > nz(a[1], x) + s ? nz(a[1], x) + s : x < nz(a[1], x) - s ? nz(a[1], x) - s : nz(a[1], x)
            //----
            //upper = 0.
            //lower = 0.
            //Up = a + abs(change(a)) * (mult * spread)
            //Dn = a - abs(change(a)) * (mult * spread)
            //upper:= Up == a ? nz(upper[1]) : Up
            //lower:= Dn == a ? nz(lower[1]) : Dn
            //----
            //n = bar_index
            //if barstate.islast and extrapolate == true
            //    line A = line.new (n[1], upper[1], n, upper, extend= extend.right,color =#0080FF,style=line.style_dashed,width=2)
            //    line B = line.new (n[1], a[1], n, a, extend= extend.right,color =#e65100,style=line.style_dashed,width=2)
            //    line C = line.new (n[1], lower[1], n, lower, extend= extend.right,color =#ff1100,style=line.style_dashed,width=2)
            //    line.delete(A[1])
            //    line.delete(B[1])
            //    line.delete(C[1])

            //plot(upper, color =#0080FF,linewidth=2,transp=0)
            //plot(a, color =#e65100,linewidth=2,transp=0)
            //plot(lower, color =#ff1100,linewidth=2,transp=0)
            List<decimal> upList = new();
            List<decimal> dnList = new();
            List<decimal> aList = new();
            List<decimal> xList = new();
            List<decimal> upperList = new();
            List<decimal> lowerList = new();
            List<Signal> signalsList = new();
            decimal mult = 50;

            try
            {
                decimal s = (decimal)1 / days;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevA = i >= 1 ? aList.ElementAtOrDefault(i - 1) : currentValue;
                    decimal prevA2 = i >= 2 ? aList.ElementAtOrDefault(i - 2) : currentValue;
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal x = currentValue + ((prevA - prevA2) * mult);
                    xList.Add(x);

                    decimal a = x > prevA + s ? prevA + s : x < prevA - s ? prevA - s : prevA;
                    aList.Add(a);

                    decimal up = a + (Math.Abs(a - prevA) * mult);
                    upList.Add(up);

                    decimal dn = a - (Math.Abs(a - prevA) * mult);
                    dnList.Add(dn);

                    decimal prevUpper = upperList.LastOrDefault();
                    decimal upper = up == a ? prevUpper : up;
                    upperList.Add(upper);

                    decimal prevLower = lowerList.LastOrDefault();
                    decimal lower = dn == a ? prevLower : dn;
                    lowerList.Add(lower);

                    var signal = GetBollingerBandsSignal(currentValue - a, prevValue - prevA, currentValue, prevValue, upper, prevUpper, lower, prevLower);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (aList, xList, upList, dnList, upperList, lowerList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateBilateralStochasticOscillator(StockData stockDataClass, string maType, int days = 100)
        {
            //@version=4
            //study("Bilateral Stochastic Oscillator")
            //length = input(100),slen = input(20, title = "Signal Length"),source = input(close)
            //method = input("SMA", title = "Pre-Filtering Method", options =["SMA", "EMA", "TMA", "LSMA", "No Filtering"])
            //----
            //f(x)=>method == x
            //s(x, p)=>f("SMA") ? sma(x, p) : f("EMA") ? ema(x, p) : f("TMA") ? sma(sma(x, p), p) : f("LSMA") ? linreg(x, p, 0) : x
            //----
            //src = s(source, length)
            //a = highest(src, length)
            //b = lowest(src, length)
            //----
            //bull = src / sma(a - b, length) - b / sma(a - b, length)
            //bear = abs(src / sma(a - b, length) - a / sma(a - b, length))
            //signal = sma(max(bull, bear), slen)
            //----
            //plot(bull, title = "Bull", color =#2196f3,linewidth=2,transp=0)
            //plot(bear, title = "Bear", color =#ff1100,linewidth=2,transp=0)
            //plot(signal, title = "Signal", color = color.orange, linewidth = 1, transp = 0)
            List<decimal> bullList = new();
            List<decimal> bearList = new();
            List<decimal> signalList = new();
            List<decimal> rangeList = new();
            List<decimal> rangeSmaList = new();
            List<decimal> maxList = new();
            List<Signal> signalsList = new();

            try
            {
                int sLength = MinOrMax((int)Math.Ceiling((decimal)days / 5));

                var smaList = GetMovingAverageList(maType, null, stockDataClass, days);
                var minMaxList = GetMaxAndMinValuesList(smaList, days);
                var highestList = minMaxList.Item1;
                var lowestList = minMaxList.Item2;

                for (int h = 0; h < stockDataClass.InputValues.Count; h++)
                {
                    decimal highest = highestList.ElementAtOrDefault(h);
                    decimal lowest = lowestList.ElementAtOrDefault(h);

                    decimal range = highest - lowest;
                    rangeList.Add(range);
                }

                rangeSmaList = GetMovingAverageList(maType, rangeList, stockDataClass, days);
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal sma = smaList.ElementAtOrDefault(i);
                    decimal highest = highestList.ElementAtOrDefault(i);
                    decimal lowest = lowestList.ElementAtOrDefault(i);
                    decimal rangeSma = rangeSmaList.ElementAtOrDefault(i);

                    decimal bull = rangeSma != 0 ? (sma / rangeSma) - (lowest / rangeSma) : 0;
                    bullList.Add(bull);

                    decimal bear = rangeSma != 0 ? Math.Abs((sma / rangeSma) - (highest / rangeSma)) : 0;
                    bearList.Add(bear);

                    decimal max = Math.Max(bull, bear);
                    maxList.Add(max);
                }

                signalList = GetMovingAverageList(maType, maxList, stockDataClass, sLength);
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal bull = bullList.ElementAtOrDefault(j);
                    decimal bear = bearList.ElementAtOrDefault(j);
                    decimal sig = signalList.ElementAtOrDefault(j);

                    var signal = GetConditionSignal(bull > bear || bull > sig, bear > bull || bull < sig);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (rangeSmaList, bullList, bearList, maxList, signalList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateFisherLeastSquaresMovingAverage(
            StockData stockDataClass, string maType, int days = 100)
        {
            //@version=4
            //study("Fisher Least Squares Moving Average", shorttitle = "FLSMA", overlay = true)
            //length = input(100),src = input(close),n = bar_index
            //----
            //b = 0.
            //----
            //e = sma(abs(src - nz(b[1])), length)
            //z = sma(src - nz(b[1], src), length) / e
            //r = (exp(2 * z) - 1) / (exp(2 * z) + 1)
            //a = (n - sma(n, length)) / stdev(n, length) * r
            //b:= sma(src, length) + a * stdev(src, length)
            //----
            //plot(b, title = "FLSMA", color =#ff1100,linewidth=2,transp=0)
            List<decimal> bList = new();
            List<decimal> eList = new();
            List<decimal> zList = new();
            List<decimal> rList = new();
            List<decimal> aList = new();
            List<decimal> indexList = new();
            List<decimal> diffList = new();
            List<decimal> absDiffList = new();
            List<Signal> signalsList = new();

            try
            {
                var stdDevSrcList = CalculateStandardDeviationVolatility(null, stockDataClass, days).Item4;
                var smaSrcList = GetMovingAverageList(maType, null, stockDataClass, days);

                for (int h = 0; h < stockDataClass.InputValues.Count; h++)
                {
                    decimal index = h;
                    indexList.Add(index);
                }

                var indexStdDevList = CalculateStandardDeviationVolatility(indexList, stockDataClass, days).Item4;
                var indexSmaList = GetMovingAverageList(maType, indexList, stockDataClass, days);
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal stdDevSrc = stdDevSrcList.ElementAtOrDefault(i);
                    decimal indexStdDev = indexStdDevList.ElementAtOrDefault(i);
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevB = i >= 1 ? bList.ElementAtOrDefault(i - 1) : currentValue;
                    decimal indexSma = indexSmaList.ElementAtOrDefault(i);
                    decimal sma = smaSrcList.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal diff = currentValue - prevB;
                    diffList.Add(diff);

                    decimal absDiff = Math.Abs(diff);
                    absDiffList.Add(absDiff);

                    decimal e = absDiffList.TakeLast(days).Average();
                    eList.Add(e);

                    decimal z = e != 0 ? diffList.TakeLast(days).Average() / e : 0;
                    zList.Add(z);

                    decimal r = Exp(2 * z) + 1 != 0 ? (Exp(2 * z) - 1) / (Exp(2 * z) + 1) : 0;
                    rList.Add(r);

                    decimal a = indexStdDev != 0 && r != 0 ? (i - indexSma) / indexStdDev * r : 0;
                    aList.Add(a);

                    decimal b = sma + (a * stdDevSrc);
                    bList.Add(b);

                    var signal = GetCompareSignal(currentValue - b, prevValue - prevB);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (diffList, absDiffList, eList, zList, rList, aList, bList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateIIRLeastSquaresEstimate(StockData stockDataClass, int days = 100)
        {
            //@version=4
            //study("IIR Least-Squares Estimate", overlay = true)
            //length = input(100),src = input(close)
            //----
            //a = 4 / (length + 2)
            //s = 0.
            //s := a * src + nz(s[1], src) - a * ema(nz(s[1], src), length / 2)
            //plot(s, color = color.red, linewidth = 2, transp = 0)
            List<decimal> sList = new();
            List<decimal> sEmaList = new();
            List<Signal> signalsList = new();

            try
            {
                decimal a = (decimal)4 / (days + 2);
                int halfLength = MinOrMax((int)Math.Ceiling((decimal)days / 2));

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal prevS = i >= 1 ? sList.ElementAtOrDefault(i - 1) : currentValue;
                    decimal prevSEma = CalculateExponentialMovingAverage(prevS, sEmaList.LastOrDefault(), halfLength);
                    sEmaList.Add(prevSEma);

                    decimal s = ((a * currentValue) + prevS) - (a * prevSEma);
                    sList.Add(s);

                    var signal = GetCompareSignal(currentValue - s, prevValue - prevS);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (sEmaList, sList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateTimeSeriesForecast(StockData stockDataClass, int days = 500)
        {
            //@version=4
            //study("Time Series Forecast", overlay = true)
            //length = input(500),mult = input(1.),short = input(false, "Short Term Extrapolation"), src = input(open)
            //----
            //n = bar_index
            //ts = linreg(src, length, 0)
            //p = short ? 1 : length
            //----
            //e = cum(abs(src - ts)) / n * mult
            //a = ts + e
            //b = ts - e
            //----
            //line Up = line.new (n[p], a[p], n, a, extend= extend.right,color = color.blue,width = 2)
            //line Md = line.new (n[p], ts[p], n, ts, extend= extend.right,color =#e65100,width=2)
            //line Dn = line.new (n[p], b[p], n, b, extend= extend.right,color = color.blue,width = 2)
            //----
            //line.delete(Up[1])
            //line.delete(Md[1])
            //line.delete(Dn[1])
            //plot(ts, color = short ? color.blue : na, transp = 0)
            List<decimal> absDiffList = new();
            List<decimal> eList = new();
            List<decimal> aList = new();
            List<decimal> bList = new();
            List<Signal> signalsList = new();

            try
            {
                var tsList = CalculateLinearRegression(null, stockDataClass, days).Item15;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal ts = tsList.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevTs = i >= 1 ? tsList.ElementAtOrDefault(i - 1) : 0;

                    decimal absDiff = Math.Abs(currentValue - ts);
                    absDiffList.Add(absDiff);

                    decimal e = i != 0 ? absDiffList.Sum() / i : 0;
                    eList.Add(e);

                    decimal prevA = aList.LastOrDefault();
                    decimal a = ts + e;
                    aList.Add(a);

                    decimal prevB = bList.LastOrDefault();
                    decimal b = ts - e;
                    bList.Add(b);

                    var signal = GetBollingerBandsSignal(currentValue - ts, prevValue - prevTs, currentValue, prevValue, a, prevA, b, prevB);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (absDiffList, eList, aList, bList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateStandardDevation(StockData stockDataClass, string maType, int days = 7)
        {
            //@version=4
            //study("Standard Deviation", shorttitle = "Stdev")
            //length = input(14)
            //----
            //a = sma(pow(close, 2), length)
            //b = pow(sum(close, length), 2) / pow(length, 2)
            //c = sqrt(a - b)
            //----
            //plot(c, title = "Stdev", color =#ec407a,transp=0)
            List<decimal> bList = new();
            List<decimal> cList = new();
            List<decimal> cSmaList = new();
            List<decimal> powList = new();
            List<decimal> tempList = new();
            List<decimal> sumList = new();
            List<Signal> signalsList = new();

            try
            {
                int signalPeriod = days;
                int length = days * 2;

                var emaList = CalculateExponentialMovingAverage(stockDataClass, length).Item1;

                for (int h = 0; h < stockDataClass.InputValues.Count; h++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(h);
                    tempList.Add(currentValue);

                    decimal sum = tempList.TakeLast(length).Sum();
                    sumList.Add(sum);

                    decimal pow = Pow(currentValue, 2);
                    powList.Add(pow);
                }

                var powSmaList = GetMovingAverageList(maType, powList, stockDataClass, length);
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal currentEma = emaList.ElementAtOrDefault(i);
                    decimal a = powSmaList.ElementAtOrDefault(i);
                    decimal sum = sumList.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevEma = i >= 1 ? emaList.ElementAtOrDefault(i - 1) : 0;

                    decimal b = Pow(sum, 2) / Pow(length, 2);
                    bList.Add(b);

                    decimal c = a - b >= 0 ? Sqrt(a - b) : 0;
                    cList.Add(c);

                    decimal cSma = cList.TakeLast(signalPeriod).Average();
                    cSmaList.Add(cSma);

                    var signal = GetVolatilitySignal(currentValue - currentEma, prevValue - prevEma, c, cSma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (bList, cList, cSmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateKaufmanAdaptiveLeastSquaresMovingAverage(StockData stockDataClass, string maType, int days = 100)
        {
            //@version=4
            //study("Kaufman Adaptive Least Squares Moving Average", shorttitle = "KALSMA", overlay = true)
            //length = input(100),prefiltering = input(true)
            //----
            //er = abs(change(close, length)) / sum(abs(change(close)), length)
            //kama(x)=>
            //    a = 0.
            //    a := er * x + (1 - er) * nz(a[1], x)
            //st(x)=>sqrt(kama(x * x) - pow(kama(x), 2))
            //----
            //src = prefiltering ? kama(close) : close
            //n = bar_index
            //a = kama(n * src) - kama(n) * kama(src)
            //b = st(n) * st(src)
            //r = a / b
            //----
            //alpha = st(src) / st(n) * r
            //beta = kama(src) - alpha * kama(n)
            //kalsma = alpha * n + beta
            //----
            //plot(kalsma, color =#0cb51a,transp=0)
            List<decimal> alphaList = new();
            List<decimal> betaList = new();
            List<decimal> kalsmaList = new();
            List<Signal> signalsList = new();

            try
            {
                var kamaList = CalculateKaufmanAdaptiveCorrelationOscillator(stockDataClass, maType, days);
                var indexStList = kamaList.Item5;
                var srcStList = kamaList.Item6;
                var rList = kamaList.Item9;
                var srcMaList = GetMovingAverageList(maType, null, stockDataClass, days);
                var indexMaList = kamaList.Item1;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    var indexSt = indexStList.ElementAtOrDefault(i);
                    var srcSt = srcStList.ElementAtOrDefault(i);
                    var srcMa = srcMaList.ElementAtOrDefault(i);
                    var indexMa = indexMaList.ElementAtOrDefault(i);
                    var r = rList.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal alpha = indexSt != 0 ? srcSt / indexSt * r : 0;
                    alphaList.Add(alpha);

                    decimal beta = srcMa - (alpha * indexMa);
                    betaList.Add(beta);

                    decimal prevKalsma = kalsmaList.LastOrDefault();
                    decimal kalsma = (alpha * i) + beta;
                    kalsmaList.Add(kalsma);

                    var signal = GetCompareSignal(currentValue - kalsma, prevValue - prevKalsma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (alphaList, betaList, kalsmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<Signal>) CalculateKaufmanAdaptiveCorrelationOscillator(StockData stockDataClass, string maType, int days = 14)
        {
            //@version=4
            //study("Kaufman Adaptive Correlation Oscillator")
            //length = input(14),prefiltering = input(false)
            //----
            //er = abs(change(close, length)) / sum(abs(change(close)), length)
            //kama(x)=>
            //    a = 0.
            //    a := er * x + (1 - er) * nz(a[1], x)
            //st(x)=>sqrt(kama(x * x) - pow(kama(x), 2))
            //----
            //src = prefiltering ? kama(close) : close
            //n = bar_index
            //a = kama(n * src) - kama(n) * kama(src)
            //b = st(n) * st(src)
            //r = a / b
            //----
            //plot(r, color =#e65100,transp=0),hline(.5),hline(-.5)
            List<decimal> indexList = new();
            List<decimal> index2List = new();
            List<decimal> src2List = new();
            List<decimal> srcStList = new();
            List<decimal> indexStList = new();
            List<decimal> index2MaList = new();
            List<decimal> src2MaList = new();
            List<decimal> indexSrcList = new();
            List<decimal> indexMaList = new();
            List<decimal> indexSrcMaList = new();
            List<decimal> aList = new();
            List<decimal> bList = new();
            List<decimal> rList = new();
            List<Signal> signalsList = new();

            try
            {
                var kamaList = GetMovingAverageList(maType, null, stockDataClass, days);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);

                    decimal index = i;
                    indexList.Add(index);

                    decimal indexSrc = i * currentValue;
                    indexSrcList.Add(indexSrc);

                    decimal srcSrc = currentValue * currentValue;
                    src2List.Add(srcSrc);

                    decimal indexIndex = index * index;
                    index2List.Add(indexIndex);
                }

                indexMaList = GetMovingAverageList(maType, indexList, stockDataClass, days);
                indexSrcMaList = GetMovingAverageList(maType, indexSrcList, stockDataClass, days);
                index2MaList = GetMovingAverageList(maType, index2List, stockDataClass, days);
                src2MaList = GetMovingAverageList(maType, src2List, stockDataClass, days);
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal srcMa = kamaList.ElementAtOrDefault(j);
                    decimal indexMa = indexMaList.ElementAtOrDefault(j);
                    decimal indexSrcMa = indexSrcMaList.ElementAtOrDefault(j);
                    decimal index2Ma = index2MaList.ElementAtOrDefault(j);
                    decimal src2Ma = src2MaList.ElementAtOrDefault(j);
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(j);
                    decimal prevR1 = j >= 1 ? rList.ElementAtOrDefault(j - 1) : 0;
                    decimal prevR2 = j >= 2 ? rList.ElementAtOrDefault(j - 2) : 0;

                    decimal indexSqrt = index2Ma - Pow(indexMa, 2);
                    decimal indexSt = indexSqrt >= 0 ? Sqrt(indexSqrt) : 0;
                    indexStList.Add(indexSt);

                    decimal srcSqrt = src2Ma - Pow(srcMa, 2);
                    decimal srcSt = srcSqrt >= 0 ? Sqrt(srcSqrt) : 0;
                    srcStList.Add(srcSt);

                    decimal a = indexSrcMa - (indexMa * srcMa);
                    aList.Add(a);

                    decimal b = indexSt * srcSt;
                    bList.Add(b);

                    decimal r = b != 0 ? a / b : 0;
                    rList.Add(r);

                    var signal = GetRsiSignal(r - prevR1, prevR1 - prevR2, r, prevR1, 0.5m, -0.5m);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (indexMaList, indexSrcMaList, index2MaList, src2MaList, indexStList, srcStList, aList, bList, rList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateUhlMaCrossoverSystem(StockData stockDataClass, string maType, int days = 100)
        {
            // This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
            // © alexgrover

            //@version=4
            //study("Uhl MA Crossover System", "UHLMA", true)
            //length = input(100),mult = input(1.),src = input(close)
            //----
            //out = 0., cma = 0., cts = 0.
            //Var = variance(src, length) * mult
            //sma = sma(src, length)
            //----
            //secma = pow(nz(sma - cma[1]), 2)
            //sects = pow(nz(src - cts[1]), 2)
            //ka = Var < secma ? 1 - Var / secma : 0
            //kb = Var < sects ? 1 - Var / sects : 0
            //----
            //cma:= ka * sma + (1 - ka) * nz(cma[1], src)
            //cts:= kb * src + (1 - kb) * nz(cts[1], src)
            //----
            //css = cts > cma ? #2157f3 : #ff1100
            //a = plot(cts, "CTS",#2157f3,2,transp=0)
            //b = plot(cma, "CMA",#ff1100,2,transp=0)
            //fill(a, b, color = css, transp = 80)
            List<decimal> secmaList = new();
            List<decimal> sectsList = new();
            List<decimal> kaList = new();
            List<decimal> kbList = new();
            List<decimal> cmaList = new();
            List<decimal> ctsList = new();
            List<Signal> signalsList = new();

            try
            {
                var smaList = GetMovingAverageList(maType, null, stockDataClass, days);
                var varList = CalculateStandardDeviationVolatility(null, stockDataClass, days).Item3;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal sma = smaList.ElementAtOrDefault(i);
                    decimal prevVar = i >= days ? varList.ElementAtOrDefault(i - days) : 0;
                    decimal prevCma = i >= 1 ? cmaList.LastOrDefault() : currentValue;
                    decimal prevCts = i >= 1 ? ctsList.LastOrDefault() : currentValue;

                    decimal secma = Pow(sma - prevCma, 2);
                    secmaList.Add(secma);

                    decimal sects = Pow(currentValue - prevCts, 2);
                    sectsList.Add(sects);

                    decimal ka = prevVar < secma && secma != 0 ? 1 - (prevVar / secma) : 0;
                    kaList.Add(ka);

                    decimal kb = prevVar < sects && sects != 0 ? 1 - (prevVar / sects) : 0;
                    kbList.Add(kb);

                    decimal cma = (ka * sma) + ((1 - ka) * prevCma);
                    cmaList.Add(cma);

                    decimal cts = (kb * currentValue) + ((1 - kb) * prevCts);
                    ctsList.Add(cts);

                    var signal = GetCompareSignal(cts - cma, prevCts - prevCma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (secmaList, sectsList, kaList, kbList, cmaList, ctsList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateKaufmanBinaryWave(StockData stockDataClass, int days = 20)
        {
            //
            // @author LazyBear
            // If you use this code in its original/modified form, do drop me a note. 
            // My other indicators: https://www.tradingview.com/u/LazyBear/#published-charts
            // 
            //study(title = "Kaufman Binary Wave [LazyBear]", shorttitle = "AMAWave_LB", overlay = true)
            //src = close
            //length = input(20)
            //filterp = input(10, title = "Filter %", type = integer)
            //cf = input(true, "Color Buy/Sell safe areas?", type = bool)
            //dw = input(true, "Draw Wave?", type = bool)

            //d = abs(src - src[1])
            //s = abs(src - src[length])
            //noise = sum(d, length)
            //efratio = s / noise
            //fastsc = 0.6022
            //slowsc = 0.0645

            //smooth = pow(efratio * fastsc + slowsc, 2)
            //ama = nz(ama[1], close) + smooth * (src - nz(ama[1], close))
            //filter = filterp / 100 * stdev(ama - nz(ama), length)
            //amalow = ama < nz(ama[1]) ? ama : nz(amalow[1])
            //amahigh = ama > nz(ama[1]) ? ama : nz(amahigh[1])
            //bw = (ama - amalow) > filter ? 1 : (amahigh - ama > filter ? -1 : 0)
            //s_color = cf ? (bw > 0 ? green : (bw < 0) ? red : blue) : maroon
            //plot(dw ? bw : na, color = s_color)
            //bgcolor(cf ? s_color : na)
            //hline(0)
            List<decimal> smoothList = new();
            List<decimal> amaList = new();
            List<decimal> diffList = new();
            List<decimal> diffStdDevList = new();
            List<decimal> filterList = new();
            List<decimal> amaLowList = new();
            List<decimal> amaHighList = new();
            List<decimal> bwList = new();
            List<Signal> signalsList = new();
            decimal fastSc = 0.6022m, slowSc = 0.0645m, filterp = 10;

            try
            {
                List<decimal> efRatioList = CalculateKaufmanAdaptiveMovingAverage(stockDataClass, days).Item3;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal efRatio = efRatioList.ElementAtOrDefault(i);
                    decimal prevAma = i >= 1 ? amaList.ElementAtOrDefault(i - 1) : currentValue;

                    decimal smooth = Pow((efRatio * fastSc) + slowSc, 2);
                    smoothList.Add(smooth);

                    decimal ama = prevAma + (smooth * (currentValue - prevAma));
                    amaList.Add(ama);

                    decimal diff = ama - prevAma;
                    diffList.Add(diff);
                }

                diffStdDevList = CalculateStandardDeviationVolatility(diffList, stockDataClass, days).Item4;
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(j);
                    decimal ama = amaList.ElementAtOrDefault(j);
                    decimal diffStdDev = diffStdDevList.ElementAtOrDefault(j);
                    decimal prevAma = j >= 1 ? amaList.ElementAtOrDefault(j - 1) : currentValue;

                    decimal filter = filterp / 100 * diffStdDev;
                    filterList.Add(filter);

                    decimal prevAmaLow = amaLowList.LastOrDefault();
                    decimal amaLow = ama < prevAma ? ama : prevAmaLow;
                    amaLowList.Add(amaLow);

                    decimal prevAmaHigh = amaHighList.LastOrDefault();
                    decimal amaHigh = ama > prevAma ? ama : prevAmaHigh;
                    amaHighList.Add(amaHigh);

                    decimal prevBw = bwList.LastOrDefault();
                    decimal bw = ama - amaLow > filter ? 1 : amaHigh - ama > filter ? -1 : 0;
                    bwList.Add(bw);

                    var signal = GetCompareSignal(bw, prevBw);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (smoothList, amaList, diffList, diffStdDevList, filterList, amaLowList, amaHighList, bwList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<decimal>, List<Signal>) CalculatePolynomialLeastSquaresMovingAverage(StockData stockDataClass, int days = 100)
        {
            // 
            //kernel(x, order) =>
            //sum = 0.
            //b = 0.
            //pi = atan(1) * 4
            //a = x * x
            //for i = 1 to order
            //b := 1 / i * sin(x * i * pi)
            //sum := sum + b
            //pol = a + sum
            //----
            //F(src, M, order) =>
            //sum = 0.
            //for i = 1 to M
            //w = kernel(i / M, order) - kernel((i - 1) / M, order)
            //sum := sum + src[i - 1] * w
            //sum
            List<decimal> x1Pow1SumList = new();
            List<decimal> x2Pow1SumList = new();
            List<decimal> wPow1List = new();
            List<decimal> sumPow1List = new();
            List<decimal> x1Pow2SumList = new();
            List<decimal> x2Pow2SumList = new();
            List<decimal> wPow2List = new();
            List<decimal> sumPow2List = new();
            List<decimal> x1Pow3SumList = new();
            List<decimal> x2Pow3SumList = new();
            List<decimal> wPow3List = new();
            List<decimal> sumPow3List = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevVal = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal prevSumPow3 = sumPow3List.LastOrDefault();
                    decimal x1Pow1Sum = 0, x2Pow1Sum = 0, x1Pow2Sum = 0, x2Pow2Sum = 0, x1Pow3Sum = 0, x2Pow3Sum = 0, wPow1 = 0, wPow2 = 0, wPow3 = 0, sumPow1 = 0, sumPow2 = 0, sumPow3 = 0;
                    for (int j = 1; j <= days; j++)
                    {
                        decimal prevValue = i >= j - 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - (j - 1)) : 0;
                        decimal x1 = (decimal)j / days;
                        decimal x2 = (decimal)(j - 1) / days;
                        decimal ax1 = x1 * x1;
                        decimal ax2 = x2 * x2;

                        decimal b1 = 0, b2 = 0, b1Pow1Sum = 0, b2Pow1Sum = 0, b1Pow2Sum = 0, b2Pow2Sum = 0, b1Pow3Sum = 0, b2Pow3Sum = 0;
                        for (int k = 1; k <= 3; k++)
                        {
                            b1 = (decimal)1 / k * Sin(x1 * k * (decimal)Math.PI);
                            b2 = (decimal)1 / k * Sin(x2 * k * (decimal)Math.PI);

                            b1Pow1Sum += k == 1 ? b1 : 0;
                            b2Pow1Sum += k == 1 ? b2 : 0;
                            b1Pow2Sum += k <= 2 ? b1 : 0;
                            b2Pow2Sum += k <= 2 ? b2 : 0;
                            b1Pow3Sum += k <= 3 ? b1 : 0;
                            b2Pow3Sum += k <= 3 ? b2 : 0;
                        }

                        x1Pow1Sum = ax1 + b1Pow1Sum;
                        x2Pow1Sum = ax2 + b2Pow1Sum;
                        wPow1 = x1Pow1Sum - x2Pow1Sum;
                        sumPow1 += prevValue * wPow1;
                        x1Pow2Sum = ax1 + b1Pow2Sum;
                        x2Pow2Sum = ax2 + b2Pow2Sum;
                        wPow2 = x1Pow2Sum - x2Pow2Sum;
                        sumPow2 += prevValue * wPow2;
                        x1Pow3Sum = ax1 + b1Pow3Sum;
                        x2Pow3Sum = ax2 + b2Pow3Sum;
                        wPow3 = x1Pow3Sum - x2Pow3Sum;
                        sumPow3 += prevValue * wPow3;
                    }
                    x1Pow1SumList.Add(x1Pow1Sum);
                    x2Pow1SumList.Add(x2Pow1Sum);
                    wPow1List.Add(wPow1);
                    sumPow1List.Add(sumPow1);
                    x1Pow2SumList.Add(x1Pow2Sum);
                    x2Pow2SumList.Add(x2Pow2Sum);
                    wPow2List.Add(wPow2);
                    sumPow2List.Add(sumPow2);
                    x1Pow3SumList.Add(x1Pow3Sum);
                    x2Pow3SumList.Add(x2Pow3Sum);
                    wPow3List.Add(wPow3);
                    sumPow3List.Add(sumPow3);

                    var signal = GetCompareSignal(currentValue - sumPow3, prevVal - prevSumPow3);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (x1Pow1SumList, x2Pow1SumList, wPow1List, sumPow1List, x1Pow2SumList, x2Pow2SumList, wPow2List, sumPow2List, x1Pow3SumList, x2Pow3SumList, wPow3List, sumPow3List, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>)
            CalculateTurboScaler(StockData stockDataClass, string maType, int days = 50)
        {
            //@version=4
            //study("Turbo Scaler")
            //length = input(50),alpha = input(.5, minval = -1, maxval = 1),smooth = input(50)
            //----
            //f(src)=>
            //    smo = alpha * src + (1 - alpha) * sma(src, length)
            //    a = highest(smo, length)
            //    b = lowest(smo, length)
            //    (src - b) / (a - b)
            //----
            //a = sma(f(close), smooth)
            //b = sma(f(sma(close, length)), smooth)
            //----
            //plot(a, color = color.blue, transp = 0)
            //plot(b, color =#e65100,transp=0)
            List<decimal> aList = new();
            List<decimal> bList = new();
            List<decimal> smoList = new();
            List<decimal> smoSmaList = new();
            List<decimal> smoSmaHighestList = new();
            List<decimal> smoSmaLowestList = new();
            List<decimal> smoHighestList = new();
            List<decimal> smoLowestList = new();
            List<decimal> aSmaList = new();
            List<decimal> bSmaList = new();
            List<Signal> signalsList = new();
            decimal alpha = 0.5m;

            try
            {
                var smaList = GetMovingAverageList(maType, null, stockDataClass, days);
                var sma2List = GetMovingAverageList(maType, smaList, stockDataClass, days);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal sma = smaList.ElementAtOrDefault(i);
                    decimal sma2 = sma2List.ElementAtOrDefault(i);

                    decimal smoSma = (alpha * sma) + ((1 - alpha) * sma2);
                    smoSmaList.Add(smoSma);

                    decimal smo = (alpha * currentValue) + ((1 - alpha) * sma);
                    smoList.Add(smo);

                    decimal smoSmaHighest = smoSmaList.TakeLast(days).Max();
                    smoSmaHighestList.Add(smoSmaHighest);

                    decimal smoSmaLowest = smoSmaList.TakeLast(days).Min();
                    smoSmaLowestList.Add(smoSmaLowest);

                    decimal smoHighest = smoList.TakeLast(days).Max();
                    smoHighestList.Add(smoHighest);

                    decimal smoLowest = smoList.TakeLast(days).Min();
                    smoLowestList.Add(smoLowest);

                    decimal a = smoHighest - smoLowest != 0 ? (currentValue - smoLowest) / (smoHighest - smoLowest) : 0;
                    aList.Add(a);

                    decimal b = smoSmaHighest - smoSmaLowest != 0 ? (sma - smoSmaLowest) / (smoSmaHighest - smoSmaLowest) : 0;
                    bList.Add(b);
                }

                aSmaList = GetMovingAverageList(maType, aList, stockDataClass, days);
                bSmaList = GetMovingAverageList(maType, bList, stockDataClass, days);
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal a = aSmaList.ElementAtOrDefault(j);
                    decimal b = bSmaList.ElementAtOrDefault(j);
                    decimal prevA = j >= 1 ? aSmaList.ElementAtOrDefault(j - 1) : 0;
                    decimal prevB = j >= 1 ? bSmaList.ElementAtOrDefault(j - 1) : 0;

                    var signal = GetCompareSignal(a - b, prevA - prevB);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (smoList, smoHighestList, smoLowestList, smoSmaList, smoSmaHighestList, smoSmaLowestList, aList, bList, aSmaList, bSmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateBryantAdaptiveMovingAverage(StockData stockDataClass, int days = 14)
        {
            //@version=3
            // Copyright (c) 2014-present, Michael R. Bryant
            // Copyright (c) 2019-present, Alex Orekhov (everget)
            // Bryant Adaptive Moving Average script may be freely distributed under the MIT license.
            //study("Bryant Adaptive Moving Average", shorttitle = "BAMA", overlay = true)

            //length = input(title = "Length", type = integer, defval = 14)
            //trendParam = input(title = "Trend Parameter", type = float, defval = -1, step = 0.1)
            //maxLength = input(title = "Max Length", type = integer, defval = 100)
            //highlightMovements = input(title = "Highlight Movements ?", type = bool, defval = false)
            //src = input(title = "Source", type = source, defval = close)

            //mom = abs(change(src, length))
            //volatility = sum(abs(change(src)), length)

            // Efficiency Ratio
            //er = volatility != 0 ? mom / volatility : 0

            // Variable Efficiency Ratio
            //ver = pow(er - (2 * er - 1) / 2 * (1 - trendParam) + 0.5, 2)

            //vlength = (length - ver + 1) / ver
            //vlength:= vlength > maxLength ? maxLength : vlength

            //valpha = 2 / (vlength + 1)

            //bama = src
            //bama:= valpha * src + (1 - valpha) * nz(bama[1], bama)

            //bamaColor = highlightMovements ? (bama > bama[1] ? green : red) : #6d1e7f
            //plot(bama, title = "BAMA", linewidth = 2, color = bamaColor, transp = 0)
            List<decimal> vLengthList = new();
            List<decimal> verList = new();
            List<decimal> bamaList = new();
            List<decimal> vAlphaList = new();
            List<Signal> signalsList = new();

            try
            {
                decimal maxLength = 100, trendParam = -1;

                List<decimal> erList = CalculateKaufmanAdaptiveMovingAverage(stockDataClass, days).Item3;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal er = erList.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal ver = Pow(er - (((2 * er) - 1) / 2 * (1 - trendParam)) + 0.5m, 2);
                    verList.Add(ver);

                    decimal vLength = ver != 0 ? (days - ver + 1) / ver : 0;
                    vLength = Math.Min(vLength, maxLength);
                    vLengthList.Add(vLength);

                    decimal vAlpha = 2 / (vLength + 1);
                    vAlphaList.Add(vAlpha);

                    decimal prevBama = bamaList.LastOrDefault();
                    decimal bama = (vAlpha * currentValue) + ((1 - vAlpha) * prevBama);
                    bamaList.Add(bama);

                    var signal = GetCompareSignal(currentValue - bama, prevValue - prevBama);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (verList, vLengthList, vAlphaList, bamaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateEmaTrapIndicator(StockData stockDataClass, string maType, int days = 3)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Ema Trap Indicator [CC] script may be freely distributed under the MIT license.
            //study("Ema Trap Indicator [CC]", overlay = true)

            //f_security(_symbol, _res, _src, _repaint) => 
            //    security(_symbol, _res, _src[_repaint ? 0 : barstate.isrealtime ? 1 : 0])[_repaint ? 0 : barstate.isrealtime ? 0 : 1]

            //inp = input(title = "Source", type = input.source, defval = close)
            //inp3 = input(title = "Source For Ema3", type = input.source, defval = close)
            //inp8 = input(title = "Source For Ema8", type = input.source, defval = close)
            //inp17 = input(title = "Source For Ema17", type = input.source, defval = close)
            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //p = f_security(syminfo.tickerid, res, inp, rep)
            //ep3 = f_security(syminfo.tickerid, res, inp3, rep)
            //ep8 = f_security(syminfo.tickerid, res, inp8, rep)
            //ep17 = f_security(syminfo.tickerid, res, inp17, rep)
            //length3 = input(title = "Length3", type = input.integer, defval = 3, minval = 1)
            //length8 = input(title = "Length8", type = input.integer, defval = 8, minval = 1)
            //length17 = input(title = "Length17", type = input.integer, defval = 17, minval = 1)
            //deltaLimit = input(title = "DeltaLimit", type = input.float, defval = 0.5, minval = 0.01, step = 0.01)

            //ema3 = ema(ep3, length3)
            //ema8 = ema(ep8, length8)
            //ema17 = ema(ep17, length17)
            //shortUptrend = ema3 > ema8
            //delta = ema3 - ema8

            // check if long trend is true and pullback is true or consolidation is true
            //longEntry = nz(delta[0]) > nz(delta[1]) and nz(delta[1]) < nz(delta[2]) and(nz(delta[0]) > ((nz(delta[1]) + (nz(delta[2]) * 4)) / 5)) and
            //shortUptrend and close > ema3 and nz(delta[1]) < deltaLimit and(low <= ema3 or low <= ema8)
            //longExit = nz(delta[0]) < nz(delta[1]) and nz(delta[1]) > nz(delta[2]) and(nz(delta[0]) < ((nz(delta[1]) + (nz(delta[2]) * 4)) / 5)) and
            //     close < ema3 and nz(delta[1]) > deltaLimit

            //sig = longEntry ? 1 : longExit ? -1 : 0
            //etiColor = sig > 0 ? color.green : sig < 0 ? color.red : color.black
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //barcolor(bar ? etiColor : na)
            //plotshape(longEntry, "Long Entry", shape.labelup, location.belowbar, color.green, text = "Long Entry", textcolor = color.white)
            //plotshape(longExit, "Long Exit", shape.labeldown, location.abovebar, color = color.red, text = "Long Exit", textcolor = color.white)
            //plot(ema3, title = "3EMA", color = color.green, linewidth = 2)
            //plot(ema8, title = "8EMA", color = color.red, linewidth = 2)
            //plot(ema17, title = "17EMA", color = color.blue, linewidth = 2)
            List<decimal> entryList = new();
            List<decimal> exitList = new();
            List<decimal> delta1List = new();
            List<decimal> delta2List = new();
            List<Signal> signalsList = new();
            decimal deltaLimit = 0.5m;

            try
            {
                int length2 = (int)Math.Ceiling(days / 0.375);
                int length3 = (int)Math.Ceiling(days / 0.176);

                var ema3List = GetMovingAverageList(maType, null, stockDataClass, days);
                var ema8List = GetMovingAverageList(maType, null, stockDataClass, length2);
                var ema17List = GetMovingAverageList(maType, null, stockDataClass, length3);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal ema3 = ema3List.ElementAtOrDefault(i);
                    decimal ema8 = ema8List.ElementAtOrDefault(i);
                    decimal ema17 = ema17List.ElementAtOrDefault(i);
                    decimal prevDelta1 = i >= 1 ? delta1List.ElementAtOrDefault(i - 1) : 0;
                    decimal prevDelta2 = i >= 2 ? delta1List.ElementAtOrDefault(i - 2) : 0;

                    decimal delta1 = ema3 - ema8;
                    delta1List.Add(delta1);

                    decimal delta2 = ema3 - ema17;
                    delta2List.Add(delta2);

                    decimal prevEntry = entryList.LastOrDefault();
                    decimal entry = delta1 > deltaLimit && delta2 > deltaLimit ? currentValue : 0;
                    entryList.Add(entry);

                    decimal prevExit = exitList.LastOrDefault();
                    decimal exit = delta1 < deltaLimit && delta2 < deltaLimit ? currentValue : 0;
                    exitList.Add(exit);

                    var signal = GetCompareSignal(entry - exit, prevEntry - prevExit);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (delta1List, delta2List, entryList, exitList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>)
            CalculateKaufmanStressIndicator(StockData stockDataClass, StockData marketDataClass, int days = 60)
        {
            //
            // @author LazyBear
            // If you use this code in its orignal/modified form, do drop me a note. 
            //
            //study("Kaufman Stress Indicator [LazyBear]", shorttitle = "KSI_LB")
            //length = input(60)
            //oblvl = input(90, title = "Overbought Level")
            //oslvl = input(10, title = "Oversold Level")
            //normlvl = input(50, title = "Normal Level")
            //d2sym = input("SPY", type = symbol)

            //calc_range(hi, lo, len) => 
            //    highest(hi, len) - lowest(lo, len)

            //d2low = security(d2sym, period, low)
            //d2high = security(d2sym, period, high)
            //d2close = security(d2sym, period, close)
            //r1 = calc_range(high, low, length)
            //r2 = calc_range(d2high, d2low, length)
            //s1 = (r1 != 0 and r2 != 0) ? (close - lowest(low, length)) / r1 : 50
            //s2 = (r1 != 0 and r2 != 0) ? (d2close - lowest(d2low, length)) / r2 : 50
            //d = s1 - s2
            //r11 = calc_range(d, d, length)
            //sv = r11 != 0 ? 100 * (d - lowest(d, length)) / r11 : 50

            //plot(sv, title = "Stress", color = red, linewidth = 2)
            //plot(s1 * 100, title = "D1 Stoch", color = green)
            //plot(s2 * 100, title = "D2 Stoch", color = blue)
            //plot(oblvl, title = "OverBought", style = 3, color = red)
            //plot(oslvl, title = "OverSold", color = green, style = 3)
            //plot(normlvl, title = "Normal", color = gray, style = 3)
            List<decimal> svList = new();
            List<decimal> r1List = new();
            List<decimal> r2List = new();
            List<decimal> s1List = new();
            List<decimal> s2List = new();
            List<decimal> dList = new();
            List<decimal> highestDList = new();
            List<decimal> lowestDList = new();
            List<decimal> r11List = new();
            List<Signal> signalsList = new();

            try
            {
                if (stockDataClass.InputValues.Count == marketDataClass.InputValues.Count)
                {
                    var list1 = VolumeInputCheck(stockDataClass, days, true);
                    var highest1List = list1.Item1;
                    var lowest1List = list1.Item2;
                    var list2 = VolumeInputCheck(marketDataClass, days, true);
                    var highest2List = list2.Item1;
                    var lowest2List = list2.Item2;

                    for (int i = 0; i < stockDataClass.HighPrices.Count; i++)
                    {
                        decimal highestHigh1 = highest1List.ElementAtOrDefault(i);
                        decimal lowestLow1 = lowest1List.ElementAtOrDefault(i);
                        decimal highestHigh2 = highest2List.ElementAtOrDefault(i);
                        decimal lowestLow2 = lowest2List.ElementAtOrDefault(i);
                        decimal currentValue1 = stockDataClass.InputValues.ElementAtOrDefault(i);
                        decimal currentValue2 = marketDataClass.InputValues.ElementAtOrDefault(i);
                        decimal prevSv1 = i >= 1 ? svList.ElementAtOrDefault(i - 1) : 0;
                        decimal prevSv2 = i >= 2 ? svList.ElementAtOrDefault(i - 2) : 0;

                        decimal r1 = highestHigh1 - lowestLow1;
                        r1List.Add(r1);

                        decimal r2 = highestHigh2 - lowestLow2;
                        r2List.Add(r2);

                        decimal s1 = r1 != 0 ? (currentValue1 - lowestLow1) / r1 : 50;
                        s1List.Add(s1);

                        decimal s2 = r2 != 0 ? (currentValue2 - lowestLow2) / r2 : 50;
                        s2List.Add(s2);

                        decimal d = s1 - s2;
                        dList.Add(d);

                        var list = dList.TakeLast(days).ToList();
                        decimal highestD = list.Max();
                        highestDList.Add(highestD);

                        decimal lowestD = list.Min();
                        lowestDList.Add(lowestD);

                        decimal r11 = highestD - lowestD;
                        r11List.Add(r11);

                        decimal sv = r11 != 0 ? MinOrMax(100 * (d - lowestD) / r11, 100, 0) : 50;
                        svList.Add(sv);

                        var signal = GetRsiSignal(sv - prevSv1, prevSv1 - prevSv2, sv, prevSv1, 90, 10);
                        signalsList.Add(signal);
                    }
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (r1List, r2List, s1List, s2List, dList, highestDList, lowestDList, r11List, svList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateHawkeyeVolumeIndicator(StockData stockDataClass, int days = 200)
        {
            //
            // @author LazyBear
            // If you use this code, in its original or modified form, do drop me a note. Thx. 
            // 
            //study("HawkEye Volume Indicator [LazyBear]", shorttitle = "HVI_LB")
            //length = input(200)
            //range = high - low
            //rangeAvg = sma(range, length)

            //volumeA = sma(volume, length)
            //divisor = input(3.6)

            //high1 = high[1]
            //low1 = low[1]
            //mid1 = hl2[1]

            //u1 = mid1 + (high1 - low1) / divisor
            //d1 = mid1 - (high1 - low1) / divisor

            //r_enabled1 = (range > rangeAvg) and(close < d1) and volume > volumeA
            //r_enabled2 = close < mid1
            //r_enabled = r_enabled1 or r_enabled2

            //g_enabled1 = close > mid1
            //g_enabled2 = (range > rangeAvg) and(close > u1) and(volume > volumeA)
            //g_enabled3 = (high > high1) and(range < rangeAvg / 1.5) and(volume < volumeA)
            //g_enabled4 = (low < low1) and(range < rangeAvg / 1.5) and(volume > volumeA)
            //g_enabled = g_enabled1 or g_enabled2 or g_enabled3 or g_enabled4

            //gr_enabled1 = (range > rangeAvg) and(close > d1) and(close < u1) and(volume > volumeA) and(volume < volumeA * 1.5) and(volume > volume[1])
            //gr_enabled2 = (range < rangeAvg / 1.5) and(volume < volumeA / 1.5)
            //gr_enabled3 = (close > d1) and(close < u1)
            //gr_enabled = gr_enabled1 or gr_enabled2 or gr_enabled3

            //v_color = gr_enabled ? gray : g_enabled ? green : r_enabled ? red : blue
            //plot(volume, style = histogram, color = v_color, linewidth = 5)
            decimal divisor = 3.6m;
            List<decimal> tempRangeList = new();
            List<decimal> tempVolumeList = new();
            List<decimal> u1List = new();
            List<decimal> d1List = new();
            List<Signal> signalsList = new();

            try
            {
                var medianPriceList = CalculateMedianPrice(stockDataClass).Item2;

                for (int i = 0; i < stockDataClass.HighPrices.Count; i++)
                {
                    decimal currentHigh = stockDataClass.HighPrices.ElementAtOrDefault(i);
                    decimal currentLow = stockDataClass.LowPrices.ElementAtOrDefault(i);
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);

                    decimal currentVolume = stockDataClass.Volumes.ElementAtOrDefault(i);
                    tempVolumeList.Add(currentVolume);

                    decimal range = currentHigh - currentLow;
                    tempRangeList.Add(range);

                    decimal volumeSma = tempVolumeList.TakeLast(days).Average();
                    decimal rangeSma = tempRangeList.TakeLast(days).Average();
                    decimal prevHigh = i >= 1 ? stockDataClass.HighPrices.ElementAtOrDefault(i - 1) : 0;
                    decimal prevLow = i >= 1 ? stockDataClass.LowPrices.ElementAtOrDefault(i - 1) : 0;
                    decimal prevMidpoint = i >= 1 ? medianPriceList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevVolume = i >= 1 ? stockDataClass.Volumes.ElementAtOrDefault(i - 1) : 0;

                    decimal u1 = divisor != 0 ? prevMidpoint + ((prevHigh - prevLow) / divisor) : prevMidpoint;
                    u1List.Add(u1);

                    decimal d1 = divisor != 0 ? prevMidpoint - ((prevHigh - prevLow) / divisor) : prevMidpoint;
                    d1List.Add(d1);

                    bool rEnabled1 = range > rangeSma && currentValue < d1 && currentVolume > volumeSma;
                    bool rEnabled2 = currentValue < prevMidpoint;
                    bool rEnabled = rEnabled1 || rEnabled2;

                    bool gEnabled1 = currentValue > prevMidpoint;
                    bool gEnabled2 = range > rangeSma && currentValue > u1 && currentVolume > volumeSma;
                    bool gEnabled3 = currentHigh > prevHigh && range < rangeSma / 1.5m && currentVolume < volumeSma;
                    bool gEnabled4 = currentLow < prevLow && range < rangeSma / 1.5m && currentVolume > volumeSma;
                    bool gEnabled = gEnabled1 || gEnabled2 || gEnabled3 || gEnabled4;

                    bool grEnabled1 = range > rangeSma && currentValue > d1 && currentValue < u1 && currentVolume > volumeSma && currentVolume < volumeSma * 1.5m && currentVolume > prevVolume;
                    bool grEnabled2 = range < rangeSma / 1.5m && currentVolume < volumeSma / 1.5m;
                    bool grEnabled3 = currentValue > d1 && currentValue < u1;
                    bool grEnabled = grEnabled1 || grEnabled2 || grEnabled3;

                    var signal = GetConditionSignal(gEnabled, rEnabled);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (u1List, d1List, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateNickRypockTrailingReverse(StockData stockDataClass, int days = 2)
        {
            //@version=4
            // Copyright (c) 2021-present, Alex Orekhov (everget)
            //study("Nick Rypock Trailing Reverse", shorttitle = "NRTR", overlay = true)

            //k = input(title = "Coefficient of Correction, %", type = input.float, minval = 0, maxval = 100, step = 0.1, defval = 2)
            //showLabels = input(title = "Show Buy/Sell Labels ?", type = input.bool, defval = true)
            //applyRibbon = input(title = "Apply Ribbon ?", type = input.bool, defval = true)

            //var int trend = 0
            //var float hp = close
            //var float lp = close
            //float nrtr = close

            //percentage = k * 0.01

            //if trend >= 0
            //    if close > hp
            //        hp:= close
            //        hp
            //    nrtr := hp * (1 - percentage)
            //    if close <= nrtr
            //
            //        trend:= -1
            //
            //        lp:= close
            //        nrtr:= lp * (1 + percentage)
            //        nrtr
            //else
            //    if close < lp
            //
            //        lp:= close
            //        lp
            //    nrtr := lp * (1 + percentage)
            //    if close > nrtr
            //
            //        trend:= 1
            //        hp:= close
            //
            //        nrtr:= hp * (1 - percentage)
            //        nrtr

            //var color longColor = color.green
            //var color shortColor = color.red
            //var color textColor = color.white

            //longStopPlot = plot(trend == 1 ? nrtr : na, title = "Long Stop", style = plot.style_linebr, linewidth = 2, color = longColor)
            //buySignal = trend == 1 and trend[1] == -1
            //plotshape(buySignal ? nrtr : na, title = "Long Stop Start", location = location.absolute, style = shape.circle, size = size.tiny, color = longColor, transp = 0)
            //plotshape(buySignal and showLabels ? nrtr : na, title = "Buy Label", text = "Buy", location = location.absolute, style = shape.labelup, size = size.tiny, color = longColor, textcolor = textColor, transp = 0)

            //shortStopPlot = plot(trend == 1 ? na : nrtr, title = "Short Stop", style = plot.style_linebr, linewidth = 2, color = shortColor)
            //sellSignal = trend == -1 and trend[1] == 1
            //plotshape(sellSignal ? nrtr : na, title = "Short Stop Start", location = location.absolute, style = shape.circle, size = size.tiny, color = shortColor, transp = 0)
            //plotshape(sellSignal and showLabels ? nrtr : na, title = "Sell Label", text = "Sell", location = location.absolute, style = shape.labeldown, size = size.tiny, color = shortColor, textcolor = textColor, transp = 0)

            //midPricePlot = plot(ohlc4, title = "", style = plot.style_circles, linewidth = 0, display = display.none, editable = false)

            //longFillColor = applyRibbon ? (trend == 1 ? longColor : na) : na
            //shortFillColor = applyRibbon ? (trend == -1 ? shortColor : na) : na
            //fill(midPricePlot, longStopPlot, title = "Long Ribbon", color = longFillColor)
            //fill(midPricePlot, shortStopPlot, title = "Short Ribbon", color = shortFillColor)

            //changeCond = trend != trend[1]
            //alertcondition(changeCond, title = "Alert: NRTR Direction Change", message = "NRTR has changed direction!")
            //alertcondition(buySignal, title = "Alert: NRTR Buy", message = "NRTR Buy!")
            //alertcondition(sellSignal, title = "Alert: NRTR Sell", message = "NRTR Sell!")
            List<decimal> nrtrList = new();
            List<decimal> hpList = new();
            List<decimal> lpList = new();
            List<decimal> trendList = new();
            List<Signal> signalsList = new();

            try
            {
                decimal pct = days * 0.01m;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevTrend = trendList.LastOrDefault();
                    decimal prevHp = hpList.LastOrDefault();
                    decimal prevLp = lpList.LastOrDefault();
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal prevNrtr = nrtrList.LastOrDefault();
                    decimal nrtr = 0, hp = 0, lp = 0, trend = 0;
                    if (prevTrend >= 0)
                    {
                        hp = currentValue > prevHp ? currentValue : prevHp;
                        nrtr = hp * (1 - pct);

                        if (currentValue <= nrtr)
                        {
                            trend = -1;
                            lp = currentValue;
                            nrtr = lp * (1 + pct);
                        }
                    }
                    else
                    {
                        lp = currentValue < prevLp ? currentValue : prevLp;
                        nrtr = lp * (1 + pct);

                        if (currentValue > nrtr)
                        {
                            trend = 1;
                            hp = currentValue;
                            nrtr = hp * (1 - pct);
                        }
                    }
                    trendList.Add(trend);
                    hpList.Add(hp);
                    lpList.Add(lp);
                    nrtrList.Add(nrtr);

                    var signal = GetCompareSignal(currentValue - nrtr, prevValue - prevNrtr);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (hpList, lpList, nrtrList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateHalfTrend(StockData stockDataClass, string maType, int days = 2)
        {
            //@version=4
            // Copyright (c) 2021-present, Alex Orekhov (everget)
            //study("HalfTrend", overlay = true)

            //amplitude = input(title = "Amplitude", defval = 2)
            //channelDeviation = input(title = "Channel Deviation", defval = 2)
            //showArrows = input(title = "Show Arrows", defval = true)
            //showChannels = input(title = "Show Channels", defval = true)

            //var int trend = 0
            //var int nextTrend = 0
            //var float maxLowPrice = nz(low[1], low)
            //var float minHighPrice = nz(high[1], high)

            //var float up = 0.0
            //var float down = 0.0
            //float atrHigh = 0.0
            //float atrLow = 0.0
            //float arrowUp = na
            //float arrowDown = na

            //atr2 = atr(100) / 2
            //dev = channelDeviation * atr2

            //highPrice = high[abs(highestbars(amplitude))]
            //lowPrice = low[abs(lowestbars(amplitude))]
            //highma = sma(high, amplitude)
            //lowma = sma(low, amplitude)

            //if nextTrend == 1
            //    maxLowPrice:= max(lowPrice, maxLowPrice)
            //    if highma < maxLowPrice and close<nz(low[1], low)
            //        trend:= 1
            //        nextTrend:= 0
            //        minHighPrice:= highPrice
            //else
            //            minHighPrice:= min(highPrice, minHighPrice)
            //    if lowma > minHighPrice and close > nz(high[1], high)
            //        trend:= 0
            //        nextTrend:= 1
            //        maxLowPrice:= lowPrice
            //if trend == 0
            //    if not na(trend[1]) and trend[1] != 0
            //        up:= na(down[1]) ? down : down[1]
            //        arrowUp:= up - atr2
            //    else
            //            up:= na(up[1]) ? maxLowPrice : max(maxLowPrice, up[1])
            //    atrHigh:= up + dev
            //    atrLow:= up - dev
            //else
            //    if not na(trend[1]) and trend[1] != 1
            //        down:= na(up[1]) ? up : up[1]
            //        arrowDown:= down + atr2
            //    else
            //            down:= na(down[1]) ? minHighPrice : min(minHighPrice, down[1])
            //    atrHigh:= down + dev
            //    atrLow:= down - dev

            //ht = trend == 0 ? up : down

            //var color buyColor = color.blue
            //var color sellColor = color.red

            //htColor = trend == 0 ? buyColor : sellColor
            //htPlot = plot(ht, title = "HalfTrend", linewidth = 2, color = htColor)

            //atrHighPlot = plot(showChannels ? atrHigh : na, title = "ATR High", style = plot.style_circles, color = sellColor)
            //atrLowPlot = plot(showChannels ? atrLow : na, title = "ATR Low", style = plot.style_circles, color = buyColor)

            //fill(htPlot, atrHighPlot, title = "ATR High Ribbon", color = sellColor)
            //fill(htPlot, atrLowPlot, title = "ATR Low Ribbon", color = buyColor)

            //buySignal = not na(arrowUp) and(trend == 0 and trend[1] == 1)
            //sellSignal = not na(arrowDown) and(trend == 1 and trend[1] == 0)

            //plotshape(showArrows and buySignal ? atrLow : na, title = "Arrow Up", style = shape.triangleup, location = location.absolute, size = size.tiny, color = buyColor)
            //plotshape(showArrows and sellSignal ? atrHigh : na, title = "Arrow Down", style = shape.triangledown, location = location.absolute, size = size.tiny, color = sellColor)

            //alertcondition(buySignal, title = "Alert: HalfTrend Buy", message = "HalfTrend Buy")
            //alertcondition(sellSignal, title = "Alert: HalfTrend Sell", message = "HalfTrend Sell")
            List<decimal> trendList = new();
            List<decimal> nextTrendList = new();
            List<decimal> upList = new();
            List<decimal> downList = new();
            List<decimal> arrowUpList = new();
            List<decimal> arrowDownList = new();
            List<decimal> htList = new();
            List<decimal> atrHighList = new();
            List<decimal> atrLowList = new();
            List<Signal> signalsList = new();

            try
            {
                int atrLength = days * 50;

                var atrList = CalculateAverageTrueRange(stockDataClass, maType, atrLength).Item1;
                var minMaxList = VolumeInputCheck(stockDataClass, days, false);
                var highList = minMaxList.Item1;
                var lowList = minMaxList.Item2;
                var minMaxList2 = GetMaxAndMinValuesList(highList, lowList, days);
                var highestList = minMaxList2.Item1;
                var lowestList = minMaxList2.Item2;
                var highMaList = GetMovingAverageList(maType, highList, stockDataClass, days);
                var lowMaList = GetMovingAverageList(maType, lowList, stockDataClass, days);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal currentAvgTrueRange = atrList.ElementAtOrDefault(i);
                    decimal highestHigh = highestList.ElementAtOrDefault(i);
                    decimal lowestLow = lowestList.ElementAtOrDefault(i);
                    decimal high = highList.ElementAtOrDefault(i);
                    decimal low = lowList.ElementAtOrDefault(i);
                    decimal prevHigh = i >= 1 ? highList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevLow = i >= 1 ? lowList.ElementAtOrDefault(i - 1) : 0;
                    decimal highMa = highMaList.ElementAtOrDefault(i);
                    decimal lowMa = lowMaList.ElementAtOrDefault(i);
                    decimal maxLow = i >= 1 ? prevLow : low;
                    decimal minHigh = i >= 1 ? prevHigh : high;
                    decimal prevNextTrend = nextTrendList.LastOrDefault();
                    decimal prevTrend = trendList.LastOrDefault();
                    decimal prevUp = upList.LastOrDefault();
                    decimal prevDown = downList.LastOrDefault();
                    decimal atr = currentAvgTrueRange / 2;
                    decimal dev = days * atr;

                    decimal trend = 0, nextTrend = 0;
                    if (prevNextTrend == 1)
                    {
                        maxLow = Math.Max(low, maxLow);

                        if (highMa < maxLow && currentValue < (prevLow != 0 ? prevLow : low))
                        {
                            trend = 1;
                            nextTrend = 0;
                            minHigh = high;
                        }
                        else
                        {
                            minHigh = Math.Min(high, minHigh);

                            if (lowMa > minHigh && currentValue > (prevHigh != 0 ? prevHigh : high))
                            {
                                trend = 0;
                                nextTrend = 1;
                                maxLow = low;
                            }
                        }
                    }
                    trendList.Add(trend);
                    nextTrendList.Add(nextTrend);

                    decimal up = 0, down = 0, atrHigh = 0, atrLow = 0, arrowUp = 0, arrowDown = 0;
                    if (trend == 0)
                    {
                        if (prevTrend != 0)
                        {
                            up = prevDown;
                            arrowUp = up - atr;
                        }
                        else
                        {
                            up = Math.Max(maxLow, prevUp);
                        }

                        atrHigh = up + dev;
                        atrLow = up - dev;
                    }
                    else
                    {
                        if (prevTrend != 1)
                        {
                            down = prevUp;
                            arrowDown = down + atr;
                        }
                        else
                        {
                            down = Math.Min(minHigh, prevDown);
                        }

                        atrHigh = down + dev;
                        atrLow = down - dev;
                    }
                    upList.Add(up);
                    downList.Add(down);
                    atrHighList.Add(atrHigh);
                    atrLowList.Add(atrLow);
                    arrowUpList.Add(arrowUp);
                    arrowDownList.Add(arrowDown);

                    decimal ht = trend == 0 ? up : down;
                    htList.Add(ht);

                    var signal = GetConditionSignal(arrowUp != 0 && trend == 0 && prevTrend == 1, arrowDown != 0 && trend == 1 && prevTrend == 0);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (upList, downList, atrHighList, atrLowList, arrowUpList, arrowDownList, htList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateChandelierExit(StockData stockDataClass, string maType, int days = 22)
        {
            //Chandelier Exit (long) = 22-day High - ATR(22) x 3 
            //Chandelier Exit(short) = 22 - day Low + ATR(22) x 3
            List<decimal> chandelierExitLongList = new();
            List<decimal> chandelierExitShortList = new();
            List<Signal> signalsList = new();
            int mult = 3;

            try
            {
                var atrList = CalculateAverageTrueRange(stockDataClass, maType, days).Item1;
                var minMaxList = VolumeInputCheck(stockDataClass, days, true);
                var highestHighList = minMaxList.Item1;
                var lowestLowList = minMaxList.Item2;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal currentAvgTrueRange = atrList.ElementAtOrDefault(i);
                    decimal highestHigh = highestHighList.ElementAtOrDefault(i);
                    decimal lowestLow = lowestLowList.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal prevExitLong = chandelierExitLongList.LastOrDefault();
                    decimal chandelierExitLong = highestHigh - (currentAvgTrueRange * mult);
                    chandelierExitLongList.Add(chandelierExitLong);

                    decimal prevExitShort = chandelierExitShortList.LastOrDefault();
                    decimal chandelierExitShort = lowestLow + (currentAvgTrueRange * mult);
                    chandelierExitShortList.Add(chandelierExitShort);

                    var signal = GetBullishBearishSignal(currentValue - chandelierExitLong, prevValue - prevExitLong, currentValue - chandelierExitShort, prevValue - prevExitShort);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (chandelierExitLongList, chandelierExitShortList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateDynamicSupportAndResistance(StockData stockDataClass, string maType, int days = 25)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Dynamic Support And Resistance [CC] script may be freely distributed under the MIT license.
            //study("Dynamic Support And Resistance [CC]", shorttitle = "DSR", overlay = true)

            //f_security(_symbol, _res, _src, _repaint) => 
            //    security(_symbol, _res, _src[_repaint ? 0 : barstate.isrealtime ? 1 : 0])[_repaint ? 0 : barstate.isrealtime ? 0 : 1]

            //length = input(title = "Length", type = input.integer, defval = 25, minval = 1)
            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //h = f_security(syminfo.tickerid, res, high, rep)
            //l = f_security(syminfo.tickerid, res, low, rep)
            //c = f_security(syminfo.tickerid, res, close, rep)

            //hh = highest(h, length)
            //ll = lowest(l, length)
            //atr = atr(length)
            //mult = sqrt(length)

            //dSup = hh - (atr * mult)
            //dRes = ll + (atr * mult)
            //dMid = (dSup + dRes) / 2

            //sig = c > dMid ? 1 : c < dMid ? -1 : 0
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //dsrColor = sig > 0 ? color.green : sig < 0 ? color.red : color.black
            //barcolor(bar ? dsrColor : na)
            //plot(dSup, title = "Support", color = color.red, linewidth = 2)
            //plot(dMid, title = "Middle", color = color.black, linewidth = 1)
            //plot(dRes, title = "Resistance", color = color.green, linewidth = 2)
            List<decimal> supportList = new();
            List<decimal> resistanceList = new();
            List<decimal> middleList = new();
            List<Signal> signalsList = new();

            try
            {
                decimal mult = Sqrt((double)days);

                var atrList = CalculateAverageTrueRange(stockDataClass, maType, days).Item1;
                var minMaxList = VolumeInputCheck(stockDataClass, days, true);
                var highestHighList = minMaxList.Item1;
                var lowestLowList = minMaxList.Item2;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal currentAvgTrueRange = atrList.ElementAtOrDefault(i);
                    decimal highestHigh = highestHighList.ElementAtOrDefault(i);
                    decimal lowestLow = lowestLowList.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal support = highestHigh - (currentAvgTrueRange * mult);
                    supportList.Add(support);

                    decimal resistance = lowestLow + (currentAvgTrueRange * mult);
                    resistanceList.Add(resistance);

                    decimal prevMiddle = middleList.LastOrDefault();
                    decimal middle = (support + resistance) / 2;
                    middleList.Add(middle);

                    var signal = GetCompareSignal(currentValue - middle, prevValue - prevMiddle);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (supportList, resistanceList, middleList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateProjectedSupportAndResistance(StockData stockDataClass, int days = 25)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Projected Support And Resistance [CC] script may be freely distributed under the MIT license.
            //study("Projected Support And Resistance [CC]", shorttitle = "PSR", overlay = true)

            //f_security(_symbol, _res, _src, _repaint) => 
            //    security(_symbol, _res, _src[_repaint ? 0 : barstate.isrealtime ? 1 : 0])[_repaint ? 0 : barstate.isrealtime ? 0 : 1]

            //length = input(title = "Length", type = input.integer, defval = 25, minval = 1)
            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //h = f_security(syminfo.tickerid, res, high, rep)
            //l = f_security(syminfo.tickerid, res, low, rep)
            //c = f_security(syminfo.tickerid, res, close, rep)

            //hh = highest(h, length)
            //ll = lowest(l, length)
            //range = hh - ll

            //sup1 = ll - (0.25 * range)
            //sup2 = ll - (0.5 * range)
            //res1 = hh + (0.25 * range)
            //res2 = hh + (0.5 * range)
            //mid = (sup1 + sup2 + res1 + res2) / 4

            //sig = c > mid ? 1 : c < mid ? -1 : 0
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //psrColor = sig > 0 ? color.green : sig < 0 ? color.red : color.black
            //barcolor(bar ? psrColor : na)
            //plot(sup1, title = "Support1", color = color.red, linewidth = 2)
            //plot(sup2, title = "Support2", color = color.red, linewidth = 2)
            //plot(mid, title = "Middle", color = color.black, linewidth = 1)
            //plot(res1, title = "Resistance1", color = color.green, linewidth = 2)
            //plot(res2, title = "Resistance2", color = color.green, linewidth = 2)
            List<decimal> support1List = new();
            List<decimal> resistance1List = new();
            List<decimal> support2List = new();
            List<decimal> resistance2List = new();
            List<decimal> middleList = new();
            List<Signal> signalsList = new();

            try
            {
                var minMaxList = VolumeInputCheck(stockDataClass, days, true);
                var highestHighList = minMaxList.Item1;
                var lowestLowList = minMaxList.Item2;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal highestHigh = highestHighList.ElementAtOrDefault(i);
                    decimal lowestLow = lowestLowList.ElementAtOrDefault(i);
                    decimal range = highestHigh - lowestLow;
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal support1 = lowestLow - (0.25m * range);
                    support1List.Add(support1);

                    decimal support2 = lowestLow - (0.5m * range);
                    support2List.Add(support2);

                    decimal resistance1 = highestHigh + (0.25m * range);
                    resistance1List.Add(resistance1);

                    decimal resistance2 = highestHigh + (0.5m * range);
                    resistance2List.Add(resistance2);

                    decimal prevMiddle = middleList.LastOrDefault();
                    decimal middle = (support1 + support2 + resistance1 + resistance2) / 4;
                    middleList.Add(middle);

                    var signal = GetCompareSignal(currentValue - middle, prevValue - prevMiddle);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (support1List, support2List, resistance1List, resistance2List, middleList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateElderSafeZoneStops(StockData stockDataClass, int days = 3)
        {
            //position = pos, user defined, default is long
            //input = price, user defined, default is close
            //method = moving average (ma), user defined, default is EMA
            //period1 = p1, user defined, default is 63
            //period2 = p2, user defined, default is 22
            //period3 = p3, user defined, default is 3
            //look back = lb, user defined, default is 5
            //factor = fac, user defined, default is 2.5
            //show entry = showE, user defined boolean, default is false
            //index = current bar number, prev = previous
            //LOE = less or equal, MOE = more or equal
            //shortP = short position, longP = long position

            //ma = ma(method, index, p1, input);
            //prevP = price[index - 1];
            //upTrend = price moreThan ma;
            //dnTrend = price lessThan ma;
            //longP = pos == "Long";
            //shortP = pos == "Short";
            //dmPlus = 0;
            //dmMinus = 0;
            //dmAv = 0;
            //safeZ = 0.0;
            //countP = 0, countM = 0;
            //for (i = index - (p2 + 1); i LOE index; i++) {
            //ihigh = high[i];
            //prevH = high[i - 1];
            //ilow = low[i];
            //prevL = low[i - 1];
            //if (prevL moreThan low) countM++; dmMinus = dmMinus + (prevL - low);
            //if (high moreThan prevH) countP++; dmPlus = dmPlus + (high - prevH);
            //endFor
            //if (upTrend AND countM != 0)
            //dmAv = dmMinus / countM;
            //safeZ = prevL - fac * dmAv;
            //safeZ = highest(p3, SAFEZ);
            //if (dnTrend AND countP != 0)
            //dmAv = dmPlus / countP;
            //safeZ = prevH + fac * dmAv;
            //safeZ = lowest(p3, SAFEZ);
            //endIf
            //Signals
            //lowFive = false;
            //for (i = -(lb - 1); i lessOr = 0; i++)
            //cLow = low[index + i];
            //pLow = low[index + i - 1];
            //cMa = MA[index + i];
            //pMa = MA[index + i - 1];
            //lowFive = (cLow lessThan pLow AND cLow lessThan cMa AND pLow lessThan pMa);
            //if (!lowFive) break;
            //endFor
            //highFive = false;
            //for (i = -(lb - 1); i LOE 0; i++)
            //cHigh = high[index + i];
            //pHigh high[index + i - 1];
            //cMa = MA[index + i];
            //pMa = MA[index + i - 1];
            //highFive = (cHigh moreThan pHigh AND cHigh moreThan cMa AND pHigh moreThan pMa);
            //if (!highFive) break;
            //endFor
            //sell = false, buy = false;
            //if (safeZ != 0)
            //{
            //    if (longP AND upTrend)
            //    sell = prevP moreThan safeZ AND price lessThan safeZ;  //sell to exit
            //    buy = highFive AND showE;  //buy
            //    endIf
            //    if (shortP AND dnTrend) {
            //    sell = lowFive AND showE;   //sell short
            //    buy = prevP lessThan safeZ AND price moreThan safeZ;  //buy to cover
            //    endIf
            //    endIf
            decimal factor = 2.5m;
            List<decimal> dmAvgPlusList = new();
            List<decimal> dmAvgMinusList = new();
            List<decimal> safeZPlusList = new();
            List<decimal> safeZMinusList = new();
            List<decimal> highestList = new();
            List<decimal> lowestList = new();
            List<decimal> dmPlusCountList = new();
            List<decimal> dmMinusCountList = new();
            List<decimal> dmMinusList = new();
            List<decimal> dmPlusList = new();
            List<decimal> stopList = new();
            List<Signal> signalsList = new();

            try
            {
                int p1 = (int)Math.Ceiling(days / 0.0477);
                int p2 = (int)Math.Ceiling(days / 0.1364);
                int p3 = days;

                List<decimal> emaList = CalculateExponentialMovingAverage(stockDataClass, p1).Item1;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal currentLow = stockDataClass.LowPrices.ElementAtOrDefault(i);
                    decimal currentHigh = stockDataClass.HighPrices.ElementAtOrDefault(i);
                    decimal currentEma = emaList.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevHigh = i >= 1 ? stockDataClass.HighPrices.ElementAtOrDefault(i - 1) : 0;
                    decimal prevLow = i >= 1 ? stockDataClass.LowPrices.ElementAtOrDefault(i - 1) : 0;
                    decimal prevEma = i >= 1 ? emaList.ElementAtOrDefault(i - 1) : 0;

                    decimal dmMinus = prevLow > currentLow ? prevLow - currentLow : 0;
                    dmMinusList.Add(dmMinus);

                    decimal dmMinusCount = prevLow > currentLow ? 1 : 0;
                    dmMinusCountList.Add(dmMinusCount);

                    decimal dmPlus = currentHigh > prevHigh ? currentHigh - prevHigh : 0;
                    dmPlusList.Add(dmPlus);

                    decimal dmPlusCount = currentHigh > prevHigh ? 1 : 0;
                    dmPlusCountList.Add(dmPlusCount);

                    decimal countM = dmMinusCountList.TakeLast(p2).Sum();
                    decimal dmMinusSum = dmMinusList.TakeLast(p2).Sum();
                    decimal dmAvgMinus = countM != 0 ? dmMinusSum / countM : 0;
                    dmAvgMinusList.Add(dmAvgMinus);

                    decimal safeZMinus = prevLow - (factor * dmAvgMinus);
                    safeZMinusList.Add(safeZMinus);

                    decimal highest = safeZMinusList.TakeLast(p3).Max();
                    highestList.Add(highest);

                    decimal countP = dmPlusCountList.TakeLast(p2).Sum();
                    decimal dmPlusSum = dmPlusList.TakeLast(p2).Sum();
                    decimal dmAvgPlus = countP != 0 ? dmPlusSum / countP : 0;
                    dmAvgPlusList.Add(dmAvgPlus);

                    decimal safeZPlus = prevHigh + (factor * dmAvgPlus);
                    safeZPlusList.Add(safeZPlus);

                    decimal lowest = safeZPlusList.TakeLast(p3).Min();
                    lowestList.Add(lowest);

                    decimal prevStop = stopList.LastOrDefault();
                    decimal stop = currentValue >= currentEma ? highest : lowest;
                    stopList.Add(stop);

                    var signal = GetBullishBearishSignal(currentValue - Math.Max(currentEma, stop), prevValue - Math.Max(prevEma, prevStop),
                        currentValue - Math.Min(currentEma, stop), prevValue - Math.Min(prevEma, prevStop));
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (dmAvgMinusList, safeZMinusList, dmAvgPlusList, safeZPlusList, highestList, lowestList, stopList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculatePercentageTrailingStops(StockData stockDataClass, int days = 10)
        {
            //position = pos, user defined, default is long
            //Index = index number, user defined, default is 100
            //show index = showI, user defined, default is false
            //percent factor = pct, user defined, default is 10
            //enterP = entry price
            //index = current bar number, prev = previous
            //shortP = short position, longP = long position

            //longP = pos == "Long";
            //shortP = pos == "Short";
            //pct = pct / 100;  //change from percent to decimal
            //highest = 0, lowest = 0;
            //enterP = CLOSE;
            //enterP = round(enterP, 2);
            //if (index == ind)
            //if (longP)
            //hhLl[index - 1] = enterP;
            //stop[index - 1] = high - (pct * high);
            //endIf
            //if (shortP)
            //hhLl[index - 1] = enterP;
            //stop[index - 1] = low + (pct * low);
            //endIf
            //endIf
            //prevHH = ifNull(enterP, hhLl[index - 1]);
            //prevLL = ifNull(enterP, hhLl[index - 1]);
            //pSl = ifNull(enterP, stop[index - 1]);
            //pSS = ifNull(enterP, stop[index - 1]);
            //stopL = 0;
            //stopS = max_value;
            //if (longP)
            //stopL = pSL;
            //highest = prevHH;
            //if (high moreThan prevHH)
            //stopL = high - (pct * high);  //set new higher stop
            //highest = high;  //set new highest
            //endIf
            //hhLl = highest;
            //stop = stopL;
            //endIf
            //if (shortP)
            //stopS = pSS;
            //lowest = prevLL;
            //if (low lessThan prevLL)
            //stopS = low + (pct * low);  //set new lower stop
            //lowest = low; //set new lowest
            //endIf
            //hhLl = lowest;
            //stop = stopS;
            //endIf
            //Signals
            //prevL = low[index - 1];
            //prevH = high[index - 1];
            //sell = prevL moreThan stopL AND low lessThan stopL;
            //buy = prevH lessThan stopS AND high moreThan stopS;
            List<decimal> highestList = new();
            List<decimal> lowestList = new();
            List<decimal> stopSList = new();
            List<decimal> stopLList = new();
            List<Signal> signalsList = new();

            try
            {
                decimal pct = (decimal)days / 100;

                for (int i = 0; i < stockDataClass.HighPrices.Count; i++)
                {
                    decimal currentHigh = stockDataClass.HighPrices.ElementAtOrDefault(i);
                    decimal currentLow = stockDataClass.LowPrices.ElementAtOrDefault(i);
                    decimal currentClose = stockDataClass.ClosePrices.ElementAtOrDefault(i);
                    decimal prevHigh = i >= 1 ? stockDataClass.HighPrices.ElementAtOrDefault(i - 1) : 0;
                    decimal prevLow = i >= 1 ? stockDataClass.LowPrices.ElementAtOrDefault(i - 1) : 0;
                    decimal prevHH = i >= 1 ? highestList.LastOrDefault() : currentClose;
                    decimal prevLL = i >= 1 ? lowestList.LastOrDefault() : currentClose;
                    decimal pSS = i >= 1 ? stopSList.LastOrDefault() : currentClose;
                    decimal pSL = i >= 1 ? stopLList.LastOrDefault() : currentClose;

                    // long first
                    decimal stopL = currentHigh > prevHH ? currentHigh - (pct * currentHigh) : pSL;
                    stopLList.Add(stopL);

                    decimal highest = currentHigh > prevHH ? currentHigh : prevHH;
                    highestList.Add(highest);

                    // short now
                    decimal stopS = currentLow < prevLL ? currentLow + (pct * currentLow) : pSS;
                    stopSList.Add(stopS);

                    decimal lowest = currentLow < prevLL ? currentLow : prevLL;
                    lowestList.Add(lowest);

                    var signal = GetConditionSignal(prevHigh < stopS && currentHigh > stopS, prevLow > stopL && currentLow < stopL);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (stopLList, stopSList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>)
            CalculateDirectionalTrendIndex(StockData stockDataClass, string maType, int days = 5)
        {
            //method = moving average (ma) user defined, default is EMA
            //rPeriod = user defined, default is 14
            //sPeriod = user defined, default is 10
            //uPeriod = user defined, default is 5
            //prev = previous
            //LT = less than, MT = more than
            //abs = absolute value, index = current bar number

            //prevHigh = high[index - 1];
            //prevLow = low[index - 1];
            //hmu = 0;
            //if (high - prevHigh MT 0) hmu = high - prevHigh;
            //lmd = 0;
            //if (low - prevLow LT 0) lmd = -(low - prevLow);
            //diff = hmu - lmd;
            //absDiff = abs(diff);
            //ma1 = ma(method, index, rPeriod, diff);
            //aMa1 = ma(method, index, rPeriod, absDiff);
            //ma2 = ma(method, index, sPeriod, ma1);
            //aMa2 = ma(method, index, sPeriod, aMa1);
            //ma3 = ma(method, index, uPeriod, ma2);
            //aMa3 = ma(method, , index, uPeriod, aMa2);
            //Plot: dti = 100 * ma3 / aMa3;
            //Signals
            //prevDti = dti[index - 1];
            //highSell = dti for last sell signal, reset to max_negative at each  buy signal;
            //lowBuy = dti for last buy signal, reset to max_positive at each sell signal;
            //sell = (dti MT topGuide) AND(prevDti MT dti) AND(dti MT highSell); //peaked above topGuide
            //buy = (dti LT bottomGuide AND prevDti LT dti) AND(dti LT lowBuy);  //trough below bottomGuide
            List<decimal> dtiList = new();
            List<decimal> diffList = new();
            List<decimal> absDiffList = new();
            List<decimal> diffEma1List = new();
            List<decimal> absDiffEma1List = new();
            List<decimal> diffEma2List = new();
            List<decimal> absDiffEma2List = new();
            List<decimal> diffEma3List = new();
            List<decimal> absDiffEma3List = new();
            List<Signal> signalsList = new();

            try
            {
                int uPeriod = days;
                int sPeriod = MinOrMax(uPeriod * 2);
                int rPeriod = MinOrMax((int)Math.Ceiling(uPeriod / 0.357));

                for (int i = 0; i < stockDataClass.HighPrices.Count; i++)
                {
                    decimal currentHigh = stockDataClass.HighPrices.ElementAtOrDefault(i);
                    decimal currentLow = stockDataClass.LowPrices.ElementAtOrDefault(i);
                    decimal prevHigh = i >= 1 ? stockDataClass.HighPrices.ElementAtOrDefault(i - 1) : 0;
                    decimal prevLow = i >= 1 ? stockDataClass.LowPrices.ElementAtOrDefault(i - 1) : 0;
                    decimal hmu = currentHigh - prevHigh > 0 ? currentHigh - prevHigh : 0;
                    decimal lmd = currentLow - prevLow < 0 ? (currentLow - prevLow) * -1 : 0;

                    decimal diff = hmu - lmd;
                    diffList.Add(diff);

                    decimal absDiff = Math.Abs(diff);
                    absDiffList.Add(absDiff);
                }

                diffEma1List = GetMovingAverageList(maType, diffList, stockDataClass, rPeriod);
                absDiffEma1List = GetMovingAverageList(maType, absDiffList, stockDataClass, rPeriod);
                diffEma2List = GetMovingAverageList(maType, diffEma1List, stockDataClass, sPeriod);
                absDiffEma2List = GetMovingAverageList(maType, absDiffEma1List, stockDataClass, sPeriod);
                diffEma3List = GetMovingAverageList(maType, diffEma2List, stockDataClass, uPeriod);
                absDiffEma3List = GetMovingAverageList(maType, absDiffEma2List, stockDataClass, uPeriod);
                for (int j = 0; j < stockDataClass.HighPrices.Count; j++)
                {
                    decimal diffEma3 = diffEma3List.ElementAtOrDefault(j);
                    decimal absDiffEma3 = absDiffEma3List.ElementAtOrDefault(j);
                    decimal prevDti1 = j >= 1 ? dtiList.ElementAtOrDefault(j - 1) : 0;
                    decimal prevDti2 = j >= 2 ? dtiList.ElementAtOrDefault(j - 2) : 0;

                    decimal dti = absDiffEma3 != 0 ? MinOrMax(100 * diffEma3 / absDiffEma3, 100, -100) : 0;
                    dtiList.Add(dti);

                    var signal = GetRsiSignal(dti - prevDti1, prevDti1 - prevDti2, dti, prevDti1, 25, -25);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (diffList, absDiffList, diffEma1List, absDiffEma1List, diffEma2List, absDiffEma2List, diffEma3List, absDiffEma3List, dtiList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<decimal>, List<Signal>) CalculateDoubleSmoothedStochastic(StockData stockDataClass, string maType, int days = 2)
        {
            //input = price, user defined, default is closing price
            //method = moving average, user defined, default is EMA
            //kPeriod = user defined, default is 2
            //ssPeriod = user defined, default is 3
            //dsPeriod = user defined, default is 15
            //sdsPeriod = user defined, default is 3
            //num = numerator
            //den = denomator
            //ss = single smoothed
            //ds = decimal smoothed
            //dss = decimal smoothed stochastic
            //sdss = signal for decimal smoothed stochastic
            //index = current bar number

            //if (HighLow)
            //lowest = lowest(index, kPeriod, Low);
            //highest = highest(index, kPeriod, High);
            //else
            //lowest = lowest(index, kPeriod, input);
            //highest = highest(index, kPeriod, input);
            //end
            //num = input - lowest;
            //den = highest - lowest;
            //ssNum = ma(method, index, ssPeriod, num);
            //ssDen = ma(method, index, ssPeriod, den);
            //dsNum = ma(method, index, dsPeriod, ssNum);
            //dsDen = ma(method, index, dsPeriod, ssDen);
            //Plot1: DSS = 100 * dsNum / dsDen;
            //Plot2: SDSS = ma(method, index, sdsPeriod, DSS);
            //Signals
            //highSell = dss for last sell signal, reset to max_negative at each  buy signal;
            //lowBuy = dss for last buy signal, reset to max_positive at each sell signal;
            //sell = crossedBelow(DSS, SDSS) AND dss moreThan topGuide AND dss moreThan highSell;
            //buy = crossedAbove(DSS, SDSS) AND dss lessThan bottomGuide AND dss lessThan lowBuy;
            List<decimal> dssList = new();
            List<decimal> sdssList = new();
            List<decimal> numList = new();
            List<decimal> denomList = new();
            List<decimal> ssNumList = new();
            List<decimal> ssDenomList = new();
            List<decimal> dsNumList = new();
            List<decimal> dsDenomList = new();
            List<decimal> tempList = new();
            List<Signal> signalsList = new();

            try
            {
                int kPeriod = days;
                int ssPeriod = MinOrMax((int)Math.Ceiling(kPeriod / 0.6667));
                int sdsPeriod = ssPeriod;
                int dsPeriod = MinOrMax(ssPeriod * 5);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    tempList.Add(currentValue);

                    decimal highestHigh = tempList.TakeLast(kPeriod).Max();
                    decimal lowestLow = tempList.TakeLast(kPeriod).Min();

                    decimal num = currentValue - lowestLow;
                    numList.Add(num);

                    decimal denom = highestHigh - lowestLow;
                    denomList.Add(denom);
                }

                ssNumList = GetMovingAverageList(maType, numList, stockDataClass, ssPeriod);
                ssDenomList = GetMovingAverageList(maType, denomList, stockDataClass, ssPeriod);
                dsNumList = GetMovingAverageList(maType, ssNumList, stockDataClass, dsPeriod);
                dsDenomList = GetMovingAverageList(maType, ssDenomList, stockDataClass, dsPeriod);
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal dsNum = dsNumList.ElementAtOrDefault(j);
                    decimal dsDenom = dsDenomList.ElementAtOrDefault(j);

                    decimal dss = dsDenom != 0 ? MinOrMax(100 * dsNum / dsDenom, 100, 0) : 0;
                    dssList.Add(dss);
                }

                sdssList = GetMovingAverageList(maType, dssList, stockDataClass, sdsPeriod);
                for (int k = 0; k < stockDataClass.InputValues.Count; k++)
                {
                    decimal dss = dssList.ElementAtOrDefault(k);
                    decimal sdss = sdssList.ElementAtOrDefault(k);
                    decimal prevDss = k >= 1 ? dssList.ElementAtOrDefault(k - 1) : 0;
                    decimal prevSdss = k >= 1 ? sdssList.ElementAtOrDefault(k - 1) : 0;

                    var signal = GetRsiSignal(dss - sdss, prevDss - prevSdss, dss, prevDss, 70, 30);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (numList, denomList, ssNumList, ssDenomList, dsNumList, dsDenomList, dssList, sdssList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateTilsonIE2(StockData stockDataClass, string maType, int days = 15)
        {
            //input = price, user defined, default is close
            //method = moving average, user defined, default is SMA
            //period = user defined, default is 15
            //av = average
            //ma = moving average, index = current bar number
            //a and m are values in line equation y=a+mx.

            //avPrice = ma(method, index, period, input);
            //value[] = linRegLine(index, period, input, 0);
            //a = value[0];.
            //m = value[1] + avPrice;
            //Plot1: ie2 = (m + a) / 2;
            //Plot2: price;
            //Signals
            //buy = crossedAbove(IE2, price);
            //sell = crossedBelow(IE2, price);
            List<decimal> ie2List = new();
            List<decimal> mList = new();
            List<Signal> signalsList = new();

            try
            {
                List<decimal> smaList = GetMovingAverageList(maType, null, stockDataClass, days);
                var linRegList = CalculateLinearRegression(null, stockDataClass, days);
                List<decimal> regressionSlopeAList = linRegList.Item14;
                List<decimal> regressionSlopeMList = linRegList.Item11;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal sma = smaList.ElementAtOrDefault(i);
                    decimal a0 = regressionSlopeAList.ElementAtOrDefault(i);
                    decimal a1 = regressionSlopeMList.ElementAtOrDefault(i);
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal m = a1 + sma;
                    mList.Add(m);

                    decimal prevIe2 = ie2List.LastOrDefault();
                    decimal ie2 = (m + a0) / 2;
                    ie2List.Add(ie2);

                    var signal = GetCompareSignal(currentValue - ie2, prevValue - prevIe2);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (mList, ie2List, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateSupportResistance(StockData stockDataClass, string maType, int days = 20)
        {
            //high input = price, user defined, default is close
            //period = user defined, default is 20
            //prev = previous, sma = simple moving average
            //LT = less than, LOE = less or equal
            //MT = more than, MOE = more or equal
            //supp = support, res = resistance

            //prev = price[index - 1];
            //current = price[index];
            //sma = sma(index - 1, period, input);
            //crossAbove = (prev LT sma AND current MOE sma);
            //crossBelow = (prev MT sma AND current LOE sma);
            //res = res[index - 1];
            //supp = supp[index - 1];
            //if (crossBelow)
            // Calculate new resistance point
            //res = highest(index, period, HIGH);
            //end
            //if (crossAbove)
            // Calculate new support point
            //supp = lowest(index, period, LOW);
            //end
            //if (res == null)
            //res = highest(index, period, HIGH);
            //end
            //if (supp == null)
            //supp = lowest(index, period, LOW);
            //end
            List<decimal> resList = new();
            List<decimal> suppList = new();
            List<Signal> signalsList = new();

            try
            {
                var smaList = GetMovingAverageList(maType, null, stockDataClass, days);
                var minMaxList = VolumeInputCheck(stockDataClass, days, true);
                var highestHighList = minMaxList.Item1;
                var lowestLowList = minMaxList.Item2;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal currentHigh = stockDataClass.HighPrices.ElementAtOrDefault(i);
                    decimal currentLow = stockDataClass.LowPrices.ElementAtOrDefault(i);
                    decimal highest = highestHighList.ElementAtOrDefault(i);
                    decimal lowest = lowestLowList.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal sma = i >= 1 ? smaList.ElementAtOrDefault(i - 1) : 0;
                    bool crossAbove = prevValue < sma && currentValue >= sma;
                    bool crossBelow = prevValue > sma && currentValue <= sma;

                    decimal prevRes = resList.LastOrDefault();
                    decimal res = crossBelow ? highest : i >= 1 ? prevRes : highest;
                    resList.Add(res);

                    decimal prevSupp = suppList.LastOrDefault();
                    decimal supp = crossAbove ? lowest : i >= 1 ? prevSupp : lowest;
                    suppList.Add(supp);

                    var signal = GetBullishBearishSignal(currentValue - res, prevValue - prevRes, currentValue - supp, prevValue - prevSupp);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (suppList, resList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>)
            CalculateRainbowOscillator(StockData stockDataClass, string maType, int days = 2)
        {
            //REM RAINBOW OSCILLATOR
            //@version=2
            //by HPotter on platform Tradingview
            //adapted for the Prorealtime platform by bolsatrilera
            //  Copyright by HPotter v1.0 07/03/2018
            // Ever since the people concluded that stock market price movements are not
            // random or chaotic, but follow specific trends that can be forecasted, they
            // tried to develop different tools or procedures that could help them identify
            // those trends. And one of those financial indicators is the Rainbow Oscillator
            // Indicator. The Rainbow Oscillator Indicator is relatively new, originally
            // introduced in 1997, and it is used to forecast the changes of trend direction.
            //
            // As market prices go up and down, the oscillator appears as a direction of the
            // trend, but also as the safety of the market and the depth of that trend. As
            // the rainbow grows in width, the current trend gives signs of continuity, and
            // if the value of the oscillator goes beyond 80, the market becomes more and more
            // unstable, being prone to a sudden reversal. When prices move towards the rainbow
            // and the oscillator becomes more and more flat, the market tends to remain more
            // stable and the bandwidth decreases. Still, if the oscillator value goes below 20,
            // the market is again, prone to sudden reversals. The safest bandwidth value where
            // the market is stable is between 20 and 80, in the Rainbow Oscillator indicator value.
            // The depth a certain price has on a chart and into the rainbow can be used to judge
            // the strength of the move.
            ////////////////////////////////////////////////////////////

            //Length = 2
            //LengthHHLL = 10 //title="HHV/LLV Lookback")
            //xMA1 = Average[Length](close)
            //xMA2 = Average[Length](xMA1)
            //xMA3 = Average[Length](xMA2)
            //xMA4 = Average[Length](xMA3)
            //xMA5 = Average[Length](xMA4)
            //xMA6 = Average[Length](xMA5)
            //xMA7 = Average[Length](xMA6)
            //xMA8 = Average[Length](xMA7)
            //xMA9 = Average[Length](xMA8)
            //xMA10 = Average[Length](xMA9)
            //xHH = highest[LengthHHLL](close)
            //xLL = lowest[LengthHHLL](close)
            //xHHMAs = max(xMA1,max(xMA2,max(xMA3,max(xMA4,max(xMA5,max(xMA6,max(xMA7,max(xMA8,max(xMA9,xMA10)))))))))
            //xLLMAs = min(xMA1, min(xMA2, min(xMA3, min(xMA4, min(xMA5, min(xMA6, min(xMA7, min(xMA8, min(xMA9, xMA10)))))))))
            //xRBO = 100 * ((close - ((xMA1 + xMA2 + xMA3 + xMA4 + xMA5 + xMA6 + xMA7 + xMA8 + xMA9 + xMA10) / 10)) / (xHH - xLL))
            //xRB = 100 * ((xHHMAs - xLLMAs) / (xHH - xLL))
            //clr = iff(xRBO >= 0, green, red)
            //pos = iff(xRBO > 0, 1,
            //      iff(xRBO < 0, -1, nz(pos[1], 0)))
            //barcolor(pos == -1 ? red : pos == 1 ? green : blue)
            //plot(xRBO, color = clr, title = "RO", style = histogram, linewidth = 2)
            //p0 = plot(0, color = gray, title = "0")
            //p1 = plot(xRB, color = green, title = "RB")
            //p2 = plot(-xRB, color = red, title = "RB")
            //fill(p1, p0, color = green)
            //fill(p2, p0, color = red)
            //If RO is positive and the amplitude of RB when the movement starts is not very large(it is between 30 % and 60 %), we will say that the market is bullish.
            //If RO is negative and the amplitude of RB when the movement starts is not very big(it is between 30 % and 60 %), we will say that the market is bearish.
            List<decimal> r3List = new();
            List<decimal> r4List = new();
            List<decimal> r5List = new();
            List<decimal> r6List = new();
            List<decimal> r7List = new();
            List<decimal> r8List = new();
            List<decimal> r9List = new();
            List<decimal> r10List = new();
            List<decimal> highestRainbowList = new();
            List<decimal> lowestRainbowList = new();
            List<decimal> rainbowOscillatorList = new();
            List<decimal> rainbowList = new();
            List<Signal> signalsList = new();

            try
            {
                int hhLLLength = MinOrMax(days * 5);

                var minMaxList = VolumeInputCheck(stockDataClass, hhLLLength, true);
                var highestHighs = minMaxList.Item1;
                var lowestLows = minMaxList.Item2;

                var r1List = GetMovingAverageList(maType, null, stockDataClass, days);
                var r2List = GetMovingAverageList(maType, r1List, stockDataClass, days);
                r3List = GetMovingAverageList(maType, r2List, stockDataClass, days);
                r4List = GetMovingAverageList(maType, r3List, stockDataClass, days);
                r5List = GetMovingAverageList(maType, r4List, stockDataClass, days);
                r6List = GetMovingAverageList(maType, r5List, stockDataClass, days);
                r7List = GetMovingAverageList(maType, r6List, stockDataClass, days);
                r8List = GetMovingAverageList(maType, r7List, stockDataClass, days);
                r9List = GetMovingAverageList(maType, r8List, stockDataClass, days);
                r10List = GetMovingAverageList(maType, r9List, stockDataClass, days);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal highestHigh = highestHighs.ElementAtOrDefault(i);
                    decimal lowestLow = lowestLows.ElementAtOrDefault(i);
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal r1 = r1List.ElementAtOrDefault(i);
                    decimal r2 = r2List.ElementAtOrDefault(i);
                    decimal r3 = r3List.ElementAtOrDefault(i);
                    decimal r4 = r4List.ElementAtOrDefault(i);
                    decimal r5 = r5List.ElementAtOrDefault(i);
                    decimal r6 = r6List.ElementAtOrDefault(i);
                    decimal r7 = r7List.ElementAtOrDefault(i);
                    decimal r8 = r8List.ElementAtOrDefault(i);
                    decimal r9 = r9List.ElementAtOrDefault(i);
                    decimal r10 = r10List.ElementAtOrDefault(i);

                    decimal highestRainbow = Math.Max(r1, Math.Max(r2, Math.Max(r3, Math.Max(r4, Math.Max(r5, Math.Max(r6, Math.Max(r7, Math.Max(r8, Math.Max(r9, r10)))))))));
                    highestRainbowList.Add(highestRainbow);

                    decimal lowestRainbow = Math.Min(r1, Math.Min(r2, Math.Min(r3, Math.Min(r4, Math.Min(r5, Math.Min(r6, Math.Min(r7, Math.Min(r8, Math.Min(r9, r10)))))))));
                    lowestRainbowList.Add(lowestRainbow);

                    decimal prevRainbowOscillator = rainbowOscillatorList.LastOrDefault();
                    decimal rainbowOscillator = highestHigh - lowestLow != 0 ?
                        100 * ((currentValue - ((r1 + r2 + r3 + r4 + r5 + r6 + r7 + r8 + r9 + r10) / 10)) / (highestHigh - lowestLow)) : 0;
                    rainbowOscillatorList.Add(rainbowOscillator);

                    decimal rainbow = highestHigh - lowestLow != 0 ? 100 * ((highestRainbow - lowestRainbow) / (highestHigh - lowestLow)) : 0;
                    rainbowList.Add(rainbow);

                    var signal = GetCompareSignal(rainbowOscillator, prevRainbowOscillator);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (r3List, r4List, r5List, r6List, r7List, r8List, r9List, r10List, highestRainbowList, lowestRainbowList, rainbowOscillatorList, rainbowList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateRahulMohindarOscillator(StockData stockDataClass, string maType, int days = 2)
        {
            //
            // @author LazyBear
            // 
            //study(title = "Rahul Mohinder Oscillator [LazyBear]", shorttitle = "RMO_LB")
            //C = close
            //cm2(x) => sma(x, 2)
            //ma1 = cm2(C)
            //ma2 = cm2(ma1)
            //ma3 = cm2(ma2)
            //ma4 = cm2(ma3)
            //ma5 = cm2(ma4)
            //ma6 = cm2(ma5)
            //ma7 = cm2(ma6)
            //ma8 = cm2(ma7)
            //ma9 = cm2(ma8)
            //ma10 = cm2(ma9)
            //SwingTrd1 = 100 * (close - (ma1 + ma2 + ma3 + ma4 + ma5 + ma6 + ma7 + ma8 + ma9 + ma10) / 10) / (highest(C, 10) - lowest(C, 10))
            //SwingTrd2 = ema(SwingTrd1, 30)
            //SwingTrd3 = ema(SwingTrd2, 30)
            //RMO = ema(SwingTrd3, 81)
            List<decimal> swingTrd1List = new();
            List<decimal> swingTrd2List = new();
            List<decimal> swingTrd3List = new();
            List<decimal> rmoList = new();
            List<decimal> tempList = new();
            List<Signal> signalsList = new();

            try
            {
                int lookBackPeriod = days * 5;
                int swingTrdPeriod = MinOrMax(lookBackPeriod * 3);
                int rmoPeriod = MinOrMax((int)Math.Ceiling(lookBackPeriod * 8.1));

                var r1List = GetMovingAverageList(maType, null, stockDataClass, days);
                var r2List = GetMovingAverageList(maType, r1List, stockDataClass, days);
                var r3List = GetMovingAverageList(maType, r2List, stockDataClass, days);
                var r4List = GetMovingAverageList(maType, r3List, stockDataClass, days);
                var r5List = GetMovingAverageList(maType, r4List, stockDataClass, days);
                var r6List = GetMovingAverageList(maType, r5List, stockDataClass, days);
                var r7List = GetMovingAverageList(maType, r6List, stockDataClass, days);
                var r8List = GetMovingAverageList(maType, r7List, stockDataClass, days);
                var r9List = GetMovingAverageList(maType, r8List, stockDataClass, days);
                var r10List = GetMovingAverageList(maType, r9List, stockDataClass, days);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    tempList.Add(currentValue);

                    decimal highest = tempList.TakeLast(lookBackPeriod).Max();
                    decimal lowest = tempList.TakeLast(lookBackPeriod).Min();
                    decimal r1 = r1List.ElementAtOrDefault(i);
                    decimal r2 = r2List.ElementAtOrDefault(i);
                    decimal r3 = r3List.ElementAtOrDefault(i);
                    decimal r4 = r4List.ElementAtOrDefault(i);
                    decimal r5 = r5List.ElementAtOrDefault(i);
                    decimal r6 = r6List.ElementAtOrDefault(i);
                    decimal r7 = r7List.ElementAtOrDefault(i);
                    decimal r8 = r8List.ElementAtOrDefault(i);
                    decimal r9 = r9List.ElementAtOrDefault(i);
                    decimal r10 = r10List.ElementAtOrDefault(i);

                    decimal swingTrd1 = highest - lowest != 0 ? 100 * (currentValue - ((r1 + r2 + r3 + r4 + r5 + r6 + r7 + r8 + r9 + r10) / 10)) / (highest - lowest) : 0;
                    swingTrd1List.Add(swingTrd1);

                    decimal swingTrd2 = CalculateExponentialMovingAverage(swingTrd1, swingTrd2List.LastOrDefault(), swingTrdPeriod);
                    swingTrd2List.Add(swingTrd2);

                    decimal swingTrd3 = CalculateExponentialMovingAverage(swingTrd2, swingTrd3List.LastOrDefault(), swingTrdPeriod);
                    swingTrd3List.Add(swingTrd3);

                    decimal prevRmo = rmoList.LastOrDefault();
                    decimal rmo = CalculateExponentialMovingAverage(swingTrd3, prevRmo, rmoPeriod);
                    rmoList.Add(rmo);

                    var signal = GetCompareSignal(rmo, prevRmo);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (swingTrd2List, swingTrd3List, rmoList, signalsList);
        }

        public static (List<decimal>, List<Signal>) CalculateWellesWilderVolatilitySystem(StockData stockDataClass, string maType, int days = 21)
        {
            //position = pos, user defined, default is long
            //input = price, user defined, default is close
            //method = moving average (ma), user defined, default is EMA
            //period1 = maP, user defined, default is 63
            //period2 = artP, user defined, default is 21
            //factor = fac, user defined, default is 3
            //art = Average True Range
            //index = current bar number, prev = previous
            //shortP = short position, longP = long position

            //longP = pos == "Long";
            //shortP = pos == "Short";
            //vstop = 0;
            //sic = 0, atrUp = 0, atrDn = 0;
            //ma = ma(method, index, maP, input);
            //upTrend = price moreThan ma; ;
            //dnTrend = price lessOr = ma;
            //if (longP AND upTrend)
            //atrUp = atr(index, atrP);
            //sic = highest(index, atrP, input);
            //vstop = sic - (fac * atrUp);
            //endIf
            //if (shortP AND dnTrend)
            //atrDn = atr(index, atrP);
            //sic = lowest(index, atrP, input);
            //vstop = sic + (fac * atrDn);
            //endIf
            //if (vstop != 0) vstop[index + 1];
            //Signals
            //prevP = price[index - 1];
            //if (vstop != 0)
            //{
            //sell = prevP moreThan vstop AND price lessThan vstop AND longP AND upTrend;
            //buy = prevP lessThan vstop AND price moreThan vstop AND shortP AND dnTrend;
            //endIf
            decimal factor = 3;
            List<decimal> tempList = new();
            List<decimal> vstopList = new();
            List<Signal> signalsList = new();

            try
            {
                int period1 = MinOrMax(days * 3);

                var atrList = CalculateAverageTrueRange(stockDataClass, maType, days).Item1;
                List<decimal> emaList = GetMovingAverageList(maType, null, stockDataClass, period1);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentAtr = atrList.ElementAtOrDefault(i);
                    decimal currentEma = emaList.ElementAtOrDefault(i);

                    decimal prevValue = tempList.LastOrDefault();
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    tempList.Add(currentValue);

                    decimal prevVStop = vstopList.LastOrDefault();
                    decimal sic = currentValue > currentEma ? tempList.TakeLast(days).Max() : tempList.TakeLast(days).Min();
                    decimal vstop = currentValue > currentEma ? sic - (factor * currentAtr) : sic + (factor * currentAtr);
                    vstopList.Add(vstop);

                    var signal = GetCompareSignal(currentValue - vstop, prevValue - prevVStop);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (vstopList, signalsList);
        }

        public static (List<decimal>, List<Signal>) CalculateWellesWilderSummation(StockData stockDataClass, int days)
        {
            // sum = prevSum - (prevSum / n) + input
            List<decimal> sumList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal prevSum = sumList.LastOrDefault();
                    decimal sum = prevSum - (prevSum / days) + currentValue;
                    sumList.Add(sum);

                    var signal = GetCompareSignal(currentValue - sum, prevValue - prevSum);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (sumList, signalsList);
        }

        public static (List<decimal>, List<Signal>) CalculateWellesWilderMovingAverage(StockData stockDataClass, int days = 14)
        {
            //WMAi = prevWma + (Price - prevWma) / N
            List<decimal> wwmaList = new();
            List<Signal> signalsList = new();

            try
            {
                decimal k = (decimal)1 / days;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal prevWwma = wwmaList.LastOrDefault();
                    decimal wwma = (currentValue * k) + (prevWwma * (1 - k));
                    wwmaList.Add(wwma);

                    var signal = GetCompareSignal(currentValue - wwma, prevValue - prevWwma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (wwmaList, signalsList);
        }

        public static (List<decimal>, List<Signal>) CalculateWeightedClose(StockData stockDataClass)
        {
            // weighted close = (high + low + (close * 2)) / 4
            List<decimal> weightedCloseList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.HighPrices.Count; i++)
                {
                    decimal currentHigh = stockDataClass.HighPrices.ElementAtOrDefault(i);
                    decimal currentLow = stockDataClass.LowPrices.ElementAtOrDefault(i);
                    decimal currentClose = stockDataClass.ClosePrices.ElementAtOrDefault(i);
                    decimal prevClose = i >= 1 ? stockDataClass.ClosePrices.ElementAtOrDefault(i - 1) : 0;

                    decimal prevWeightedClose = weightedCloseList.LastOrDefault();
                    decimal weightedClose = (currentHigh + currentLow + (currentClose * 2)) / 4;
                    weightedCloseList.Add(weightedClose);

                    var signal = GetCompareSignal(currentClose - weightedClose, prevClose - prevWeightedClose);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (weightedCloseList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculatePriceChannel(StockData stockDataClass, string maType, int days = 6)
        {
            //Upper Channel Line: Ema * (1 + (Upper Pct / 100))
            //Lower Channel Line: Ema * (1 - (Lower Pct / 100))
            //Upper and Lower Pct default value: 6
            //Ema period default value: 21
            List<decimal> upperPriceChannelList = new();
            List<decimal> lowerPriceChannelList = new();
            List<decimal> midPriceChannelList = new();
            List<Signal> signalsList = new();

            try
            {
                int length = (int)Math.Ceiling(days / 0.2857);
                decimal pctAmount = days;

                List<decimal> emaList = GetMovingAverageList(maType, null, stockDataClass, days);

                for (int i = 0; i < emaList.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal currentEma = emaList.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal upperPriceChannel = currentEma * (1 + (pctAmount / 100));
                    upperPriceChannelList.Add(upperPriceChannel);

                    decimal lowerPriceChannel = currentEma * (1 - (pctAmount / 100));
                    lowerPriceChannelList.Add(lowerPriceChannel);

                    decimal prevMidPriceChannel = midPriceChannelList.LastOrDefault();
                    decimal midPriceChannel = (upperPriceChannel + lowerPriceChannel) / 2;
                    midPriceChannelList.Add(midPriceChannel);

                    var signal = GetCompareSignal(currentValue - midPriceChannel, prevValue - prevMidPriceChannel);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (upperPriceChannelList, lowerPriceChannelList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateVaradiOscillator(StockData stockDataClass, string maType, int days = 14)
        {
            // This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
            // An original idea of David Varadi, check his blog here : https://cssanalytics.wordpress.com

            //@version=4
            //study("Varadi Oscillator", "DVO")
            //prank = input(14, "Percent Rank Length")
            //len = input(14, "SMA Length")
            //----
            //a = sma(close / hl2, len)
            //dvo = percentrank(a, prank)
            //----
            //plot(dvo, "DVO",#ff1100,2)
            //hline(80), hline(20)
            List<decimal> dvoList = new();
            List<decimal> aList = new();
            List<decimal> ratioList = new();
            List<decimal> tempList = new();
            List<Signal> signalsList = new();

            try
            {
                var list = VolumeInputCheck(stockDataClass, days, false);
                var highList = list.Item1;
                var lowList = list.Item2;

                for (int h = 0; h < stockDataClass.InputValues.Count; h++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(h);
                    decimal currentHigh = highList.ElementAtOrDefault(h);
                    decimal currentLow = lowList.ElementAtOrDefault(h);
                    decimal median = (currentHigh + currentLow) / 2;

                    decimal ratio = median != 0 ? currentValue / median : 0;
                    ratioList.Add(ratio);
                }

                aList = GetMovingAverageList(maType, ratioList, stockDataClass, days);
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal a = aList.ElementAtOrDefault(i);
                    decimal prevDvo1 = i >= 1 ? dvoList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevDvo2 = i >= 2 ? dvoList.ElementAtOrDefault(i - 2) : 0;

                    decimal prevA = i >= 1 ? aList.ElementAtOrDefault(i - 1) : 0;
                    tempList.Add(prevA);

                    decimal dvo = MinOrMax((decimal)tempList.TakeLast(days).Where(i => i <= a).ToList().Count / days * 100, 100, 0);
                    dvoList.Add(dvo);

                    var signal = GetRsiSignal(dvo - prevDvo1, prevDvo1 - prevDvo2, dvo, prevDvo1, 80, 20);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (ratioList, aList, dvoList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateAroonOscillator(StockData stockDataClass, int days = 25)
        {
            //// Aroon - Up = ((25 - Days Since 25 - day High)/ 25) x 100
            //// Aroon - Down = ((25 - Days Since 25 - day Low)/ 25) x 100
            //// Aroon Oscillator = Aroon-Up  -  Aroon-Down
            List<decimal> aroonUpList = new();
            List<decimal> aroonDownList = new();
            List<decimal> aroonOscillatorList = new();
            List<decimal> tempList = new();
            List<Signal> signalsList = new();

            try
            {
                var minMaxList = VolumeInputCheck(stockDataClass, days, true);
                var highestList = minMaxList.Item1;
                var lowestList = minMaxList.Item2;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentPrice = stockDataClass.InputValues.ElementAtOrDefault(i);
                    tempList.Add(currentPrice);

                    decimal maxPrice = highestList.ElementAtOrDefault(i);
                    int maxIndex = tempList.LastIndexOf(maxPrice);
                    decimal minPrice = lowestList.ElementAtOrDefault(i);
                    int minIndex = tempList.LastIndexOf(minPrice);
                    int daysSinceMax = i - maxIndex;
                    int daysSinceMin = i - minIndex;

                    decimal aroonUp = (decimal)(days - daysSinceMax) / days * 100;
                    aroonUpList.Add(aroonUp);

                    decimal aroonDown = (decimal)(days - daysSinceMin) / days * 100;
                    aroonDownList.Add(aroonDown);

                    decimal prevAroonOscillator = aroonOscillatorList.LastOrDefault();
                    decimal aroonOscillator = aroonUp - aroonDown;
                    aroonOscillatorList.Add(aroonOscillator);

                    var signal = GetCompareSignal(aroonOscillator, prevAroonOscillator);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (aroonUpList, aroonDownList, aroonOscillatorList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateTimePriceIndicator(StockData stockDataClass, int days = 50)
        {
            //@version=2
            //study("Time Price Indicator")
            //length = input(50)
            //----
            //A = barssince(rising(high, length))
            //B = barssince(falling(low, length))
            //upper = (A > length ? length : A) / length - 0.5
            //lower = (B > length ? length : B) / length - 0.5
            //----
            //plot(upper * -1, title = "Upper Line", color =#2196f3,linewidth=2,transp=0)
            //plot(lower * -1, title = "Lower Line", color =#e65100,linewidth=2,transp=0)
            List<decimal> aList = new();
            List<decimal> bList = new();
            List<decimal> upperList = new();
            List<decimal> lowerList = new();
            List<decimal> tempHighList = new();
            List<decimal> tempLowList = new();
            List<decimal> risingList = new();
            List<decimal> fallingList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.HighPrices.Count; i++)
                {
                    decimal currentHigh = stockDataClass.HighPrices.ElementAtOrDefault(i);
                    decimal currentLow = stockDataClass.LowPrices.ElementAtOrDefault(i);

                    decimal prevHigh = i >= 1 ? stockDataClass.HighPrices.ElementAtOrDefault(i - 1) : 0;
                    tempHighList.Add(prevHigh);

                    decimal prevLow = i >= 1 ? stockDataClass.LowPrices.ElementAtOrDefault(i - 1) : 0;
                    tempLowList.Add(prevLow);

                    decimal rising = currentHigh > tempHighList.TakeLast(days).Max() ? 1 : 0;
                    risingList.Add(rising);

                    decimal falling = currentLow < tempLowList.TakeLast(days).Min() ? 1 : 0;
                    fallingList.Add(falling);

                    decimal a = i - risingList.LastIndexOf(1);
                    aList.Add(a);

                    decimal b = i - fallingList.LastIndexOf(1);
                    bList.Add(b);

                    decimal prevUpper = upperList.LastOrDefault();
                    decimal upper = ((a > days ? days : a) / days) - 0.5m;
                    upperList.Add(upper);

                    decimal prevLower = lowerList.LastOrDefault();
                    decimal lower = ((b > days ? days : b) / days) - 0.5m;
                    lowerList.Add(lower);

                    var signal = GetCompareSignal((lower * -1) - (upper * -1), (prevLower * -1) - (prevUpper * -1));
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (risingList, fallingList, aList, bList, upperList, lowerList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateChandeMomentumOscillator(StockData stockDataClass, string maType, int days = 14)
        {
            //input = price, user defined, default is closing price
            //period = user defined, default is 14
            //MT = more than
            //LT = less than
            //prev = previous, diff = difference
            //index = current bar number

            //prevPrice = price[index - 1];
            //diff = price - prevPrice;
            //cmo1 = 0,
            //cmo2 = 0;
            //if (diff MT 0) cmo1 = diff;
            //if (diff LT 0) cmo2 = -diff;
            //sum1 = sum(index, period, CMO1);
            //sum2 = sum(index, period, CMO2);
            //cmo = ((sum1 - sum2) / (sum1 + sum2)) * 100;
            //Signals
            //buy = crossedAbove(CMO, topGuide);
            //sell = crossedBelow(CMO, bottomGuide);
            List<decimal> cmoList = new();
            List<decimal> cmoPosSumList = new();
            List<decimal> cmoPosChgList = new();
            List<decimal> cmoNegSumList = new();
            List<decimal> cmoNegChgList = new();
            List<decimal> cmoSignalList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal diff = currentValue - prevValue;

                    decimal negChg = diff < 0 ? Math.Abs(diff) : 0;
                    cmoNegChgList.Add(negChg);

                    decimal posChg = diff > 0 ? diff : 0;
                    cmoPosChgList.Add(posChg);

                    decimal negSum = cmoNegChgList.TakeLast(days).Sum();
                    cmoNegSumList.Add(negSum);

                    decimal posSum = cmoPosChgList.TakeLast(days).Sum();
                    cmoPosSumList.Add(posSum);

                    decimal cmo = posSum + negSum != 0 ? MinOrMax((posSum - negSum) / (posSum + negSum) * 100, 100, -100) : 0;
                    cmoList.Add(cmo);
                }

                cmoSignalList = GetMovingAverageList(maType, cmoList, stockDataClass, days);
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal cmo = cmoList.ElementAtOrDefault(j);
                    decimal cmoSignal = cmoSignalList.ElementAtOrDefault(j);
                    decimal prevCmo = j >= 1 ? cmoList.ElementAtOrDefault(j - 1) : 0;
                    decimal prevCmoSignal = j >= 1 ? cmoSignalList.ElementAtOrDefault(j - 1) : 0;

                    var signal = GetRsiSignal(cmo - cmoSignal, prevCmo - prevCmoSignal, cmo, prevCmo, 50, -50);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (cmoNegChgList, cmoNegSumList, cmoPosChgList, cmoPosSumList, cmoList, cmoSignalList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateChandeMomentumOscillatorFilter(StockData stockDataClass, string maType, int days = 9)
        {
            //input = price (user defined, default is closing price)
            //period = user defined, default is 9
            //filter = user defined, default is 3
            //prev = previous, index = current bar number
            //abs = absolute value, diff = difference
            //MT = more than, LT = less than

            //prevValue = price[index - 1];
            //diffV = price - prevValue;
            //absV = abs(diffV);
            //if (absV MT filter) diffV = 0; absV = 0;
            //temp1 = sum(index, period, diffV);
            //temp2 = sum(index, period, absV);
            //Plot: cmof = 100 * temp1 / temp2;
            //Signals
            //prevC = cmof[1];
            //highSell = cmof for last sell signal, reset to max_negative at each  buy signal;
            //lowBuy = cmof for last buy signal, reset to max_positive at each sell signal;
            //sell = (cmof MT topGuide) AND(prevC MT cmof)  AND(cmof MT highSell); ;
            //buy = (cmof LT bottGuide AND prevC LT cmof) AND(cmof LT lowBuy);
            List<decimal> cmoList = new();
            List<decimal> diffList = new();
            List<decimal> absDiffList = new();
            List<decimal> diffSumList = new();
            List<decimal> absDiffSumList = new();
            List<decimal> cmoSignalList = new();
            List<Signal> signalsList = new();

            try
            {
                decimal filter = stockDataClass.InputValues.Where(i => i != 0).FirstOrDefault() * 3;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal diff = currentValue - prevValue;
                    decimal absDiff = Math.Abs(currentValue - prevValue);
                    if (absDiff > filter) diff = 0; absDiff = 0;
                    diffList.Add(diff);
                    absDiffList.Add(absDiff);

                    decimal diffSum = diffList.TakeLast(days).Sum();
                    diffSumList.Add(diffSum);

                    decimal absDiffSum = absDiffList.TakeLast(days).Sum();
                    absDiffSumList.Add(absDiffSum);

                    decimal cmo = absDiffSum != 0 ? MinOrMax(100 * diffSum / absDiffSum, 100, -100) : 0;
                    cmoList.Add(cmo);
                }

                cmoSignalList = GetMovingAverageList(maType, cmoList, stockDataClass, days);
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal cmo = cmoList.ElementAtOrDefault(j);
                    decimal cmoSignal = cmoSignalList.ElementAtOrDefault(j);
                    decimal prevCmo = j >= 1 ? cmoList.ElementAtOrDefault(j - 1) : 0;
                    decimal prevCmoSignal = j >= 1 ? cmoSignalList.ElementAtOrDefault(j - 1) : 0;

                    var signal = GetRsiSignal(cmo - cmoSignal, prevCmo - prevCmoSignal, cmo, prevCmo, 70, -70);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (diffSumList, absDiffList, absDiffSumList, cmoList, cmoSignalList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateChandeMomentumOscillatorAbsolute(StockData stockDataClass, int days = 9)
        {
            //input = price, user defined, default is closing price
            //period = user defined, default is 9
            //num = numerator, den = denomator
            //abs = absolute value, prev = previous
            //index = current bar number

            //lastV = price[index - 1];
            //absDiff = abs(price - lastV)
            //priorV = price[index - period];
            //num = abs(100 * (price - priorV));
            //den = sum(index, period, absDiff);
            //Plot: cmoabs = num / den;
            //Signals
            //prevC = cmoabs[index - 1];
            //highSell = cmoabs for last sell signal, reset to max_negative at each  buy signal;
            //lowBuy = cmoabs for last buy signal, reset to max_positive at each sell signal;
            //sell = (cmoabs moreThan topGuide) AND(prevC moreThan cmoabs) AND(cmoabs moreThan highSell);
            //buy = (cmoabs lessThan bottomGuide AND prevC lessThan cmoabs) AND(cmoabs lessThan lowBuy);
            List<decimal> cmoAbsList = new();
            List<decimal> absDiffList = new();
            List<decimal> numList = new();
            List<decimal> denomList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal priorValue = i >= days ? stockDataClass.InputValues.ElementAtOrDefault(i - days) : 0;
                    decimal prevCmoAbs1 = i >= 1 ? cmoAbsList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevCmoAbs2 = i >= 2 ? cmoAbsList.ElementAtOrDefault(i - 2) : 0;

                    decimal absDiff = Math.Abs(currentValue - prevValue);
                    absDiffList.Add(absDiff);

                    decimal num = Math.Abs(100 * (currentValue - priorValue));
                    numList.Add(num);

                    decimal denom = absDiffList.TakeLast(days).Sum();
                    denomList.Add(denom);

                    decimal cmoAbs = denom != 0 ? MinOrMax(num / denom, 100, 0) : 0;
                    cmoAbsList.Add(cmoAbs);

                    var signal = GetRsiSignal(cmoAbs - prevCmoAbs1, prevCmoAbs1 - prevCmoAbs2, cmoAbs, prevCmoAbs1, 70, 30);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (absDiffList, numList, denomList, cmoAbsList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateChandeMomentumOscillatorAverage(StockData stockDataClass, int days = 5)
        {
            //input = price (user defined, default is closing price)
            //period1 = user defined, default is 5
            //period2 = user defined, default is 10
            //period3 = user defined, default is 20
            //prev = previous, index = current bar number
            //abs = absolute value
            //MT = more than, LT = less than

            //prevValue1 = price[index - 1];
            //minusC1 = price - prevValue1;
            //absMinusC1 = abs(minusC1);
            //sumP1 = sum(index, period1, minusC1);
            //absSumP1 = sum(index, period1, absMinusC1);
            //sumP2 = sum(index, period2, minusC1);
            //absSumP2 = sum(index, period2, absMinusC1);
            //sumP3 = sum(index, period3, minusC1);
            //absSumP3 = sum(index, period3, absMinusC1);
            //Plot: cmoAv = 100 * (((sumP1 / absSumP1) + (sumP2 / absSumP2) + (sumP3 / absSumP3)) / 3);
            //Signals
            //prevCmo = cmoAv[index - 1];
            //highSell = cmoAv for last sell signal, reset to max_negative at each  buy signal;
            //lowBuy = cmoAv for last buy signal, reset to max_positive at each sell signal;
            //sell = (cmoAv MT topGuide) AND(prevCmo MT cmoAv) AND(cmoAv MT highSell);
            //buy = (cmoAv LT bottomGuide AND prevCmo LT cmoAv)  AND(cmoAv LT lowBuy);
            List<decimal> cmoAvgList = new();
            List<decimal> diffList = new();
            List<decimal> absDiffList = new();
            List<decimal> temp1List = new();
            List<decimal> temp2List = new();
            List<decimal> temp3List = new();
            List<decimal> diffSum1List = new();
            List<decimal> absSum1List = new();
            List<decimal> diffSum2List = new();
            List<decimal> absSum2List = new();
            List<decimal> diffSum3List = new();
            List<decimal> absSum3List = new();
            List<Signal> signalsList = new();

            try
            {
                int period2 = MinOrMax(days * 2);
                int period3 = MinOrMax(days * 4);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentPrice = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevPrice = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevCmoAvg1 = i >= 1 ? cmoAvgList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevCmoAvg2 = i >= 2 ? cmoAvgList.ElementAtOrDefault(i - 2) : 0;

                    decimal diff = currentPrice - prevPrice;
                    diffList.Add(diff);

                    decimal absDiff = Math.Abs(diff);
                    absDiffList.Add(absDiff);

                    decimal diffSum1 = diffList.TakeLast(days).Sum();
                    diffSum1List.Add(diffSum1);

                    decimal absSum1 = absDiffList.TakeLast(days).Sum();
                    absSum1List.Add(absSum1);

                    decimal diffSum2 = diffList.TakeLast(period2).Sum();
                    diffSum2List.Add(diffSum2);

                    decimal absSum2 = absDiffList.TakeLast(period2).Sum();
                    absSum2List.Add(absSum2);

                    decimal diffSum3 = diffList.TakeLast(period3).Sum();
                    diffSum3List.Add(diffSum3);

                    decimal absSum3 = absDiffList.TakeLast(period3).Sum();
                    absSum3List.Add(absSum3);

                    decimal temp1 = absSum1 != 0 ? MinOrMax(diffSum1 / absSum1, 1, -1) : 0;
                    temp1List.Add(temp1);

                    decimal temp2 = absSum2 != 0 ? MinOrMax(diffSum2 / absSum2, 1, -1) : 0;
                    temp2List.Add(temp2);

                    decimal temp3 = absSum3 != 0 ? MinOrMax(diffSum3 / absSum3, 1, -1) : 0;
                    temp3List.Add(temp3);

                    decimal cmoAvg = 100 * ((temp1 + temp2 + temp3) / 3);
                    cmoAvgList.Add(cmoAvg);

                    var signal = GetRsiSignal(cmoAvg - prevCmoAvg1, prevCmoAvg1 - prevCmoAvg2, cmoAvg, prevCmoAvg1, 50, -50);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (diffSum1List, absSum1List, diffSum2List, absSum2List, diffSum3List, absSum3List, temp1List, temp2List, temp3List, cmoAvgList, signalsList);
        }

        public static (List<decimal>, List<Signal>) CalculateChandeMomentumOscillatorAbsoluteAverage(StockData stockDataClass, int days = 5)
        {
            //input = price (user defined, default is closing price)
            //period1 = user defined, default is 5
            //period2 = user defined, default is 10
            //period3 = user defined, default is 20
            //abs = absolute value, diff = difference
            //index = current bar number

            //lastV = price[index - 1];
            //diff = price - lastV;
            //absDiff = abs(diff);
            //diffSum1 = sum(index, period1, diff);
            //absSum1 = sum(index, period1, absDiff);
            //diffSum2 = sum(index, period2, diff);
            //absSum2 = sum(index, period2, absDiff);
            //diffSum3 = sum(index, period3, diff);
            //absSum3 = sum(index, period3, absDiff);
            //temp1 = diffSum1 / absSum1;
            //temp2 = diffSum2 / absSum2;
            //temp3 = diffSum3 / absSum3;
            //Plot: cmoAbsAv = abs(100 * (temp1 + temp2 + temp3) / 3);
            //Signals
            //prevC = cmoAbsAv[index - 1];
            //highSell = cmoAbsAv for last sell signal, reset to max_negative at each  buy signal;
            //lowBuy = cmoAbsAv for last buy signal, reset to max_positive at each sell signal;
            //sell = cmoAbsAv moreThan topGuide AND prevC moreThan cmoAbsAv AND cmoAbsAv moreThan highSell;
            //buy = cmoAbsAv lessThan bottGuide AND prevC lessThan cmoAbsAv AND cmoAbsAv lessThan lowBuy;
            List<decimal> cmoAbsAvgList = new();
            List<decimal> diffList = new();
            List<decimal> absDiffList = new();
            List<decimal> temp1List = new();
            List<decimal> temp2List = new();
            List<decimal> temp3List = new();
            List<decimal> diffSum1List = new();
            List<decimal> absSum1List = new();
            List<decimal> diffSum2List = new();
            List<decimal> absSum2List = new();
            List<decimal> diffSum3List = new();
            List<decimal> absSum3List = new();
            List<Signal> signalsList = new();

            try
            {
                int period1 = days;
                int period2 = MinOrMax(period1 * 2);
                int period3 = MinOrMax(period1 * 4);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentPrice = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevPrice = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevCmoAbsAvg1 = i >= 1 ? cmoAbsAvgList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevCmoAbsAvg2 = i >= 2 ? cmoAbsAvgList.ElementAtOrDefault(i - 2) : 0;

                    decimal diff = currentPrice - prevPrice;
                    diffList.Add(diff);

                    decimal absDiff = Math.Abs(diff);
                    absDiffList.Add(absDiff);

                    decimal diffSum1 = diffList.TakeLast(period1).Sum();
                    diffSum1List.Add(diffSum1);

                    decimal absSum1 = absDiffList.TakeLast(period1).Sum();
                    absSum1List.Add(absSum1);

                    decimal diffSum2 = diffList.TakeLast(period2).Sum();
                    diffSum2List.Add(diffSum2);

                    decimal absSum2 = absDiffList.TakeLast(period2).Sum();
                    absSum2List.Add(absSum2);

                    decimal diffSum3 = diffList.TakeLast(period3).Sum();
                    diffSum3List.Add(diffSum3);

                    decimal absSum3 = absDiffList.TakeLast(period3).Sum();
                    absSum3List.Add(absSum3);

                    decimal temp1 = absSum1 != 0 ? MinOrMax(diffSum1 / absSum1, 1, -1) : 0;
                    temp1List.Add(temp1);

                    decimal temp2 = absSum2 != 0 ? MinOrMax(diffSum2 / absSum2, 1, -1) : 0;
                    temp2List.Add(temp2);

                    decimal temp3 = absSum3 != 0 ? MinOrMax(diffSum3 / absSum3, 1, -1) : 0;
                    temp3List.Add(temp3);

                    decimal cmoAbsAvg = Math.Abs(100 * ((temp1 + temp2 + temp3) / 3));
                    cmoAbsAvgList.Add(cmoAbsAvg);

                    var signal = GetRsiSignal(cmoAbsAvg - prevCmoAbsAvg1, prevCmoAbsAvg1 - prevCmoAbsAvg2, cmoAbsAvg, prevCmoAbsAvg1, 70, 30);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (cmoAbsAvgList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateChandeCompositeMomentumIndex(StockData stockDataClass, string maType, int days = 3)
        {
            //
            // @author LazyBear 
            // 
            // List of my public indicators: http://bit.ly/1LQaPK8 
            // List of my app-store indicators: http://blog.tradingview.com/?p=970 
            //
            //study(title = "Chande Composite Momentum Index [LazyBear]", shorttitle = "CCMI_LB")
            //src = input(close, title = "Source")
            //lenSmooth = input(3, title = "Composite Smoothing Length")
            //trigg = input(5, title = "Signal Length")
            //calc_dema(src, length) => 
            //    e1 = ema(src, length)
            //    e2 = ema(e1, length)
            //    2 * e1 - e2

            //cmo51 = sum(iff(src > src[1], (src - src[1]), 0), 5)
            //cmo52 = sum(iff(src < src[1], (src[1] - src), 0), 5)
            //cmo5 = calc_dema(100 * nz((cmo51 - cmo52) / (cmo51 + cmo52)), 3)
            //cmo101 = sum(iff(src > src[1], (src - src[1]), 0), 10)
            //cmo102 = sum(iff(src < src[1], (src[1] - src), 0), 10)
            //cmo10 = calc_dema(100 * nz((cmo101 - cmo102) / (cmo101 + cmo102)), 3)
            //cmo201 = sum(iff(src > src[1], (src - src[1]), 0), 20)
            //cmo202 = sum(iff(src < src[1], (src[1] - src), 0), 20)
            //cmo20 = calc_dema(100 * nz((cmo201 - cmo202) / (cmo201 + cmo202)), 3)
            //dmi = ((stdev(src, 5) * cmo5) + (stdev(src, 10) * cmo10) + (stdev(src, 20) * cmo20)) / (stdev(src, 5) + stdev(src, 10) + stdev(src, 20))
            //e = ema(dmi, lenSmooth), s = sma(dmi, trigg)
            //hline(70, color = red, title = "High2")
            //ul = hline(30, color = green, title = "High1")
            //hline(0, color = black, title = "Mid")
            //ll = hline(-30, color = green, title = "Low1")
            //hline(-70, color = red, title = "Low2")
            //fill(ul, ll, black, title = "MidRegionFill")
            //duml = plot(e > s ? s : e, style = circles, linewidth = 0, color = gray, title = "Dummy")
            //cmil = plot(e, title = "DynamicIndex", color = blue)
            //tl = plot(s, title = "trigger", color = red)
            //fill(cmil, duml, color = lime, transp = 50, title = "PositiveFill")
            //fill(tl, duml, color = red, transp = 50, title = "NegativeFill")
            List<decimal> valueDiff1List = new();
            List<decimal> valueDiff2List = new();
            List<decimal> cmo51List = new();
            List<decimal> cmo52List = new();
            List<decimal> cmo101List = new();
            List<decimal> cmo102List = new();
            List<decimal> cmo201List = new();
            List<decimal> cmo202List = new();
            List<decimal> dmiList = new();
            List<decimal> eList = new();
            List<decimal> sList = new();
            List<decimal> cmo5RatioList = new();
            List<decimal> cmo10RatioList = new();
            List<decimal> cmo20RatioList = new();
            List<decimal> cmo5List = new();
            List<decimal> cmo10List = new();
            List<decimal> cmo20List = new();
            List<Signal> signalsList = new();

            try
            {
                int cmo5Period = (int)Math.Ceiling(days / 0.6);
                int cmo10Period = MinOrMax(cmo5Period * 2);
                int cmo20Period = MinOrMax(cmo5Period * 4);

                List<decimal> stdDevList = CalculateStandardDeviationVolatility(null, stockDataClass, cmo5Period).Item4;
                List<decimal> stdDev10List = CalculateStandardDeviationVolatility(null, stockDataClass, cmo10Period).Item4;
                List<decimal> stdDev20List = CalculateStandardDeviationVolatility(null, stockDataClass, cmo20Period).Item4;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal valueDiff1 = currentValue > prevValue ? currentValue - prevValue : 0;
                    valueDiff1List.Add(valueDiff1);

                    decimal valueDiff2 = currentValue < prevValue ? prevValue - currentValue : 0;
                    valueDiff2List.Add(valueDiff2);

                    decimal cmo51 = valueDiff1List.TakeLast(cmo5Period).Sum();
                    cmo51List.Add(cmo51);

                    decimal cmo52 = valueDiff2List.TakeLast(cmo5Period).Sum();
                    cmo52List.Add(cmo52);

                    decimal cmo5Ratio = cmo51 + cmo52 != 0 ? MinOrMax(100 * (cmo51 - cmo52) / (cmo51 + cmo52), 100, -100) : 0;
                    cmo5RatioList.Add(cmo5Ratio);

                    decimal cmo101 = valueDiff1List.TakeLast(cmo10Period).Sum();
                    cmo101List.Add(cmo101);

                    decimal cmo102 = valueDiff2List.TakeLast(cmo10Period).Sum();
                    cmo102List.Add(cmo102);

                    decimal cmo10Ratio = cmo101 + cmo102 != 0 ? MinOrMax(100 * (cmo101 - cmo102) / (cmo101 + cmo102), 100, -100) : 0;
                    cmo10RatioList.Add(cmo10Ratio);

                    decimal cmo201 = valueDiff1List.TakeLast(cmo20Period).Sum();
                    cmo201List.Add(cmo201);

                    decimal cmo202 = valueDiff2List.TakeLast(cmo20Period).Sum();
                    cmo202List.Add(cmo202);

                    decimal cmo20Ratio = cmo201 + cmo202 != 0 ? MinOrMax(100 * (cmo201 - cmo202) / (cmo201 + cmo202), 100, -100) : 0;
                    cmo20RatioList.Add(cmo20Ratio);
                }

                cmo5List = GetMovingAverageList(maType, cmo5RatioList, stockDataClass, days);
                cmo10List = GetMovingAverageList(maType, cmo10RatioList, stockDataClass, days);
                cmo20List = GetMovingAverageList(maType, cmo20RatioList, stockDataClass, days);
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal stdDev5 = stdDevList.ElementAtOrDefault(j);
                    decimal stdDev10 = stdDev10List.ElementAtOrDefault(j);
                    decimal stdDev20 = stdDev20List.ElementAtOrDefault(j);
                    decimal cmo5 = cmo5List.ElementAtOrDefault(j);
                    decimal cmo10 = cmo10List.ElementAtOrDefault(j);
                    decimal cmo20 = cmo20List.ElementAtOrDefault(j);

                    decimal dmi = stdDev5 + stdDev10 + stdDev20 != 0 ?
                        MinOrMax(((stdDev5 * cmo5) + (stdDev10 * cmo10) + (stdDev20 * cmo20)) / (stdDev5 + stdDev10 + stdDev20), 100, -100) : 0;
                    dmiList.Add(dmi);

                    decimal prevS = sList.LastOrDefault();
                    decimal s = dmiList.TakeLast(cmo5Period).Average();
                    sList.Add(s);

                    decimal prevE = eList.LastOrDefault();
                    decimal e = CalculateExponentialMovingAverage(dmi, prevE, days);
                    eList.Add(e);

                    var signal = GetRsiSignal(e - s, prevE - prevS, e, prevE, 70, -70);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (cmo51List, cmo52List, cmo5List, cmo5RatioList, cmo101List, cmo102List, cmo10List, cmo10RatioList, cmo201List, cmo202List, cmo20List, cmo20RatioList,
                dmiList, sList, eList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateAbsoluteStrengthIndex(StockData stockDataClass, int days = 10)
        {
            //
            // @author LazyBear 
            // 
            // List of my public indicators: http://bit.ly/1LQaPK8 
            // List of my app-store indicators: http://blog.tradingview.com/?p=970 
            //
            //study("Absolute Strength Index Oscillator [LazyBear]", shorttitle = "ABSSIO_LB")
            //sh = input(false, title = "Show as Histo")
            //ebc = input(false, title = "Enable Bar Colors")
            //lma = input(21, title = "EMA Length")
            //ld = input(34, title = "Signal Length")
            //osl = 10
            //calc_abssio() =>
            //    A = iff(close > close[1], nz(A[1]) + (close / close[1]) - 1, nz(A[1]))
            //    M = iff(close == close[1], nz(M[1]) + 1.0 / osl, nz(M[1]))
            //    D = iff(close < close[1], nz(D[1]) + (close[1] / close) - 1, nz(D[1]))
            //    iff(D + M / 2 == 0, 1, 1 - 1 / (1 + (A + M / 2) / (D + M / 2)))

            //abssi = calc_abssio()
            //abssio = (abssi - ema(abssi, lma))
            //alp = 2.0 / (ld + 1)
            //mt = alp * abssio + (1 - alp) * nz(mt[1])
            //ut = alp * mt + (1 - alp) * nz(ut[1])
            //s = ((2 - alp) * mt - ut) / (1 - alp)
            //d = abssio - s
            List<decimal> AList = new();
            List<decimal> MList = new();
            List<decimal> DList = new();
            List<decimal> mtList = new();
            List<decimal> utList = new();
            List<decimal> abssioList = new();
            List<decimal> abssiList = new();
            List<decimal> abssiEmaList = new();
            List<decimal> sList = new();
            List<decimal> dList = new();
            List<Signal> signalsList = new();

            try
            {
                int lma = (int)Math.Ceiling(days / 0.4762);
                int ld = (int)Math.Ceiling(days / 0.2942);
                decimal alp = (decimal)2 / (ld + 1);
                int osl = days;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal prevA = AList.LastOrDefault();
                    decimal A = currentValue > prevValue && prevValue != 0 ? prevA + ((currentValue / prevValue) - 1) : prevA;
                    AList.Add(A);

                    decimal prevM = MList.LastOrDefault();
                    decimal M = currentValue == prevValue ? prevM + ((decimal)1 / osl) : prevM;
                    MList.Add(M);

                    decimal prevD = DList.LastOrDefault();
                    decimal D = currentValue < prevValue && currentValue != 0 ? prevD + ((prevValue / currentValue) - 1) : prevD;
                    DList.Add(D);

                    decimal abssi = (D + M) / 2 != 0 ? 1 - (1 / (1 + ((A + M) / 2 / ((D + M) / 2)))) : 1;
                    abssiList.Add(abssi);

                    decimal abssiEma = CalculateExponentialMovingAverage(abssi, abssiEmaList.LastOrDefault(), lma);
                    abssiEmaList.Add(abssiEma);

                    decimal abssio = abssi - abssiEma;
                    abssioList.Add(abssio);

                    decimal prevMt = mtList.LastOrDefault();
                    decimal mt = (alp * abssio) + ((1 - alp) * prevMt);
                    mtList.Add(mt);

                    decimal prevUt = utList.LastOrDefault();
                    decimal ut = (alp * mt) + ((1 - alp) * prevUt);
                    utList.Add(ut);

                    decimal s = (2 - alp) * (mt - ut) / (1 - alp);
                    sList.Add(s);

                    decimal prevd = dList.LastOrDefault();
                    decimal d = abssio - s;
                    dList.Add(d);

                    var signal = GetCompareSignal(d, prevd);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (AList, MList, DList, abssiList, abssiEmaList, abssioList, mtList, utList, sList, dList, signalsList);
        }

        public static (List<decimal>, List<Signal>) CalculateAbsolutePriceOscillator(StockData stockDataClass, string maType, int days = 10)
        {
            //@version=2
            ////////////////////////////////////////////////////////////
            //  Copyright by HPotter v1.0 19/09/2018
            // The Absolute Price Oscillator displays the difference between two exponential 
            // moving averages of a security's price and is expressed as an absolute value.
            // How this indicator works
            //    APO crossing above zero is considered bullish, while crossing below zero is bearish.
            //    A positive indicator value indicates an upward movement, while negative readings 
            //      signal a downward trend.
            //    Divergences form when a new high or low in price is not confirmed by the Absolute Price 
            //      Oscillator (APO). A bullish divergence forms when price make a lower low, but the APO 
            //      forms a higher low. This indicates less downward momentum that could foreshadow a bullish 
            //      reversal. A bearish divergence forms when price makes a higher high, but the APO forms a 
            //      lower high. This shows less upward momentum that could foreshadow a bearish reversal.
            //
            // WARNING:
            // - This script to change bars colors.
            ////////////////////////////////////////////////////////////
            //study(title = "Absolute Price Oscillator (APO) Strategy 2.0", shorttitle = "APO")
            //LengthShortEMA = input(10, minval = 1)
            //LengthLongEMA = input(20, minval = 1)
            //BuyZone = input(3, step = 0.01)
            //SellZone = input(-3, step = 0.01)
            //hline(BuyZone, color = green, linestyle = line)
            //hline(SellZone, color = red, linestyle = line)
            //hline(0, color = gray, linestyle = line)
            //xPrice = close
            //xShortEMA = ema(xPrice, LengthShortEMA)
            //xLongEMA = ema(xPrice, LengthLongEMA)
            //xAPO = xShortEMA - xLongEMA
            //pos = iff(xAPO > BuyZone, 1,
            //      iff(xAPO < SellZone, -1, nz(pos[1], 0)))
            //barcolor(pos == -1 ? red : pos == 1 ? green : blue)
            //plot(xAPO, color = blue, title = "APO")
            List<decimal> apoList = new();
            List<Signal> signalsList = new();

            try
            {
                int fastEmaPeriod = days;
                int slowEmaPeriod = MinOrMax(fastEmaPeriod * 2);

                var fastEmaList = GetMovingAverageList(maType, null, stockDataClass, fastEmaPeriod);
                var slowEmaList = GetMovingAverageList(maType, null, stockDataClass, slowEmaPeriod);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal fastEma = fastEmaList.ElementAtOrDefault(i);
                    decimal slowEma = slowEmaList.ElementAtOrDefault(i);

                    decimal prevApo = apoList.LastOrDefault();
                    decimal apo = fastEma - slowEma;
                    apoList.Add(apo);

                    var signal = GetCompareSignal(apo, prevApo);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (apoList, signalsList);
        }

        public static (List<decimal>, List<Signal>) CalculateVariableIndexDynamicAverage(StockData stockDataClass, string maType, int days = 14)
        {
            //@version=3
            // Copyright (c) 2018-present, Alex Orekhov (everget)
            // Variable Index Dynamic Average script may be freely distributed under the MIT license.
            //study(title = "Variable Index Dynamic Average", shorttitle = "VIDYA", overlay = true)

            //length = input(title = "Length", type = integer, defval = 14)
            //highlightMovements = input(title = "Highlight Movements ?", type = bool, defval = true)
            //src = input(title = "Source", type = source, defval = close)

            // Chande Momentum Oscillator
            //getCMO(src, length) =>
            //    mom = change(src)
            //    upSum = sum(max(mom, 0), length)
            //    downSum = sum(-min(mom, 0), length)
            //    out = (upSum - downSum) / (upSum + downSum)
            //    out

            //cmo = abs(getCMO(src, length))

            //alpha = 2 / (length + 1)

            //vidya = 0.0
            //vidya:= src * alpha * cmo + nz(vidya[1]) * (1 - alpha * cmo)

            //vidyaColor = highlightMovements ? (vidya > vidya[1] ? green : red) : #6d1e7f
            //plot(vidya, title = "VIDYA", linewidth = 2, color = vidyaColor, transp = 0)
            List<decimal> vidyaList = new();
            List<Signal> signalsList = new();

            try
            {
                decimal alpha = (decimal)2 / (days + 1);

                var cmoList = CalculateChandeMomentumOscillator(stockDataClass, maType, days).Item5;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal currentCmo = Math.Abs(cmoList.ElementAtOrDefault(i) / 100);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal prevVidya = vidyaList.LastOrDefault();
                    decimal currentVidya = (currentValue * alpha * currentCmo) + (prevVidya * (1 - (alpha * currentCmo)));
                    vidyaList.Add(currentVidya);

                    var signal = GetCompareSignal(currentValue - currentVidya, prevValue - prevVidya);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (vidyaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>)
            CalculateChandeVolatilityIndexDynamicAverageIndicator(StockData stockDataClass, string maType, int days = 20)
        {
            //input = user defined, default is close
            //period = user defined, default is 20
            //alpha1 = user defined, default is .2
            //alpha2 = user defined, default is .04
            //prev = previous, index = current bar number
            //std = stdDev = standard deviation

            //stdDev = std(index, period, input);
            //avStdDev = ma(method, index, period, stdDev);
            //prevVidya1 = isNull(price, vidya1[index - 1]); //feedback
            //prevVidya2 = isNull(price, vidya2[index - 1]); //feedback
            //ratio = stdDev / avStdDev;
            //Plot1: vidya1 = (alpha1 * ratio * price) + ((1 - (alpha1 * ratio)) * prevVidya1);
            //Plot2: vidya2 = (alpha2 * ratio * price) + ((1 - (alpha2 * ratio)) * prevVidya2);
            List<decimal> vidya1List = new();
            List<decimal> vidya2List = new();
            List<decimal> ratioList = new();
            List<decimal> stdDevEmaList = new();
            List<Signal> signalsList = new();
            decimal alpha1 = 0.2m, alpha2 = 0.04m;

            try
            {
                List<decimal> stdDevList = CalculateStandardDeviationVolatility(null, stockDataClass, days).Item4;
                stdDevEmaList = GetMovingAverageList(maType, stdDevList, stockDataClass, days);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal currentStdDev = stdDevList.ElementAtOrDefault(i);
                    decimal currentStdDevEma = stdDevEmaList.ElementAtOrDefault(i);
                    decimal prevVidya1 = i >= 1 ? vidya1List.LastOrDefault() : currentValue;
                    decimal prevVidya2 = i >= 1 ? vidya2List.LastOrDefault() : currentValue;
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal ratio = currentStdDevEma != 0 ? currentStdDev / currentStdDevEma : 0;
                    ratioList.Add(ratio);

                    decimal vidya1 = (alpha1 * ratio * currentValue) + ((1 - (alpha1 * ratio)) * prevVidya1);
                    vidya1List.Add(vidya1);

                    decimal vidya2 = (alpha2 * ratio * currentValue) + ((1 - (alpha2 * ratio)) * prevVidya2);
                    vidya2List.Add(vidya2);

                    var signal = GetBullishBearishSignal(currentValue - Math.Max(vidya1, vidya2), prevValue - Math.Max(prevVidya1, prevVidya2),
                        currentValue - Math.Min(vidya1, vidya2), prevValue - Math.Min(prevVidya1, prevVidya2));
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (stdDevEmaList, ratioList, vidya1List, vidya2List, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>)
            CalculateAlligatorIndex(StockData stockDataClass, string maType, int days = 3)
        {
            // //input = price, user defined, default is Midpoint
            //method = moving average (ma), user defined, default is SMMA
            //jawPeriod = user defined, default is 13
            //jawShift = user defined, default is 8
            //teethPeriod = user defined, default is 8
            //teethShift = user defined, default is 5
            //lipsPeriod = user defined, default is 5
            //lipsShift = user defined, default is 3
            //index = current bar number, abs = absolute value
            //jaw = ma(method, index + jawShift, input, jawPeriod); 
            //teeth = ma(method, index + teethShift, input, teethPeriod);
            //lips = ma(method, index + lipsShift, input, lipsPeriod);
            //PlotHist1: top = Math.abs(jaw - teeth);
            //PlotHist2: bottom = -Math.abs(teeth - lips);
            //min = Math.min(Math.min(cJaw, cTeeth), cLips);
            //max = Math.max(Math.max(cJaw, cTeeth), cLips);
            //mid = (max + min) * .5;
            //minL = min - (fac * min / 100);
            //if (minL moreThan mid) minL = mid;
            //maxH = max + (fac * max / 100);
            //if (maxH lessThan mid) maxH = mid;
            //Plot4: maxH; ;
            //Plot5: minL;
            decimal fac = 1;
            List<decimal> topList = new();
            List<decimal> bottomList = new();
            List<decimal> minList = new();
            List<decimal> maxList = new();
            List<decimal> midList = new();
            List<decimal> minLList = new();
            List<decimal> maxHList = new();
            List<decimal> displacedJawList = new();
            List<decimal> displacedTeethList = new();
            List<decimal> displacedLipsList = new();
            List<Signal> signalsList = new();

            try
            {
                int lipsPeriod = (int)Math.Ceiling(days / 0.6);
                int teethShift = lipsPeriod;
                int teethPeriod = (int)Math.Ceiling(days / 0.375);
                int jawShift = teethPeriod;
                int jawPeriod = (int)Math.Ceiling(days / 0.2308);
                int lipsShift = days;

                var jawList = GetMovingAverageList(maType, null, stockDataClass, jawPeriod);
                var teethList = GetMovingAverageList(maType, null, stockDataClass, teethPeriod);
                var lipsList = GetMovingAverageList(maType, null, stockDataClass, lipsPeriod);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentLips = lipsList.ElementAtOrDefault(i);
                    decimal currentTeeth = teethList.ElementAtOrDefault(i);
                    decimal currentJaw = jawList.ElementAtOrDefault(i);
                    decimal prevLips = i >= 1 ? lipsList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevTeeth = i >= 1 ? teethList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevJaw = i >= 1 ? jawList.ElementAtOrDefault(i - 1) : 0;

                    decimal displacedJaw = i >= jawShift ? jawList.ElementAtOrDefault(i - jawShift) : 0;
                    displacedJawList.Add(displacedJaw);

                    decimal displacedTeeth = i >= teethShift ? teethList.ElementAtOrDefault(i - teethShift) : 0;
                    displacedTeethList.Add(displacedTeeth);

                    decimal displacedLips = i >= lipsShift ? lipsList.ElementAtOrDefault(i - lipsShift) : 0;
                    displacedLipsList.Add(displacedLips);

                    decimal top = Math.Abs(displacedJaw - displacedTeeth);
                    topList.Add(top);

                    decimal bottom = Math.Abs(displacedTeeth - displacedLips) * -1;
                    bottomList.Add(bottom);

                    decimal min = Math.Min(Math.Min(currentJaw, currentTeeth), currentLips);
                    minList.Add(min);

                    decimal max = Math.Max(Math.Max(currentJaw, currentTeeth), currentLips);
                    maxList.Add(max);

                    decimal mid = (max + min) * 0.5m;
                    midList.Add(mid);

                    decimal minL = Math.Min(min - (fac * min / 100), mid);
                    minLList.Add(minL);

                    decimal maxH = Math.Max(max + (fac * max / 100), mid);
                    maxHList.Add(maxH);

                    var signal = GetBullishBearishSignal(currentLips - Math.Max(currentJaw, currentTeeth), prevLips - Math.Max(prevJaw, prevTeeth),
                        currentLips - Math.Min(currentJaw, currentTeeth), prevLips - Math.Min(prevJaw, prevTeeth));
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (displacedJawList, displacedTeethList, displacedLipsList, topList, bottomList, minList, maxList, midList, minLList, maxHList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateTradeVolumeIndex(StockData stockDataClass, int days)
        {
            // Change = Price - Last price
            //MTV = Minimum Tick Value

            //If change is greater than MTV, then Direction = Accumulate.
            //If change is less than - MTV, then Direction = Distribute.
            //If change is less than or equal to MTV and change is greater than or equal to - MTV, then Direction = Last Direction.

            //After determining the trend, one can calculate the Trade Volume Index by using the following formula:

            //If direction is accumulate then: TVI = TVI + Today's Volume
            //If Direction is Distribute then: TVI = Previous TVI – Today’s Volume
            decimal minimumTickValue = 0.5m, negMinimumTickValue = -0.5m;
            List<decimal> tviList = new();
            List<decimal> tviSignalList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentPrice = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal currentVolume = stockDataClass.Volumes.ElementAtOrDefault(i);
                    decimal prevPrice = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal priceChange = currentPrice - prevPrice;

                    decimal prevTvi = tviList.LastOrDefault();
                    decimal tvi = priceChange > minimumTickValue ? prevTvi + currentVolume : priceChange < negMinimumTickValue ? prevTvi - currentVolume : prevTvi;
                    tviList.Add(tvi);

                    decimal prevTviSignal = tviSignalList.LastOrDefault();
                    decimal tviSignal = tviList.TakeLast(days).Average();
                    tviSignalList.Add(tviSignal);

                    var signal = GetCompareSignal(tvi - tviSignal, prevTvi - prevTviSignal);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (tviList, tviSignalList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateVerticalHorizontalFilter(StockData stockDataClass, int days = 14)
        {
            //@version=3
            // Copyright (c) 2018-present, Alex Orekhov (everget)
            // Vertical Horizontal Filter script may be freely distributed under the MIT license.
            //study("Vertical Horizontal Filter", shorttitle = "VHF")

            //length = input(title = "Length", type = integer, defval = 28)
            //src = input(title = "Source", type = source, defval = close)

            //vhf = abs(highest(src, length) - lowest(src, length)) / sum(abs(change(src)), length)

            //vhfColor = vhf >= vhf[1] ? #0ebb23 : red

            //plot(vhf, title = "VHF", color = vhfColor, transp = 0)
            List<decimal> vhfList = new();
            List<decimal> changeList = new();
            List<decimal> vhfEmaList = new();
            List<Signal> signalsList = new();

            try
            {
                int signalPeriod = days;
                int length = days * 2;

                var emaList = CalculateExponentialMovingAverage(stockDataClass, length).Item1;
                var minMaxList = GetMaxAndMinValuesList(stockDataClass.InputValues, length);
                var highestList = minMaxList.Item1;
                var lowestList = minMaxList.Item2;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentEma = emaList.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal highestPrice = highestList.ElementAtOrDefault(i);
                    decimal lowestPrice = lowestList.ElementAtOrDefault(i);
                    decimal numerator = Math.Abs(highestPrice - lowestPrice);
                    decimal prevEma = i >= 1 ? emaList.ElementAtOrDefault(i - 1) : 0;

                    decimal priceChange = Math.Abs(currentValue - prevValue);
                    changeList.Add(priceChange);

                    decimal denominator = changeList.TakeLast(length).Sum();

                    decimal vhf = denominator != 0 ? numerator / denominator : 0;
                    vhfList.Add(vhf);

                    decimal vhfEma = CalculateExponentialMovingAverage(vhf, vhfEmaList.LastOrDefault(), signalPeriod);
                    vhfEmaList.Add(vhfEma);

                    var signal = GetVolatilitySignal(currentValue - currentEma, prevValue - prevEma, vhf, vhfEma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (vhfList, vhfEmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<decimal>, List<decimal>, List<Signal>) CalculateVervoortSmoothedOscillator(StockData stockDataClass, string maType, int days = 2)
        {
            //
            // @author LazyBear 
            // List of all my indicators: https://www.tradingview.com/v/4IneGo8h/
            //
            //study(title = "Vervoort Smoothed Oscillator [LazyBear]", shorttitle = "SV%BStoch_LB")
            //lengthStdev = input(18, title = "StdDev lookback")
            //mult = input(2.0, title = "StDev Mult Factor")
            //smooth = input(3, title = "calc_tema smoothing")
            //periodK = input(30, title = "PeriodK")
            //smoothK = input(3, title = "SmoothK")

            //calc_tema(src, length) =>
            //    e1 = ema(src, length)
            //    e2 = ema(e1, length)
            //    e3 = ema(e2, length)
            //    3 * (e1 - e2) + e3

            //sma2 = sma(close, 2)
            //dsma2 = sma(sma2, 2)
            //tsma2 = sma(dsma2, 2)
            //qsma2 = sma(tsma2, 2)
            //psma2 = sma(qsma2, 2)
            //ssma2 = sma(psma2, 2)
            //s2sma2 = sma(ssma2, 2)
            //osma2 = sma(s2sma2, 2)
            //o2sma2 = sma(osma2, 2)
            //desma2 = sma(o2sma2, 2)
            //rainbow = (5 * sma2 + 4 * dsma2 + 3 * tsma2 + 2 * qsma2 + psma2 + ssma2 + s2sma2 + osma2 + o2sma2 + desma2) / 20
            //ema1 = ema(rainbow, smooth)
            //ema2 = ema(ema1, smooth)
            //zlrb = 2 * ema1 - ema2
            //tz = calc_tema(zlrb, smooth)
            //hwidth = stdev(tz, lengthStdev)
            //zlrbpercb = (tz + mult * hwidth - wma(tz, lengthStdev)) / (2 * mult * hwidth) * 100
            //rbc = avg(rainbow, hlc3)
            //nom = rbc - lowest(low, periodK)
            //den = highest(high, periodK) - lowest(rbc, periodK)
            //fastK = 100*nom/den // No Stoch clipping version
            //fastK = min(100, max(0, 100 * nom / den))

            //hline(0)
            //hline(50)
            //hline(100)

            //slowKOBLevel = input(80)
            //slowKOSLevel = input(20)
            //sk = sma(fastK, smoothK)
            //bs = (sk > slowKOBLevel) ? slowKOBLevel : sk
            //us = (sk < slowKOSLevel) ? slowKOSLevel : sk
            //bl = plot(bs, color = red, style = circles, linewidth = 0)
            //ul = plot(us, color = red, style = circles, linewidth = 0)
            //tl = plot(sk, title = "SlowK", color = red, linewidth = 2)
            //fill(bl, tl, color = red, transp = 90)
            //fill(ul, tl, color = blue, transp = 90)
            //plot(zlrbpercb, title = "Zero Lag Rainbow %B", color = blue, linewidth = 2)
            decimal mult = 2;
            List<decimal> rainbowList = new();
            List<decimal> ema1List = new();
            List<decimal> ema2List = new();
            List<decimal> zlrbList = new();
            List<decimal> tzList = new();
            List<decimal> hwidthList = new();
            List<decimal> wmatzList = new();
            List<decimal> zlrbpercbList = new();
            List<decimal> rbcList = new();
            List<decimal> nomList = new();
            List<decimal> denList = new();
            List<decimal> fastKList = new();
            List<decimal> skList = new();
            List<decimal> tempHighList = new();
            List<decimal> tempLowList = new();
            List<decimal> skEmaList = new();
            List<Signal> signalsList = new();

            try
            {
                int smoothPeriod = MinOrMax((int)Math.Ceiling(days / 0.667));
                int lengthStdev = MinOrMax(days * 9);
                int periodK = MinOrMax(days * 15);

                var typicalPriceList = CalculateTypicalPrice(stockDataClass).Item1;
                var r1List = GetMovingAverageList(maType, null, stockDataClass, days);
                var r2List = GetMovingAverageList(maType, r1List, stockDataClass, days);
                var r3List = GetMovingAverageList(maType, r2List, stockDataClass, days);
                var r4List = GetMovingAverageList(maType, r3List, stockDataClass, days);
                var r5List = GetMovingAverageList(maType, r4List, stockDataClass, days);
                var r6List = GetMovingAverageList(maType, r5List, stockDataClass, days);
                var r7List = GetMovingAverageList(maType, r6List, stockDataClass, days);
                var r8List = GetMovingAverageList(maType, r7List, stockDataClass, days);
                var r9List = GetMovingAverageList(maType, r8List, stockDataClass, days);
                var r10List = GetMovingAverageList(maType, r9List, stockDataClass, days);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal r1 = r1List.ElementAtOrDefault(i);
                    decimal r2 = r2List.ElementAtOrDefault(i);
                    decimal r3 = r3List.ElementAtOrDefault(i);
                    decimal r4 = r4List.ElementAtOrDefault(i);
                    decimal r5 = r5List.ElementAtOrDefault(i);
                    decimal r6 = r6List.ElementAtOrDefault(i);
                    decimal r7 = r7List.ElementAtOrDefault(i);
                    decimal r8 = r8List.ElementAtOrDefault(i);
                    decimal r9 = r9List.ElementAtOrDefault(i);
                    decimal r10 = r10List.ElementAtOrDefault(i);

                    decimal rainbow = ((5 * r1) + (4 * r2) + (3 * r3) + (2 * r4) + r5 + r6 + r7 + r8 + r9 + r10) / 20;
                    rainbowList.Add(rainbow);

                    decimal ema1 = CalculateExponentialMovingAverage(rainbow, ema1List.LastOrDefault(), smoothPeriod);
                    ema1List.Add(ema1);

                    decimal ema2 = CalculateExponentialMovingAverage(ema1, ema2List.LastOrDefault(), smoothPeriod);
                    ema2List.Add(ema2);

                    decimal zlrb = (2 * ema1) - ema2;
                    zlrbList.Add(zlrb);
                }

                tzList = GetMovingAverageList("TripleExponentialMovingAverage", zlrbList, stockDataClass, smoothPeriod);
                hwidthList = CalculateStandardDeviationVolatility(tzList, stockDataClass, lengthStdev).Item4;
                wmatzList = GetMovingAverageList("WeightedMovingAverage", tzList, stockDataClass, lengthStdev);
                for (int j = 0; j < tzList.Count; j++)
                {
                    decimal currentTypicalPrice = typicalPriceList.ElementAtOrDefault(j);
                    decimal rainbow = rainbowList.ElementAtOrDefault(j);
                    decimal tz = tzList.ElementAtOrDefault(j);
                    decimal hwidth = hwidthList.ElementAtOrDefault(j);
                    decimal wmatz = wmatzList.ElementAtOrDefault(j);
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(j);

                    decimal currentHigh = Math.Max(stockDataClass.HighPrices.ElementAtOrDefault(j), currentValue);
                    tempHighList.Add(currentHigh);

                    decimal currentLow = Math.Min(stockDataClass.LowPrices.ElementAtOrDefault(j), currentValue);
                    tempLowList.Add(currentLow);

                    decimal zlrbpercb = hwidth != 0 ? (tz + (mult * hwidth) - wmatz) / (2 * mult * hwidth * 100) : 0;
                    zlrbpercbList.Add(zlrbpercb);

                    decimal rbc = (rainbow + currentTypicalPrice) / 2;
                    rbcList.Add(rbc);

                    decimal lowest = tempLowList.TakeLast(periodK).Min();
                    decimal highest = tempHighList.TakeLast(periodK).Max();
                    decimal lowestRbc = rbcList.TakeLast(periodK).Min();

                    decimal nom = rbc - lowest;
                    nomList.Add(nom);

                    decimal den = highest - lowestRbc;
                    denList.Add(den);

                    decimal fastK = den != 0 ? MinOrMax(100 * nom / den, 100, 0) : 0;
                    fastKList.Add(fastK);

                    decimal prevSk = skList.LastOrDefault();
                    decimal sk = fastKList.TakeLast(smoothPeriod).Average();
                    skList.Add(sk);

                    decimal prevSkEma = skEmaList.LastOrDefault();
                    decimal skEma = CalculateExponentialMovingAverage(sk, prevSkEma, smoothPeriod);
                    skEmaList.Add(skEma);

                    var signal = GetRsiSignal(sk - skEma, prevSk - prevSkEma, sk, prevSk, 80, 20);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (rainbowList, ema1List, ema2List, zlrbList, tzList, hwidthList, wmatzList, zlrbpercbList, nomList, denList, fastKList, skList, skEmaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateVervoortModifiedBollingerBandIndicator(StockData stockDataClass, string maType, int days = 8)
        {
            //
            // @author LazyBear 
            // List of all my indicators: 
            // https://docs.google.com/document/d/15AGCufJZ8CIUvwFJ9W-IKns88gkWOKBCvByMEvm5MLo/edit?usp=sharing
            //
            //study("Vervoort Modified BB%b [LazyBear]", shorttitle = "VMBB%b_LB")
            //calc_tema(s, length) =>
            //    ema1 = ema(s, length)
            //    ema2 = ema(ema1, length)
            //    ema3 = ema(ema2, length)
            //    3 * (ema1 - ema2) + ema3

            //length = input(18, minval = 2, maxval = 100, title = "%B Length")
            //temaLength = input(8, title = "TEMA Length")
            //stdevHigh = input(1.6, title = "Stdev High")
            //stdevLow = input(1.6, title = "Stdev Low")
            //stdevLength = input(200, title = "Stdev Length")
            //haOpen = (ohlc4[1] + nz(haOpen[1])) / 2
            //haC = (ohlc4 + haOpen + max(high, haOpen) + min(low, haOpen)) / 4

            //tma1 = calc_tema(haC, temaLength)
            //tma2 = calc_tema(tma1, temaLength)
            //diff = tma1 - tma2
            //zlha = tma1 + diff
            //percb = (calc_tema(zlha, temaLength) + 2 * stdev(calc_tema(zlha, temaLength), length) - wma(calc_tema(zlha, temaLength), length)) / (4 * stdev(calc_tema(zlha, temaLength), length)) * 100

            //ub = 50 + stdevHigh * stdev(percb, stdevLength)
            //lb = 50 - stdevLow * stdev(percb, stdevLength)
            //ul = plot(ub, color = red, title = "Stdev+")
            //ll = plot(lb, color = green, title = "Stdev-")
            //plot((ub + lb) / 2, color = blue, style = 3, title = "Stdev Mid")
            //fill(ul, ll, red)
            //plot(percb, linewidth = 2, color = maroon, title = "SVE %b")
            decimal stdevLow = 1.6m, stdevHigh = 1.6m;
            List<decimal> haOpenList = new();
            List<decimal> hacList = new();
            List<decimal> tma2List = new();
            List<decimal> zlhaTemaList = new();
            List<decimal> zlhaTemaStdDevList = new();
            List<decimal> wmaZlhaTemaList = new();
            List<decimal> diffList = new();
            List<decimal> zlhaList = new();
            List<decimal> percbList = new();
            List<decimal> percbStdDevList = new();
            List<decimal> ubList = new();
            List<decimal> lbList = new();
            List<decimal> percbSignalList = new();
            List<Signal> signalsList = new();

            try
            {
                int length = MinOrMax((int)Math.Ceiling(days / 0.4444));
                int stdDevLength = MinOrMax(length * 11);

                for (int i = 0; i < stockDataClass.HighPrices.Count; i++)
                {
                    decimal currentHigh = stockDataClass.HighPrices.ElementAtOrDefault(i);
                    decimal currentLow = stockDataClass.LowPrices.ElementAtOrDefault(i);
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevOhlc = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal prevHaOpen = haOpenList.LastOrDefault();
                    decimal haOpen = (prevOhlc + prevHaOpen) / 2;
                    haOpenList.Add(haOpen);

                    decimal haC = (currentValue + haOpen + Math.Max(currentHigh, haOpen) + Math.Min(currentLow, haOpen)) / 4;
                    hacList.Add(haC);
                }

                var tma1List = GetMovingAverageList(maType, hacList, stockDataClass, days);
                tma2List = GetMovingAverageList(maType, tma1List, stockDataClass, days);
                for (int k = 0; k < stockDataClass.InputValues.Count; k++)
                {
                    decimal tma1 = tma1List.ElementAtOrDefault(k);
                    decimal tma2 = tma2List.ElementAtOrDefault(k);

                    decimal diff = tma1 - tma2;
                    diffList.Add(diff);

                    decimal zlha = tma1 + diff;
                    zlhaList.Add(zlha);
                }

                zlhaTemaList = GetMovingAverageList(maType, zlhaList, stockDataClass, days);
                zlhaTemaStdDevList = CalculateStandardDeviationVolatility(zlhaTemaList, stockDataClass, length).Item4;
                wmaZlhaTemaList = GetMovingAverageList("WeightedMovingAverage", zlhaTemaList, stockDataClass, length);
                for (int l = 0; l < stockDataClass.InputValues.Count; l++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(l);
                    decimal zlhaTema = zlhaTemaList.ElementAtOrDefault(l);
                    decimal zlhaTemaStdDev = zlhaTemaStdDevList.ElementAtOrDefault(l);
                    decimal wmaZlhaTema = wmaZlhaTemaList.ElementAtOrDefault(l);

                    decimal percb = zlhaTemaStdDev != 0 ? (zlhaTema + (2 * zlhaTemaStdDev) - wmaZlhaTema) / (4 * zlhaTemaStdDev) * 100 : 0;
                    percbList.Add(percb);
                }

                percbStdDevList = CalculateStandardDeviationVolatility(percbList, stockDataClass, stdDevLength).Item4;
                for (int m = 0; m < stockDataClass.InputValues.Count; m++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(m);
                    decimal percbStdDev = percbStdDevList.ElementAtOrDefault(m);
                    decimal prevValue = m >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(m - 1) : 0;

                    decimal ub = 50 + (stdevHigh * percbStdDev);
                    ubList.Add(ub);

                    decimal lb = 50 - (stdevLow * percbStdDev);
                    lbList.Add(lb);

                    decimal prevPercbSignal = percbSignalList.LastOrDefault();
                    decimal percbSignal = (ub + lb) / 2;
                    percbSignalList.Add(percbSignal);

                    var signal = GetCompareSignal(currentValue - percbSignal, prevValue - prevPercbSignal);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (tma2List, diffList, zlhaList, zlhaTemaList, zlhaTemaStdDevList, wmaZlhaTemaList, percbList, percbStdDevList, ubList, lbList, percbSignalList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateVervoortVolatilityBands(StockData stockDataClass, string maType,
            int days = 8)
        {
            //
            // @author LazyBear 
            // List of all my indicators: 
            // https://docs.google.com/document/d/15AGCufJZ8CIUvwFJ9W-IKns88gkWOKBCvByMEvm5MLo/edit?usp=sharing
            //
            //study("Vervoort Volatility Bands [LazyBear]", shorttitle = "VVB_LB", overlay = true)
            //src = hlc3
            //al = input(8, title = "Average Length")
            //vl = input(13, title = "Volatility Length")
            //df = input(3.55, "Deviation Multiplier")
            //lba = input(0.9, "Lower Band Adjustment Multiplier")

            //typical = src >= src[1] ? src - low[1] : src[1] - low
            //deviation = df * sma(typical, vl)
            //devHigh = ema(deviation, al)
            //devLow = lba * devHigh
            //medianAvg = ema(src, al)

            //MidLine = plot(sma(medianAvg, al), color = gray, title = "MidLine")
            //UpperBand = plot(ema(medianAvg, al) + devHigh, color = red, linewidth = 2, title = "UpperBand")
            //LowerBand = plot(ema(medianAvg, al) - devLow, color = green, linewidth = 2, title = "LowerBand")
            decimal df = 3.55m, lba = 0.9m;
            List<decimal> typicalList = new();
            List<decimal> deviationList = new();
            List<decimal> devHighList = new();
            List<decimal> devLowList = new();
            List<decimal> typicalSmaList = new();
            List<decimal> midList = new();
            List<decimal> ubList = new();
            List<decimal> lbList = new();
            List<decimal> tempList = new();
            List<decimal> medianAvgSmaList = new();
            List<Signal> signalsList = new();

            try
            {
                int al = days;
                int vl = MinOrMax((int)Math.Ceiling(al / 0.6154));

                var medianAvgList = GetMovingAverageList(maType, null, stockDataClass, al);
                var medianAvgEmaList = GetMovingAverageList(maType, medianAvgList, stockDataClass, al);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal medianAvg = medianAvgList.ElementAtOrDefault(i);
                    tempList.Add(medianAvg);

                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal currentLow = stockDataClass.LowPrices.ElementAtOrDefault(i);
                    decimal prevLow = i >= 1 ? stockDataClass.LowPrices.ElementAtOrDefault(i - 1) : 0;
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal typical = currentValue >= prevValue ? currentValue - prevLow : prevValue - currentLow;
                    typicalList.Add(typical);

                    decimal typicalSma = typicalList.TakeLast(vl).Average();
                    typicalSmaList.Add(typicalSma);

                    decimal deviation = df * typicalSma;
                    deviationList.Add(deviation);

                    decimal medianAvgSma = tempList.TakeLast(al).Average();
                    medianAvgSmaList.Add(medianAvgSma);
                }

                devHighList = GetMovingAverageList(maType, deviationList, stockDataClass, al);
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal devHigh = devHighList.ElementAtOrDefault(j);
                    decimal midline = medianAvgSmaList.ElementAtOrDefault(j);
                    decimal medianAvgEma = medianAvgEmaList.ElementAtOrDefault(j);
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(j);
                    decimal prevValue = j >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(j - 1) : 0;
                    decimal prevMidline = j >= 1 ? medianAvgSmaList.ElementAtOrDefault(j - 1) : 0;

                    decimal devLow = lba * devHigh;
                    devLowList.Add(devLow);

                    decimal prevUb = ubList.LastOrDefault();
                    decimal ub = medianAvgEma + devHigh;
                    ubList.Add(ub);

                    decimal prevLb = lbList.LastOrDefault();
                    decimal lb = medianAvgEma - devLow;
                    lbList.Add(lb);

                    var signal = GetBollingerBandsSignal(currentValue - midline, prevValue - prevMidline, currentValue, prevValue, ub, prevUb, lb, prevLb);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (typicalSmaList, deviationList, devHighList, devLowList, midList, medianAvgSmaList, ubList, lbList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateSmoothedVolatilityBands(StockData stockDataClass, string maType, int days = 20)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Smoothed Volatility Bands [CC] script may be freely distributed under the MIT license.
            //study("Smoothed Volatility Bands [CC]", overlay = true)

            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //inp = input(title = "Source", type = input.source, defval = close)
            //src = security(syminfo.tickerid, res, inp[rep ? 0 : barstate.isrealtime ? 1 : 0])[rep ? 0 : barstate.isrealtime ? 0 : 1]
            //length = input(title = "Length", type = input.integer, defval = 20, minval = 1)
            //middleBandLength = input(title = "MiddleBandLength", type = input.integer, defval = 21, minval = 1)
            //bandsDeviation = input(title = "BandsDeviation", type = input.float, defval = 2.4, minval = 0.1)
            //lowBandAdjust = input(title = "LowBandAdjust", type = input.float, defval = 0.9, minval = 0.1)

            //atrPeriod = (length * 2) - 1
            //atrBuf = atr(atrPeriod) * bandsDeviation
            //ma = ema(src, length)

            //upperBand = ma + (ma * atrBuf / src)
            //middleBand = ema(src, middleBandLength)
            //lowerBand = ma - (ma * atrBuf * lowBandAdjust / src)

            //sig = (src > upperBand and nz(src[1]) <= nz(upperBand[1])) or(src > lowerBand and nz(src[1]) <= nz(lowerBand[1])) or src > middleBand ? 1 :
            //     (src < lowerBand and nz(src[1]) >= nz(lowerBand[1])) or(src < upperBand and nz(src[1]) >= nz(upperBand[1])) or src<middleBand ? -1 : 0
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //svbColor = sig > 0 ? color.green : sig < 0 ? color.red : color.black
            //barcolor(bar ? svbColor : na)
            //plot(upperBand, title = "SVBUp", color = svbColor, linewidth = 2)
            //plot(middleBand, title = "SVBMid", color = color.black, linewidth = 1)
            //plot(lowerBand, title = "SVBLow", color = svbColor, linewidth = 2)
            List<decimal> atrBufList = new();
            List<decimal> upperBandList = new();
            List<decimal> lowerBandList = new();
            List<Signal> signalsList = new();

            try
            {
                int length = days;
                int middleBandLength = (int)Math.Ceiling(days / 0.9524);
                int atrPeriod = (length * 2) - 1;
                decimal bandsDeviation = 2.4m, lowBandAdjust = 0.9m;

                var atrList = CalculateAverageTrueRange(stockDataClass, maType, atrPeriod).Item1;
                var maList = GetMovingAverageList(maType, null, stockDataClass, length);
                var middleBandList = GetMovingAverageList(maType, null, stockDataClass, middleBandLength);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal atr = atrList.ElementAtOrDefault(i);
                    decimal middleBand = middleBandList.ElementAtOrDefault(i);
                    decimal ma = maList.ElementAtOrDefault(i);
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevMiddleBand = i >= 1 ? middleBandList.ElementAtOrDefault(i - 1) : 0;

                    decimal atrBuf = atr * bandsDeviation;
                    atrBufList.Add(atrBuf);

                    decimal prevUpperBand = upperBandList.LastOrDefault();
                    decimal upperBand = currentValue != 0 ? ma + (ma * atrBuf / currentValue) : ma;
                    upperBandList.Add(upperBand);

                    decimal prevLowerBand = lowerBandList.LastOrDefault();
                    decimal lowerBand = currentValue != 0 ? ma - (ma * atrBuf * lowBandAdjust / currentValue) : ma;
                    lowerBandList.Add(lowerBand);

                    var signal = GetBollingerBandsSignal(currentValue - middleBand, prevValue - prevMiddleBand, currentValue, prevValue, upperBand, prevUpperBand, lowerBand, prevLowerBand);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (atrBufList, upperBandList, lowerBandList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateRateOfChangeBands(StockData stockDataClass, string maType, int days = 3)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // Rate Of Change Bands [CC] script may be freely distributed under the MIT license.
            //study("Rate Of Change Bands [CC]", overlay = false)

            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //inp = input(title = "Source", type = input.source, defval = close)
            //src = security(syminfo.tickerid, res, inp[rep ? 0 : barstate.isrealtime ? 1 : 0])[rep ? 0 : barstate.isrealtime ? 0 : 1]
            //length = input(title = "Length", type = input.integer, defval = 12, minval = 1)
            //smoothLength = input(title = "SmoothLength", type = input.integer, defval = 3, minval = 1)

            //rocVal = roc(src, length)
            //sqAvg = sum(pow(rocVal, 2), length) / length

            //upperBand = sqAvg >= 0 ? sqrt(sqAvg) : 0
            //middleBand = ema(rocVal, smoothLength)
            //lowerBand = -upperBand

            //sig = (middleBand > upperBand and nz(middleBand[1]) <= nz(upperBand[1])) or(middleBand > lowerBand and nz(middleBand[1]) <= nz(lowerBand[1]))
            //      ? 1 : (middleBand < lowerBand and nz(middleBand[1]) >= nz(lowerBand[1])) or(middleBand < upperBand and nz(middleBand[1]) >= nz(upperBand[1]))
            //      ? -1 : middleBand > 0 ? 1 : middleBand < 0 ? -1 : 0
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //rocbColor = sig > 0 ? color.green : sig < 0 ? color.red : color.black
            //barcolor(bar ? rocbColor : na)
            //plot(upperBand, title = "ROCBBUp", color = rocbColor, linewidth = 2)
            //plot(middleBand, title = "ROCBMid", color = color.black, linewidth = 1)
            //plot(lowerBand, title = "ROCBLow", color = rocbColor, linewidth = 2)
            List<decimal> rocSquaredList = new();
            List<decimal> squaredSumList = new();
            List<decimal> upperBandList = new();
            List<decimal> lowerBandList = new();
            List<decimal> squaredAvgList = new();
            List<Signal> signalsList = new();

            try
            {
                int smoothLength = days;
                int length = days * 4;

                var rocList = CalculateRateOfChange(null, stockDataClass, length).Item1;
                var middleBandList = GetMovingAverageList(maType, rocList, stockDataClass, smoothLength);

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal roc = rocList.ElementAtOrDefault(i);
                    decimal middleBand = middleBandList.ElementAtOrDefault(i);
                    decimal prevMiddleBand1 = i >= 1 ? middleBandList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevMiddleBand2 = i >= 2 ? middleBandList.ElementAtOrDefault(i - 2) : 0;

                    decimal rocSquared = Pow(roc, 2);
                    rocSquaredList.Add(rocSquared);

                    decimal squaredSum = rocSquaredList.TakeLast(length).Sum();
                    squaredSumList.Add(squaredSum);

                    decimal squaredAvg = squaredSum / length;
                    squaredAvgList.Add(squaredAvg);

                    decimal prevUpperBand = upperBandList.LastOrDefault();
                    decimal upperBand = squaredAvg >= 0 ? Sqrt(squaredAvg) : 0;
                    upperBandList.Add(upperBand);

                    decimal prevLowerBand = lowerBandList.LastOrDefault();
                    decimal lowerBand = -upperBand;
                    lowerBandList.Add(lowerBand);

                    var signal = GetBollingerBandsSignal(middleBand - prevMiddleBand1, prevMiddleBand1 - prevMiddleBand2, middleBand, prevMiddleBand1, upperBand, prevUpperBand, lowerBand, prevLowerBand);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (rocSquaredList, squaredSumList, squaredAvgList, upperBandList, lowerBandList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateRSINGIndicator(StockData stockDataClass,
            string maType, int days = 20)
        {
            //@version=4
            // Copyright (c) 2019-present, Franklin Moormann (cheatcountry)
            // RSING Indicator [CC] script may be freely distributed under the MIT license.
            //study("RSING Indicator [CC]", overlay = false)

            //f_security(_symbol, _res, _src, _repaint) => 
            //    security(_symbol, _res, _src[_repaint ? 0 : barstate.isrealtime ? 1 : 0])[_repaint ? 0 : barstate.isrealtime ? 0 : 1]

            //res = input(title = "Resolution", type = input.resolution, defval = "")
            //rep = input(title = "Allow Repainting?", type = input.bool, defval = false)
            //bar = input(title = "Allow Bar Color Change?", type = input.bool, defval = true)
            //length = input(title = "Length", type = input.integer, defval = 20, minval = 1)
            //c = f_security(syminfo.tickerid, res, close, rep)
            //h = f_security(syminfo.tickerid, res, high, rep)
            //l = f_security(syminfo.tickerid, res, low, rep)
            //v = f_security(syminfo.tickerid, res, volume, rep)

            //ma = wma(v, length)
            //range = h - l
            //std = stdev(range, length)

            //vwr = ma != 0 ? v / ma : 0
            //blr = std != 0 ? range / std : 0
            //irr = mom(c, length)

            //rsing = wma(vwr * blr * irr, length)

            //slo = rsing - nz(rsing[1])
            //sig = slo > 0 ? slo > nz(slo[1]) ? 2 : 1 : slo < 0 ? slo < nz(slo[1]) ? -2 : -1 : 0
            //alertcondition(crossover(sig, 1), "Strong Buy Signal", "Strong Bullish Change Detected")
            //alertcondition(crossunder(sig, -1), "Strong Sell Signal", "Strong Bearish Change Detected")
            //alertcondition(crossover(sig, 0), "Buy Signal", "Bullish Change Detected")
            //alertcondition(crossunder(sig, 0), "Sell Signal", "Bearish Change Detected")
            //rsingColor = sig > 1 ? color.green : sig > 0 ? color.lime : sig < -1 ? color.maroon : sig < 0 ? color.red : color.black
            //barcolor(bar ? rsingColor : na)
            //plot(rsing, title = "RSING", color = rsingColor, linewidth = 2)
            List<decimal> vwrList = new();
            List<decimal> blrList = new();
            List<decimal> rsingList = new();
            List<decimal> rsingMaList = new();
            List<decimal> irrList = new();
            List<decimal> maxUpList = new();
            List<decimal> maxDnList = new();
            List<decimal> upList = new();
            List<decimal> dnList = new();
            List<decimal> rangeList = new();
            List<Signal> signalsList = new();

            try
            {
                int length = days;

                var maList = GetMovingAverageList(maType, stockDataClass.Volumes, stockDataClass, length);

                for (int h = 0; h < stockDataClass.InputValues.Count; h++)
                {
                    decimal high = stockDataClass.HighPrices.ElementAtOrDefault(h);
                    decimal low = stockDataClass.LowPrices.ElementAtOrDefault(h);

                    decimal range = high - low;
                    rangeList.Add(range);
                }

                var stdevList = CalculateStandardDeviationVolatility(rangeList, stockDataClass, length).Item4;
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentVolume = stockDataClass.Volumes.ElementAtOrDefault(i);
                    decimal ma = maList.ElementAtOrDefault(i);
                    decimal stdev = stdevList.ElementAtOrDefault(i);
                    decimal range = rangeList.ElementAtOrDefault(i);
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= length ? stockDataClass.InputValues.ElementAtOrDefault(i - length) : 0;

                    decimal vwr = ma != 0 ? currentVolume / ma : 0;
                    vwrList.Add(vwr);

                    decimal blr = stdev != 0 ? range / stdev : 0;
                    blrList.Add(blr);

                    bool isUp = currentValue > prevValue;
                    bool isDn = currentValue < prevValue;
                    bool isEq = currentValue == prevValue;

                    decimal prevUpCount = upList.LastOrDefault();
                    decimal upCount = isEq ? 0 : isUp ? (prevUpCount <= 0 ? 1 : prevUpCount + 1) : (prevUpCount >= 0 ? -1 : prevUpCount - 1);
                    upList.Add(upCount);

                    decimal prevDnCount = dnList.LastOrDefault();
                    decimal dnCount = isEq ? 0 : isDn ? (prevDnCount <= 0 ? 1 : prevDnCount + 1) : (prevDnCount >= 0 ? -1 : prevDnCount - 1);
                    dnList.Add(dnCount);

                    decimal maxUp = Math.Max(upCount, upList.TakeLast(length).Max());
                    maxUpList.Add(maxUp);

                    decimal maxDn = Math.Max(dnCount, dnList.TakeLast(length).Max());
                    maxDnList.Add(maxDn);

                    decimal pmo = currentValue - prevValue;
                    decimal irr = pmo > 0 && maxUp > 0 ? pmo / maxUp : pmo < 0 && maxDn > 0 ? pmo / maxDn : 0;
                    irrList.Add(irr);

                    decimal prevRsing = rsingList.LastOrDefault();
                    decimal rsing = vwr * blr * pmo;
                    rsingList.Add(rsing);
                }

                rsingMaList = GetMovingAverageList(maType, rsingList, stockDataClass, length);
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal rsing = rsingMaList.ElementAtOrDefault(j);
                    decimal prevRsing1 = j >= 1 ? rsingMaList.ElementAtOrDefault(j - 1) : 0;
                    decimal prevRsing2 = j >= 2 ? rsingMaList.ElementAtOrDefault(j - 2) : 0;

                    var signal = GetCompareSignal(rsing - prevRsing1, prevRsing1 - prevRsing2);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (vwrList, blrList, upList, dnList, maxUpList, maxDnList, irrList, rsingList, rsingMaList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>,
            List<decimal>, List<Signal>) CalculateVervoortHeikenAshiCandlestickOscillator(StockData stockDataClass, string maType, int days = 34)
        {
            //
            // @author LazyBear 
            // List of all my indicators: 
            // https://docs.google.com/document/d/15AGCufJZ8CIUvwFJ9W-IKns88gkWOKBCvByMEvm5MLo/edit?usp=sharing
            //
            //study("Vervoort Heiken Ashi Candlestick Oscillator [LazyBear]", shorttitle = "HACO_LB")
            //avgup = input(title = "Up TEMA Length", defval = 34, minval = 1, maxval = 100)
            //avgdn = input(title = "Down TEMA Length", defval = 34, minval = 1, maxval = 100)
            //overlayMode = input(defval = false, title = "Overlay mode (color bars)?")

            //calc_tema(src, length) =>
            //    ema1 = ema(src, length)
            //    ema2 = ema(ema1, length)
            //    ema3 = ema(ema2, length)
            //    3 * (ema1 - ema2) + ema3

            //calc_zltema(src, length) => 
            //    tma1 = calc_tema(src, length)
            //    tma2 = calc_tema(tma1, length)
            //    diff = tma1 - tma2
            //    tma1 + diff

            //haO = (ohlc4[1] + nz(haO[1])) / 2
            //haC = (ohlc4 + haO + max(high, haO) + min(low, haO)) / 4

            //upTMA1 = calc_zltema(haC, avgup)
            //upTMA2 = calc_zltema(upTMA1, avgup)
            //upDiff = upTMA1 - upTMA2
            //upZlHa = upTMA1 + upDiff
            //upTMA12 = calc_zltema(hl2, avgup)
            //upTMA22 = calc_zltema(upTMA12, avgup)
            //upDiff2 = upTMA12 - upTMA22
            //upZlCl = upTMA12 + upDiff2
            //upZlDiff = upZlCl - upZlHa
            //upKeep1 = (haC >= haO) and(haC[1] >= haO[1])
            //upKeep2 = upZlDiff >= 0
            //upKeeping = (upKeep1 or upKeep2)
            //upKeepAll = upKeeping or(nz(upKeeping[1]) and(close >= open) or close >= close[1])
            //upKeep3 = (abs(close - open) < (high - low) * 0.35 and high>= (low[1]))
            //upTrend = upKeepAll or(nz(upKeepAll[1]) and upKeep3)

            //dnTMA1 = calc_zltema(haC, avgdn)
            //dnTMA2 = calc_zltema(dnTMA1, avgdn)
            //dnDiff = dnTMA1 - dnTMA2
            //dnZlHa = dnTMA1 + dnDiff
            //dnTMA12 = calc_zltema(hl2, avgdn)
            //dnTMA22 = calc_zltema(dnTMA12, avgdn)
            //dnDiff2 = dnTMA12 - dnTMA22
            //dnZlCl = dnTMA12 + dnDiff2
            //dnZlDiff = dnZlCl - dnZlHa
            //dnKeep1 = haC < haO and(haC[1] < haO[1])
            //dnKeep2 = dnZlDiff < 0
            //dnKeep3 = abs(close - open) < (high - low) * 0.35 and low<= high[1]
            //dnKeeping = dnKeep1 or dnKeep2
            //dnKeepAll = dnKeeping or(nz(dnKeeping[1]) and(close < open) or(close < close[1]))
            //dnTrend = iff(dnKeepAll or(nz(dnKeepAll[1]) and dnKeep3) == 1, 1, 0)

            //upw = dnTrend == 0 and nz(dnTrend[1]) and upTrend
            //dnw = upTrend == 0 and nz(upTrend[1]) and dnTrend
            //haco = iff(upw, 1, iff(dnw, -1, nz(haco[1])))
            //haco_c = haco > 0 ? green : red

            //plot(not overlayMode ? haco : na, style = columns, color = haco_c)
            //barcolor(overlayMode ? haco_c : na)
            List<decimal> haoList = new();
            List<decimal> hacList = new();
            List<decimal> tma1List = new();
            List<decimal> tma2List = new();
            List<decimal> tma12List = new();
            List<decimal> tma22List = new();
            List<decimal> diffList = new();
            List<decimal> zlHaList = new();
            List<decimal> diff2List = new();
            List<decimal> zlClList = new();
            List<decimal> zlDiffList = new();
            List<decimal> medianPriceList = new();
            List<bool> dnKeepingList = new();
            List<bool> dnKeepAllList = new();
            List<bool> dnTrendList = new();
            List<bool> upKeepingList = new();
            List<bool> upKeepAllList = new();
            List<bool> upTrendList = new();
            List<decimal> hacoList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentHigh = stockDataClass.HighPrices.ElementAtOrDefault(i);
                    decimal currentLow = stockDataClass.LowPrices.ElementAtOrDefault(i);
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal prevHao = haoList.LastOrDefault();
                    decimal hao = (prevValue + prevHao) / 2;
                    haoList.Add(hao);

                    decimal hac = (currentValue + hao + Math.Max(currentHigh, hao) + Math.Min(currentLow, hao)) / 4;
                    hacList.Add(hac);

                    decimal medianPrice = (currentHigh + currentLow) / 2;
                    medianPriceList.Add(medianPrice);
                }

                tma1List = GetMovingAverageList(maType, hacList, stockDataClass, days);
                tma2List = GetMovingAverageList(maType, tma1List, stockDataClass, days);
                tma12List = GetMovingAverageList(maType, medianPriceList, stockDataClass, days);
                tma22List = GetMovingAverageList(maType, tma12List, stockDataClass, days);
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal tma1 = tma1List.ElementAtOrDefault(j);
                    decimal tma2 = tma2List.ElementAtOrDefault(j);
                    decimal tma12 = tma12List.ElementAtOrDefault(j);
                    decimal tma22 = tma22List.ElementAtOrDefault(j);
                    decimal hao = haoList.ElementAtOrDefault(j);
                    decimal hac = hacList.ElementAtOrDefault(j);
                    decimal currentHigh = stockDataClass.HighPrices.ElementAtOrDefault(j);
                    decimal currentLow = stockDataClass.LowPrices.ElementAtOrDefault(j);
                    decimal currentOpen = stockDataClass.OpenPrices.ElementAtOrDefault(j);
                    decimal currentClose = stockDataClass.ClosePrices.ElementAtOrDefault(j);
                    decimal prevHao = j >= 1 ? haoList.ElementAtOrDefault(j - 1) : 0;
                    decimal prevHac = j >= 1 ? hacList.ElementAtOrDefault(j - 1) : 0;
                    decimal prevHigh = j >= 1 ? stockDataClass.HighPrices.ElementAtOrDefault(j - 1) : 0;
                    decimal prevLow = j >= 1 ? stockDataClass.LowPrices.ElementAtOrDefault(j - 1) : 0;
                    decimal prevClose = j >= 1 ? stockDataClass.ClosePrices.ElementAtOrDefault(j - 1) : 0;

                    decimal diff = tma1 - tma2;
                    diffList.Add(diff);

                    decimal zlHa = tma1 + diff;
                    zlHaList.Add(zlHa);

                    decimal diff2 = tma12 - tma22;
                    diff2List.Add(diff2);

                    decimal zlCl = tma12 + diff2;
                    zlClList.Add(zlCl);

                    decimal zlDiff = zlCl - zlHa;
                    zlDiffList.Add(zlDiff);

                    bool dnKeep1 = hac < hao && prevHac < prevHao;
                    bool dnKeep2 = zlDiff < 0;
                    bool dnKeep3 = Math.Abs(currentClose - currentOpen) < (currentHigh - currentLow) * 0.35m && currentLow <= prevHigh;

                    bool prevDnKeeping = dnKeepingList.LastOrDefault();
                    bool dnKeeping = dnKeep1 || dnKeep2;
                    dnKeepingList.Add(dnKeeping);

                    bool prevDnKeepAll = dnKeepAllList.LastOrDefault();
                    bool dnKeepAll = (dnKeeping || prevDnKeeping) && ((currentClose < currentOpen) || (currentClose < prevClose));
                    dnKeepAllList.Add(dnKeepAll);

                    bool prevDnTrend = dnTrendList.LastOrDefault();
                    bool dnTrend = dnKeepAll || (prevDnKeepAll && dnKeep3);
                    dnTrendList.Add(dnTrend);

                    bool upKeep1 = hac >= hao && prevHac >= prevHao;
                    bool upKeep2 = zlDiff >= 0;
                    bool upKeep3 = Math.Abs(currentClose - currentOpen) < (currentHigh - currentLow) * 0.35m && currentHigh >= prevLow;

                    bool prevUpKeeping = upKeepingList.LastOrDefault();
                    bool upKeeping = upKeep1 || upKeep2;
                    upKeepingList.Add(upKeeping);

                    bool prevUpKeepAll = upKeepAllList.LastOrDefault();
                    bool upKeepAll = (upKeeping || prevUpKeeping) && ((currentClose >= currentOpen) || (currentClose >= prevClose));
                    upKeepAllList.Add(upKeepAll);

                    bool prevUpTrend = upTrendList.LastOrDefault();
                    bool upTrend = upKeepAll || (prevUpKeepAll && upKeep3);
                    upTrendList.Add(upTrend);

                    bool upw = dnTrend == false && prevDnTrend && upTrend;
                    bool dnw = upTrend == false && prevUpTrend && dnTrend;

                    decimal prevHaco = hacoList.LastOrDefault();
                    decimal haco = upw ? 1 : dnw ? -1 : prevHaco;
                    hacoList.Add(haco);

                    var signal = GetCompareSignal(haco, prevHaco);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (haoList, hacList, tma1List, tma2List, tma12List, tma22List, diffList, zlHaList, diff2List, zlClList, zlDiffList, hacoList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>)
            CalculateRetrospectiveCandlestickChart(StockData stockDataClass, int days = 100)
        {
            //@version=2
            //study("Retrospective Candlestick Chart", overlay = true)
            //length = input(100)
            //
            //s(x) =>
            //    s = stoch(x, x, x, length) / 100
            //
            //weight = s(abs(change(close)))
            //c = weight * close + (1 - weight) * nz(c[1], close)
            //h = weight * high + (1 - weight) * nz(c[1], high)
            //l = weight * low + (1 - weight) * nz(c[1], low)
            //o = weight * open + (1 - weight) * nz(c[1], open)
            //k = (c + h + l + o) / 4
            //
            //plotcandle(k[1], h, l, k, color = k > k[1] ? #2E9AFE : red)
            //plot(k, title = "Value", color = na, editable = false)
            List<decimal> absChgList = new();
            List<decimal> weightList = new();
            List<decimal> kList = new();
            List<decimal> cList = new();
            List<decimal> hList = new();
            List<decimal> lList = new();
            List<decimal> oList = new();
            List<decimal> highestList = new();
            List<decimal> lowestList = new();
            List<decimal> sList = new();
            List<Signal> signalsList = new();

            try
            {
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentHigh = stockDataClass.HighPrices.ElementAtOrDefault(i);
                    decimal currentLow = stockDataClass.LowPrices.ElementAtOrDefault(i);
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal currentClose = stockDataClass.ClosePrices.ElementAtOrDefault(i);
                    decimal currentOpen = stockDataClass.OpenPrices.ElementAtOrDefault(i);
                    decimal prevK1 = i >= 1 ? kList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevK2 = i >= 2 ? kList.ElementAtOrDefault(i - 2) : 0;

                    decimal absChg = Math.Abs(currentValue - prevValue);
                    absChgList.Add(absChg);

                    var lbList = absChgList.TakeLast(days).ToList();
                    decimal highest = lbList.Max();
                    highestList.Add(highest);

                    decimal lowest = lbList.Min();
                    lowestList.Add(lowest);

                    decimal s = highest - lowest != 0 ? (absChg - lowest) / (highest - lowest) * 100 : 0;
                    sList.Add(s);

                    decimal weight = s / 100;
                    weightList.Add(weight);

                    decimal prevC = i >= 1 ? cList.ElementAtOrDefault(i - 1) : currentClose;
                    decimal c = (weight * currentClose) + ((1 - weight) * prevC);
                    cList.Add(c);

                    prevC = i >= 1 ? prevC : currentHigh;
                    decimal h = (weight * currentHigh) + ((1 - weight) * prevC);
                    hList.Add(h);

                    prevC = i >= 1 ? prevC : currentLow;
                    decimal l = (weight * currentLow) + ((1 - weight) * prevC);
                    lList.Add(l);

                    prevC = i >= 1 ? prevC : currentOpen;
                    decimal o = (weight * currentOpen) + ((1 - weight) * prevC);
                    oList.Add(o);

                    decimal k = (c + h + l + o) / 4;
                    kList.Add(k);

                    var signal = GetCompareSignal(k - prevK1, prevK1 - prevK2);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (highestList, lowestList, sList, weightList, cList, hList, lList, oList, kList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateVervoortHeikenAshiLongTermCandlestickOscillator(StockData stockDataClass, string maType, int days = 55)
        {
            //
            // @author LazyBear 
            // List of all my indicators: 
            // https://docs.google.com/document/d/15AGCufJZ8CIUvwFJ9W-IKns88gkWOKBCvByMEvm5MLo/edit?usp=sharing
            //
            //study("Vervoort LongTerm Heiken-Ashi Candlestick Oscillator [LazyBear]", shorttitle = "HACOLT_LB")
            //length = input(defval = 55, title = "TEMA Period")
            //emaLength = input(defval = 60, title = "EMA Period")
            //candleSizeFactor = input(defval = 1.1, title = "Candle size factor")
            //overlayMode = input(false)
            //calc_tema(src, length) =>
            //ema1 = ema(src, length)
            //ema2 = ema(ema1, length)
            //ema3 = ema(ema2, length)
            //3 * (ema1 - ema2) + ema3

            //haOpen = nz((haOpen[1] + ohlc4) / 2, ohlc4)
            //haClose = (haOpen + max(high, haOpen) + min(low, haOpen) + ohlc4) / 4
            //thaClose = calc_tema(haClose, length)
            //thl2 = calc_tema(hl2, length)
            //haCloseSmooth = 2 * thaClose - calc_tema(thaClose, length)
            //hl2Smooth = 2 * thl2 - calc_tema(thl2, length)
            //shortCandle = abs(close - open) < ((high - low) * candleSizeFactor)
            //keepn1 = ((haClose >= haOpen) and(haClose[1] >= haOpen[1])) or(close >= haClose) or(high > high[1]) or(low > low[1]) or(hl2Smooth >= haCloseSmooth)
            //keepall1 = keepn1 or(keepn1[1] and(close >= open) or(close >= close[1]))
            //keep13 = shortCandle and(high >= low[1])
            //utr = keepall1 or(keepall1[1] and keep13)
            //keepn2 = (haClose < haOpen) and(haClose[1] < haOpen[1]) or(hl2Smooth < haCloseSmooth)
            //keep23 = shortCandle and(low <= high[1])
            //keepall2 = keepn2 or(keepn2[1] and(close < open) or(close < close[1]))
            //dtr = keepall2 or(keepall2[1] and keep23)
            //upw = dtr == 0 and dtr[1] and utr
            //dnw = utr == 0 and utr[1] and dtr
            //upwWithOffset = upw != dnw ? upw : nz(upwWithOffset[1])

            //buySig = upw or(not dnw and(na(upwWithOffset) ? 0 : upwWithOffset))
            //ltSellSig = close < ema(close, emaLength)
            //neutralSig = buySig or(ltSellSig ? 0 : nz(neutralSig[1]))
            //hacolt = buySig ? 1 : neutralSig ? 0 : -1
            //plot(not overlayMode ? hacolt : na, style = columns, color = hacolt > 0 ? green : hacolt < 0 ? red : blue, title = "HACOLT")
            //barcolor(overlayMode ? hacolt > 0 ? green : hacolt < 0 ? red : blue : na)
            List<decimal> haoList = new();
            List<decimal> hacList = new();
            List<decimal> tacList = new();
            List<decimal> thl2TemaList = new();
            List<decimal> tacTemaList = new();
            List<decimal> hl2SmoothList = new();
            List<decimal> medianPriceList = new();
            List<bool> keepN1List = new();
            List<bool> keepAll1List = new();
            List<bool> keepN2List = new();
            List<bool> keepAll2List = new();
            List<bool> utrList = new();
            List<bool> dtrList = new();
            List<decimal> hacoList = new();
            List<decimal> hacSmoothList = new();
            List<Signal> signalsList = new();
            decimal factor = 1.1m;

            try
            {
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentHigh = stockDataClass.HighPrices.ElementAtOrDefault(i);
                    decimal currentLow = stockDataClass.LowPrices.ElementAtOrDefault(i);
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal prevHao = haoList.LastOrDefault();
                    decimal hao = (prevValue + prevHao) / 2;
                    haoList.Add(hao);

                    decimal hac = (currentValue + hao + Math.Max(currentHigh, hao) + Math.Min(currentLow, hao)) / 4;
                    hacList.Add(hac);

                    decimal medianPrice = (currentHigh + currentLow) / 2;
                    medianPriceList.Add(medianPrice);
                }

                tacList = GetMovingAverageList(maType, hacList, stockDataClass, days);
                var thl2List = GetMovingAverageList(maType, medianPriceList, stockDataClass, days);
                tacTemaList = GetMovingAverageList(maType, tacList, stockDataClass, days);
                thl2TemaList = GetMovingAverageList(maType, thl2List, stockDataClass, days);
                for (int j = 0; j < stockDataClass.InputValues.Count; j++)
                {
                    decimal tac = tacList.ElementAtOrDefault(j);
                    decimal tacTema = tacTemaList.ElementAtOrDefault(j);
                    decimal thl2 = thl2List.ElementAtOrDefault(j);
                    decimal thl2Tema = thl2TemaList.ElementAtOrDefault(j);
                    decimal currentOpen = stockDataClass.OpenPrices.ElementAtOrDefault(j);
                    decimal currentClose = stockDataClass.ClosePrices.ElementAtOrDefault(j);
                    decimal currentHigh = stockDataClass.HighPrices.ElementAtOrDefault(j);
                    decimal currentLow = stockDataClass.LowPrices.ElementAtOrDefault(j);
                    decimal hac = hacList.ElementAtOrDefault(j);
                    decimal hao = haoList.ElementAtOrDefault(j);
                    decimal prevHac = j >= 1 ? hacList.ElementAtOrDefault(j - 1) : 0;
                    decimal prevHao = j >= 1 ? haoList.ElementAtOrDefault(j - 1) : 0;
                    decimal prevHigh = j >= 1 ? stockDataClass.HighPrices.ElementAtOrDefault(j - 1) : 0;
                    decimal prevLow = j >= 1 ? stockDataClass.LowPrices.ElementAtOrDefault(j - 1) : 0;
                    decimal prevClose = j >= 1 ? stockDataClass.ClosePrices.ElementAtOrDefault(j - 1) : 0;

                    decimal hacSmooth = (2 * tac) - tacTema;
                    hacSmoothList.Add(hacSmooth);

                    decimal hl2Smooth = (2 * thl2) - thl2Tema;
                    hl2SmoothList.Add(hl2Smooth);

                    bool shortCandle = Math.Abs(currentClose - currentOpen) < (currentHigh - currentLow) * factor;
                    bool prevKeepN1 = keepN1List.LastOrDefault();
                    bool keepN1 = ((hac >= hao) && (prevHac >= prevHao)) || currentClose >= hac || currentHigh > prevHigh || currentLow > prevLow || hl2Smooth >= hacSmooth;
                    keepN1List.Add(keepN1);

                    bool prevKeepAll1 = keepAll1List.LastOrDefault();
                    bool keepAll1 = keepN1 || (prevKeepN1 && (currentClose >= currentOpen || currentClose >= prevClose));
                    keepAll1List.Add(keepAll1);

                    bool keep13 = shortCandle && currentHigh >= prevLow;
                    bool prevUtr = utrList.LastOrDefault();
                    bool utr = keepAll1 || (prevKeepAll1 && keep13);
                    utrList.Add(utr);

                    bool prevKeepN2 = keepN2List.LastOrDefault();
                    bool keepN2 = (hac < hao && prevHac < prevHao) || hl2Smooth < hacSmooth;
                    keepN2List.Add(keepN2);

                    bool keep23 = shortCandle && currentLow <= prevHigh;
                    bool prevKeepAll2 = keepAll2List.LastOrDefault();
                    bool keepAll2 = keepN2 || (prevKeepN2 && (currentClose < currentOpen || currentClose < prevClose));
                    keepAll2List.Add(keepAll2);

                    bool prevDtr = dtrList.LastOrDefault();
                    bool dtr = keepAll2 || prevKeepAll2 && keep23;
                    dtrList.Add(dtr);

                    bool upw = dtr == false && prevDtr && utr;
                    bool dnw = utr == false && prevUtr && dtr;
                    decimal prevHaco = hacoList.LastOrDefault();
                    decimal haco = upw ? 1 : dnw ? -1 : prevHaco;
                    hacoList.Add(haco);

                    var signal = GetCompareSignal(haco, prevHaco);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (tacList, tacTemaList, thl2TemaList, hl2SmoothList, hacoList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateRecursiveMovingTrendAverage(StockData stockDataClass, int days = 21)
        {
            //@version=2
            ////////////////////////////////////////////////////////////
            //  Copyright by HPotter v1.0 25/05/2017
            // Taken from an article "The Yen Recused" in the December 1998 issue of TASC, 
            // written by Dennis Meyers. He describes the Recursive MA in mathematical terms 
            // as "recursive polynomial fit, a technique that uses a small number of past values 
            // of the estimated price and today's price to predict tomorrows price."
            // Red bars color - short position. Green is long.
            ////////////////////////////////////////////////////////////
            //study(title = "Recursive Moving Trend Average", shorttitle = "RMTA", overlay = true)
            //Length = input(21, minval = 3)
            //Alpha = 2 / (Length + 1)
            //Bot = (1 - Alpha) * nz(Bot[1], close) + close
            //nRes = (1 - Alpha) * nz(nRes[1], close) + (Alpha * (close + Bot - nz(Bot[1], 0)))
            //pos = iff(nRes > close[1], -1,
            //iff(nRes < close[1], 1, nz(pos[1], 0)))
            //barcolor(pos == -1 ? red : pos == 1 ? green : blue)
            //plot(nRes, color = blue, title = "RMTA")
            List<decimal> botList = new();
            List<decimal> nResList = new();
            List<decimal> toscList = new();
            List<Signal> signalsList = new();

            try
            {
                int length = days;
                decimal alpha = (decimal)2 / (length + 1);

                List<decimal> emaList = CalculateExponentialMovingAverage(stockDataClass, length).Item1;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal currentEma = emaList.ElementAtOrDefault(i);
                    decimal prevValue = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevBot = i >= 1 ? botList.ElementAtOrDefault(i - 1) : currentValue;
                    decimal prevNRes = i >= 1 ? nResList.ElementAtOrDefault(i - 1) : currentValue;

                    decimal bot = ((1 - alpha) * prevBot) + currentValue;
                    botList.Add(bot);

                    decimal nRes = ((1 - alpha) * prevNRes) + (alpha * (currentValue + bot - prevBot));
                    nResList.Add(nRes);

                    decimal tosc = nRes - currentEma;
                    toscList.Add(tosc);

                    var signal = GetCompareSignal(currentValue - nRes, prevValue - prevNRes);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (botList, nResList, toscList, signalsList);
        }

        public static (List<decimal>, List<Signal>) CalculateLogisticCorrelation(StockData stockDataClass, int days = 100)
        {
            //@version=3
            //study("Logistic Correlation", overlay = false)
            //length = input(100),k = input(10, minval = 1)
            //
            //c = correlation(close, n, length)
            //log = 1 / (1 + exp(k * -c))
            //
            //css = log > 0.5 ? #1B5BBB : red
            //a = plot(log, color =#4EC7F7,transp=0)
            //b = plot(0.5, color = gray, transp = 0)
            //fill(a, b, color = css)
            List<decimal> tempList = new();
            List<decimal> indexList = new();
            List<decimal> logList = new();
            List<decimal> corrList = new();
            List<Signal> signalsList = new();
            decimal k = 10;

            try
            {
                for (int h = 0; h < stockDataClass.InputValues.Count; h++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(h);
                    tempList.Add(currentValue);

                    decimal index = h;
                    indexList.Add(index);

                    var corr = GoodnessOfFit.R(indexList.TakeLast(days).Select(x => (double)x), tempList.TakeLast(days).Select(x => (double)x));
                    corr = IsValueNullOrInfinity(corr) ? 0 : corr;
                    corrList.Add((decimal)corr);
                }

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal corr = corrList.ElementAtOrDefault(i);
                    decimal prevLog1 = i >= 1 ? logList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevLog2 = i >= 2 ? logList.ElementAtOrDefault(i - 2) : 0;

                    decimal log = 1 / (1 + Exp(k * -corr));
                    logList.Add(log);

                    var signal = GetCompareSignal(log - prevLog1, prevLog1 - prevLog2);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (logList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<Signal>) CalculateDoubleExponentialSmoothing(StockData stockDataClass)
        {
            //@version=2
            //study("decimal Exponential Smoothing", overlay = true)
            //alpha = input(0.01, minval = 0, maxval = 1),gamma = input(0.9, minval = 0, maxval = 1)
            //
            //x = close
            //o = change(x)
            //s = alpha * x + (1 - alpha) * (nz(s[1], x) + (gamma * (nz(change(s[1]), o) + (1 - gamma) * nz(nz(change(s[1]), o)))))
            //
            //plot(s, color =#8840C4,transp=0)
            List<decimal> sList = new();
            List<decimal> sChgList = new();
            List<Signal> signalsList = new();
            decimal alpha = 0.01m, gamma = 0.9m;

            try
            {
                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal x = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal prevX = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;
                    decimal prevS = i >= 1 ? sList.ElementAtOrDefault(i - 1) : 0;
                    decimal prevS2 = i >= 2 ? sList.ElementAtOrDefault(i - 2) : 0;

                    decimal sChg = prevS - prevS2;
                    sChgList.Add(sChg);

                    decimal s = (alpha * x) + ((1 - alpha) * (prevS + (gamma * (sChg + ((1 - gamma) * sChg)))));
                    sList.Add(s);

                    var signal = GetCompareSignal(x - s, prevX - prevS);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (sChgList, sList, signalsList);
        }

        public static (List<decimal>, List<decimal>, List<decimal>, List<Signal>) CalculateSharpModifiedMovingAverage(StockData stockDataClass, int days = 14)
        {
            //@version=3
            // Copyright (c) 2018-present, Alex Orekhov (everget)
            // Sharp Modified Moving Average script may be freely distributed under the MIT license.
            //study("Sharp Modified Moving Average", shorttitle = "SHMMA", overlay = true)

            //length = input(title = "Length", type = integer, defval = 14)
            //highlightMovements = input(title = "Highlight Movements ?", type = bool, defval = true)
            //src = input(title = "Source", type = source, defval = close)

            //factor = 0.0
            //slope = 0.0

            //for i = 1 to length
            //    factor := 1 + 2 * (i - 1)
            //    slope := slope + (src[i - 1]) * (length - factor) / 2

            //shmma = sma(src, length) + (6 * slope) / ((length + 1) * length)

            //shmmaColor = highlightMovements ? (shmma > shmma[1] ? green : red) : #6d1e7f
            //plot(shmma, title = "ShMMA", linewidth = 2, color = shmmaColor, transp = 0)
            List<decimal> factorList = new();
            List<decimal> slopeList = new();
            List<decimal> shmmaList = new();
            List<Signal> signalsList = new();

            try
            {
                List<decimal> smaList = CalculateSimpleMovingAverage(stockDataClass, days).Item1;

                for (int i = 0; i < stockDataClass.InputValues.Count; i++)
                {
                    decimal currentValue = stockDataClass.InputValues.ElementAtOrDefault(i);
                    decimal currentSma = smaList.ElementAtOrDefault(i);
                    decimal prevVal = i >= 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - 1) : 0;

                    decimal factor = 0, slope = 0;
                    for (int j = 1; j <= days; j++)
                    {
                        decimal prevValue = i >= j - 1 ? stockDataClass.InputValues.ElementAtOrDefault(i - (j - 1)) : 0;

                        factor = 1 + (2 * (j - 1));
                        slope += prevValue * (days - factor) / 2;
                    }
                    factorList.Add(factor);
                    slopeList.Add(slope);

                    decimal prevShmma = shmmaList.LastOrDefault();
                    decimal shmma = currentSma + (6 * slope / ((days + 1) * days));
                    shmmaList.Add(shmma);

                    var signal = GetCompareSignal(currentValue - shmma, prevVal - prevShmma);
                    signalsList.Add(signal);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return (factorList, slopeList, shmmaList, signalsList);
        }
    }
}